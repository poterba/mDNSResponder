<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uds_daemon.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uds_daemon.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="uds_daemon.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;process.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">usleep</span>(X) Sleep(((X)+999)/1000)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uDNS.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uds_daemon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd_internal.h&quot;</span>

<span class="enscript-comment">// Apple-specific functionality, not required for other platforms
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;os/log.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PID_FILE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_PID_FILE</span> // We need to signal that this platform has no PID file, and not just that we are taking the default
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCAL_PEEREPID</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/un.h&gt;</span>         // for LOCAL_PEEREPID
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>     // for getsockopt
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>  // for struct proc_bsdshortinfo
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libproc.h&gt;</span>        // for proc_pidinfo()
#<span class="enscript-reference">endif</span> //<span class="enscript-variable-name">LOCAL_PEEREPID</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;D2D.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;BLE.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// User IDs 0-500 are system-wide processes, not actual users in the usual sense
</span><span class="enscript-comment">// User IDs for real user accounts start at 501 and count up from there
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">SystemUID</span>(X) ((X) &lt;= 500)

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Globals</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// globals
</span>mDNSexport mDNS mDNSStorage;
mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> ProgramName[] = <span class="enscript-string">&quot;mDNSResponder&quot;</span>;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* boundPath = NULL;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span>* boundPath = MDNS_UDS_SERVERPATH;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MDNS_UDS_SERVERPATH_DEBUG</span> <span class="enscript-string">&quot;/var/tmp/mDNSResponder&quot;</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> dnssd_sock_t listenfd = dnssd_InvalidSocket;
<span class="enscript-type">static</span> request_state *all_requests = NULL;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCAL_PEEREPID</span>
<span class="enscript-type">struct</span> proc_bsdshortinfo proc;
#<span class="enscript-reference">endif</span> //<span class="enscript-variable-name">LOCAL_PEEREPID</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">set_peer_pid</span>(request_state *request);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastClientInfo</span>(request_state *req);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetMcastClients</span>(request_state *req);
<span class="enscript-type">static</span> mDNSu32 mcount;     <span class="enscript-comment">// tracks the current active mcast operations for McastLogging
</span><span class="enscript-type">static</span> mDNSu32 i_mcount;   <span class="enscript-comment">// sets mcount when McastLogging is enabled(PROF signal is sent)
</span><span class="enscript-type">static</span> mDNSu32 n_mrecords; <span class="enscript-comment">// tracks the current active mcast records for McastLogging
</span><span class="enscript-type">static</span> mDNSu32 n_mquests;  <span class="enscript-comment">// tracks the current active mcast questions for McastLogging
</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
mDNSu32 curr_num_regservices = 0;
mDNSu32 max_num_regservices = 0;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// Note asymmetry here between registration and browsing.
</span><span class="enscript-comment">// For service registrations we only automatically register in domains that explicitly appear in local configuration data
</span><span class="enscript-comment">// (so AutoRegistrationDomains could equally well be called SCPrefRegDomains)
</span><span class="enscript-comment">// For service browsing we also learn automatic browsing domains from the network, so for that case we have:
</span><span class="enscript-comment">// 1. SCPrefBrowseDomains (local configuration data)
</span><span class="enscript-comment">// 2. LocalDomainEnumRecords (locally-generated local-only PTR records -- equivalent to slElem-&gt;AuthRecs in uDNS.c)
</span><span class="enscript-comment">// 3. AutoBrowseDomains, which is populated by tracking add/rmv events in AutomaticBrowseDomainChange, the callback function for our mDNS_GetDomains call.
</span><span class="enscript-comment">// By creating and removing our own LocalDomainEnumRecords, we trigger AutomaticBrowseDomainChange callbacks just like domains learned from the network would.
</span>
mDNSexport DNameListElem *AutoRegistrationDomains;  <span class="enscript-comment">// Domains where we automatically register for empty-string registrations
</span>
<span class="enscript-type">static</span> DNameListElem *SCPrefBrowseDomains;          <span class="enscript-comment">// List of automatic browsing domains read from SCPreferences for &quot;empty string&quot; browsing
</span><span class="enscript-type">static</span> ARListElem    *LocalDomainEnumRecords;       <span class="enscript-comment">// List of locally-generated PTR records to augment those we learn from the network
</span>mDNSexport DNameListElem *AutoBrowseDomains;        <span class="enscript-comment">// List created from those local-only PTR records plus records we get from the network
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MSG_PAD_BYTES</span> 5     // pad message buffer (read from client) with n zero'd bytes to guarantee
                            <span class="enscript-comment">// n get_string() calls w/o buffer overrun
</span><span class="enscript-comment">// initialization, setup/teardown functions
</span>
<span class="enscript-comment">// If a platform specifies its own PID file name, we use that
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PID_FILE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PID_FILE</span> <span class="enscript-string">&quot;/var/run/mDNSResponder.pid&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FatalError</span>(<span class="enscript-type">char</span> *errmsg)
{
    LogMsg(<span class="enscript-string">&quot;%s: %s&quot;</span>, errmsg, dnssd_strerror(dnssd_errno));
    abort();
}

mDNSlocal mDNSu32 <span class="enscript-function-name">dnssd_htonl</span>(mDNSu32 l)
{
    mDNSu32 ret;
    <span class="enscript-type">char</span> *data = (<span class="enscript-type">char</span>*) &amp;ret;
    put_uint32(l, &amp;data);
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">// hack to search-replace perror's to LogMsg's
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">my_perror</span>(<span class="enscript-type">char</span> *errmsg)
{
    LogMsg(<span class="enscript-string">&quot;%s: %d (%s)&quot;</span>, errmsg, dnssd_errno, dnssd_strerror(dnssd_errno));
}

<span class="enscript-comment">// Throttled version of my_perror: Logs once every 250 msgs
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">my_throttled_perror</span>(<span class="enscript-type">char</span> *err_msg)
{
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> uds_throttle_count = 0;
    <span class="enscript-keyword">if</span> ((uds_throttle_count++ % 250) == 0)
        my_perror(err_msg);
}

<span class="enscript-comment">// LogMcastQuestion/LogMcastQ should be called after the DNSQuestion struct is initialized(especially for q-&gt;TargetQID)
</span><span class="enscript-comment">// Hence all calls are made after mDNS_StartQuery()/mDNS_StopQuery()/mDNS_StopBrowse() is called.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastQuestion</span>(<span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, request_state *req, q_state status)
{
    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-comment">// Check for Mcast Query
</span>    {
        mDNSBool mflag = mDNSfalse;
        <span class="enscript-keyword">if</span> (status == q_start)
        {
            <span class="enscript-keyword">if</span> (++mcount == 1)
                mflag = mDNStrue;
        }
        <span class="enscript-keyword">else</span>
        {
            mcount--;
        }
        LogMcast(<span class="enscript-string">&quot;%s: %##s  (%s) (%s)  Client(%d)[%s]&quot;</span>, status ? <span class="enscript-string">&quot;+Question&quot;</span> : <span class="enscript-string">&quot;-Question&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype),
                 q-&gt;InterfaceID == mDNSInterface_LocalOnly ? <span class="enscript-string">&quot;lo&quot;</span> :
                 q-&gt;InterfaceID == mDNSInterface_P2P ? <span class="enscript-string">&quot;p2p&quot;</span> :
                 q-&gt;InterfaceID == mDNSInterface_BLE ? <span class="enscript-string">&quot;BLE&quot;</span> :
                 q-&gt;InterfaceID == mDNSInterface_Any ? <span class="enscript-string">&quot;any&quot;</span> : InterfaceNameForID(&amp;mDNSStorage, q-&gt;InterfaceID),
                 req-&gt;process_id, req-&gt;pid_name);
        LogMcastStateInfo(mflag, mDNSfalse, mDNSfalse);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// LogMcastService/LogMcastS should be called after the AuthRecord struct is initialized
</span><span class="enscript-comment">// Hence all calls are made after mDNS_Register()/ just before mDNS_Deregister()
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastService</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> ar, request_state *req, reg_state status)
{
    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(ar)) <span class="enscript-comment">// Check for Mcast Service
</span>    {
        mDNSBool mflag = mDNSfalse;
        <span class="enscript-keyword">if</span> (status == reg_start)
        {
            <span class="enscript-keyword">if</span> (++mcount == 1)
                mflag = mDNStrue;
        }
        <span class="enscript-keyword">else</span>
        {
            mcount--;
        }
        LogMcast(<span class="enscript-string">&quot;%s: %##s  (%s)  (%s)  Client(%d)[%s]&quot;</span>, status ? <span class="enscript-string">&quot;+Service&quot;</span> : <span class="enscript-string">&quot;-Service&quot;</span>, ar-&gt;resrec.name-&gt;c, DNSTypeName(ar-&gt;resrec.rrtype),
                 ar-&gt;resrec.InterfaceID == mDNSInterface_LocalOnly ? <span class="enscript-string">&quot;lo&quot;</span> :
                 ar-&gt;resrec.InterfaceID == mDNSInterface_P2P ? <span class="enscript-string">&quot;p2p&quot;</span> :
                 ar-&gt;resrec.InterfaceID == mDNSInterface_BLE ? <span class="enscript-string">&quot;BLE&quot;</span> :
                 ar-&gt;resrec.InterfaceID == mDNSInterface_Any ? <span class="enscript-string">&quot;all&quot;</span> : InterfaceNameForID(&amp;mDNSStorage, ar-&gt;resrec.InterfaceID),
                 req-&gt;process_id, req-&gt;pid_name);
        LogMcastStateInfo(mflag, mDNSfalse, mDNSfalse);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// For complete Mcast State Log, pass mDNStrue to mstatelog in LogMcastStateInfo()
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastStateInfo</span>(mDNSBool mflag, mDNSBool start, mDNSBool mstatelog)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-keyword">if</span> (!mstatelog)
    {
        <span class="enscript-keyword">if</span> (!all_requests)
        {
            LogMcastNoIdent(<span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            request_state *req, *r;
            <span class="enscript-keyword">for</span> (req = all_requests; req; req=req-&gt;next)
            {
                <span class="enscript-keyword">if</span> (req-&gt;primary) <span class="enscript-comment">// If this is a subbordinate operation, check that the parent is in the list
</span>                {
                    <span class="enscript-keyword">for</span> (r = all_requests; r &amp;&amp; r != req; r=r-&gt;next)
                        <span class="enscript-keyword">if</span> (r == req-&gt;primary)
                            <span class="enscript-keyword">goto</span> <span class="enscript-reference">foundpar</span>;
                }
                <span class="enscript-comment">// For non-subbordinate operations, and subbordinate operations that have lost their parent, write out their info
</span>                GetMcastClients(req);
    <span class="enscript-reference">foundpar</span>:;
            }
            LogMcastNoIdent(<span class="enscript-string">&quot;--- MCAST RECORDS COUNT[%d] MCAST QUESTIONS COUNT[%d] ---&quot;</span>, n_mrecords, n_mquests);
            n_mrecords = n_mquests = 0; <span class="enscript-comment">// Reset the values
</span>        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">static</span> mDNSu32 i_mpktnum;
        i_mcount = 0;
        <span class="enscript-keyword">if</span> (start)
            mcount = 0;
        <span class="enscript-comment">// mcount is initialized to 0 when the PROF signal is sent since mcount could have
</span>        <span class="enscript-comment">// wrong value if MulticastLogging is disabled and then re-enabled
</span>        LogMcastNoIdent(<span class="enscript-string">&quot;--- START MCAST STATE LOG ---&quot;</span>);
        <span class="enscript-keyword">if</span> (!all_requests)
        {
            mcount = 0;
            LogMcastNoIdent(<span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            request_state *req, *r;
            <span class="enscript-keyword">for</span> (req = all_requests; req; req=req-&gt;next)
            {
                <span class="enscript-keyword">if</span> (req-&gt;primary) <span class="enscript-comment">// If this is a subbordinate operation, check that the parent is in the list
</span>                {
                    <span class="enscript-keyword">for</span> (r = all_requests; r &amp;&amp; r != req; r=r-&gt;next)
                        <span class="enscript-keyword">if</span> (r == req-&gt;primary)
                            <span class="enscript-keyword">goto</span> <span class="enscript-reference">foundparent</span>;
                    LogMcastNoIdent(<span class="enscript-string">&quot;%3d: Orphan operation; parent not found in request list&quot;</span>, req-&gt;sd);
                }
                <span class="enscript-comment">// For non-subbordinate operations, and subbordinate operations that have lost their parent, write out their info
</span>                LogMcastClientInfo(req);
    <span class="enscript-reference">foundparent</span>:;
            }
            <span class="enscript-keyword">if</span>(!mcount) <span class="enscript-comment">// To initially set mcount
</span>                mcount = i_mcount;
        }
        <span class="enscript-keyword">if</span> (mcount == 0)
        {
            i_mpktnum = m-&gt;MPktNum;
            LogMcastNoIdent(<span class="enscript-string">&quot;--- MCOUNT[%d]: IMPKTNUM[%d] ---&quot;</span>, mcount, i_mpktnum);
        }
        <span class="enscript-keyword">if</span> (mflag)
            LogMcastNoIdent(<span class="enscript-string">&quot;--- MCOUNT[%d]: CMPKTNUM[%d] - IMPKTNUM[%d] = [%d]PKTS ---&quot;</span>, mcount, m-&gt;MPktNum, i_mpktnum, (m-&gt;MPktNum - i_mpktnum));
        LogMcastNoIdent(<span class="enscript-string">&quot;--- END MCAST STATE LOG ---&quot;</span>);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">abort_request</span>(request_state *req)
{
    <span class="enscript-keyword">if</span> (req-&gt;terminate == (req_termination_fn) ~0)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                  <span class="enscript-string">&quot;[R%d] abort_request: ERROR: Attempt to abort operation %p with req-&gt;terminate %p&quot;</span>, req-&gt;request_id, req, req-&gt;terminate);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// First stop whatever mDNSCore operation we were doing
</span>    <span class="enscript-comment">// If this is actually a shared connection operation, then its req-&gt;terminate function will scan
</span>    <span class="enscript-comment">// the all_requests list and terminate any subbordinate operations sharing this file descriptor
</span>    <span class="enscript-keyword">if</span> (req-&gt;terminate) req-&gt;terminate(req);

    <span class="enscript-keyword">if</span> (!dnssd_SocketValid(req-&gt;sd))
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                  <span class="enscript-string">&quot;[R%d] abort_request: ERROR: Attempt to abort operation %p with invalid fd %d&quot;</span>, req-&gt;request_id, req, req-&gt;sd);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Now, if this request_state is not subordinate to some other primary, close file descriptor and discard replies
</span>    <span class="enscript-keyword">if</span> (!req-&gt;primary)
    {
        <span class="enscript-keyword">if</span> (req-&gt;errsd != req-&gt;sd)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
                      <span class="enscript-string">&quot;[R%d] Removing FD %d and closing errsd %d&quot;</span>, req-&gt;request_id, req-&gt;sd, req-&gt;errsd);
        }
        <span class="enscript-keyword">else</span>
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
                      <span class="enscript-string">&quot;[R%d] Removing FD %d&quot;</span>, req-&gt;request_id, req-&gt;sd);
        }
        udsSupportRemoveFDFromEventLoop(req-&gt;sd, req-&gt;platform_data);       <span class="enscript-comment">// Note: This also closes file descriptor req-&gt;sd for us
</span>        <span class="enscript-keyword">if</span> (req-&gt;errsd != req-&gt;sd) { dnssd_close(req-&gt;errsd); req-&gt;errsd = req-&gt;sd; }

        <span class="enscript-keyword">while</span> (req-&gt;replies)    <span class="enscript-comment">// free pending replies
</span>        {
            reply_state *ptr = req-&gt;replies;
            req-&gt;replies = req-&gt;replies-&gt;next;
            freeL(<span class="enscript-string">&quot;reply_state (abort)&quot;</span>, ptr);
        }
    }

    <span class="enscript-comment">// Set req-&gt;sd to something invalid, so that udsserver_idle knows to unlink and free this structure
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
    <span class="enscript-comment">// Don't use dnssd_InvalidSocket (-1) because that's the sentinel value MDNS_MALLOC_DEBUGGING uses
</span>    <span class="enscript-comment">// for detecting when the memory for an object is inadvertently freed while the object is still on some list
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN32</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">This</span> <span class="enscript-variable-name">will</span> <span class="enscript-variable-name">not</span> <span class="enscript-variable-name">work</span> <span class="enscript-variable-name">on</span> <span class="enscript-variable-name">Windows</span>, <span class="enscript-variable-name">look</span> <span class="enscript-variable-name">at</span> <span class="enscript-variable-name">IsValidSocket</span> <span class="enscript-variable-name">in</span> <span class="enscript-variable-name">mDNSShared</span>/<span class="enscript-variable-name">CommonServices</span>.<span class="enscript-variable-name">h</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">see</span> <span class="enscript-variable-name">why</span>
#<span class="enscript-reference">endif</span>
    req-&gt;sd = req-&gt;errsd = -2;
#<span class="enscript-reference">else</span>
    req-&gt;sd = req-&gt;errsd = dnssd_InvalidSocket;
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// We also set req-&gt;terminate to a bogus value so we know if abort_request() gets called again for this request
</span>    req-&gt;terminate = (req_termination_fn) ~0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SetDebugBoundPath</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
    boundPath = MDNS_UDS_SERVERPATH_DEBUG;
#<span class="enscript-reference">endif</span>
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">IsDebugSocketInUse</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
    <span class="enscript-keyword">return</span> !strcmp(boundPath, MDNS_UDS_SERVERPATH_DEBUG);
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> mDNSfalse;
#<span class="enscript-reference">endif</span>
}
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AbortUnlinkAndFree</span>(request_state *req)
{
    request_state **p = &amp;all_requests;
    abort_request(req);
    <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != req) p=&amp;(*p)-&gt;next;
    <span class="enscript-keyword">if</span> (*p) { *p = req-&gt;next; freeL(<span class="enscript-string">&quot;request_state/AbortUnlinkAndFree&quot;</span>, req); }
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;AbortUnlinkAndFree: ERROR: Attempt to abort operation %p not in list&quot;</span>, req);
}

mDNSlocal reply_state *<span class="enscript-function-name">create_reply</span>(<span class="enscript-type">const</span> reply_op_t op, <span class="enscript-type">const</span> size_t datalen, request_state *<span class="enscript-type">const</span> request)
{
    reply_state *reply;

    <span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)datalen &lt; <span class="enscript-keyword">sizeof</span>(reply_hdr))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: create_reply - data length less than length of required fields&quot;</span>);
        <span class="enscript-keyword">return</span> NULL;
    }

    reply = (reply_state *) callocL(<span class="enscript-string">&quot;reply_state&quot;</span>, <span class="enscript-keyword">sizeof</span>(reply_state) + datalen - <span class="enscript-keyword">sizeof</span>(reply_hdr));
    <span class="enscript-keyword">if</span> (!reply) FatalError(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>);

    reply-&gt;next     = mDNSNULL;
    reply-&gt;totallen = (mDNSu32)datalen + <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr);
    reply-&gt;nwriten  = 0;

    reply-&gt;mhdr-&gt;version        = VERSION;
    reply-&gt;mhdr-&gt;datalen        = (mDNSu32)datalen;
    reply-&gt;mhdr-&gt;ipc_flags      = 0;
    reply-&gt;mhdr-&gt;op             = op;
    reply-&gt;mhdr-&gt;client_context = request-&gt;hdr.client_context;
    reply-&gt;mhdr-&gt;reg_index      = 0;

    <span class="enscript-keyword">return</span> reply;
}

<span class="enscript-comment">// Append a reply to the list in a request object
</span><span class="enscript-comment">// If our request is sharing a connection, then we append our reply_state onto the primary's list
</span><span class="enscript-comment">// If the request does not want asynchronous replies, then the reply is freed instead of being appended to any list.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">append_reply</span>(request_state *req, reply_state *rep)
{
    request_state *r;
    reply_state **ptr;

    <span class="enscript-keyword">if</span> (req-&gt;no_reply)
    {
        freeL(<span class="enscript-string">&quot;reply_state/append_reply&quot;</span>, rep);
        <span class="enscript-keyword">return</span>;
    }

    r = req-&gt;primary ? req-&gt;primary : req;
    ptr = &amp;r-&gt;replies;
    <span class="enscript-keyword">while</span> (*ptr) ptr = &amp;(*ptr)-&gt;next;
    *ptr = rep;
    rep-&gt;next = NULL;
}

<span class="enscript-comment">// Generates a response message giving name, type, domain, plus interface index,
</span><span class="enscript-comment">// suitable for a browse result or service registration result.
</span><span class="enscript-comment">// On successful completion rep is set to point to a malloc'd reply_state struct
</span>mDNSlocal mStatus <span class="enscript-function-name">GenerateNTDResponse</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> servicename, <span class="enscript-type">const</span> mDNSInterfaceID id,
                                      request_state *<span class="enscript-type">const</span> request, reply_state **<span class="enscript-type">const</span> rep, reply_op_t op, DNSServiceFlags flags, mStatus err)
{
    domainlabel name;
    domainname type, dom;
    *rep = NULL;
    <span class="enscript-keyword">if</span> (!DeconstructServiceName(servicename, &amp;name, &amp;type, &amp;dom))
        <span class="enscript-keyword">return</span> kDNSServiceErr_Invalid;
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">char</span> namestr[MAX_DOMAIN_LABEL+1];
        <span class="enscript-type">char</span> typestr[MAX_ESCAPED_DOMAIN_NAME];
        <span class="enscript-type">char</span> domstr [MAX_ESCAPED_DOMAIN_NAME];
        <span class="enscript-type">int</span> len;
        <span class="enscript-type">char</span> *data;

        ConvertDomainLabelToCString_unescaped(&amp;name, namestr);
        ConvertDomainNameToCString(&amp;type, typestr);
        ConvertDomainNameToCString(&amp;dom, domstr);

        <span class="enscript-comment">// Calculate reply data length
</span>        len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
        len += <span class="enscript-keyword">sizeof</span>(mDNSu32);  <span class="enscript-comment">// if index
</span>        len += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
        len += (<span class="enscript-type">int</span>) (strlen(namestr) + 1);
        len += (<span class="enscript-type">int</span>) (strlen(typestr) + 1);
        len += (<span class="enscript-type">int</span>) (strlen(domstr) + 1);

        <span class="enscript-comment">// Build reply header
</span>        *rep = create_reply(op, len, request);
        (*rep)-&gt;rhdr-&gt;flags = dnssd_htonl(flags);
        (*rep)-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(&amp;mDNSStorage, id, mDNSfalse));
        (*rep)-&gt;rhdr-&gt;error = dnssd_htonl(err);

        <span class="enscript-comment">// Build reply body
</span>        data = (<span class="enscript-type">char</span> *)&amp;(*rep)-&gt;rhdr[1];
        put_string(namestr, &amp;data);
        put_string(typestr, &amp;data);
        put_string(domstr, &amp;data);

        <span class="enscript-keyword">return</span> mStatus_NoError;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GenerateBrowseReply</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> servicename, <span class="enscript-type">const</span> mDNSInterfaceID id,
                                              request_state *<span class="enscript-type">const</span> request, reply_state **<span class="enscript-type">const</span> rep, reply_op_t op, DNSServiceFlags flags, mStatus err)
{
    <span class="enscript-type">char</span> namestr[MAX_DOMAIN_LABEL+1];
    <span class="enscript-type">char</span> typestr[MAX_ESCAPED_DOMAIN_NAME];
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> domstr[] = <span class="enscript-string">&quot;.&quot;</span>;
    <span class="enscript-type">int</span> len;
    <span class="enscript-type">char</span> *data;

    *rep = NULL;

    <span class="enscript-comment">// 1. Put first label in namestr
</span>    ConvertDomainLabelToCString_unescaped((<span class="enscript-type">const</span> domainlabel *)servicename, namestr);

    <span class="enscript-comment">// 2. Put second label and &quot;local&quot; into typestr
</span>    mDNS_snprintf(typestr, <span class="enscript-keyword">sizeof</span>(typestr), <span class="enscript-string">&quot;%#s.local.&quot;</span>, SecondLabel(servicename));

    <span class="enscript-comment">// Calculate reply data length
</span>    len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    len += <span class="enscript-keyword">sizeof</span>(mDNSu32);  <span class="enscript-comment">// if index
</span>    len += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
    len += (<span class="enscript-type">int</span>) (strlen(namestr) + 1);
    len += (<span class="enscript-type">int</span>) (strlen(typestr) + 1);
    len += (<span class="enscript-type">int</span>) (strlen(domstr) + 1);

    <span class="enscript-comment">// Build reply header
</span>    *rep = create_reply(op, len, request);
    (*rep)-&gt;rhdr-&gt;flags = dnssd_htonl(flags);
    (*rep)-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(&amp;mDNSStorage, id, mDNSfalse));
    (*rep)-&gt;rhdr-&gt;error = dnssd_htonl(err);

    <span class="enscript-comment">// Build reply body
</span>    data = (<span class="enscript-type">char</span> *)&amp;(*rep)-&gt;rhdr[1];
    put_string(namestr, &amp;data);
    put_string(typestr, &amp;data);
    put_string(domstr, &amp;data);
}

<span class="enscript-comment">// Returns a resource record (allocated w/ malloc) containing the data found in an IPC message
</span><span class="enscript-comment">// Data must be in the following format: flags, interfaceIndex, name, rrtype, rrclass, rdlen, rdata, (optional) ttl
</span><span class="enscript-comment">// (ttl only extracted/set if ttl argument is non-zero). Returns NULL for a bad-parameter error
</span>mDNSlocal AuthRecord *<span class="enscript-function-name">read_rr_from_ipc_msg</span>(request_state *request, <span class="enscript-type">int</span> GetTTL, <span class="enscript-type">int</span> validate_flags)
{
    DNSServiceFlags flags  = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-type">char</span> name[MAX_ESCAPED_DOMAIN_NAME];
    <span class="enscript-type">int</span> str_err = get_string(&amp;request-&gt;msgptr, request-&gt;msgend, name, <span class="enscript-keyword">sizeof</span>(name));
    mDNSu16 type    = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu16     class   = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu16 rdlen   = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *rdata   = get_rdata (&amp;request-&gt;msgptr, request-&gt;msgend, rdlen);
    mDNSu32 ttl   = GetTTL ? get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend) : 0;
    size_t storage_size = rdlen &gt; <span class="enscript-keyword">sizeof</span>(RDataBody) ? rdlen : <span class="enscript-keyword">sizeof</span>(RDataBody);
    AuthRecord *rr;
    mDNSInterfaceID InterfaceID;
    AuthRecType artype;
    mDNSu8 recordType;

    request-&gt;flags = flags;
    request-&gt;interfaceIndex = interfaceIndex;

    <span class="enscript-keyword">if</span> (str_err) { LogMsg(<span class="enscript-string">&quot;ERROR: read_rr_from_ipc_msg - get_string&quot;</span>); <span class="enscript-keyword">return</span> NULL; }

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr) { LogMsg(<span class="enscript-string">&quot;Error reading Resource Record from client&quot;</span>); <span class="enscript-keyword">return</span> NULL; }

    <span class="enscript-keyword">if</span> (validate_flags &amp;&amp;
        !((flags &amp; kDNSServiceFlagsShared) == kDNSServiceFlagsShared) &amp;&amp;
        !((flags &amp; kDNSServiceFlagsUnique) == kDNSServiceFlagsUnique) &amp;&amp;
        !((flags &amp; kDNSServiceFlagsKnownUnique) == kDNSServiceFlagsKnownUnique))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: Bad resource record flags (must be one of either kDNSServiceFlagsShared, kDNSServiceFlagsUnique or kDNSServiceFlagsKnownUnique)&quot;</span>);
        <span class="enscript-keyword">return</span> NULL;
    }
    InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);

    <span class="enscript-comment">// The registration is scoped to a specific interface index, but the interface is not currently on our list.
</span>    <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (interfaceIndex != kDNSServiceInterfaceIndexAny))
    {
        <span class="enscript-comment">// On Apple platforms, an interface's mDNSInterfaceID is equal to its index. Using an interface index that isn't
</span>        <span class="enscript-comment">// currently valid will cause the registration to take place as soon as it becomes valid. On other platforms,
</span>        <span class="enscript-comment">// mDNSInterfaceID is actually a pointer to a platform-specific interface object, but we don't know what the pointer
</span>        <span class="enscript-comment">// for the interface index will be ahead of time. For now, just return NULL to indicate an error condition since the
</span>        <span class="enscript-comment">// interface index is invalid. Otherwise, the registration would be performed on all interfaces.
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        InterfaceID = (mDNSInterfaceID)(uintptr_t)interfaceIndex;
#<span class="enscript-reference">else</span>
        <span class="enscript-keyword">return</span> NULL;
#<span class="enscript-reference">endif</span>
    }
    rr = (AuthRecord *) callocL(<span class="enscript-string">&quot;AuthRecord/read_rr_from_ipc_msg&quot;</span>, <span class="enscript-keyword">sizeof</span>(AuthRecord) - <span class="enscript-keyword">sizeof</span>(RDataBody) + storage_size);
    <span class="enscript-keyword">if</span> (!rr) FatalError(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>);

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly)
        artype = AuthRecordLocalOnly;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P || InterfaceID == mDNSInterface_BLE)
        artype = AuthRecordP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeP2P)
            &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeAWDL))
        artype = AuthRecordAnyIncludeAWDLandP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeP2P))
        artype = AuthRecordAnyIncludeP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeAWDL))
        artype = AuthRecordAnyIncludeAWDL;
    <span class="enscript-keyword">else</span>
        artype = AuthRecordAny;

    <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsShared)
        recordType = (mDNSu8) kDNSRecordTypeShared;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsKnownUnique)
        recordType = (mDNSu8) kDNSRecordTypeKnownUnique;
    <span class="enscript-keyword">else</span>
        recordType = (mDNSu8) kDNSRecordTypeUnique;

    mDNS_SetupResourceRecord(rr, mDNSNULL, InterfaceID, type, 0, recordType, artype, mDNSNULL, mDNSNULL);

    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;rr-&gt;namestorage, name))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: bad name: %s&quot;</span>, name);
        freeL(<span class="enscript-string">&quot;AuthRecord/read_rr_from_ipc_msg&quot;</span>, rr);
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsAllowRemoteQuery) rr-&gt;AllowRemoteQuery = mDNStrue;
    rr-&gt;resrec.rrclass = class;
    rr-&gt;resrec.rdlength = rdlen;
    rr-&gt;resrec.rdata-&gt;MaxRDLength = rdlen;
    mDNSPlatformMemCopy(rr-&gt;resrec.rdata-&gt;u.data, rdata, rdlen);
    <span class="enscript-keyword">if</span> (GetTTL) rr-&gt;resrec.rroriginalttl = ttl;
    rr-&gt;resrec.namehash = DomainNameHashValue(rr-&gt;resrec.name);
    SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);  <span class="enscript-comment">// Sets rr-&gt;rdatahash for us
</span>    <span class="enscript-keyword">return</span> rr;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">build_domainname_from_strings</span>(domainname *srv, <span class="enscript-type">char</span> *name, <span class="enscript-type">char</span> *regtype, <span class="enscript-type">char</span> *domain)
{
    domainlabel n;
    domainname d, t;

    <span class="enscript-keyword">if</span> (!MakeDomainLabelFromLiteralString(&amp;n, name)) <span class="enscript-keyword">return</span> -1;
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;t, regtype)) <span class="enscript-keyword">return</span> -1;
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;d, domain)) <span class="enscript-keyword">return</span> -1;
    <span class="enscript-keyword">if</span> (!ConstructServiceName(srv, &amp;n, &amp;t, &amp;d)) <span class="enscript-keyword">return</span> -1;
    <span class="enscript-keyword">return</span> 0;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">send_all</span>(dnssd_sock_t s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ptr, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> n = send(s, ptr, len, 0);
    <span class="enscript-comment">// On a freshly-created Unix Domain Socket, the kernel should *never* fail to buffer a small write for us
</span>    <span class="enscript-comment">// (four bytes for a typical error code return, 12 bytes for DNSServiceGetProperty(DaemonVersion)).
</span>    <span class="enscript-comment">// If it does fail, we don't attempt to handle this failure, but we do log it so we know something is wrong.
</span>    <span class="enscript-keyword">if</span> (n &lt; len)
        LogMsg(<span class="enscript-string">&quot;ERROR: send_all(%d) wrote %d of %d errno %d (%s)&quot;</span>,
               s, n, len, dnssd_errno, dnssd_strerror(dnssd_errno));
}

#<span class="enscript-reference">if</span> 0
mDNSlocal mDNSBool <span class="enscript-function-name">AuthorizedDomain</span>(<span class="enscript-type">const</span> request_state * <span class="enscript-type">const</span> request, <span class="enscript-type">const</span> domainname * <span class="enscript-type">const</span> d, <span class="enscript-type">const</span> DNameListElem * <span class="enscript-type">const</span> doms)
{
    <span class="enscript-type">const</span> DNameListElem   *delem = mDNSNULL;
    <span class="enscript-type">int</span> bestDelta   = -1;                           <span class="enscript-comment">// the delta of the best match, lower is better
</span>    <span class="enscript-type">int</span> dLabels     = 0;
    mDNSBool allow       = mDNSfalse;

    <span class="enscript-keyword">if</span> (SystemUID(request-&gt;uid)) <span class="enscript-keyword">return</span> mDNStrue;

    dLabels = CountLabels(d);
    <span class="enscript-keyword">for</span> (delem = doms; delem; delem = delem-&gt;next)
    {
        <span class="enscript-keyword">if</span> (delem-&gt;uid)
        {
            <span class="enscript-type">int</span> delemLabels = CountLabels(&amp;delem-&gt;name);
            <span class="enscript-type">int</span> delta       = dLabels - delemLabels;
            <span class="enscript-keyword">if</span> ((bestDelta == -1 || delta &lt;= bestDelta) &amp;&amp; SameDomainName(&amp;delem-&gt;name, SkipLeadingLabels(d, delta)))
            {
                bestDelta = delta;
                allow = (allow || (delem-&gt;uid == request-&gt;uid));
            }
        }
    }

    <span class="enscript-keyword">return</span> bestDelta == -1 ? mDNStrue : allow;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">external</span> <span class="enscript-variable-name">helpers</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">external_start_advertising_helper</span>(service_instance *<span class="enscript-type">const</span> instance)
{
    AuthRecord *st = instance-&gt;subtypes;
    ExtraResourceRecord *e;
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(instance-&gt;request-&gt;u.servicereg.port))
    {
        LogInfo(<span class="enscript-string">&quot;external_start_advertising_helper: Not registering service with port number zero&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (instance-&gt;external_advertise) LogMsg(<span class="enscript-string">&quot;external_start_advertising_helper: external_advertise already set!&quot;</span>);

    <span class="enscript-keyword">for</span> ( i = 0; i &lt; instance-&gt;request-&gt;u.servicereg.num_subtypes; i++)
        external_start_advertising_service(&amp;st[i].resrec, instance-&gt;request-&gt;flags);

    external_start_advertising_service(&amp;instance-&gt;srs.RR_PTR.resrec, instance-&gt;request-&gt;flags);
    external_start_advertising_service(&amp;instance-&gt;srs.RR_SRV.resrec, instance-&gt;request-&gt;flags);
    external_start_advertising_service(&amp;instance-&gt;srs.RR_TXT.resrec, instance-&gt;request-&gt;flags);

    <span class="enscript-keyword">for</span> (e = instance-&gt;srs.Extras; e; e = e-&gt;next)
        external_start_advertising_service(&amp;e-&gt;r.resrec, instance-&gt;request-&gt;flags);

    instance-&gt;external_advertise = mDNStrue;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">external_stop_advertising_helper</span>(service_instance *<span class="enscript-type">const</span> instance)
{
    AuthRecord *st = instance-&gt;subtypes;
    ExtraResourceRecord *e;
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">if</span> (!instance-&gt;external_advertise) <span class="enscript-keyword">return</span>;

    LogInfo(<span class="enscript-string">&quot;external_stop_advertising_helper: calling external_stop_advertising_service&quot;</span>);

    <span class="enscript-keyword">if</span> (instance-&gt;request)
    {
        <span class="enscript-keyword">for</span> (i = 0; i &lt; instance-&gt;request-&gt;u.servicereg.num_subtypes; i++)
        {
            external_stop_advertising_service(&amp;st[i].resrec, instance-&gt;request-&gt;flags);
        }

        external_stop_advertising_service(&amp;instance-&gt;srs.RR_PTR.resrec, instance-&gt;request-&gt;flags);
        external_stop_advertising_service(&amp;instance-&gt;srs.RR_SRV.resrec, instance-&gt;request-&gt;flags);
        external_stop_advertising_service(&amp;instance-&gt;srs.RR_TXT.resrec, instance-&gt;request-&gt;flags);

        <span class="enscript-keyword">for</span> (e = instance-&gt;srs.Extras; e; e = e-&gt;next)
        {
            external_stop_advertising_service(&amp;e-&gt;r.resrec, instance-&gt;request-&gt;flags);
        }
    }

    instance-&gt;external_advertise = mDNSfalse;
}
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceRegister</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">FreeExtraRR</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    ExtraResourceRecord *extra = (ExtraResourceRecord *)rr-&gt;RecordContext;
    (<span class="enscript-type">void</span>)m;  <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (result != mStatus_MemFree) { LogMsg(<span class="enscript-string">&quot;Error: FreeExtraRR invoked with unexpected error %d&quot;</span>, result); <span class="enscript-keyword">return</span>; }

    LogInfo(<span class="enscript-string">&quot;     FreeExtraRR %s&quot;</span>, RRDisplayString(m, &amp;rr-&gt;resrec));

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdata != &amp;rr-&gt;rdatastorage)
        freeL(<span class="enscript-string">&quot;Extra RData&quot;</span>, rr-&gt;resrec.rdata);
    freeL(<span class="enscript-string">&quot;ExtraResourceRecord/FreeExtraRR&quot;</span>, extra);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">unlink_and_free_service_instance</span>(service_instance *srv)
{
    ExtraResourceRecord *e = srv-&gt;srs.Extras, *tmp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    external_stop_advertising_helper(srv);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// clear pointers from parent struct
</span>    <span class="enscript-keyword">if</span> (srv-&gt;request)
    {
        service_instance **p = &amp;srv-&gt;request-&gt;u.servicereg.instances;
        <span class="enscript-keyword">while</span> (*p)
        {
            <span class="enscript-keyword">if</span> (*p == srv) { *p = (*p)-&gt;next; <span class="enscript-keyword">break</span>; }
            p = &amp;(*p)-&gt;next;
        }
    }

    <span class="enscript-keyword">while</span> (e)
    {
        e-&gt;r.RecordContext = e;
        tmp = e;
        e = e-&gt;next;
        FreeExtraRR(&amp;mDNSStorage, &amp;tmp-&gt;r, mStatus_MemFree);
    }

    <span class="enscript-keyword">if</span> (srv-&gt;srs.RR_TXT.resrec.rdata != &amp;srv-&gt;srs.RR_TXT.rdatastorage)
        freeL(<span class="enscript-string">&quot;TXT RData&quot;</span>, srv-&gt;srs.RR_TXT.resrec.rdata);

    <span class="enscript-keyword">if</span> (srv-&gt;subtypes)
    {
        freeL(<span class="enscript-string">&quot;ServiceSubTypes&quot;</span>, srv-&gt;subtypes);
        srv-&gt;subtypes = NULL;
    }
    freeL(<span class="enscript-string">&quot;service_instance&quot;</span>, srv);
}

<span class="enscript-comment">// Count how many other service records we have locally with the same name, but different rdata.
</span><span class="enscript-comment">// For auto-named services, we can have at most one per machine -- if we allowed two auto-named services of
</span><span class="enscript-comment">// the same type on the same machine, we'd get into an infinite autoimmune-response loop of continuous renaming.
</span>mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">CountPeerRegistrations</span>(ServiceRecordSet *<span class="enscript-type">const</span> srs)
{
    <span class="enscript-type">int</span> count = 0;
    ResourceRecord *r = &amp;srs-&gt;RR_SRV.resrec;
    AuthRecord *rr;

    <span class="enscript-keyword">for</span> (rr = mDNSStorage.ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; SameDomainName(rr-&gt;resrec.name, r-&gt;name) &amp;&amp; !IdenticalSameNameRecord(&amp;rr-&gt;resrec, r))
            count++;

    verbosedebugf(<span class="enscript-string">&quot;%d peer registrations for %##s&quot;</span>, count, r-&gt;name-&gt;c);
    <span class="enscript-keyword">return</span>(count);
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">CountExistingRegistrations</span>(domainname *srv, mDNSIPPort port)
{
    <span class="enscript-type">int</span> count = 0;
    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = mDNSStorage.ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp;
            mDNSSameIPPort(rr-&gt;resrec.rdata-&gt;u.srv.port, port) &amp;&amp;
            SameDomainName(rr-&gt;resrec.name, srv))
            count++;
    <span class="enscript-keyword">return</span>(count);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendServiceRemovalNotification</span>(ServiceRecordSet *<span class="enscript-type">const</span> srs)
{
    reply_state *rep;
    service_instance *instance = srs-&gt;ServiceContext;
    <span class="enscript-keyword">if</span> (GenerateNTDResponse(srs-&gt;RR_SRV.resrec.name, srs-&gt;RR_SRV.resrec.InterfaceID, instance-&gt;request, &amp;rep, reg_service_reply_op, 0, mStatus_NoError) != mStatus_NoError)
        LogMsg(<span class="enscript-string">&quot;%3d: SendServiceRemovalNotification: %##s is not valid DNS-SD SRV name&quot;</span>, instance-&gt;request-&gt;sd, srs-&gt;RR_SRV.resrec.name-&gt;c);
    <span class="enscript-keyword">else</span> { append_reply(instance-&gt;request, rep); instance-&gt;clientnotified = mDNSfalse; }
}

<span class="enscript-comment">// service registration callback performs three duties - frees memory for deregistered services,
</span><span class="enscript-comment">// handles name conflicts, and delivers completed registration information to the client
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">regservice_callback</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> srs, mStatus result)
{
    mStatus err;
    mDNSBool SuppressError = mDNSfalse;
    service_instance *instance;
    reply_state         *rep;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (!srs)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;regservice_callback: srs is NULL %d&quot;</span>, result);
        <span class="enscript-keyword">return</span>;
    }

    instance = srs-&gt;ServiceContext;
    <span class="enscript-keyword">if</span> (!instance)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;regservice_callback: srs-&gt;ServiceContext is NULL %d&quot;</span>, result);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// don't send errors up to client for wide-area, empty-string registrations
</span>    <span class="enscript-keyword">if</span> (instance-&gt;request &amp;&amp;
        instance-&gt;request-&gt;u.servicereg.default_domain &amp;&amp;
        !instance-&gt;default_local)
        SuppressError = mDNStrue;

    <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *result_description;
        <span class="enscript-type">char</span> description[32]; <span class="enscript-comment">// 32-byte is enough for holding &quot;suppressed error -2147483648\0&quot;
</span>        mDNSu32 request_id = instance-&gt;request ? instance-&gt;request-&gt;request_id : 0;
        <span class="enscript-keyword">switch</span> (result) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NoError</span>:
                result_description = <span class="enscript-string">&quot;REGISTERED&quot;</span>;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_MemFree</span>:
                result_description = <span class="enscript-string">&quot;DEREGISTERED&quot;</span>;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NameConflict</span>:
                result_description = <span class="enscript-string">&quot;NAME CONFLICT&quot;</span>;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                mDNS_snprintf(description, <span class="enscript-keyword">sizeof</span>(description), <span class="enscript-string">&quot;%s %d&quot;</span>, SuppressError ? <span class="enscript-string">&quot;suppressed error&quot;</span> : <span class="enscript-string">&quot;CALLBACK&quot;</span>, result);
                result_description = description;
                <span class="enscript-keyword">break</span>;
        }
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%u] DNSServiceRegister(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, %u) %s&quot;</span>,
                  request_id, DM_NAME_PARAM(srs-&gt;RR_SRV.resrec.name-&gt;c), mDNSVal16(srs-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port), result_description);
    }

    <span class="enscript-keyword">if</span> (!instance-&gt;request &amp;&amp; result != mStatus_MemFree)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;regservice_callback: instance-&gt;request is NULL %d&quot;</span>, result);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (result == mStatus_NoError)
    {
        <span class="enscript-keyword">if</span> (instance-&gt;request-&gt;u.servicereg.allowremotequery)
        {
            ExtraResourceRecord *e;
            srs-&gt;RR_ADV.AllowRemoteQuery = mDNStrue;
            srs-&gt;RR_PTR.AllowRemoteQuery = mDNStrue;
            srs-&gt;RR_SRV.AllowRemoteQuery = mDNStrue;
            srs-&gt;RR_TXT.AllowRemoteQuery = mDNStrue;
            <span class="enscript-keyword">for</span> (e = instance-&gt;srs.Extras; e; e = e-&gt;next) e-&gt;r.AllowRemoteQuery = mDNStrue;
        }

        <span class="enscript-keyword">if</span> (GenerateNTDResponse(srs-&gt;RR_SRV.resrec.name, srs-&gt;RR_SRV.resrec.InterfaceID, instance-&gt;request, &amp;rep, reg_service_reply_op, kDNSServiceFlagsAdd, result) != mStatus_NoError)
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;[R%u] regservice_callback: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; is not valid DNS-SD SRV name&quot;</span>, instance-&gt;request-&gt;request_id, DM_NAME_PARAM(srs-&gt;RR_SRV.resrec.name-&gt;c));
        <span class="enscript-keyword">else</span> { append_reply(instance-&gt;request, rep); instance-&gt;clientnotified = mDNStrue; }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        <span class="enscript-keyword">if</span> (callExternalHelpers(instance-&gt;request-&gt;u.servicereg.InterfaceID, &amp;instance-&gt;domain, instance-&gt;request-&gt;flags))
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%u] regservice_callback: calling external_start_advertising_helper()&quot;</span>, instance-&gt;request-&gt;request_id);
            external_start_advertising_helper(instance);
        }
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (instance-&gt;request-&gt;u.servicereg.autoname &amp;&amp; CountPeerRegistrations(srs) == 0)
            RecordUpdatedNiceLabel(0);   <span class="enscript-comment">// Successfully got new name, tell user immediately
</span>    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
        curr_num_regservices--;
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (instance-&gt;request &amp;&amp; instance-&gt;renameonmemfree)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            external_stop_advertising_helper(instance);
#<span class="enscript-reference">endif</span>
            instance-&gt;renameonmemfree = 0;
            err = mDNS_RenameAndReregisterService(m, srs, &amp;instance-&gt;request-&gt;u.servicereg.name);
            <span class="enscript-keyword">if</span> (err)
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;[R%u] ERROR: regservice_callback - RenameAndReregisterService returned %d&quot;</span>, instance-&gt;request-&gt;request_id, err);
            <span class="enscript-comment">// error should never happen - safest to log and continue
</span>        }
        <span class="enscript-keyword">else</span>
            unlink_and_free_service_instance(instance);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
    {
        <span class="enscript-keyword">if</span> (instance-&gt;request-&gt;u.servicereg.autorename)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            external_stop_advertising_helper(instance);
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (instance-&gt;request-&gt;u.servicereg.autoname &amp;&amp; CountPeerRegistrations(srs) == 0)
            {
                <span class="enscript-comment">// On conflict for an autoname service, rename and reregister *all* autoname services
</span>                IncrementLabelSuffix(&amp;m-&gt;nicelabel, mDNStrue);
                mDNS_ConfigChanged(m);  <span class="enscript-comment">// Will call back into udsserver_handle_configchange()
</span>            }
            <span class="enscript-keyword">else</span>    <span class="enscript-comment">// On conflict for a non-autoname service, rename and reregister just that one service
</span>            {
                <span class="enscript-keyword">if</span> (instance-&gt;clientnotified) SendServiceRemovalNotification(srs);
                mDNS_RenameAndReregisterService(m, srs, mDNSNULL);
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (!SuppressError)
            {
                <span class="enscript-keyword">if</span> (GenerateNTDResponse(srs-&gt;RR_SRV.resrec.name, srs-&gt;RR_SRV.resrec.InterfaceID, instance-&gt;request, &amp;rep, reg_service_reply_op, kDNSServiceFlagsAdd, result) != mStatus_NoError)
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;[R%u] regservice_callback: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; is not valid DNS-SD SRV name&quot;</span>, instance-&gt;request-&gt;request_id, DM_NAME_PARAM(srs-&gt;RR_SRV.resrec.name-&gt;c));
                <span class="enscript-keyword">else</span> { append_reply(instance-&gt;request, rep); instance-&gt;clientnotified = mDNStrue; }
            }
            unlink_and_free_service_instance(instance);
        }
    }
    <span class="enscript-keyword">else</span>        <span class="enscript-comment">// Not mStatus_NoError, mStatus_MemFree, or mStatus_NameConflict
</span>    {
        <span class="enscript-keyword">if</span> (!SuppressError)
        {
            <span class="enscript-keyword">if</span> (GenerateNTDResponse(srs-&gt;RR_SRV.resrec.name, srs-&gt;RR_SRV.resrec.InterfaceID, instance-&gt;request, &amp;rep, reg_service_reply_op, kDNSServiceFlagsAdd, result) != mStatus_NoError)
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;[R%u] regservice_callback: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; is not valid DNS-SD SRV name&quot;</span>, instance-&gt;request-&gt;request_id, DM_NAME_PARAM(srs-&gt;RR_SRV.resrec.name-&gt;c));
            <span class="enscript-keyword">else</span> { append_reply(instance-&gt;request, rep); instance-&gt;clientnotified = mDNStrue; }
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">regrecord_callback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (!rr-&gt;RecordContext)     <span class="enscript-comment">// parent struct already freed by termination callback
</span>    {
        <span class="enscript-keyword">if</span> (result == mStatus_NoError)
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;Error: regrecord_callback: successful registration of orphaned record &quot;</span> PRI_S, ARDisplayString(m, rr));
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (result != mStatus_MemFree)
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;regrecord_callback: error %d received after parent termination&quot;</span>, result);

            <span class="enscript-comment">// We come here when the record is being deregistered either from DNSServiceRemoveRecord or connection_termination.
</span>            <span class="enscript-comment">// If the record has been updated, we need to free the rdata. Every time we call mDNS_Update, it calls update_callback
</span>            <span class="enscript-comment">// with the old rdata (so that we can free it) and stores the new rdata in &quot;rr-&gt;resrec.rdata&quot;. This means, we need
</span>            <span class="enscript-comment">// to free the latest rdata for which the update_callback was never called with.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdata != &amp;rr-&gt;rdatastorage) freeL(<span class="enscript-string">&quot;RData/regrecord_callback&quot;</span>, rr-&gt;resrec.rdata);
            freeL(<span class="enscript-string">&quot;AuthRecord/regrecord_callback&quot;</span>, rr);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        registered_record_entry *re = rr-&gt;RecordContext;
        request_state *request = re-&gt;request;

        <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
        {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *result_description;
            <span class="enscript-type">char</span> description[16]; <span class="enscript-comment">// 16-byte is enough for holding -2147483648\0
</span>            <span class="enscript-keyword">switch</span> (result) {
                <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NoError</span>:
                    result_description = <span class="enscript-string">&quot;REGISTERED&quot;</span>;
                    <span class="enscript-keyword">break</span>;
                <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_MemFree</span>:
                    result_description = <span class="enscript-string">&quot;DEREGISTERED&quot;</span>;
                    <span class="enscript-keyword">break</span>;
                <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NameConflict</span>:
                    result_description = <span class="enscript-string">&quot;NAME CONFLICT&quot;</span>;
                    <span class="enscript-keyword">break</span>;
                <span class="enscript-reference">default</span>:
                    mDNS_snprintf(description, <span class="enscript-keyword">sizeof</span>(description), <span class="enscript-string">&quot;%d&quot;</span>, result);
                    result_description = description;
                    <span class="enscript-keyword">break</span>;
            }

            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%u] DNSServiceRegisterRecord(%u &quot;</span> PRI_S <span class="enscript-string">&quot;)&quot;</span> PUB_S,
                      request-&gt;request_id, re-&gt;key, RRDisplayString(m, &amp;rr-&gt;resrec), result_description);
        }

        <span class="enscript-keyword">if</span> (result != mStatus_MemFree)
        {
            <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags) + <span class="enscript-keyword">sizeof</span>(mDNSu32) + <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
            reply_state *reply = create_reply(reg_record_reply_op, len, request);
            reply-&gt;mhdr-&gt;client_context = re-&gt;regrec_client_context;
            reply-&gt;rhdr-&gt;flags = dnssd_htonl(0);
            reply-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, rr-&gt;resrec.InterfaceID, mDNSfalse));
            reply-&gt;rhdr-&gt;error = dnssd_htonl(result);
            append_reply(request, reply);
        }

        <span class="enscript-keyword">if</span> (result)
        {
            <span class="enscript-comment">// If this is a callback to a keepalive record, do not free it.
</span>            <span class="enscript-keyword">if</span> (result == mStatus_BadStateErr)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u] regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.&quot;</span>, request-&gt;request_id);
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// unlink from list, free memory
</span>                registered_record_entry **ptr = &amp;request-&gt;u.reg_recs;
                <span class="enscript-keyword">while</span> (*ptr &amp;&amp; (*ptr) != re) ptr = &amp;(*ptr)-&gt;next;
                <span class="enscript-keyword">if</span> (!*ptr)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                              <span class="enscript-string">&quot;[R%u] regrecord_callback - record not in list!&quot;</span>, request-&gt;request_id);
                    <span class="enscript-keyword">return</span>;
                }
                *ptr = (*ptr)-&gt;next;
                freeL(<span class="enscript-string">&quot;registered_record_entry AuthRecord regrecord_callback&quot;</span>, re-&gt;rr);
                freeL(<span class="enscript-string">&quot;registered_record_entry regrecord_callback&quot;</span>, re);
             }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (re-&gt;external_advertise)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                          <span class="enscript-string">&quot;[R%u] regrecord_callback: external_advertise already set!&quot;</span>, request-&gt;request_id);
            }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            <span class="enscript-keyword">if</span> (callExternalHelpers(re-&gt;origInterfaceID, &amp;rr-&gt;namestorage, request-&gt;flags))
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u] regrecord_callback: calling external_start_advertising_service&quot;</span>, request-&gt;request_id);
                external_start_advertising_service(&amp;rr-&gt;resrec, request-&gt;flags);
                re-&gt;external_advertise = mDNStrue;
            }
#<span class="enscript-reference">endif</span>
        }
    }
}

<span class="enscript-comment">// set_peer_pid() is called after mem is allocated for each new request in NewRequest()
</span><span class="enscript-comment">// This accounts for 2 places (connect_callback, request_callback)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">set_peer_pid</span>(request_state *request)
{
    request-&gt;pid_name[0] = <span class="enscript-string">'\0'</span>;
    request-&gt;process_id  = -1;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCAL_PEEREPID</span>
    pid_t           p    = (pid_t) -1;
    socklen_t       len  = <span class="enscript-keyword">sizeof</span>(p);
    <span class="enscript-keyword">if</span> (request-&gt;sd &lt; 0)
        <span class="enscript-keyword">return</span>;
    <span class="enscript-comment">// to extract the effective pid value
</span>    <span class="enscript-keyword">if</span> (getsockopt(request-&gt;sd, SOL_LOCAL, LOCAL_PEEREPID, &amp;p, &amp;len) != 0)
        <span class="enscript-keyword">return</span>;
    <span class="enscript-comment">// to extract the process name from the pid value
</span>    <span class="enscript-keyword">if</span> (proc_pidinfo(p, PROC_PIDT_SHORTBSDINFO, 1, &amp;proc, PROC_PIDT_SHORTBSDINFO_SIZE) == 0)
        <span class="enscript-keyword">return</span>;
    mDNSPlatformStrLCopy(request-&gt;pid_name, proc.pbsi_comm, <span class="enscript-keyword">sizeof</span>(request-&gt;pid_name));
    request-&gt;process_id = p;
    debugf(<span class="enscript-string">&quot;set_peer_pid: Client PEEREPID is %d %s&quot;</span>, p, request-&gt;pid_name);
#<span class="enscript-reference">else</span>   // !<span class="enscript-variable-name">LOCAL_PEEREPID</span>
    LogInfo(<span class="enscript-string">&quot;set_peer_pid: Not Supported on this version of OS&quot;</span>);
    <span class="enscript-keyword">if</span> (request-&gt;sd &lt; 0)
        <span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">LOCAL_PEEREPID</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">connection_termination</span>(request_state *request)
{
    <span class="enscript-comment">// When terminating a shared connection, we need to scan the all_requests list
</span>    <span class="enscript-comment">// and terminate any subbordinate operations sharing this file descriptor
</span>    request_state **req = &amp;all_requests;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceCreateConnection STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;process_id, request-&gt;pid_name);

    <span class="enscript-keyword">while</span> (*req)
    {
        <span class="enscript-keyword">if</span> ((*req)-&gt;primary == request)
        {
            <span class="enscript-comment">// Since we're already doing a list traversal, we unlink the request directly instead of using AbortUnlinkAndFree()
</span>            request_state *tmp = *req;
            <span class="enscript-keyword">if</span> (tmp-&gt;primary == tmp) LogMsg(<span class="enscript-string">&quot;connection_termination ERROR (*req)-&gt;primary == *req for %p %d&quot;</span>,                  tmp, tmp-&gt;sd);
            <span class="enscript-keyword">if</span> (tmp-&gt;replies) LogMsg(<span class="enscript-string">&quot;connection_termination ERROR How can subordinate req %p %d have replies queued?&quot;</span>, tmp, tmp-&gt;sd);
            abort_request(tmp);
            *req = tmp-&gt;next;
            freeL(<span class="enscript-string">&quot;request_state/connection_termination&quot;</span>, tmp);
        }
        <span class="enscript-keyword">else</span>
            req = &amp;(*req)-&gt;next;
    }

    <span class="enscript-keyword">while</span> (request-&gt;u.reg_recs)
    {
        registered_record_entry *ptr = request-&gt;u.reg_recs;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d] DNSServiceRegisterRecord(0x%X, %d, &quot;</span> PRI_S <span class="enscript-string">&quot;) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, RRDisplayString(&amp;mDNSStorage, &amp;ptr-&gt;rr-&gt;resrec), request-&gt;process_id,
               request-&gt;pid_name);
        request-&gt;u.reg_recs = request-&gt;u.reg_recs-&gt;next;
        ptr-&gt;rr-&gt;RecordContext = NULL;
        <span class="enscript-keyword">if</span> (ptr-&gt;external_advertise)
        {
            ptr-&gt;external_advertise = mDNSfalse;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            external_stop_advertising_service(&amp;ptr-&gt;rr-&gt;resrec, request-&gt;flags);
#<span class="enscript-reference">endif</span>
        }
        LogMcastS(ptr-&gt;rr, request, reg_stop);
        mDNS_Deregister(&amp;mDNSStorage, ptr-&gt;rr);     <span class="enscript-comment">// Will free ptr-&gt;rr for us
</span>        freeL(<span class="enscript-string">&quot;registered_record_entry/connection_termination&quot;</span>, ptr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handle_cancel_request</span>(request_state *request)
{
    request_state **req = &amp;all_requests;
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;[R%d] Cancel %08X %08X&quot;</span>,
           request-&gt;request_id, request-&gt;hdr.client_context.u32[1], request-&gt;hdr.client_context.u32[0]);
    <span class="enscript-keyword">while</span> (*req)
    {
        <span class="enscript-keyword">if</span> ((*req)-&gt;primary == request &amp;&amp;
            (*req)-&gt;hdr.client_context.u32[0] == request-&gt;hdr.client_context.u32[0] &amp;&amp;
            (*req)-&gt;hdr.client_context.u32[1] == request-&gt;hdr.client_context.u32[1])
        {
            <span class="enscript-comment">// Since we're already doing a list traversal, we unlink the request directly instead of using AbortUnlinkAndFree()
</span>            request_state *tmp = *req;
            abort_request(tmp);
            *req = tmp-&gt;next;
            freeL(<span class="enscript-string">&quot;request_state/handle_cancel_request&quot;</span>, tmp);
        }
        <span class="enscript-keyword">else</span>
            req = &amp;(*req)-&gt;next;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">handle_regrecord_request</span>(request_state *request)
{
    mStatus err = mStatus_BadParamErr;
    AuthRecord *rr;

    <span class="enscript-keyword">if</span> (request-&gt;terminate != connection_termination)
    { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceRegisterRecord(not a shared connection ref)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(err); }

    rr = read_rr_from_ipc_msg(request, 1, 1);
    <span class="enscript-keyword">if</span> (rr)
    {
        registered_record_entry *re;
        <span class="enscript-comment">// Don't allow non-local domains to be regsitered as LocalOnly. Allowing this would permit
</span>        <span class="enscript-comment">// clients to register records such as www.bigbank.com A w.x.y.z to redirect Safari.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == mDNSInterface_LocalOnly &amp;&amp; !IsLocalDomain(rr-&gt;resrec.name) &amp;&amp;
            rr-&gt;resrec.rrclass == kDNSClass_IN &amp;&amp; (rr-&gt;resrec.rrtype == kDNSType_A || rr-&gt;resrec.rrtype == kDNSType_AAAA ||
                                                   rr-&gt;resrec.rrtype == kDNSType_CNAME))
        {
            freeL(<span class="enscript-string">&quot;AuthRecord/handle_regrecord_request&quot;</span>, rr);
            <span class="enscript-keyword">return</span> (mStatus_BadParamErr);
        }
        <span class="enscript-comment">// allocate registration entry, link into list
</span>        re = (registered_record_entry *) callocL(<span class="enscript-string">&quot;registered_record_entry&quot;</span>, <span class="enscript-keyword">sizeof</span>(*re));
        <span class="enscript-keyword">if</span> (!re) FatalError(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>);
        re-&gt;key                   = request-&gt;hdr.reg_index;
        re-&gt;rr                    = rr;
        re-&gt;regrec_client_context = request-&gt;hdr.client_context;
        re-&gt;request               = request;
        re-&gt;external_advertise    = mDNSfalse;
        rr-&gt;RecordContext         = re;
        rr-&gt;RecordCallback        = regrecord_callback;

        re-&gt;origInterfaceID = rr-&gt;resrec.InterfaceID;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == mDNSInterface_P2P)
            rr-&gt;resrec.InterfaceID = mDNSInterface_Any;
#<span class="enscript-reference">if</span> 0
        <span class="enscript-keyword">if</span> (!AuthorizedDomain(request, rr-&gt;resrec.name, AutoRegistrationDomains)) <span class="enscript-keyword">return</span> (mStatus_NoError);
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rroriginalttl == 0)
            rr-&gt;resrec.rroriginalttl = DefaultTTLforRRType(rr-&gt;resrec.rrtype);

        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d] DNSServiceRegisterRecord(0x%X, %d, &quot;</span> PRI_S <span class="enscript-string">&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, RRDisplayString(&amp;mDNSStorage, &amp;rr-&gt;resrec), request-&gt;process_id,
               request-&gt;pid_name);

        err = mDNS_Register(&amp;mDNSStorage, rr);
        <span class="enscript-keyword">if</span> (err)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                   <span class="enscript-string">&quot;[R%d] DNSServiceRegisterRecord(0x%X, %d,&quot;</span> PRI_S <span class="enscript-string">&quot;) ERROR (%d)&quot;</span>,
                   request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, RRDisplayString(&amp;mDNSStorage, &amp;rr-&gt;resrec), err);
            freeL(<span class="enscript-string">&quot;registered_record_entry&quot;</span>, re);
            freeL(<span class="enscript-string">&quot;registered_record_entry/AuthRecord&quot;</span>, rr);
        }
        <span class="enscript-keyword">else</span>
        {
            LogMcastS(rr, request, reg_start);
            re-&gt;next = request-&gt;u.reg_recs;
            request-&gt;u.reg_recs = re;
        }
    }
    <span class="enscript-keyword">return</span>(err);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateDeviceInfoRecord</span>(mDNS *<span class="enscript-type">const</span> m);

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">regservice_termination_callback</span>(request_state *request)
{
    <span class="enscript-keyword">if</span> (!request)
    {
        LogMsg(<span class="enscript-string">&quot;regservice_termination_callback context is NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">while</span> (request-&gt;u.servicereg.instances)
    {
        service_instance *p = request-&gt;u.servicereg.instances;
        request-&gt;u.servicereg.instances = request-&gt;u.servicereg.instances-&gt;next;
        <span class="enscript-comment">// only safe to free memory if registration is not valid, i.e. deregister fails (which invalidates p)
</span>        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%d] DNSServiceRegister(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, %u) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               request-&gt;request_id, DM_NAME_PARAM(p-&gt;srs.RR_SRV.resrec.name-&gt;c),
               mDNSVal16(p-&gt;srs.RR_SRV.resrec.rdata-&gt;u.srv.port), request-&gt;process_id, request-&gt;pid_name);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        external_stop_advertising_helper(p);
#<span class="enscript-reference">endif</span>

        <span class="enscript-comment">// Clear backpointer *before* calling mDNS_DeregisterService/unlink_and_free_service_instance
</span>        <span class="enscript-comment">// We don't need unlink_and_free_service_instance to cut its element from the list, because we're already advancing
</span>        <span class="enscript-comment">// request-&gt;u.servicereg.instances as we work our way through the list, implicitly cutting one element at a time
</span>        <span class="enscript-comment">// We can't clear p-&gt;request *after* the calling mDNS_DeregisterService/unlink_and_free_service_instance
</span>        <span class="enscript-comment">// because by then we might have already freed p
</span>        p-&gt;request = NULL;
        LogMcastS(&amp;p-&gt;srs.RR_SRV, request, reg_stop);
        <span class="enscript-keyword">if</span> (mDNS_DeregisterService(&amp;mDNSStorage, &amp;p-&gt;srs))
        {
            unlink_and_free_service_instance(p);
            <span class="enscript-comment">// Don't touch service_instance *p after this -- it's likely to have been freed already
</span>        }
    }
    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.txtdata)
    {
        freeL(<span class="enscript-string">&quot;service_info txtdata&quot;</span>, request-&gt;u.servicereg.txtdata);
        request-&gt;u.servicereg.txtdata = NULL;
    }
    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.autoname)
    {
        <span class="enscript-comment">// Clear autoname before calling UpdateDeviceInfoRecord() so it doesn't mistakenly include this in its count of active autoname registrations
</span>        request-&gt;u.servicereg.autoname = mDNSfalse;
        UpdateDeviceInfoRecord(&amp;mDNSStorage);
    }
}

mDNSlocal request_state *<span class="enscript-function-name">LocateSubordinateRequest</span>(request_state *request)
{
    request_state *req;
    <span class="enscript-keyword">for</span> (req = all_requests; req; req = req-&gt;next)
        <span class="enscript-keyword">if</span> (req-&gt;primary == request &amp;&amp;
            req-&gt;hdr.client_context.u32[0] == request-&gt;hdr.client_context.u32[0] &amp;&amp;
            req-&gt;hdr.client_context.u32[1] == request-&gt;hdr.client_context.u32[1]) <span class="enscript-keyword">return</span>(req);
    <span class="enscript-keyword">return</span>(request);
}

mDNSlocal mStatus <span class="enscript-function-name">add_record_to_service</span>(request_state *request, service_instance *instance, mDNSu16 rrtype, mDNSu16 rdlen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *rdata, mDNSu32 ttl)
{
    ServiceRecordSet *srs = &amp;instance-&gt;srs;
    mStatus result;
    size_t size = rdlen &gt; <span class="enscript-keyword">sizeof</span>(RDataBody) ? rdlen : <span class="enscript-keyword">sizeof</span>(RDataBody);
    ExtraResourceRecord *extra = (ExtraResourceRecord *) mallocL(<span class="enscript-string">&quot;ExtraResourceRecord&quot;</span>, <span class="enscript-keyword">sizeof</span>(*extra) - <span class="enscript-keyword">sizeof</span>(RDataBody) + size);
    <span class="enscript-keyword">if</span> (!extra) { my_perror(<span class="enscript-string">&quot;ERROR: malloc&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }

    mDNSPlatformMemZero(extra, <span class="enscript-keyword">sizeof</span>(*extra));  <span class="enscript-comment">// OK if oversized rdata not zero'd
</span>    extra-&gt;r.resrec.rrtype = rrtype;
    extra-&gt;r.rdatastorage.MaxRDLength = (mDNSu16) size;
    extra-&gt;r.resrec.rdlength = rdlen;
    mDNSPlatformMemCopy(&amp;extra-&gt;r.rdatastorage.u.data, rdata, rdlen);
    <span class="enscript-comment">// use InterfaceID value from DNSServiceRegister() call that created the original service
</span>    extra-&gt;r.resrec.InterfaceID = request-&gt;u.servicereg.InterfaceID;

    result = mDNS_AddRecordToService(&amp;mDNSStorage, srs, extra, &amp;extra-&gt;r.rdatastorage, ttl, request-&gt;flags);
    <span class="enscript-keyword">if</span> (result)
    {
        freeL(<span class="enscript-string">&quot;ExtraResourceRecord/add_record_to_service&quot;</span>, extra);
        <span class="enscript-keyword">return</span> result;
    }
    LogMcastS(&amp;srs-&gt;RR_PTR, request, reg_start);

    extra-&gt;ClientID = request-&gt;hdr.reg_index;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    <span class="enscript-keyword">if</span> (   instance-&gt;external_advertise
           &amp;&amp; callExternalHelpers(request-&gt;u.servicereg.InterfaceID, &amp;instance-&gt;domain, request-&gt;flags))
    {
        LogInfo(<span class="enscript-string">&quot;add_record_to_service: calling external_start_advertising_service&quot;</span>);
        external_start_advertising_service(&amp;extra-&gt;r.resrec, request-&gt;flags);
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> result;
}

mDNSlocal mStatus <span class="enscript-function-name">handle_add_request</span>(request_state *request)
{
    service_instance *i;
    mStatus result = mStatus_UnknownErr;
    DNSServiceFlags flags  = get_flags (&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu16 rrtype = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu16 rdlen  = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     *rdata  = get_rdata (&amp;request-&gt;msgptr, request-&gt;msgend, rdlen);
    mDNSu32 ttl    = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-keyword">if</span> (!ttl) ttl = DefaultTTLforRRType(rrtype);
    (<span class="enscript-type">void</span>)flags; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceAddRecord(unreadable parameters)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// If this is a shared connection, check if the operation actually applies to a subordinate request_state object
</span>    <span class="enscript-keyword">if</span> (request-&gt;terminate == connection_termination) request = LocateSubordinateRequest(request);

    <span class="enscript-keyword">if</span> (request-&gt;terminate != regservice_termination_callback)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceAddRecord(not a registered service ref)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// For a service registered with zero port, don't allow adding records. This mostly happens due to a bug
</span>    <span class="enscript-comment">// in the application. See radar://9165807.
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(request-&gt;u.servicereg.port))
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceAddRecord: adding record to a service registered with zero port&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceAddRecord(%X, &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;, %d) PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, flags,
           DM_NAME_PARAM((request-&gt;u.servicereg.instances) ? (request-&gt;u.servicereg.instances-&gt;srs.RR_SRV.resrec.name-&gt;c) : mDNSNULL),
           DNSTypeName(rrtype), rdlen, request-&gt;process_id, request-&gt;pid_name);

    <span class="enscript-keyword">for</span> (i = request-&gt;u.servicereg.instances; i; i = i-&gt;next)
    {
        result = add_record_to_service(request, i, rrtype, rdlen, rdata, ttl);
        <span class="enscript-keyword">if</span> (result &amp;&amp; i-&gt;default_local) <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">else</span> result = mStatus_NoError;  <span class="enscript-comment">// suppress non-local default errors
</span>    }

    <span class="enscript-keyword">return</span>(result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">update_callback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, RData *oldrd, mDNSu16 oldrdlen)
{
    mDNSBool external_advertise = (rr-&gt;UpdateContext) ? *((mDNSBool *)rr-&gt;UpdateContext) : mDNSfalse;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-comment">// There are three cases.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. We have updated the primary TXT record of the service
</span>    <span class="enscript-comment">// 2. We have updated the TXT record that was added to the service using DNSServiceAddRecord
</span>    <span class="enscript-comment">// 3. We have updated the TXT record that was registered using DNSServiceRegisterRecord
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// external_advertise is set if we have advertised at least once during the initial addition
</span>    <span class="enscript-comment">// of the record in all of the three cases above. We should have checked for InterfaceID/LocalDomain
</span>    <span class="enscript-comment">// checks during the first time and hence we don't do any checks here
</span>    <span class="enscript-keyword">if</span> (external_advertise)
    {
        ResourceRecord ext = rr-&gt;resrec;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        DNSServiceFlags flags = deriveD2DFlagsFromAuthRecType(rr-&gt;ARType);
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">if</span> (ext.rdlength == oldrdlen &amp;&amp; mDNSPlatformMemSame(&amp;ext.rdata-&gt;u, &amp;oldrd-&gt;u, oldrdlen)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        SetNewRData(&amp;ext, oldrd, oldrdlen);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        external_stop_advertising_service(&amp;ext, flags);
        LogInfo(<span class="enscript-string">&quot;update_callback: calling external_start_advertising_service&quot;</span>);
        external_start_advertising_service(&amp;rr-&gt;resrec, flags);
#<span class="enscript-reference">endif</span>
    }
<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (oldrd != &amp;rr-&gt;rdatastorage) freeL(<span class="enscript-string">&quot;RData/update_callback&quot;</span>, oldrd);
}

mDNSlocal mStatus <span class="enscript-function-name">update_record</span>(AuthRecord *rr, mDNSu16 rdlen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *rdata, mDNSu32 ttl, <span class="enscript-type">const</span> mDNSBool *<span class="enscript-type">const</span> external_advertise)
{
    mStatus result;
    <span class="enscript-type">const</span> size_t rdsize = (rdlen &gt; <span class="enscript-keyword">sizeof</span>(RDataBody)) ? rdlen : <span class="enscript-keyword">sizeof</span>(RDataBody);
    RData *newrd = (RData *) mallocL(<span class="enscript-string">&quot;RData/update_record&quot;</span>, <span class="enscript-keyword">sizeof</span>(RData) - <span class="enscript-keyword">sizeof</span>(RDataBody) + rdsize);
    <span class="enscript-keyword">if</span> (!newrd) FatalError(<span class="enscript-string">&quot;ERROR: malloc&quot;</span>);
    newrd-&gt;MaxRDLength = (mDNSu16) rdsize;
    mDNSPlatformMemCopy(&amp;newrd-&gt;u, rdata, rdlen);

    <span class="enscript-comment">// BIND named (name daemon) doesn't allow TXT records with zero-length rdata. This is strictly speaking correct,
</span>    <span class="enscript-comment">// since RFC 1035 specifies a TXT record as &quot;One or more &lt;character-string&gt;s&quot;, not &quot;Zero or more &lt;character-string&gt;s&quot;.
</span>    <span class="enscript-comment">// Since some legacy apps try to create zero-length TXT records, we'll silently correct it here.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_TXT &amp;&amp; rdlen == 0) { rdlen = 1; newrd-&gt;u.txt.c[0] = 0; }

    <span class="enscript-keyword">if</span> (external_advertise) rr-&gt;UpdateContext = (<span class="enscript-type">void</span> *)external_advertise;

    result = mDNS_Update(&amp;mDNSStorage, rr, ttl, rdlen, newrd, update_callback);
    <span class="enscript-keyword">if</span> (result) { LogMsg(<span class="enscript-string">&quot;update_record: Error %d for %s&quot;</span>, (<span class="enscript-type">int</span>)result, ARDisplayString(&amp;mDNSStorage, rr)); freeL(<span class="enscript-string">&quot;RData/update_record&quot;</span>, newrd); }
    <span class="enscript-keyword">return</span> result;
}

mDNSlocal mStatus <span class="enscript-function-name">handle_update_request</span>(request_state *request)
{
    <span class="enscript-type">const</span> ipc_msg_hdr *<span class="enscript-type">const</span> hdr = &amp;request-&gt;hdr;
    mStatus result = mStatus_BadReferenceErr;
    service_instance *i;
    AuthRecord *rr = NULL;

    <span class="enscript-comment">// get the message data
</span>    DNSServiceFlags flags = get_flags (&amp;request-&gt;msgptr, request-&gt;msgend);  <span class="enscript-comment">// flags unused
</span>    mDNSu16 rdlen = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     *rdata = get_rdata (&amp;request-&gt;msgptr, request-&gt;msgend, rdlen);
    mDNSu32 ttl   = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    (<span class="enscript-type">void</span>)flags; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceUpdateRecord(unreadable parameters)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// If this is a shared connection, check if the operation actually applies to a subordinate request_state object
</span>    <span class="enscript-keyword">if</span> (request-&gt;terminate == connection_termination) request = LocateSubordinateRequest(request);

    <span class="enscript-keyword">if</span> (request-&gt;terminate == connection_termination)
    {
        <span class="enscript-comment">// update an individually registered record
</span>        registered_record_entry *reptr;
        <span class="enscript-keyword">for</span> (reptr = request-&gt;u.reg_recs; reptr; reptr = reptr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (reptr-&gt;key == hdr-&gt;reg_index)
            {
                result = update_record(reptr-&gt;rr, rdlen, rdata, ttl, &amp;reptr-&gt;external_advertise);
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                       <span class="enscript-string">&quot;[R%d] DNSServiceUpdateRecord(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                       request-&gt;request_id, DM_NAME_PARAM(reptr-&gt;rr-&gt;resrec.name-&gt;c),
                       reptr-&gt;rr ? DNSTypeName(reptr-&gt;rr-&gt;resrec.rrtype) : <span class="enscript-string">&quot;&lt;NONE&gt;&quot;</span>,
                       request-&gt;process_id, request-&gt;pid_name);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
            }
        }
        result = mStatus_BadReferenceErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
    }

    <span class="enscript-keyword">if</span> (request-&gt;terminate != regservice_termination_callback)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceUpdateRecord(not a registered service ref)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// For a service registered with zero port, only SRV record is initialized. Don't allow any updates.
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(request-&gt;u.servicereg.port))
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceUpdateRecord: updating the record of a service registered with zero port&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// update the saved off TXT data for the service
</span>    <span class="enscript-keyword">if</span> (hdr-&gt;reg_index == TXT_RECORD_INDEX)
    {
        <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.txtdata)
        { freeL(<span class="enscript-string">&quot;service_info txtdata&quot;</span>, request-&gt;u.servicereg.txtdata); request-&gt;u.servicereg.txtdata = NULL; }
        <span class="enscript-keyword">if</span> (rdlen &gt; 0)
        {
            request-&gt;u.servicereg.txtdata = mallocL(<span class="enscript-string">&quot;service_info txtdata&quot;</span>, rdlen);
            <span class="enscript-keyword">if</span> (!request-&gt;u.servicereg.txtdata) FatalError(<span class="enscript-string">&quot;ERROR: handle_update_request - malloc&quot;</span>);
            mDNSPlatformMemCopy(request-&gt;u.servicereg.txtdata, rdata, rdlen);
        }
        request-&gt;u.servicereg.txtlen = rdlen;
    }

    <span class="enscript-comment">// update a record from a service record set
</span>    <span class="enscript-keyword">for</span> (i = request-&gt;u.servicereg.instances; i; i = i-&gt;next)
    {
        <span class="enscript-keyword">if</span> (hdr-&gt;reg_index == TXT_RECORD_INDEX) rr = &amp;i-&gt;srs.RR_TXT;
        <span class="enscript-keyword">else</span>
        {
            ExtraResourceRecord *e;
            <span class="enscript-keyword">for</span> (e = i-&gt;srs.Extras; e; e = e-&gt;next)
                <span class="enscript-keyword">if</span> (e-&gt;ClientID == hdr-&gt;reg_index) { rr = &amp;e-&gt;r; <span class="enscript-keyword">break</span>; }
        }

        <span class="enscript-keyword">if</span> (!rr) { result = mStatus_BadReferenceErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        result = update_record(rr, rdlen, rdata, ttl, &amp;i-&gt;external_advertise);
        <span class="enscript-keyword">if</span> (result &amp;&amp; i-&gt;default_local) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
        <span class="enscript-keyword">else</span> result = mStatus_NoError;  <span class="enscript-comment">// suppress non-local default errors
</span>    }

<span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (request-&gt;terminate == regservice_termination_callback)
        LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceUpdateRecord(%##s, %s)  PID[%d](%s)&quot;</span>, request-&gt;sd,
                     (request-&gt;u.servicereg.instances) ? request-&gt;u.servicereg.instances-&gt;srs.RR_SRV.resrec.name-&gt;c : NULL,
                     rr ? DNSTypeName(rr-&gt;resrec.rrtype) : <span class="enscript-string">&quot;&lt;NONE&gt;&quot;</span>,
                     request-&gt;process_id, request-&gt;pid_name);

    <span class="enscript-keyword">return</span>(result);
}

<span class="enscript-comment">// remove a resource record registered via DNSServiceRegisterRecord()
</span>mDNSlocal mStatus <span class="enscript-function-name">remove_record</span>(request_state *request)
{
    mStatus err = mStatus_UnknownErr;
    registered_record_entry *e, **ptr = &amp;request-&gt;u.reg_recs;

    <span class="enscript-keyword">while</span> (*ptr &amp;&amp; (*ptr)-&gt;key != request-&gt;hdr.reg_index) ptr = &amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (!*ptr) { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceRemoveRecord(%u) not found&quot;</span>, request-&gt;sd, request-&gt;hdr.reg_index); <span class="enscript-keyword">return</span> mStatus_BadReferenceErr; }
    e = *ptr;
    *ptr = e-&gt;next; <span class="enscript-comment">// unlink
</span>
    LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceRemoveRecord(%u %s)  PID[%d](%s)&quot;</span>,
                request-&gt;sd, e-&gt;key, RRDisplayString(&amp;mDNSStorage, &amp;e-&gt;rr-&gt;resrec), request-&gt;process_id, request-&gt;pid_name);
    e-&gt;rr-&gt;RecordContext = NULL;
    <span class="enscript-keyword">if</span> (e-&gt;external_advertise)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        external_stop_advertising_service(&amp;e-&gt;rr-&gt;resrec, request-&gt;flags);
#<span class="enscript-reference">endif</span>
        e-&gt;external_advertise = mDNSfalse;
    }
    LogMcastS(e-&gt;rr, request, reg_stop);
    err = mDNS_Deregister(&amp;mDNSStorage, e-&gt;rr);     <span class="enscript-comment">// Will free e-&gt;rr for us; we're responsible for freeing e
</span>    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: remove_record, mDNS_Deregister: %d&quot;</span>, err);
        freeL(<span class="enscript-string">&quot;registered_record_entry AuthRecord remove_record&quot;</span>, e-&gt;rr);
    }
    freeL(<span class="enscript-string">&quot;registered_record_entry remove_record&quot;</span>, e);
    <span class="enscript-keyword">return</span> err;
}

mDNSlocal mStatus <span class="enscript-function-name">remove_extra</span>(<span class="enscript-type">const</span> request_state *<span class="enscript-type">const</span> request, service_instance *<span class="enscript-type">const</span> serv, mDNSu16 *<span class="enscript-type">const</span> rrtype)
{
    mStatus err = mStatus_BadReferenceErr;
    ExtraResourceRecord *ptr;

    <span class="enscript-keyword">for</span> (ptr = serv-&gt;srs.Extras; ptr; ptr = ptr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (ptr-&gt;ClientID == request-&gt;hdr.reg_index) <span class="enscript-comment">// found match
</span>        {
            *rrtype = ptr-&gt;r.resrec.rrtype;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            <span class="enscript-keyword">if</span> (serv-&gt;external_advertise) external_stop_advertising_service(&amp;ptr-&gt;r.resrec, request-&gt;flags);
#<span class="enscript-reference">endif</span>
            err = mDNS_RemoveRecordFromService(&amp;mDNSStorage, &amp;serv-&gt;srs, ptr, FreeExtraRR, ptr);
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">return</span> err;
}

mDNSlocal mStatus <span class="enscript-function-name">handle_removerecord_request</span>(request_state *request)
{
    mStatus err = mStatus_BadReferenceErr;
    get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);   <span class="enscript-comment">// flags unused
</span>
    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceRemoveRecord(unreadable parameters)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// If this is a shared connection, check if the operation actually applies to a subordinate request_state object
</span>    <span class="enscript-keyword">if</span> (request-&gt;terminate == connection_termination) request = LocateSubordinateRequest(request);

    <span class="enscript-keyword">if</span> (request-&gt;terminate == connection_termination)
        err = remove_record(request);  <span class="enscript-comment">// remove individually registered record
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (request-&gt;terminate != regservice_termination_callback)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceRemoveRecord(not a registered service ref)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }
    <span class="enscript-keyword">else</span>
    {
        service_instance *i;
        mDNSu16 rrtype = 0;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%d] DNSServiceRemoveRecord(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               request-&gt;request_id,
               DM_NAME_PARAM((request-&gt;u.servicereg.instances) ? (request-&gt;u.servicereg.instances-&gt;srs.RR_SRV.resrec.name-&gt;c) : mDNSNULL),
               rrtype ? DNSTypeName(rrtype) : <span class="enscript-string">&quot;&lt;NONE&gt;&quot;</span>, request-&gt;process_id, request-&gt;pid_name);
        <span class="enscript-keyword">for</span> (i = request-&gt;u.servicereg.instances; i; i = i-&gt;next)
        {
            err = remove_extra(request, i, &amp;rrtype);
            <span class="enscript-keyword">if</span> (err &amp;&amp; i-&gt;default_local) <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">else</span> err = mStatus_NoError;  <span class="enscript-comment">// suppress non-local default errors
</span>        }
    }

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// If there's a comma followed by another character,
</span><span class="enscript-comment">// FindFirstSubType overwrites the comma with a nul and returns the pointer to the next character.
</span><span class="enscript-comment">// Otherwise, it returns a pointer to the final nul at the end of the string
</span>mDNSlocal <span class="enscript-type">char</span> *<span class="enscript-function-name">FindFirstSubType</span>(<span class="enscript-type">char</span> *p)
{
    <span class="enscript-keyword">while</span> (*p)
    {
        <span class="enscript-keyword">if</span> (p[0] == <span class="enscript-string">'\\'</span> &amp;&amp; p[1])
        {
             p += 2;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p[0] == <span class="enscript-string">','</span> &amp;&amp; p[1])
        {
            *p++ = 0;
            <span class="enscript-keyword">return</span>(p);
        }
        <span class="enscript-keyword">else</span>
        {
            p++;
        }
    }
    <span class="enscript-keyword">return</span>(p);
}

<span class="enscript-comment">// If there's a comma followed by another character,
</span><span class="enscript-comment">// FindNextSubType overwrites the comma with a nul and returns the pointer to the next character.
</span><span class="enscript-comment">// If it finds an illegal unescaped dot in the subtype name, it returns mDNSNULL
</span><span class="enscript-comment">// Otherwise, it returns a pointer to the final nul at the end of the string
</span>mDNSlocal <span class="enscript-type">char</span> *<span class="enscript-function-name">FindNextSubType</span>(<span class="enscript-type">char</span> *p)
{
    <span class="enscript-keyword">while</span> (*p)
    {
        <span class="enscript-keyword">if</span> (p[0] == <span class="enscript-string">'\\'</span> &amp;&amp; p[1])       <span class="enscript-comment">// If escape character
</span>            p += 2;                     <span class="enscript-comment">// ignore following character
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p[0] == <span class="enscript-string">','</span>)           <span class="enscript-comment">// If we found a comma
</span>        {
            <span class="enscript-keyword">if</span> (p[1]) *p++ = 0;
            <span class="enscript-keyword">return</span>(p);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p[0] == <span class="enscript-string">'.'</span>)
            <span class="enscript-keyword">return</span>(mDNSNULL);
        <span class="enscript-keyword">else</span> p++;
    }
    <span class="enscript-keyword">return</span>(p);
}

<span class="enscript-comment">// Returns -1 if illegal subtype found
</span>mDNSlocal mDNSs32 <span class="enscript-function-name">ChopSubTypes</span>(<span class="enscript-type">char</span> *regtype)
{
    mDNSs32 NumSubTypes = 0;
    <span class="enscript-type">char</span> *stp = FindFirstSubType(regtype);
    <span class="enscript-keyword">while</span> (stp &amp;&amp; *stp)                 <span class="enscript-comment">// If we found a comma...
</span>    {
        <span class="enscript-keyword">if</span> (*stp == <span class="enscript-string">','</span>) <span class="enscript-keyword">return</span>(-1);
        NumSubTypes++;
        stp = FindNextSubType(stp);
    }
    <span class="enscript-keyword">if</span> (!stp) <span class="enscript-keyword">return</span>(-1);
    <span class="enscript-keyword">return</span>(NumSubTypes);
}

mDNSlocal AuthRecord *<span class="enscript-function-name">AllocateSubTypes</span>(mDNSs32 NumSubTypes, <span class="enscript-type">char</span> *p)
{
    AuthRecord *st = mDNSNULL;
    <span class="enscript-keyword">if</span> (NumSubTypes)
    {
        mDNSs32 i;
        st = (AuthRecord *) callocL(<span class="enscript-string">&quot;ServiceSubTypes&quot;</span>, NumSubTypes * <span class="enscript-keyword">sizeof</span>(AuthRecord));
        <span class="enscript-keyword">if</span> (!st) <span class="enscript-keyword">return</span>(mDNSNULL);
        <span class="enscript-keyword">for</span> (i = 0; i &lt; NumSubTypes; i++)
        {
            mDNS_SetupResourceRecord(&amp;st[i], mDNSNULL, mDNSInterface_Any, kDNSQType_ANY, kStandardTTL, 0, AuthRecordAny, mDNSNULL, mDNSNULL);
            <span class="enscript-keyword">while</span> (*p) p++;
            p++;
            <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;st[i].namestorage, p))
            {
                freeL(<span class="enscript-string">&quot;ServiceSubTypes&quot;</span>, st);
                <span class="enscript-keyword">return</span>(mDNSNULL);
            }
        }
    }
    <span class="enscript-keyword">return</span>(st);
}

mDNSlocal mStatus <span class="enscript-function-name">register_service_instance</span>(request_state *request, <span class="enscript-type">const</span> domainname *domain)
{
    service_instance **ptr, *instance;
    size_t extra_size = (request-&gt;u.servicereg.txtlen &gt; <span class="enscript-keyword">sizeof</span>(RDataBody)) ? (request-&gt;u.servicereg.txtlen - <span class="enscript-keyword">sizeof</span>(RDataBody)) : 0;
    <span class="enscript-type">const</span> mDNSBool DomainIsLocal = SameDomainName(domain, &amp;localdomain);
    mStatus result;
    mDNSInterfaceID interfaceID = request-&gt;u.servicereg.InterfaceID;

    <span class="enscript-comment">// If the client specified an interface, but no domain, then we honor the specified interface for the &quot;local&quot; (mDNS)
</span>    <span class="enscript-comment">// registration but for the wide-area registrations we don't (currently) have any concept of a wide-area unicast
</span>    <span class="enscript-comment">// registrations scoped to a specific interface, so for the automatic domains we add we must *not* specify an interface.
</span>    <span class="enscript-comment">// (Specifying an interface with an apparently wide-area domain (i.e. something other than &quot;local&quot;)
</span>    <span class="enscript-comment">// currently forces the registration to use mDNS multicast despite the apparently wide-area domain.)
</span>    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.default_domain &amp;&amp; !DomainIsLocal) interfaceID = mDNSInterface_Any;

    <span class="enscript-keyword">for</span> (ptr = &amp;request-&gt;u.servicereg.instances; *ptr; ptr = &amp;(*ptr)-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;(*ptr)-&gt;domain, domain))
        {
            LogMsg(<span class="enscript-string">&quot;register_service_instance: domain %##s already registered for %#s.%##s&quot;</span>,
                   domain-&gt;c, &amp;request-&gt;u.servicereg.name, &amp;request-&gt;u.servicereg.type);
            <span class="enscript-keyword">return</span> mStatus_AlreadyRegistered;
        }
    }

    instance = (service_instance *) callocL(<span class="enscript-string">&quot;service_instance&quot;</span>, <span class="enscript-keyword">sizeof</span>(*instance) + extra_size);
    <span class="enscript-keyword">if</span> (!instance) { my_perror(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }

    instance-&gt;next                          = mDNSNULL;
    instance-&gt;request                       = request;
    instance-&gt;renameonmemfree               = 0;
    instance-&gt;clientnotified                = mDNSfalse;
    instance-&gt;default_local                 = (request-&gt;u.servicereg.default_domain &amp;&amp; DomainIsLocal);
    instance-&gt;external_advertise            = mDNSfalse;
    AssignDomainName(&amp;instance-&gt;domain, domain);

    instance-&gt;subtypes = AllocateSubTypes(request-&gt;u.servicereg.num_subtypes, request-&gt;u.servicereg.type_as_string);

    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.num_subtypes &amp;&amp; !instance-&gt;subtypes)
    {
        unlink_and_free_service_instance(instance);
        instance = NULL;
        FatalError(<span class="enscript-string">&quot;ERROR: malloc&quot;</span>);
    }

    result = mDNS_RegisterService(&amp;mDNSStorage, &amp;instance-&gt;srs,
                                  &amp;request-&gt;u.servicereg.name, &amp;request-&gt;u.servicereg.type, domain,
                                  request-&gt;u.servicereg.host.c[0] ? &amp;request-&gt;u.servicereg.host : NULL,
                                  request-&gt;u.servicereg.port,
                                  mDNSNULL, request-&gt;u.servicereg.txtdata, request-&gt;u.servicereg.txtlen,
                                  instance-&gt;subtypes, request-&gt;u.servicereg.num_subtypes,
                                  interfaceID, regservice_callback, instance, request-&gt;flags);

    <span class="enscript-keyword">if</span> (!result)
    {
        *ptr = instance;        <span class="enscript-comment">// Append this to the end of our request-&gt;u.servicereg.instances list
</span>        LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceRegister(%##s, %u) ADDED&quot;</span>, instance-&gt;request-&gt;sd,
                     instance-&gt;srs.RR_SRV.resrec.name-&gt;c, mDNSVal16(request-&gt;u.servicereg.port));
        LogMcastS(&amp;instance-&gt;srs.RR_SRV, request, reg_start);
    }
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;register_service_instance %#s.%##s%##s error %d&quot;</span>,
               &amp;request-&gt;u.servicereg.name, &amp;request-&gt;u.servicereg.type, domain-&gt;c, result);
        unlink_and_free_service_instance(instance);
    }

    <span class="enscript-keyword">return</span> result;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_default_reg_domain_changed</span>(<span class="enscript-type">const</span> DNameListElem *<span class="enscript-type">const</span> d, <span class="enscript-type">const</span> mDNSBool add)
{
    request_state *request;

    LogMsg(<span class="enscript-string">&quot;%s registration domain %##s&quot;</span>, add ? <span class="enscript-string">&quot;Adding&quot;</span> : <span class="enscript-string">&quot;Removing&quot;</span>, d-&gt;name.c);
    <span class="enscript-keyword">for</span> (request = all_requests; request; request = request-&gt;next)
    {
        <span class="enscript-keyword">if</span> (request-&gt;terminate != regservice_termination_callback) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!request-&gt;u.servicereg.default_domain) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!d-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == d-&gt;uid)
        {
            service_instance **ptr = &amp;request-&gt;u.servicereg.instances;
            <span class="enscript-keyword">while</span> (*ptr &amp;&amp; !SameDomainName(&amp;(*ptr)-&gt;domain, &amp;d-&gt;name)) ptr = &amp;(*ptr)-&gt;next;
            <span class="enscript-keyword">if</span> (add)
            {
                <span class="enscript-comment">// If we don't already have this domain in our list for this registration, add it now
</span>                <span class="enscript-keyword">if</span> (!*ptr) register_service_instance(request, &amp;d-&gt;name);
                <span class="enscript-keyword">else</span> debugf(<span class="enscript-string">&quot;udsserver_default_reg_domain_changed %##s already in list, not re-adding&quot;</span>, &amp;d-&gt;name);
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Normally we should not fail to find the specified instance
</span>                <span class="enscript-comment">// One case where this can happen is if a uDNS update fails for some reason,
</span>                <span class="enscript-comment">// and regservice_callback then calls unlink_and_free_service_instance and disposes of that instance.
</span>                <span class="enscript-keyword">if</span> (!*ptr)
                    LogMsg(<span class="enscript-string">&quot;udsserver_default_reg_domain_changed domain %##s not found for service %#s type %s&quot;</span>,
                           &amp;d-&gt;name, request-&gt;u.servicereg.name.c, request-&gt;u.servicereg.type_as_string);
                <span class="enscript-keyword">else</span>
                {
                    DNameListElem *p;
                    <span class="enscript-keyword">for</span> (p = AutoRegistrationDomains; p; p=p-&gt;next)
                        <span class="enscript-keyword">if</span> (!p-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == p-&gt;uid)
                            <span class="enscript-keyword">if</span> (SameDomainName(&amp;d-&gt;name, &amp;p-&gt;name)) <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">if</span> (p) debugf(<span class="enscript-string">&quot;udsserver_default_reg_domain_changed %##s still in list, not removing&quot;</span>, &amp;d-&gt;name);
                    <span class="enscript-keyword">else</span>
                    {
                        mStatus err;
                        service_instance *si = *ptr;
                        *ptr = si-&gt;next;
                        <span class="enscript-keyword">if</span> (si-&gt;clientnotified) SendServiceRemovalNotification(&amp;si-&gt;srs); <span class="enscript-comment">// Do this *before* clearing si-&gt;request backpointer
</span>                        <span class="enscript-comment">// Now that we've cut this service_instance from the list, we MUST clear the si-&gt;request backpointer.
</span>                        <span class="enscript-comment">// Otherwise what can happen is this: While our mDNS_DeregisterService is in the
</span>                        <span class="enscript-comment">// process of completing asynchronously, the client cancels the entire operation, so
</span>                        <span class="enscript-comment">// regservice_termination_callback then runs through the whole list deregistering each
</span>                        <span class="enscript-comment">// instance, clearing the backpointers, and then disposing the parent request_state object.
</span>                        <span class="enscript-comment">// However, because this service_instance isn't in the list any more, regservice_termination_callback
</span>                        <span class="enscript-comment">// has no way to find it and clear its backpointer, and then when our mDNS_DeregisterService finally
</span>                        <span class="enscript-comment">// completes later with a mStatus_MemFree message, it calls unlink_and_free_service_instance() with
</span>                        <span class="enscript-comment">// a service_instance with a stale si-&gt;request backpointer pointing to memory that's already been freed.
</span>                        si-&gt;request = NULL;
                        err = mDNS_DeregisterService(&amp;mDNSStorage, &amp;si-&gt;srs);
                        <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;udsserver_default_reg_domain_changed err %d&quot;</span>, err); unlink_and_free_service_instance(si); }
                    }
                }
            }
        }
    }
}

<span class="enscript-comment">// Returns true if the interfaceIndex value matches one of the pre-defined
</span><span class="enscript-comment">// special values listed in the switch statement below.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">PreDefinedInterfaceIndex</span>(mDNSu32 interfaceIndex)
{
    <span class="enscript-keyword">switch</span>(interfaceIndex)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceInterfaceIndexAny</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceInterfaceIndexLocalOnly</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceInterfaceIndexUnicast</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceInterfaceIndexP2P</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceInterfaceIndexBLE</span>:
            <span class="enscript-keyword">return</span> mDNStrue;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span> mDNSfalse;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">handle_regservice_request</span>(request_state *request)
{
    <span class="enscript-type">char</span> name[256]; <span class="enscript-comment">// Lots of spare space for extra-long names that we'll auto-truncate down to 63 bytes
</span>    <span class="enscript-type">char</span> domain[MAX_ESCAPED_DOMAIN_NAME], host[MAX_ESCAPED_DOMAIN_NAME];
    <span class="enscript-type">char</span> type_as_string[MAX_ESCAPED_DOMAIN_NAME];  <span class="enscript-comment">// Note that this service type may include a trailing list of subtypes
</span>    domainname d, srv;
    mStatus err;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msgTXTData;

    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSInterfaceID InterfaceID;

    <span class="enscript-comment">// Map kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny with the 
</span>    <span class="enscript-comment">// kDNSServiceFlagsIncludeP2P flag set.
</span>    <span class="enscript-keyword">if</span> (interfaceIndex == kDNSServiceInterfaceIndexP2P)
    {
        LogOperation(<span class="enscript-string">&quot;handle_regservice_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P&quot;</span>);
        flags |= kDNSServiceFlagsIncludeP2P;
        interfaceIndex = kDNSServiceInterfaceIndexAny;
    }

    InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);

    <span class="enscript-comment">// The registration is scoped to a specific interface index, but the 
</span>    <span class="enscript-comment">// interface is not currently in our list.
</span>    <span class="enscript-keyword">if</span> (interfaceIndex &amp;&amp; !InterfaceID)
    {
        <span class="enscript-comment">// If it's one of the specially defined inteface index values, just return an error.
</span>        <span class="enscript-keyword">if</span> (PreDefinedInterfaceIndex(interfaceIndex))
        {
            LogInfo(<span class="enscript-string">&quot;handle_regservice_request: bad interfaceIndex %d&quot;</span>, interfaceIndex);
            <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        }

        <span class="enscript-comment">// Otherwise, use the specified interface index value and the registration will
</span>        <span class="enscript-comment">// be applied to that interface when it comes up.
</span>        InterfaceID = (mDNSInterfaceID)(uintptr_t)interfaceIndex;
        LogInfo(<span class="enscript-string">&quot;handle_regservice_request: registration pending for interface index %d&quot;</span>, interfaceIndex);
    }

    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, name,           <span class="enscript-keyword">sizeof</span>(name          )) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, type_as_string, <span class="enscript-keyword">sizeof</span>(type_as_string)) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, domain,         <span class="enscript-keyword">sizeof</span>(domain        )) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, host,           <span class="enscript-keyword">sizeof</span>(host          )) &lt; 0)
    { LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - Couldn't read name/regtype/domain&quot;</span>); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    request-&gt;flags = flags;
    request-&gt;interfaceIndex = interfaceIndex;
    request-&gt;u.servicereg.InterfaceID = InterfaceID;
    request-&gt;u.servicereg.instances = NULL;
    request-&gt;u.servicereg.txtlen  = 0;
    request-&gt;u.servicereg.txtdata = NULL;
    mDNSPlatformStrLCopy(request-&gt;u.servicereg.type_as_string, type_as_string, <span class="enscript-keyword">sizeof</span>(request-&gt;u.servicereg.type_as_string));

    <span class="enscript-keyword">if</span> (request-&gt;msgptr + 2 &gt; request-&gt;msgend) request-&gt;msgptr = NULL;
    <span class="enscript-keyword">else</span>
    {
        request-&gt;u.servicereg.port.b[0] = *request-&gt;msgptr++;
        request-&gt;u.servicereg.port.b[1] = *request-&gt;msgptr++;
    }

    request-&gt;u.servicereg.txtlen = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    msgTXTData = get_rdata(&amp;request-&gt;msgptr, request-&gt;msgend, request-&gt;u.servicereg.txtlen);

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr) { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceRegister(unreadable parameters)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.txtlen)
    {
        request-&gt;u.servicereg.txtdata = mallocL(<span class="enscript-string">&quot;service_info txtdata&quot;</span>, request-&gt;u.servicereg.txtlen);
        <span class="enscript-keyword">if</span> (!request-&gt;u.servicereg.txtdata) FatalError(<span class="enscript-string">&quot;ERROR: handle_regservice_request - malloc&quot;</span>);
        mDNSPlatformMemCopy(request-&gt;u.servicereg.txtdata, msgTXTData, request-&gt;u.servicereg.txtlen);
    }

    <span class="enscript-comment">// Check for sub-types after the service type
</span>    request-&gt;u.servicereg.num_subtypes = ChopSubTypes(request-&gt;u.servicereg.type_as_string);    <span class="enscript-comment">// Note: Modifies regtype string to remove trailing subtypes
</span>    <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.num_subtypes &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - ChopSubTypes failed %s&quot;</span>, request-&gt;u.servicereg.type_as_string);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>;
    }

    <span class="enscript-comment">// Don't try to construct &quot;domainname t&quot; until *after* ChopSubTypes has worked its magic
</span>    <span class="enscript-keyword">if</span> (!*request-&gt;u.servicereg.type_as_string || !MakeDomainNameFromDNSNameString(&amp;request-&gt;u.servicereg.type, request-&gt;u.servicereg.type_as_string))
    { LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - type_as_string bad %s&quot;</span>, request-&gt;u.servicereg.type_as_string); <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>; }

    <span class="enscript-keyword">if</span> (!name[0])
    {
        request-&gt;u.servicereg.name = mDNSStorage.nicelabel;
        request-&gt;u.servicereg.autoname = mDNStrue;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// If the client is allowing AutoRename, then truncate name to legal length before converting it to a DomainLabel
</span>        <span class="enscript-keyword">if</span> ((flags &amp; kDNSServiceFlagsNoAutoRename) == 0)
        {
            <span class="enscript-type">int</span> newlen = TruncateUTF8ToLength((mDNSu8*)name, mDNSPlatformStrLen(name), MAX_DOMAIN_LABEL);
            name[newlen] = 0;
        }
        <span class="enscript-keyword">if</span> (!MakeDomainLabelFromLiteralString(&amp;request-&gt;u.servicereg.name, name))
        { LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - name bad %s&quot;</span>, name); <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>; }
        request-&gt;u.servicereg.autoname = mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (*domain)
    {
        request-&gt;u.servicereg.default_domain = mDNSfalse;
        <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;d, domain))
        { LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - domain bad %s&quot;</span>, domain); <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>; }
    }
    <span class="enscript-keyword">else</span>
    {
        request-&gt;u.servicereg.default_domain = mDNStrue;
        MakeDomainNameFromDNSNameString(&amp;d, <span class="enscript-string">&quot;local.&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (!ConstructServiceName(&amp;srv, &amp;request-&gt;u.servicereg.name, &amp;request-&gt;u.servicereg.type, &amp;d))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - Couldn't ConstructServiceName from, “%#s” “%##s” “%##s”&quot;</span>,
               request-&gt;u.servicereg.name.c, request-&gt;u.servicereg.type.c, d.c); <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>;
    }

    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;request-&gt;u.servicereg.host, host))
    { LogMsg(<span class="enscript-string">&quot;ERROR: handle_regservice_request - host bad %s&quot;</span>, host); <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_param</span>; }
    request-&gt;u.servicereg.autorename       = (flags &amp; kDNSServiceFlagsNoAutoRename    ) == 0;
    request-&gt;u.servicereg.allowremotequery = (flags &amp; kDNSServiceFlagsAllowRemoteQuery) != 0;

    <span class="enscript-comment">// Some clients use mDNS for lightweight copy protection, registering a pseudo-service with
</span>    <span class="enscript-comment">// a port number of zero. When two instances of the protected client are allowed to run on one
</span>    <span class="enscript-comment">// machine, we don't want to see misleading &quot;Bogus client&quot; messages in syslog and the console.
</span>    <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(request-&gt;u.servicereg.port))
    {
        <span class="enscript-type">int</span> count = CountExistingRegistrations(&amp;srv, request-&gt;u.servicereg.port);
        <span class="enscript-keyword">if</span> (count)
            LogMsg(<span class="enscript-string">&quot;Client application[%d](%s) registered %d identical instances of service %##s port %u.&quot;</span>, request-&gt;process_id,
                   request-&gt;pid_name, count+1, srv.c, mDNSVal16(request-&gt;u.servicereg.port));
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-comment">// Determine if this request should be promoted to use BLE triggered feature.
</span>    <span class="enscript-keyword">if</span> (shouldUseBLE(InterfaceID, 0, &amp;request-&gt;u.servicereg.type, &amp;d))
    {
        request-&gt;flags |= (kDNSServiceFlagsAutoTrigger | kDNSServiceFlagsIncludeAWDL);
        LogInfo(<span class="enscript-string">&quot;handle_regservice_request: registration promoted to use kDNSServiceFlagsAutoTrigger&quot;</span>);
    }
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceRegister(%X, %d, \&quot;&quot;</span> PRI_S <span class="enscript-string">&quot;\&quot;, \&quot;&quot;</span> PRI_S <span class="enscript-string">&quot;\&quot;, \&quot;&quot;</span> PRI_S <span class="enscript-string">&quot;\&quot;, \&quot;&quot;</span> PRI_S <span class="enscript-string">&quot;\&quot;, %u) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, interfaceIndex, name, request-&gt;u.servicereg.type_as_string, domain, host,
           mDNSVal16(request-&gt;u.servicereg.port), request-&gt;process_id, request-&gt;pid_name);

    <span class="enscript-comment">// We need to unconditionally set request-&gt;terminate, because even if we didn't successfully
</span>    <span class="enscript-comment">// start any registrations right now, subsequent configuration changes may cause successful
</span>    <span class="enscript-comment">// registrations to be added, and we'll need to cancel them before freeing this memory.
</span>    <span class="enscript-comment">// We also need to set request-&gt;terminate first, before adding additional service instances,
</span>    <span class="enscript-comment">// because the udsserver_validatelists uses the request-&gt;terminate function pointer to determine
</span>    <span class="enscript-comment">// what kind of request this is, and therefore what kind of list validation is required.
</span>    request-&gt;terminate = regservice_termination_callback;

    err = register_service_instance(request, &amp;d);
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    ++curr_num_regservices;
    <span class="enscript-keyword">if</span> (curr_num_regservices &gt; max_num_regservices)
        max_num_regservices = curr_num_regservices;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
    err = AuthorizedDomain(request, &amp;d, AutoRegistrationDomains) ? register_service_instance(request, &amp;d) : mStatus_NoError;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!err)
    {
        <span class="enscript-keyword">if</span> (request-&gt;u.servicereg.autoname) UpdateDeviceInfoRecord(&amp;mDNSStorage);

        <span class="enscript-keyword">if</span> (!*domain)
        {
            DNameListElem *ptr;
            <span class="enscript-comment">// Note that we don't report errors for non-local, non-explicit domains
</span>            <span class="enscript-keyword">for</span> (ptr = AutoRegistrationDomains; ptr; ptr = ptr-&gt;next)
                <span class="enscript-keyword">if</span> (!ptr-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == ptr-&gt;uid)
                    register_service_instance(request, &amp;ptr-&gt;name);
        }
    }

    <span class="enscript-keyword">return</span>(err);

<span class="enscript-reference">bad_param</span>:
    freeL(<span class="enscript-string">&quot;handle_regservice_request (txtdata)&quot;</span>, request-&gt;u.servicereg.txtdata);
    request-&gt;u.servicereg.txtdata = NULL;
    <span class="enscript-keyword">return</span> mStatus_BadParamErr;
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceBrowse</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FoundInstance</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    DNSServiceFlags flags = AddRecord ? kDNSServiceFlagsAdd : 0;
    request_state *req = question-&gt;QuestionContext;
    reply_state *rep;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype != kDNSType_PTR)
    { LogMsg(<span class="enscript-string">&quot;%3d: FoundInstance: Should not be called with rrtype %d (not a PTR record)&quot;</span>, req-&gt;sd, answer-&gt;rrtype); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(question-&gt;TargetQID) &amp;&amp; (question-&gt;BrowseThreshold &gt; 0) &amp;&amp; (question-&gt;CurrentAnswers &gt;= question-&gt;BrowseThreshold))
    {
        flags |= kDNSServiceFlagsThresholdReached;
    }

    <span class="enscript-comment">// if returning a negative answer, then use question's name in reply
</span>    <span class="enscript-keyword">if</span> (answer-&gt;RecordType == kDNSRecordTypePacketNegative)
    {
        GenerateBrowseReply(&amp;question-&gt;qname, answer-&gt;InterfaceID, req, &amp;rep, browse_reply_op, flags, kDNSServiceErr_NoSuchRecord);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">validReply</span>;
    }

    <span class="enscript-keyword">if</span> (GenerateNTDResponse(&amp;answer-&gt;rdata-&gt;u.name, answer-&gt;InterfaceID, req, &amp;rep, browse_reply_op, flags, mStatus_NoError) != mStatus_NoError)
    {
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;req-&gt;u.browser.regtype, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x09_services\x07_dns-sd\x04_udp&quot;</span>))
        {
            <span class="enscript-comment">// Special support to enable the DNSServiceBrowse call made by Bonjour Browser
</span>            <span class="enscript-comment">// Remove after Bonjour Browser is updated to use DNSServiceQueryRecord instead of DNSServiceBrowse
</span>            GenerateBrowseReply(&amp;answer-&gt;rdata-&gt;u.name, answer-&gt;InterfaceID, req, &amp;rep, browse_reply_op, flags, mStatus_NoError);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">validReply</span>;
        }

        LogMsg(<span class="enscript-string">&quot;%3d: FoundInstance: %##s PTR %##s received from network is not valid DNS-SD service pointer&quot;</span>,
               req-&gt;sd, answer-&gt;name-&gt;c, answer-&gt;rdata-&gt;u.name.c);
        <span class="enscript-keyword">return</span>;
    }

<span class="enscript-reference">validReply</span>:

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d-&gt;Q%d] DNSServiceBrowse(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) RESULT &quot;</span> PUB_S <span class="enscript-string">&quot; interface %d: &quot;</span> PRI_S,
           req-&gt;request_id, mDNSVal16(question-&gt;TargetQID), DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype),
           AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>, mDNSPlatformInterfaceIndexfromInterfaceID(m, answer-&gt;InterfaceID, mDNSfalse),
           RRDisplayString(m, answer));

    append_reply(req, rep);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetQuestionPolicy</span>(DNSQuestion *q, request_state *req)
{
    q-&gt;euid = req-&gt;uid;
    <span class="enscript-comment">// The policy is either based on pid or UUID. Pass a zero pid
</span>    <span class="enscript-comment">// to the &quot;core&quot; if the UUID is valid. If we always pass the pid,
</span>    <span class="enscript-comment">// then the &quot;core&quot; needs to determine whether the uuid is valid 
</span>    <span class="enscript-comment">// by examining all the 16 bytes at the time of the policy
</span>    <span class="enscript-comment">// check and also when setting the delegate socket option. Also, it
</span>    <span class="enscript-comment">// requires that we zero out the uuid wherever the question is
</span>    <span class="enscript-comment">// initialized to make sure that it is not interpreted as valid.
</span>    <span class="enscript-comment">// To prevent these intrusive changes, just pass a zero pid to indicate
</span>    <span class="enscript-comment">// that pid is not valid when uuid is valid. In future if we need the
</span>    <span class="enscript-comment">// pid in the question, we will reevaluate this strategy.
</span>    <span class="enscript-keyword">if</span> (req-&gt;validUUID)
    {
        mDNSPlatformMemCopy(q-&gt;uuid, req-&gt;uuid, UUID_SIZE);
        q-&gt;pid = 0;
    }
    <span class="enscript-keyword">else</span>
    {
        q-&gt;pid = req-&gt;process_id;
    }

    <span class="enscript-comment">//debugf(&quot;SetQuestionPolicy: q-&gt;euid[%d] q-&gt;pid[%d] uuid is valid : %s&quot;, q-&gt;euid, q-&gt;pid, req-&gt;validUUID ? &quot;true&quot; : &quot;false&quot;);
</span>}

mDNSlocal mStatus <span class="enscript-function-name">add_domain_to_browser</span>(request_state *info, <span class="enscript-type">const</span> domainname *d)
{
    browser_t *b, *p;
    mStatus err;

    <span class="enscript-keyword">for</span> (p = info-&gt;u.browser.browsers; p; p = p-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;p-&gt;domain, d))
        { debugf(<span class="enscript-string">&quot;add_domain_to_browser %##s already in list&quot;</span>, d-&gt;c); <span class="enscript-keyword">return</span> mStatus_AlreadyRegistered; }
    }

    b = (browser_t *) callocL(<span class="enscript-string">&quot;browser_t&quot;</span>, <span class="enscript-keyword">sizeof</span>(*b));
    <span class="enscript-keyword">if</span> (!b) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
    AssignDomainName(&amp;b-&gt;domain, d);
    SetQuestionPolicy(&amp;b-&gt;q, info);
    err = mDNS_StartBrowse(&amp;mDNSStorage, &amp;b-&gt;q, &amp;info-&gt;u.browser.regtype, d, info-&gt;u.browser.interface_id, info-&gt;flags,
                            info-&gt;u.browser.ForceMCast, (info-&gt;flags &amp; kDNSServiceFlagsBackgroundTrafficClass) != 0, FoundInstance, info);
    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_StartBrowse returned %d for type %##s domain %##s&quot;</span>, err, info-&gt;u.browser.regtype.c, d-&gt;c);
        freeL(<span class="enscript-string">&quot;browser_t/add_domain_to_browser&quot;</span>, b);
    }
    <span class="enscript-keyword">else</span>
    {
        b-&gt;next = info-&gt;u.browser.browsers;
        info-&gt;u.browser.browsers = b;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        <span class="enscript-comment">// Determine if this request should be promoted to use BLE triggered discovery.
</span>        <span class="enscript-keyword">if</span> (shouldUseBLE(info-&gt;u.browser.interface_id, 0, &amp;info-&gt;u.browser.regtype, (domainname *) d))
        {
            info-&gt;flags |= (kDNSServiceFlagsAutoTrigger | kDNSServiceFlagsIncludeAWDL);
            b-&gt;q.flags |= (kDNSServiceFlagsAutoTrigger | kDNSServiceFlagsIncludeAWDL);
            LogInfo(<span class="enscript-string">&quot;add_domain_to_browser: request promoted to use kDNSServiceFlagsAutoTrigger&quot;</span>);
        }
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>

        LogMcastQ(&amp;b-&gt;q, info, q_start);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        <span class="enscript-keyword">if</span> (callExternalHelpers(info-&gt;u.browser.interface_id, &amp;b-&gt;domain, info-&gt;flags))
        {
            domainname tmp;
            ConstructServiceName(&amp;tmp, NULL, &amp;info-&gt;u.browser.regtype, &amp;b-&gt;domain);
            LogDebug(<span class="enscript-string">&quot;add_domain_to_browser: calling external_start_browsing_for_service()&quot;</span>);
            external_start_browsing_for_service(info-&gt;u.browser.interface_id, &amp;tmp, kDNSType_PTR, info-&gt;flags);
        }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">return</span> err;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">browse_termination_callback</span>(request_state *info)
{
    <span class="enscript-keyword">if</span> (info-&gt;u.browser.default_domain)
    {
        <span class="enscript-comment">// Stop the domain enumeration queries to discover the WAB legacy browse domains
</span>        LogInfo(<span class="enscript-string">&quot;%3d: DNSServiceBrowse Cancel WAB PID[%d](%s)&quot;</span>, info-&gt;sd, info-&gt;process_id, info-&gt;pid_name);
        uDNS_StopWABQueries(&amp;mDNSStorage, UDNS_WAB_LBROWSE_QUERY);
    }
    <span class="enscript-keyword">while</span> (info-&gt;u.browser.browsers)
    {
        browser_t *ptr = info-&gt;u.browser.browsers;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        <span class="enscript-keyword">if</span> (callExternalHelpers(ptr-&gt;q.InterfaceID, &amp;ptr-&gt;domain, ptr-&gt;q.flags))
        {
            domainname tmp;
            ConstructServiceName(&amp;tmp, NULL, &amp;info-&gt;u.browser.regtype, &amp;ptr-&gt;domain);
            LogInfo(<span class="enscript-string">&quot;browse_termination_callback: calling external_stop_browsing_for_service()&quot;</span>);
            external_stop_browsing_for_service(ptr-&gt;q.InterfaceID, &amp;tmp, kDNSType_PTR, ptr-&gt;q.flags);
        }
#<span class="enscript-reference">endif</span>
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d] DNSServiceBrowse(%X, %d, \&quot;&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;\&quot;) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               info-&gt;request_id, info-&gt;flags, info-&gt;interfaceIndex, DM_NAME_PARAM(ptr-&gt;q.qname.c),
               info-&gt;process_id, info-&gt;pid_name);

        info-&gt;u.browser.browsers = ptr-&gt;next;
        mDNS_StopBrowse(&amp;mDNSStorage, &amp;ptr-&gt;q);  <span class="enscript-comment">// no need to error-check result
</span>        LogMcastQ(&amp;ptr-&gt;q, info, q_stop);
        freeL(<span class="enscript-string">&quot;browser_t/browse_termination_callback&quot;</span>, ptr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_automatic_browse_domain_changed</span>(<span class="enscript-type">const</span> DNameListElem *<span class="enscript-type">const</span> d, <span class="enscript-type">const</span> mDNSBool add)
{
    request_state *request;
    debugf(<span class="enscript-string">&quot;udsserver_automatic_browse_domain_changed: %s default browse domain %##s&quot;</span>, add ? <span class="enscript-string">&quot;Adding&quot;</span> : <span class="enscript-string">&quot;Removing&quot;</span>, d-&gt;name.c);

    <span class="enscript-keyword">for</span> (request = all_requests; request; request = request-&gt;next)
    {
        <span class="enscript-keyword">if</span> (request-&gt;terminate != browse_termination_callback) <span class="enscript-keyword">continue</span>;    <span class="enscript-comment">// Not a browse operation
</span>        <span class="enscript-keyword">if</span> (!request-&gt;u.browser.default_domain) <span class="enscript-keyword">continue</span>;                   <span class="enscript-comment">// Not an auto-browse operation
</span>        <span class="enscript-keyword">if</span> (!d-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == d-&gt;uid)
        {
            browser_t **ptr = &amp;request-&gt;u.browser.browsers;
            <span class="enscript-keyword">while</span> (*ptr &amp;&amp; !SameDomainName(&amp;(*ptr)-&gt;domain, &amp;d-&gt;name)) ptr = &amp;(*ptr)-&gt;next;
            <span class="enscript-keyword">if</span> (add)
            {
                <span class="enscript-comment">// If we don't already have this domain in our list for this browse operation, add it now
</span>                <span class="enscript-keyword">if</span> (!*ptr) add_domain_to_browser(request, &amp;d-&gt;name);
                <span class="enscript-keyword">else</span> debugf(<span class="enscript-string">&quot;udsserver_automatic_browse_domain_changed %##s already in list, not re-adding&quot;</span>, &amp;d-&gt;name);
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (!*ptr) LogMsg(<span class="enscript-string">&quot;udsserver_automatic_browse_domain_changed ERROR %##s not found&quot;</span>, &amp;d-&gt;name);
                <span class="enscript-keyword">else</span>
                {
                    DNameListElem *p;
                    <span class="enscript-keyword">for</span> (p = AutoBrowseDomains; p; p=p-&gt;next)
                        <span class="enscript-keyword">if</span> (!p-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == p-&gt;uid)
                            <span class="enscript-keyword">if</span> (SameDomainName(&amp;d-&gt;name, &amp;p-&gt;name)) <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">if</span> (p) debugf(<span class="enscript-string">&quot;udsserver_automatic_browse_domain_changed %##s still in list, not removing&quot;</span>, &amp;d-&gt;name);
                    <span class="enscript-keyword">else</span>
                    {
                        browser_t *rem = *ptr;
                        *ptr = (*ptr)-&gt;next;
                        mDNS_StopQueryWithRemoves(&amp;mDNSStorage, &amp;rem-&gt;q);
                        freeL(<span class="enscript-string">&quot;browser_t/udsserver_automatic_browse_domain_changed&quot;</span>, rem);
                    }
                }
            }
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeARElemCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m;  <span class="enscript-comment">// unused
</span>    <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        <span class="enscript-comment">// On shutdown, mDNS_Close automatically deregisters all records
</span>        <span class="enscript-comment">// Since in this case no one has called DeregisterLocalOnlyDomainEnumPTR to cut the record
</span>        <span class="enscript-comment">// from the LocalDomainEnumRecords list, we do this here before we free the memory.
</span>        <span class="enscript-comment">// (This should actually no longer be necessary, now that we do the proper cleanup in
</span>        <span class="enscript-comment">// udsserver_exit. To confirm this, we'll log an error message if we do find a record that
</span>        <span class="enscript-comment">// hasn't been cut from the list yet. If these messages don't appear, we can delete this code.)
</span>        ARListElem **ptr = &amp;LocalDomainEnumRecords;
        <span class="enscript-keyword">while</span> (*ptr &amp;&amp; &amp;(*ptr)-&gt;ar != rr) ptr = &amp;(*ptr)-&gt;next;
        <span class="enscript-keyword">if</span> (*ptr) { *ptr = (*ptr)-&gt;next; LogMsg(<span class="enscript-string">&quot;FreeARElemCallback: Have to cut %s&quot;</span>, ARDisplayString(m, rr)); }
        mDNSPlatformMemFree(rr-&gt;RecordContext);
    }
}

<span class="enscript-comment">// RegisterLocalOnlyDomainEnumPTR and DeregisterLocalOnlyDomainEnumPTR largely duplicate code in
</span><span class="enscript-comment">// &quot;FoundDomain&quot; in uDNS.c for creating and destroying these special mDNSInterface_LocalOnly records.
</span><span class="enscript-comment">// We may want to turn the common code into a subroutine.
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RegisterLocalOnlyDomainEnumPTR</span>(mDNS *m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">int</span> type)
{
    <span class="enscript-comment">// allocate/register legacy and non-legacy _browse PTR record
</span>    mStatus err;
    ARListElem *ptr = (ARListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*ptr));

    debugf(<span class="enscript-string">&quot;Incrementing %s refcount for %##s&quot;</span>,
           (type == mDNS_DomainTypeBrowse         ) ? <span class="enscript-string">&quot;browse domain   &quot;</span> :
           (type == mDNS_DomainTypeRegistration   ) ? <span class="enscript-string">&quot;registration dom&quot;</span> :
           (type == mDNS_DomainTypeBrowseAutomatic) ? <span class="enscript-string">&quot;automatic browse&quot;</span> : <span class="enscript-string">&quot;?&quot;</span>, d-&gt;c);

    mDNS_SetupResourceRecord(&amp;ptr-&gt;ar, mDNSNULL, mDNSInterface_LocalOnly, kDNSType_PTR, 7200, kDNSRecordTypeShared, AuthRecordLocalOnly, FreeARElemCallback, ptr);
    MakeDomainNameFromDNSNameString(&amp;ptr-&gt;ar.namestorage, mDNS_DomainTypeNames[type]);
    AppendDNSNameString            (&amp;ptr-&gt;ar.namestorage, <span class="enscript-string">&quot;local&quot;</span>);
    AssignDomainName(&amp;ptr-&gt;ar.resrec.rdata-&gt;u.name, d);
    err = mDNS_Register(m, &amp;ptr-&gt;ar);
    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;SetSCPrefsBrowseDomain: mDNS_Register returned error %d&quot;</span>, err);
        mDNSPlatformMemFree(ptr);
    }
    <span class="enscript-keyword">else</span>
    {
        ptr-&gt;next = LocalDomainEnumRecords;
        LocalDomainEnumRecords = ptr;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeregisterLocalOnlyDomainEnumPTR</span>(mDNS *m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">int</span> type)
{
    ARListElem **ptr = &amp;LocalDomainEnumRecords;
    domainname lhs; <span class="enscript-comment">// left-hand side of PTR, for comparison
</span>
    debugf(<span class="enscript-string">&quot;Decrementing %s refcount for %##s&quot;</span>,
           (type == mDNS_DomainTypeBrowse         ) ? <span class="enscript-string">&quot;browse domain   &quot;</span> :
           (type == mDNS_DomainTypeRegistration   ) ? <span class="enscript-string">&quot;registration dom&quot;</span> :
           (type == mDNS_DomainTypeBrowseAutomatic) ? <span class="enscript-string">&quot;automatic browse&quot;</span> : <span class="enscript-string">&quot;?&quot;</span>, d-&gt;c);

    MakeDomainNameFromDNSNameString(&amp;lhs, mDNS_DomainTypeNames[type]);
    AppendDNSNameString            (&amp;lhs, <span class="enscript-string">&quot;local&quot;</span>);

    <span class="enscript-keyword">while</span> (*ptr)
    {
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;(*ptr)-&gt;ar.resrec.rdata-&gt;u.name, d) &amp;&amp; SameDomainName((*ptr)-&gt;ar.resrec.name, &amp;lhs))
        {
            ARListElem *rem = *ptr;
            *ptr = (*ptr)-&gt;next;
            mDNS_Deregister(m, &amp;rem-&gt;ar);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span> ptr = &amp;(*ptr)-&gt;next;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AddAutoBrowseDomain</span>(<span class="enscript-type">const</span> mDNSu32 uid, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    DNameListElem *new = (DNameListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*new));
    <span class="enscript-keyword">if</span> (!new) { LogMsg(<span class="enscript-string">&quot;ERROR: malloc&quot;</span>); <span class="enscript-keyword">return</span>; }
    AssignDomainName(&amp;new-&gt;name, name);
    new-&gt;uid = uid;
    new-&gt;next = AutoBrowseDomains;
    AutoBrowseDomains = new;
    udsserver_automatic_browse_domain_changed(new, mDNStrue);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RmvAutoBrowseDomain</span>(<span class="enscript-type">const</span> mDNSu32 uid, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    DNameListElem **p = &amp;AutoBrowseDomains;
    <span class="enscript-keyword">while</span> (*p &amp;&amp; (!SameDomainName(&amp;(*p)-&gt;name, name) || (*p)-&gt;uid != uid)) p = &amp;(*p)-&gt;next;
    <span class="enscript-keyword">if</span> (!*p) LogMsg(<span class="enscript-string">&quot;RmvAutoBrowseDomain: Got remove event for domain %##s not in list&quot;</span>, name-&gt;c);
    <span class="enscript-keyword">else</span>
    {
        DNameListElem *ptr = *p;
        *p = ptr-&gt;next;
        udsserver_automatic_browse_domain_changed(ptr, mDNSfalse);
        mDNSPlatformMemFree(ptr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetPrefsBrowseDomains</span>(mDNS *m, DNameListElem *browseDomains, mDNSBool add)
{
    DNameListElem *d;
    <span class="enscript-keyword">for</span> (d = browseDomains; d; d = d-&gt;next)
    {
        <span class="enscript-keyword">if</span> (add)
        {
            RegisterLocalOnlyDomainEnumPTR(m, &amp;d-&gt;name, mDNS_DomainTypeBrowse);
            AddAutoBrowseDomain(d-&gt;uid, &amp;d-&gt;name);
        }
        <span class="enscript-keyword">else</span>
        {
            DeregisterLocalOnlyDomainEnumPTR(m, &amp;d-&gt;name, mDNS_DomainTypeBrowse);
            RmvAutoBrowseDomain(d-&gt;uid, &amp;d-&gt;name);
        }
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateDeviceInfoRecord</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-type">int</span> num_autoname = 0;
    request_state *req;

    <span class="enscript-comment">// Don't need to register the device info record for kDNSServiceInterfaceIndexLocalOnly registrations.
</span>    <span class="enscript-keyword">for</span> (req = all_requests; req; req = req-&gt;next)
    {
        <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback &amp;&amp; req-&gt;u.servicereg.autoname &amp;&amp; req-&gt;interfaceIndex != kDNSServiceInterfaceIndexLocalOnly)
            num_autoname++;
    }

    <span class="enscript-comment">// If DeviceInfo record is currently registered, see if we need to deregister it
</span>    <span class="enscript-keyword">if</span> (m-&gt;DeviceInfo.resrec.RecordType != kDNSRecordTypeUnregistered)
        <span class="enscript-keyword">if</span> (num_autoname == 0 || !SameDomainLabelCS(m-&gt;DeviceInfo.resrec.name-&gt;c, m-&gt;nicelabel.c))
        {
            LogOperation(<span class="enscript-string">&quot;UpdateDeviceInfoRecord Deregister %##s&quot;</span>, m-&gt;DeviceInfo.resrec.name);
            mDNS_Deregister(m, &amp;m-&gt;DeviceInfo);
        }

    <span class="enscript-comment">// If DeviceInfo record is not currently registered, see if we need to register it
</span>    <span class="enscript-keyword">if</span> (m-&gt;DeviceInfo.resrec.RecordType == kDNSRecordTypeUnregistered)
        <span class="enscript-keyword">if</span> (num_autoname &gt; 0)
        {
            mDNS_SetupResourceRecord(&amp;m-&gt;DeviceInfo, mDNSNULL, mDNSNULL, kDNSType_TXT, kStandardTTL, kDNSRecordTypeAdvisory, AuthRecordAny, mDNSNULL, mDNSNULL);
            ConstructServiceName(&amp;m-&gt;DeviceInfo.namestorage, &amp;m-&gt;nicelabel, &amp;DeviceInfoName, &amp;localdomain);
            m-&gt;DeviceInfo.resrec.rdlength = initializeDeviceInfoTXT(m, m-&gt;DeviceInfo.resrec.rdata-&gt;u.data);
            LogOperation(<span class="enscript-string">&quot;UpdateDeviceInfoRecord   Register %##s&quot;</span>, m-&gt;DeviceInfo.resrec.name);
            mDNS_Register(m, &amp;m-&gt;DeviceInfo);
        }
}
#<span class="enscript-reference">else</span>   // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateDeviceInfoRecord</span>(mDNS *<span class="enscript-type">const</span> m)
{
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// unused
</span>}
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_handle_configchange</span>(mDNS *<span class="enscript-type">const</span> m)
{
    request_state *req;
    service_instance *ptr;
    DNameListElem *RegDomains = NULL;
    DNameListElem *BrowseDomains = NULL;
    DNameListElem *p;

    UpdateDeviceInfoRecord(m);

    <span class="enscript-comment">// For autoname services, see if the default service name has changed, necessitating an automatic update
</span>    <span class="enscript-keyword">for</span> (req = all_requests; req; req = req-&gt;next)
        <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
            <span class="enscript-keyword">if</span> (req-&gt;u.servicereg.autoname &amp;&amp; !SameDomainLabelCS(req-&gt;u.servicereg.name.c, m-&gt;nicelabel.c))
            {
                req-&gt;u.servicereg.name = m-&gt;nicelabel;
                <span class="enscript-keyword">for</span> (ptr = req-&gt;u.servicereg.instances; ptr; ptr = ptr-&gt;next)
                {
                    ptr-&gt;renameonmemfree = 1;
                    <span class="enscript-keyword">if</span> (ptr-&gt;clientnotified) SendServiceRemovalNotification(&amp;ptr-&gt;srs);
                    LogInfo(<span class="enscript-string">&quot;udsserver_handle_configchange: Calling deregister for Service %##s&quot;</span>, ptr-&gt;srs.RR_PTR.resrec.name-&gt;c);
                    <span class="enscript-keyword">if</span> (mDNS_DeregisterService_drt(m, &amp;ptr-&gt;srs, mDNS_Dereg_rapid))
                        regservice_callback(m, &amp;ptr-&gt;srs, mStatus_MemFree); <span class="enscript-comment">// If service deregistered already, we can re-register immediately
</span>                }
            }

    <span class="enscript-comment">// Let the platform layer get the current DNS information
</span>    mDNS_Lock(m);
    mDNSPlatformSetDNSConfig(mDNSfalse, mDNSfalse, mDNSNULL, &amp;RegDomains, &amp;BrowseDomains, mDNSfalse);
    mDNS_Unlock(m);

    <span class="enscript-comment">// Any automatic registration domains are also implicitly automatic browsing domains
</span>    <span class="enscript-keyword">if</span> (RegDomains) SetPrefsBrowseDomains(m, RegDomains, mDNStrue);                             <span class="enscript-comment">// Add the new list first
</span>    <span class="enscript-keyword">if</span> (AutoRegistrationDomains) SetPrefsBrowseDomains(m, AutoRegistrationDomains, mDNSfalse);  <span class="enscript-comment">// Then clear the old list
</span>
    <span class="enscript-comment">// Add any new domains not already in our AutoRegistrationDomains list
</span>    <span class="enscript-keyword">for</span> (p=RegDomains; p; p=p-&gt;next)
    {
        DNameListElem **pp = &amp;AutoRegistrationDomains;
        <span class="enscript-keyword">while</span> (*pp &amp;&amp; ((*pp)-&gt;uid != p-&gt;uid || !SameDomainName(&amp;(*pp)-&gt;name, &amp;p-&gt;name))) pp = &amp;(*pp)-&gt;next;
        <span class="enscript-keyword">if</span> (!*pp)       <span class="enscript-comment">// If not found in our existing list, this is a new default registration domain
</span>        {
            RegisterLocalOnlyDomainEnumPTR(m, &amp;p-&gt;name, mDNS_DomainTypeRegistration);
            udsserver_default_reg_domain_changed(p, mDNStrue);
        }
        <span class="enscript-keyword">else</span>            <span class="enscript-comment">// else found same domainname in both old and new lists, so no change, just delete old copy
</span>        {
            DNameListElem *del = *pp;
            *pp = (*pp)-&gt;next;
            mDNSPlatformMemFree(del);
        }
    }

    <span class="enscript-comment">// Delete any domains in our old AutoRegistrationDomains list that are now gone
</span>    <span class="enscript-keyword">while</span> (AutoRegistrationDomains)
    {
        DNameListElem *del = AutoRegistrationDomains;
        AutoRegistrationDomains = AutoRegistrationDomains-&gt;next;        <span class="enscript-comment">// Cut record from list FIRST,
</span>        DeregisterLocalOnlyDomainEnumPTR(m, &amp;del-&gt;name, mDNS_DomainTypeRegistration);
        udsserver_default_reg_domain_changed(del, mDNSfalse);           <span class="enscript-comment">// before calling udsserver_default_reg_domain_changed()
</span>        mDNSPlatformMemFree(del);
    }

    <span class="enscript-comment">// Now we have our new updated automatic registration domain list
</span>    AutoRegistrationDomains = RegDomains;

    <span class="enscript-comment">// Add new browse domains to internal list
</span>    <span class="enscript-keyword">if</span> (BrowseDomains) SetPrefsBrowseDomains(m, BrowseDomains, mDNStrue);

    <span class="enscript-comment">// Remove old browse domains from internal list
</span>    <span class="enscript-keyword">if</span> (SCPrefBrowseDomains)
    {
        SetPrefsBrowseDomains(m, SCPrefBrowseDomains, mDNSfalse);
        <span class="enscript-keyword">while</span> (SCPrefBrowseDomains)
        {
            DNameListElem *fptr = SCPrefBrowseDomains;
            SCPrefBrowseDomains = SCPrefBrowseDomains-&gt;next;
            mDNSPlatformMemFree(fptr);
        }
    }

    <span class="enscript-comment">// Replace the old browse domains array with the new array
</span>    SCPrefBrowseDomains = BrowseDomains;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AutomaticBrowseDomainChange</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// unused;
</span>    (<span class="enscript-type">void</span>)q; <span class="enscript-comment">// unused
</span>
    LogOperation(<span class="enscript-string">&quot;AutomaticBrowseDomainChange: %s automatic browse domain %##s&quot;</span>,
                 AddRecord ? <span class="enscript-string">&quot;Adding&quot;</span> : <span class="enscript-string">&quot;Removing&quot;</span>, answer-&gt;rdata-&gt;u.name.c);

    <span class="enscript-keyword">if</span> (AddRecord) AddAutoBrowseDomain(0, &amp;answer-&gt;rdata-&gt;u.name);
    <span class="enscript-keyword">else</span> RmvAutoBrowseDomain(0, &amp;answer-&gt;rdata-&gt;u.name);
}

mDNSlocal mStatus <span class="enscript-function-name">handle_browse_request</span>(request_state *request)
{
    <span class="enscript-comment">// Note that regtype may include a trailing subtype
</span>    <span class="enscript-type">char</span> regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
    domainname typedn, d, temp;
    mDNSs32 NumSubTypes;
    mStatus err = mStatus_NoError;

    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSInterfaceID InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);

    <span class="enscript-comment">// The browse is scoped to a specific interface index, but the 
</span>    <span class="enscript-comment">// interface is not currently in our list.
</span>    <span class="enscript-keyword">if</span> (interfaceIndex &amp;&amp; !InterfaceID)
    {
        <span class="enscript-comment">// If it's one of the specially defined inteface index values, just return an error.
</span>        <span class="enscript-keyword">if</span> (PreDefinedInterfaceIndex(interfaceIndex))
        {
            LogInfo(<span class="enscript-string">&quot;handle_browse_request: bad interfaceIndex %d&quot;</span>, interfaceIndex);
            <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        }

        <span class="enscript-comment">// Otherwise, use the specified interface index value and the browse will
</span>        <span class="enscript-comment">// be applied to that interface when it comes up.
</span>        InterfaceID = (mDNSInterfaceID)(uintptr_t)interfaceIndex;
        LogInfo(<span class="enscript-string">&quot;handle_browse_request: browse pending for interface index %d&quot;</span>, interfaceIndex);
    }

    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, regtype, <span class="enscript-keyword">sizeof</span>(regtype)) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, domain,  <span class="enscript-keyword">sizeof</span>(domain )) &lt; 0) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr) { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceBrowse(unreadable parameters)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    request-&gt;flags = flags;
    request-&gt;interfaceIndex = interfaceIndex;
    typedn.c[0] = 0;
    NumSubTypes = ChopSubTypes(regtype);    <span class="enscript-comment">// Note: Modifies regtype string to remove trailing subtypes
</span>    <span class="enscript-keyword">if</span> (NumSubTypes &lt; 0 || NumSubTypes &gt; 1)
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (NumSubTypes == 1)
    {
        <span class="enscript-keyword">if</span> (!AppendDNSNameString(&amp;typedn, regtype + strlen(regtype) + 1))
            <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-keyword">if</span> (!regtype[0] || !AppendDNSNameString(&amp;typedn, regtype)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);

    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;temp, regtype)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-comment">// For over-long service types, we only allow domain &quot;local&quot;
</span>    <span class="enscript-keyword">if</span> (temp.c[0] &gt; 15 &amp;&amp; domain[0] == 0) mDNSPlatformStrLCopy(domain, <span class="enscript-string">&quot;local.&quot;</span>, <span class="enscript-keyword">sizeof</span>(domain));

    <span class="enscript-comment">// Set up browser info
</span>    request-&gt;u.browser.ForceMCast = (flags &amp; kDNSServiceFlagsForceMulticast) != 0;
    request-&gt;u.browser.interface_id = InterfaceID;
    AssignDomainName(&amp;request-&gt;u.browser.regtype, &amp;typedn);
    request-&gt;u.browser.default_domain = !domain[0];
    request-&gt;u.browser.browsers = NULL;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%d] DNSServiceBrowse(%X, %d, \&quot;&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;\&quot;, \&quot;&quot;</span> PRI_S <span class="enscript-string">&quot;\&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, interfaceIndex, DM_NAME_PARAM(request-&gt;u.browser.regtype.c), domain,
           request-&gt;process_id, request-&gt;pid_name);

    <span class="enscript-keyword">if</span> (request-&gt;u.browser.default_domain)
    {
        <span class="enscript-comment">// Start the domain enumeration queries to discover the WAB browse domains
</span>        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d] DNSServiceBrowse Start WAB PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               request-&gt;request_id, request-&gt;process_id, request-&gt;pid_name);
        uDNS_StartWABQueries(&amp;mDNSStorage, UDNS_WAB_LBROWSE_QUERY);
    }
    <span class="enscript-comment">// We need to unconditionally set request-&gt;terminate, because even if we didn't successfully
</span>    <span class="enscript-comment">// start any browses right now, subsequent configuration changes may cause successful
</span>    <span class="enscript-comment">// browses to be added, and we'll need to cancel them before freeing this memory.
</span>    request-&gt;terminate = browse_termination_callback;

    <span class="enscript-keyword">if</span> (domain[0])
    {
        <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;d, domain)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        err = add_domain_to_browser(request, &amp;d);
    }
    <span class="enscript-keyword">else</span>
    {
        DNameListElem *sdom;
        <span class="enscript-keyword">for</span> (sdom = AutoBrowseDomains; sdom; sdom = sdom-&gt;next)
            <span class="enscript-keyword">if</span> (!sdom-&gt;uid || SystemUID(request-&gt;uid) || request-&gt;uid == sdom-&gt;uid)
            {
                err = add_domain_to_browser(request, &amp;sdom-&gt;name);
                <span class="enscript-keyword">if</span> (err)
                {
                    <span class="enscript-keyword">if</span> (SameDomainName(&amp;sdom-&gt;name, &amp;localdomain)) <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">else</span> err = mStatus_NoError;  <span class="enscript-comment">// suppress errors for non-local &quot;default&quot; domains
</span>                }
            }
    }

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceResolve</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">resolve_result_callback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    size_t len = 0;
    <span class="enscript-type">char</span> fullname[MAX_ESCAPED_DOMAIN_NAME], target[MAX_ESCAPED_DOMAIN_NAME] = <span class="enscript-string">&quot;0&quot;</span>;
    <span class="enscript-type">char</span> *data;
    reply_state *rep;
    request_state *req = question-&gt;QuestionContext;
    <span class="enscript-type">const</span> DNSServiceErrorType error =
        (answer-&gt;RecordType == kDNSRecordTypePacketNegative) ? kDNSServiceErr_NoSuchRecord : kDNSServiceErr_NoError;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>
    LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceResolve(%##s) %s interface %d: %s&quot;</span>, 
        req-&gt;sd, question-&gt;qname.c, AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>,
        mDNSPlatformInterfaceIndexfromInterfaceID(m, answer-&gt;InterfaceID, mDNSfalse), RRDisplayString(m, answer));

    <span class="enscript-keyword">if</span> (!AddRecord)
    {
        <span class="enscript-keyword">if</span> (req-&gt;u.resolve.srv == answer) req-&gt;u.resolve.srv = mDNSNULL;
        <span class="enscript-keyword">if</span> (req-&gt;u.resolve.txt == answer) req-&gt;u.resolve.txt = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_SRV) req-&gt;u.resolve.srv = answer;
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_TXT) req-&gt;u.resolve.txt = answer;

    <span class="enscript-keyword">if</span> (!req-&gt;u.resolve.txt || !req-&gt;u.resolve.srv) <span class="enscript-keyword">return</span>;     <span class="enscript-comment">// only deliver result to client if we have both answers
</span>
    ConvertDomainNameToCString(answer-&gt;name, fullname);

    <span class="enscript-keyword">if</span> (answer-&gt;RecordType != kDNSRecordTypePacketNegative)
        ConvertDomainNameToCString(&amp;req-&gt;u.resolve.srv-&gt;rdata-&gt;u.srv.target, target);

    <span class="enscript-comment">// calculate reply length
</span>    len += <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    len += <span class="enscript-keyword">sizeof</span>(mDNSu32);  <span class="enscript-comment">// interface index
</span>    len += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
    len += strlen(fullname) + 1;
    len += strlen(target) + 1;
    len += 2 * <span class="enscript-keyword">sizeof</span>(mDNSu16);  <span class="enscript-comment">// port, txtLen
</span>    len += req-&gt;u.resolve.txt-&gt;rdlength;

    <span class="enscript-comment">// allocate/init reply header
</span>    rep = create_reply(resolve_reply_op, len, req);
    rep-&gt;rhdr-&gt;flags = dnssd_htonl(0);
    rep-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, answer-&gt;InterfaceID, mDNSfalse));
    rep-&gt;rhdr-&gt;error = dnssd_htonl(error);

    data = (<span class="enscript-type">char</span> *)&amp;rep-&gt;rhdr[1];

    <span class="enscript-comment">// write reply data to message
</span>    put_string(fullname, &amp;data);
    put_string(target, &amp;data);
    *data++ =  req-&gt;u.resolve.srv-&gt;rdata-&gt;u.srv.port.b[0];
    *data++ =  req-&gt;u.resolve.srv-&gt;rdata-&gt;u.srv.port.b[1];
    put_uint16(req-&gt;u.resolve.txt-&gt;rdlength, &amp;data);
    put_rdata (req-&gt;u.resolve.txt-&gt;rdlength, req-&gt;u.resolve.txt-&gt;rdata-&gt;u.data, &amp;data);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%d-&gt;Q%d] DNSServiceResolve(&quot;</span> PRI_S <span class="enscript-string">&quot;) RESULT   &quot;</span> PRI_S <span class="enscript-string">&quot;:%d&quot;</span>,
           req-&gt;request_id, mDNSVal16(question-&gt;TargetQID), fullname, target,
           mDNSVal16(req-&gt;u.resolve.srv-&gt;rdata-&gt;u.srv.port));
    append_reply(req, rep);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">resolve_termination_callback</span>(request_state *request)
{
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceResolve(%X, %d, \&quot;&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;\&quot;) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, DM_NAME_PARAM(request-&gt;u.resolve.qtxt.qname.c),
           request-&gt;process_id, request-&gt;pid_name);
    mDNS_StopQuery(&amp;mDNSStorage, &amp;request-&gt;u.resolve.qtxt);
    mDNS_StopQuery(&amp;mDNSStorage, &amp;request-&gt;u.resolve.qsrv);
    LogMcastQ(&amp;request-&gt;u.resolve.qsrv, request, q_stop);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    <span class="enscript-keyword">if</span> (request-&gt;u.resolve.external_advertise)
        external_stop_resolving_service(request-&gt;u.resolve.qsrv.InterfaceID, &amp;request-&gt;u.resolve.qsrv.qname, request-&gt;flags);
#<span class="enscript-reference">endif</span>
}

mDNSlocal mStatus <span class="enscript-function-name">handle_resolve_request</span>(request_state *request)
{
    <span class="enscript-type">char</span> name[256], regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
    domainname fqdn;
    mStatus err;

    <span class="enscript-comment">// extract the data from the message
</span>    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSInterfaceID InterfaceID;

    <span class="enscript-comment">// Map kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny with the kDNSServiceFlagsIncludeP2P
</span>    <span class="enscript-comment">// flag set so that the resolve will run over P2P interfaces that are not yet created.
</span>    <span class="enscript-keyword">if</span> (interfaceIndex == kDNSServiceInterfaceIndexP2P)
    {
        LogOperation(<span class="enscript-string">&quot;handle_resolve_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P&quot;</span>);
        flags |= kDNSServiceFlagsIncludeP2P;
        interfaceIndex = kDNSServiceInterfaceIndexAny;
    }

    InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);

    <span class="enscript-comment">// The operation is scoped to a specific interface index, but the 
</span>    <span class="enscript-comment">// interface is not currently in our list.
</span>    <span class="enscript-keyword">if</span> (interfaceIndex &amp;&amp; !InterfaceID)
    {
        <span class="enscript-comment">// If it's one of the specially defined inteface index values, just return an error.
</span>        <span class="enscript-keyword">if</span> (PreDefinedInterfaceIndex(interfaceIndex))
        {
            LogInfo(<span class="enscript-string">&quot;handle_resolve_request: bad interfaceIndex %d&quot;</span>, interfaceIndex);
            <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        }

        <span class="enscript-comment">// Otherwise, use the specified interface index value and the operation will
</span>        <span class="enscript-comment">// be applied to that interface when it comes up.
</span>        InterfaceID = (mDNSInterfaceID)(uintptr_t)interfaceIndex;
        LogInfo(<span class="enscript-string">&quot;handle_resolve_request: resolve pending for interface index %d&quot;</span>, interfaceIndex);
    }

    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, name,    <span class="enscript-keyword">sizeof</span>(name   )) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, regtype, <span class="enscript-keyword">sizeof</span>(regtype)) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, domain,  <span class="enscript-keyword">sizeof</span>(domain )) &lt; 0)
    { LogMsg(<span class="enscript-string">&quot;ERROR: handle_resolve_request - Couldn't read name/regtype/domain&quot;</span>); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr) { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceResolve(unreadable parameters)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    <span class="enscript-keyword">if</span> (build_domainname_from_strings(&amp;fqdn, name, regtype, domain) &lt; 0)
    { LogMsg(<span class="enscript-string">&quot;ERROR: handle_resolve_request bad “%s” “%s” “%s”&quot;</span>, name, regtype, domain); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    mDNSPlatformMemZero(&amp;request-&gt;u.resolve, <span class="enscript-keyword">sizeof</span>(request-&gt;u.resolve));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-comment">// Determine if this request should be promoted to use BLE triggered discovery.
</span>    <span class="enscript-keyword">if</span> (shouldUseBLE(InterfaceID, 0, (domainname *)SkipLeadingLabels(&amp;fqdn, 1), &amp;fqdn))
    {
        flags |= (kDNSServiceFlagsAutoTrigger | kDNSServiceFlagsIncludeAWDL);
        LogInfo(<span class="enscript-string">&quot;handle_resolve_request: request promoted to use kDNSServiceFlagsAutoTrigger&quot;</span>);
    } 
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>

    request-&gt;flags = flags;
    request-&gt;interfaceIndex = interfaceIndex;

    <span class="enscript-comment">// format questions
</span>    request-&gt;u.resolve.qsrv.InterfaceID      = InterfaceID;
    request-&gt;u.resolve.qsrv.flags            = flags;
    AssignDomainName(&amp;request-&gt;u.resolve.qsrv.qname, &amp;fqdn);
    request-&gt;u.resolve.qsrv.qtype            = kDNSType_SRV;
    request-&gt;u.resolve.qsrv.qclass           = kDNSClass_IN;
    request-&gt;u.resolve.qsrv.LongLived        = (flags &amp; kDNSServiceFlagsLongLivedQuery     ) != 0;
    request-&gt;u.resolve.qsrv.ExpectUnique     = mDNStrue;
    request-&gt;u.resolve.qsrv.ForceMCast       = (flags &amp; kDNSServiceFlagsForceMulticast     ) != 0;
    request-&gt;u.resolve.qsrv.ReturnIntermed   = (flags &amp; kDNSServiceFlagsReturnIntermediates) != 0;
    request-&gt;u.resolve.qsrv.SuppressUnusable = mDNSfalse;
    request-&gt;u.resolve.qsrv.AppendSearchDomains = 0;
    request-&gt;u.resolve.qsrv.TimeoutQuestion  = 0;
    request-&gt;u.resolve.qsrv.WakeOnResolve    = (flags &amp; kDNSServiceFlagsWakeOnResolve) != 0;
    request-&gt;u.resolve.qsrv.UseBackgroundTraffic = (flags &amp; kDNSServiceFlagsBackgroundTrafficClass) != 0;
    request-&gt;u.resolve.qsrv.ValidationRequired = 0;
    request-&gt;u.resolve.qsrv.ValidatingResponse = 0;
    request-&gt;u.resolve.qsrv.ProxyQuestion    = 0;
    request-&gt;u.resolve.qsrv.pid              = request-&gt;process_id;
    request-&gt;u.resolve.qsrv.euid             = request-&gt;uid;
    request-&gt;u.resolve.qsrv.QuestionCallback = resolve_result_callback;
    request-&gt;u.resolve.qsrv.QuestionContext  = request;

    request-&gt;u.resolve.qtxt.InterfaceID      = InterfaceID;
    request-&gt;u.resolve.qtxt.flags            = flags;
    AssignDomainName(&amp;request-&gt;u.resolve.qtxt.qname, &amp;fqdn);
    request-&gt;u.resolve.qtxt.qtype            = kDNSType_TXT;
    request-&gt;u.resolve.qtxt.qclass           = kDNSClass_IN;
    request-&gt;u.resolve.qtxt.LongLived        = (flags &amp; kDNSServiceFlagsLongLivedQuery     ) != 0;
    request-&gt;u.resolve.qtxt.ExpectUnique     = mDNStrue;
    request-&gt;u.resolve.qtxt.ForceMCast       = (flags &amp; kDNSServiceFlagsForceMulticast     ) != 0;
    request-&gt;u.resolve.qtxt.ReturnIntermed   = (flags &amp; kDNSServiceFlagsReturnIntermediates) != 0;
    request-&gt;u.resolve.qtxt.SuppressUnusable = mDNSfalse;
    request-&gt;u.resolve.qtxt.AppendSearchDomains = 0;
    request-&gt;u.resolve.qtxt.TimeoutQuestion  = 0;
    request-&gt;u.resolve.qtxt.WakeOnResolve    = 0;
    request-&gt;u.resolve.qtxt.UseBackgroundTraffic = (flags &amp; kDNSServiceFlagsBackgroundTrafficClass) != 0;
    request-&gt;u.resolve.qtxt.ValidationRequired = 0;
    request-&gt;u.resolve.qtxt.ValidatingResponse = 0;
    request-&gt;u.resolve.qtxt.ProxyQuestion    = 0;
    request-&gt;u.resolve.qtxt.pid              = request-&gt;process_id;
    request-&gt;u.resolve.qtxt.euid             = request-&gt;uid;
    request-&gt;u.resolve.qtxt.QuestionCallback = resolve_result_callback;
    request-&gt;u.resolve.qtxt.QuestionContext  = request;

    request-&gt;u.resolve.ReportTime            = NonZeroTime(mDNS_TimeNow(&amp;mDNSStorage) + 130 * mDNSPlatformOneSecond);

    request-&gt;u.resolve.external_advertise    = mDNSfalse;

#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">if</span> (!AuthorizedDomain(request, &amp;fqdn, AutoBrowseDomains)) <span class="enscript-keyword">return</span>(mStatus_NoError);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// ask the questions
</span>    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceResolve(%X, %d, \&quot;&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;\&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, flags, interfaceIndex, DM_NAME_PARAM(request-&gt;u.resolve.qsrv.qname.c),
           request-&gt;process_id, request-&gt;pid_name);

    err = mDNS_StartQuery(&amp;mDNSStorage, &amp;request-&gt;u.resolve.qsrv);

    <span class="enscript-keyword">if</span> (!err)
    {
        err = mDNS_StartQuery(&amp;mDNSStorage, &amp;request-&gt;u.resolve.qtxt);
        <span class="enscript-keyword">if</span> (err)
        {
            mDNS_StopQuery(&amp;mDNSStorage, &amp;request-&gt;u.resolve.qsrv);
        }
        <span class="enscript-keyword">else</span>
        {
            request-&gt;terminate = resolve_termination_callback;
            LogMcastQ(&amp;request-&gt;u.resolve.qsrv, request, q_start);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
            <span class="enscript-keyword">if</span> (callExternalHelpers(InterfaceID, &amp;fqdn, flags))
            {
                request-&gt;u.resolve.external_advertise    = mDNStrue;
                LogInfo(<span class="enscript-string">&quot;handle_resolve_request: calling external_start_resolving_service()&quot;</span>);
                external_start_resolving_service(InterfaceID, &amp;fqdn, flags);
            }
#<span class="enscript-reference">endif</span>
        }
    }

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceQueryRecord</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">queryrecord_result_reply</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord, DNSServiceErrorType error, <span class="enscript-type">void</span> *context)
{
    <span class="enscript-type">char</span> name[MAX_ESCAPED_DOMAIN_NAME];
    size_t len;
    DNSServiceFlags flags = 0;
    reply_state *rep;
    <span class="enscript-type">char</span> *data;
    request_state *req = (request_state *)context;

    ConvertDomainNameToCString(answer-&gt;name, name);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
       <span class="enscript-string">&quot;[R%u-&gt;Q%u] DNSService&quot;</span> PUB_S <span class="enscript-string">&quot;(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) RESULT &quot;</span> PUB_S <span class="enscript-string">&quot; interface %d: (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span> PRI_S,
       req-&gt;request_id, mDNSVal16(question-&gt;TargetQID), req-&gt;hdr.op == query_request ? <span class="enscript-string">&quot;QueryRecord&quot;</span> : <span class="enscript-string">&quot;GetAddrInfo&quot;</span>,
       DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype), AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>,
       mDNSPlatformInterfaceIndexfromInterfaceID(m, answer-&gt;InterfaceID, mDNSfalse),
       MortalityDisplayString(answer-&gt;mortality), RRDisplayString(m, answer));

    len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);  <span class="enscript-comment">// calculate reply data length
</span>    len += <span class="enscript-keyword">sizeof</span>(mDNSu32);     <span class="enscript-comment">// interface index
</span>    len += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
    len += strlen(name) + 1;
    len += 3 * <span class="enscript-keyword">sizeof</span>(mDNSu16); <span class="enscript-comment">// type, class, rdlen
</span>    len += answer-&gt;rdlength;
    len += <span class="enscript-keyword">sizeof</span>(mDNSu32);     <span class="enscript-comment">// TTL
</span>
    rep = create_reply(req-&gt;hdr.op == query_request ? query_reply_op : addrinfo_reply_op, len, req);

    <span class="enscript-keyword">if</span> (AddRecord)
        flags |= kDNSServiceFlagsAdd;
    <span class="enscript-keyword">if</span> (answer-&gt;mortality == Mortality_Ghost)
        flags |= kDNSServiceFlagsExpiredAnswer;
    <span class="enscript-keyword">if</span> (!question-&gt;InitialCacheMiss)
        flags |= kDNSServiceFlagAnsweredFromCache;
    <span class="enscript-keyword">if</span> (question-&gt;ValidationStatus != 0)
    {
        error =   kDNSServiceErr_NoError;
        <span class="enscript-keyword">if</span> (question-&gt;ValidationRequired &amp;&amp; question-&gt;ValidationState == DNSSECValDone)
        {
            <span class="enscript-keyword">switch</span> (question-&gt;ValidationStatus) <span class="enscript-comment">//Set the dnssec flags to be passed on to the Apps here
</span>            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Secure</span>:
                flags |= kDNSServiceFlagsSecure;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Insecure</span>:
                flags |= kDNSServiceFlagsInsecure;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Indeterminate</span>:
                flags |= kDNSServiceFlagsIndeterminate;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Bogus</span>:
                flags |= kDNSServiceFlagsBogus;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                LogMsg(<span class="enscript-string">&quot;queryrecord_result_reply unknown status %d for %##s&quot;</span>, question-&gt;ValidationStatus, question-&gt;qname.c);
            }
        }
    }

    rep-&gt;rhdr-&gt;flags = dnssd_htonl(flags);
    <span class="enscript-comment">// Call mDNSPlatformInterfaceIndexfromInterfaceID, but suppressNetworkChange (last argument). Otherwise, if the
</span>    <span class="enscript-comment">// InterfaceID is not valid, then it simulates a &quot;NetworkChanged&quot; which in turn makes questions
</span>    <span class="enscript-comment">// to be stopped and started including  *this* one. Normally the InterfaceID is valid. But when we
</span>    <span class="enscript-comment">// are using the /etc/hosts entries to answer a question, the InterfaceID may not be known to the
</span>    <span class="enscript-comment">// mDNS core . Eventually, we should remove the calls to &quot;NetworkChanged&quot; in
</span>    <span class="enscript-comment">// mDNSPlatformInterfaceIndexfromInterfaceID when it can't find InterfaceID as ResourceRecords
</span>    <span class="enscript-comment">// should not have existed to answer this question if the corresponding interface is not valid.
</span>    rep-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, answer-&gt;InterfaceID, mDNStrue));
    rep-&gt;rhdr-&gt;error = dnssd_htonl(error);

    data = (<span class="enscript-type">char</span> *)&amp;rep-&gt;rhdr[1];

    put_string(name,             &amp;data);
    put_uint16(answer-&gt;rrtype,   &amp;data);
    put_uint16(answer-&gt;rrclass,  &amp;data);
    put_uint16(answer-&gt;rdlength, &amp;data);
    <span class="enscript-comment">// We need to use putRData here instead of the crude put_rdata function, because the crude put_rdata
</span>    <span class="enscript-comment">// function just does a blind memory copy without regard to structures that may have holes in them.
</span>    <span class="enscript-keyword">if</span> (answer-&gt;rdlength)
        <span class="enscript-keyword">if</span> (!putRData(mDNSNULL, (mDNSu8 *)data, (mDNSu8 *)rep-&gt;rhdr + len, answer))
            LogMsg(<span class="enscript-string">&quot;queryrecord_result_reply putRData failed %d&quot;</span>, (mDNSu8 *)rep-&gt;rhdr + len - (mDNSu8 *)data);
    data += answer-&gt;rdlength;
    put_uint32(AddRecord ? answer-&gt;rroriginalttl : 0, &amp;data);

    append_reply(req, rep);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">queryrecord_termination_callback</span>(request_state *request)
{
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%u] DNSServiceQueryRecord(%X, %d, &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex,
           DM_NAME_PARAM(QueryRecordClientRequestGetQName(&amp;request-&gt;u.queryrecord)-&gt;c),
           DNSTypeName(QueryRecordClientRequestGetType(&amp;request-&gt;u.queryrecord)), request-&gt;process_id, request-&gt;pid_name);

    QueryRecordClientRequestStop(&amp;request-&gt;u.queryrecord);
}

mDNSlocal mStatus <span class="enscript-function-name">handle_queryrecord_request</span>(request_state *request)
{
    mStatus             err;
    DNSServiceFlags     flags;
    mDNSu32             interfaceIndex;
    mDNSu16             qtype, qclass;
    <span class="enscript-type">char</span>                qname[MAX_ESCAPED_DOMAIN_NAME];

    flags           = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    interfaceIndex  = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, qname, <span class="enscript-keyword">sizeof</span>(qname)) &lt; 0)
    {
        err = mStatus_BadParamErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    qtype           = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);
    qclass          = get_uint16(&amp;request-&gt;msgptr, request-&gt;msgend);

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceQueryRecord(unreadable parameters)&quot;</span>, request-&gt;request_id);
        err = mStatus_BadParamErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    request-&gt;flags          = flags;
    request-&gt;interfaceIndex = interfaceIndex;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceQueryRecord(%X, %d, &quot;</span> PRI_S <span class="enscript-string">&quot;, &quot;</span> PUB_S <span class="enscript-string">&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, qname, DNSTypeName(qtype), request-&gt;process_id,
           request-&gt;pid_name);

    mDNSPlatformMemZero(&amp;request-&gt;u.queryrecord, (mDNSu32)<span class="enscript-keyword">sizeof</span>(request-&gt;u.queryrecord));

    err = QueryRecordClientRequestStart(&amp;request-&gt;u.queryrecord, request-&gt;request_id, qname, interfaceIndex, flags, qtype,
        qclass, request-&gt;validUUID ? 0 : request-&gt;process_id, request-&gt;validUUID ? request-&gt;uuid : mDNSNULL, request-&gt;uid,
        queryrecord_result_reply, request);
    <span class="enscript-keyword">if</span> (err) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    request-&gt;terminate = queryrecord_termination_callback;

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceEnumerateDomains</span>
#<span class="enscript-reference">endif</span>

mDNSlocal reply_state *<span class="enscript-function-name">format_enumeration_reply</span>(request_state *request,
                                                <span class="enscript-type">const</span> <span class="enscript-type">char</span> *domain, DNSServiceFlags flags, mDNSu32 ifi, DNSServiceErrorType err)
{
    size_t len;
    reply_state *reply;
    <span class="enscript-type">char</span> *data;

    len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    len += <span class="enscript-keyword">sizeof</span>(mDNSu32);
    len += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
    len += strlen(domain) + 1;

    reply = create_reply(enumeration_reply_op, len, request);
    reply-&gt;rhdr-&gt;flags = dnssd_htonl(flags);
    reply-&gt;rhdr-&gt;ifi   = dnssd_htonl(ifi);
    reply-&gt;rhdr-&gt;error = dnssd_htonl(err);
    data = (<span class="enscript-type">char</span> *)&amp;reply-&gt;rhdr[1];
    put_string(domain, &amp;data);
    <span class="enscript-keyword">return</span> reply;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">enum_termination_callback</span>(request_state *request)
{
    <span class="enscript-comment">// Stop the domain enumeration queries to discover the WAB Browse/Registration domains
</span>    <span class="enscript-keyword">if</span> (request-&gt;u.enumeration.flags &amp; kDNSServiceFlagsRegistrationDomains)
    {
        LogInfo(<span class="enscript-string">&quot;%3d: DNSServiceEnumeration Cancel WAB Registration PID[%d](%s)&quot;</span>, request-&gt;sd, request-&gt;process_id, request-&gt;pid_name);
        uDNS_StopWABQueries(&amp;mDNSStorage, UDNS_WAB_REG_QUERY);
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;%3d: DNSServiceEnumeration Cancel WAB Browse PID[%d](%s)&quot;</span>, request-&gt;sd, request-&gt;process_id, request-&gt;pid_name);
        uDNS_StopWABQueries(&amp;mDNSStorage, UDNS_WAB_BROWSE_QUERY | UDNS_WAB_LBROWSE_QUERY);
        mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_autoall);
    }
    mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_all);
    mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_default);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">enum_result_callback</span>(mDNS *<span class="enscript-type">const</span> m,
                                    DNSQuestion *<span class="enscript-type">const</span> question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    <span class="enscript-type">char</span> domain[MAX_ESCAPED_DOMAIN_NAME];
    request_state *request = question-&gt;QuestionContext;
    DNSServiceFlags flags = 0;
    reply_state *reply;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype != kDNSType_PTR) <span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">if</span> (!AuthorizedDomain(request, &amp;answer-&gt;rdata-&gt;u.name, request-&gt;u.enumeration.flags ? AutoRegistrationDomains : AutoBrowseDomains)) <span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// We only return add/remove events for the browse and registration lists
</span>    <span class="enscript-comment">// For the default browse and registration answers, we only give an &quot;ADD&quot; event
</span>    <span class="enscript-keyword">if</span> (question == &amp;request-&gt;u.enumeration.q_default &amp;&amp; !AddRecord) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (AddRecord)
    {
        flags |= kDNSServiceFlagsAdd;
        <span class="enscript-keyword">if</span> (question == &amp;request-&gt;u.enumeration.q_default) flags |= kDNSServiceFlagsDefault;
    }

    ConvertDomainNameToCString(&amp;answer-&gt;rdata-&gt;u.name, domain);
    <span class="enscript-comment">// Note that we do NOT propagate specific interface indexes to the client - for example, a domain we learn from
</span>    <span class="enscript-comment">// a machine's system preferences may be discovered on the LocalOnly interface, but should be browsed on the
</span>    <span class="enscript-comment">// network, so we just pass kDNSServiceInterfaceIndexAny
</span>    reply = format_enumeration_reply(request, domain, flags, kDNSServiceInterfaceIndexAny, kDNSServiceErr_NoError);
    <span class="enscript-keyword">if</span> (!reply) { LogMsg(<span class="enscript-string">&quot;ERROR: enum_result_callback, format_enumeration_reply&quot;</span>); <span class="enscript-keyword">return</span>; }

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d-&gt;Q%d] DNSServiceEnumerateDomains(%2.*s) RESULT &quot;</span> PUB_S <span class="enscript-string">&quot;: &quot;</span> PRI_S,
           request-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question-&gt;qname.c[0], &amp;question-&gt;qname.c[1],
           AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>, domain);

    append_reply(request, reply);
}

mDNSlocal mStatus <span class="enscript-function-name">handle_enum_request</span>(request_state *request)
{
    mStatus err;
    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    DNSServiceFlags reg = flags &amp; kDNSServiceFlagsRegistrationDomains;
    mDNS_DomainType t_all     = reg ? mDNS_DomainTypeRegistration        : mDNS_DomainTypeBrowse;
    mDNS_DomainType t_default = reg ? mDNS_DomainTypeRegistrationDefault : mDNS_DomainTypeBrowseDefault;
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSInterfaceID InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);
    <span class="enscript-keyword">if</span> (interfaceIndex &amp;&amp; !InterfaceID) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceEnumerateDomains(unreadable parameters)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    request-&gt;flags = flags;
    request-&gt;interfaceIndex = interfaceIndex;

    <span class="enscript-comment">// mark which kind of enumeration we're doing so that we know what domain enumeration queries to stop
</span>    request-&gt;u.enumeration.flags = reg;

    <span class="enscript-comment">// enumeration requires multiple questions, so we must link all the context pointers so that
</span>    <span class="enscript-comment">// necessary context can be reached from the callbacks
</span>    request-&gt;u.enumeration.q_all.QuestionContext = request;
    request-&gt;u.enumeration.q_default.QuestionContext = request;
    <span class="enscript-keyword">if</span> (!reg) request-&gt;u.enumeration.q_autoall.QuestionContext = request;

    <span class="enscript-comment">// if the caller hasn't specified an explicit interface, we use local-only to get the system-wide list.
</span>    <span class="enscript-keyword">if</span> (!InterfaceID) InterfaceID = mDNSInterface_LocalOnly;

    <span class="enscript-comment">// make the calls
</span>    LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceEnumerateDomains(%X=%s)&quot;</span>, request-&gt;sd, flags,
                 (flags &amp; kDNSServiceFlagsBrowseDomains      ) ? <span class="enscript-string">&quot;kDNSServiceFlagsBrowseDomains&quot;</span> :
                 (flags &amp; kDNSServiceFlagsRegistrationDomains) ? <span class="enscript-string">&quot;kDNSServiceFlagsRegistrationDomains&quot;</span> : <span class="enscript-string">&quot;&lt;&lt;Unknown&gt;&gt;&quot;</span>);
    err = mDNS_GetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_all, t_all, NULL, InterfaceID, enum_result_callback, request);
    <span class="enscript-keyword">if</span> (!err)
    {
        err = mDNS_GetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_default, t_default, NULL, InterfaceID, enum_result_callback, request);
        <span class="enscript-keyword">if</span> (err) mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_all);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!reg)
        {
            err = mDNS_GetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_autoall, mDNS_DomainTypeBrowseAutomatic, NULL, InterfaceID, enum_result_callback, request);
            <span class="enscript-keyword">if</span> (err)
            {
                mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_all);
                mDNS_StopGetDomains(&amp;mDNSStorage, &amp;request-&gt;u.enumeration.q_default);
            }
        }
        <span class="enscript-keyword">if</span> (!err) request-&gt;terminate = enum_termination_callback;
    }
    <span class="enscript-keyword">if</span> (!err)
    {
        <span class="enscript-comment">// Start the domain enumeration queries to discover the WAB Browse/Registration domains
</span>        <span class="enscript-keyword">if</span> (reg)
        {
            LogInfo(<span class="enscript-string">&quot;%3d: DNSServiceEnumerateDomains Start WAB Registration PID[%d](%s)&quot;</span>, request-&gt;sd, request-&gt;process_id, request-&gt;pid_name);
            uDNS_StartWABQueries(&amp;mDNSStorage, UDNS_WAB_REG_QUERY);
        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;%3d: DNSServiceEnumerateDomains Start WAB Browse PID[%d](%s)&quot;</span>, request-&gt;sd, request-&gt;process_id, request-&gt;pid_name);
            uDNS_StartWABQueries(&amp;mDNSStorage, UDNS_WAB_BROWSE_QUERY | UDNS_WAB_LBROWSE_QUERY);
        }
    }

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceReconfirmRecord</span> &amp; <span class="enscript-variable-name">Misc</span>
#<span class="enscript-reference">endif</span>

mDNSlocal mStatus <span class="enscript-function-name">handle_reconfirm_request</span>(request_state *request)
{
    mStatus status = mStatus_BadParamErr;
    AuthRecord *rr = read_rr_from_ipc_msg(request, 0, 0);
    <span class="enscript-keyword">if</span> (rr)
    {
        status = mDNS_ReconfirmByValue(&amp;mDNSStorage, &amp;rr-&gt;resrec);
        LogOperation(
            (status == mStatus_NoError) ?
            <span class="enscript-string">&quot;%3d: DNSServiceReconfirmRecord(%s) interface %d initiated PID[%d](%s)&quot;</span> :
            <span class="enscript-string">&quot;%3d: DNSServiceReconfirmRecord(%s) interface %d failed PID[%d](%s) status %d&quot;</span>,
            request-&gt;sd, RRDisplayString(&amp;mDNSStorage, &amp;rr-&gt;resrec),
            mDNSPlatformInterfaceIndexfromInterfaceID(&amp;mDNSStorage, rr-&gt;resrec.InterfaceID, mDNSfalse), 
            request-&gt;process_id, request-&gt;pid_name, status);
        freeL(<span class="enscript-string">&quot;AuthRecord/handle_reconfirm_request&quot;</span>, rr);
    }
    <span class="enscript-keyword">return</span>(status);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSlocal mStatus <span class="enscript-function-name">handle_release_request</span>(request_state *request)
{
    mStatus err = 0;
    <span class="enscript-type">char</span> name[256], regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
    domainname instance;

    <span class="enscript-comment">// extract the data from the message
</span>    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);

    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, name,    <span class="enscript-keyword">sizeof</span>(name   )) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, regtype, <span class="enscript-keyword">sizeof</span>(regtype)) &lt; 0 ||
        get_string(&amp;request-&gt;msgptr, request-&gt;msgend, domain,  <span class="enscript-keyword">sizeof</span>(domain )) &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: handle_release_request - Couldn't read name/regtype/domain&quot;</span>);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogMsg(<span class="enscript-string">&quot;%3d: PeerConnectionRelease(unreadable parameters)&quot;</span>, request-&gt;sd);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-keyword">if</span> (build_domainname_from_strings(&amp;instance, name, regtype, domain) &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: handle_release_request bad “%s” “%s” “%s”&quot;</span>, name, regtype, domain);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] PeerConnectionRelease(%X &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, flags, DM_NAME_PARAM(instance.c), request-&gt;process_id, request-&gt;pid_name);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    external_connection_release(&amp;instance);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span>(err);
}

#<span class="enscript-reference">else</span>   // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSlocal mStatus <span class="enscript-function-name">handle_release_request</span>(request_state *request)
{
    (<span class="enscript-type">void</span>) request;
    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSlocal mStatus <span class="enscript-function-name">handle_setdomain_request</span>(request_state *request)
{
    <span class="enscript-type">char</span> domainstr[MAX_ESCAPED_DOMAIN_NAME];
    domainname domain;
    DNSServiceFlags flags = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    (<span class="enscript-type">void</span>)flags; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, domainstr, <span class="enscript-keyword">sizeof</span>(domainstr)) &lt; 0 ||
        !MakeDomainNameFromDNSNameString(&amp;domain, domainstr))
    { LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceSetDefaultDomainForUser(unreadable parameters)&quot;</span>, request-&gt;sd); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    LogOperation(<span class="enscript-string">&quot;%3d: DNSServiceSetDefaultDomainForUser(%##s)&quot;</span>, request-&gt;sd, domain.c);
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-type">typedef</span> packedstruct
{
    mStatus err;
    mDNSu32 len;
    mDNSu32 vers;
} DaemonVersionReply;

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handle_getproperty_request</span>(request_state *request)
{
    <span class="enscript-type">const</span> mStatus BadParamErr = dnssd_htonl((mDNSu32)mStatus_BadParamErr);
    <span class="enscript-type">char</span> prop[256];
    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, prop, <span class="enscript-keyword">sizeof</span>(prop)) &gt;= 0)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d] DNSServiceGetProperty(&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>, request-&gt;request_id, prop);
        <span class="enscript-keyword">if</span> (!strcmp(prop, kDNSServiceProperty_DaemonVersion))
        {
            DaemonVersionReply x = { 0, dnssd_htonl(4), dnssd_htonl(_DNS_SD_H) };
            send_all(request-&gt;sd, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)&amp;x, <span class="enscript-keyword">sizeof</span>(x));
            <span class="enscript-keyword">return</span>;
        }
    }

    <span class="enscript-comment">// If we didn't recogize the requested property name, return BadParamErr
</span>    send_all(request-&gt;sd, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)&amp;BadParamErr, <span class="enscript-keyword">sizeof</span>(BadParamErr));
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-comment">// The caller can specify either the pid or the uuid. If the pid is not specified,
</span><span class="enscript-comment">// update the effective uuid. Don't overwrite the pid which is used for debugging
</span><span class="enscript-comment">// purposes and initialized when the socket is opened.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handle_connection_delegate_request</span>(request_state *request)
{
    mDNSs32 pid;
    socklen_t len;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceCreateDelegateConnection START PID[%d](&quot;</span> PUB_S  <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;process_id, request-&gt;pid_name);
    request-&gt;terminate = connection_termination;

    len = 0;
    pid = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCAL_PEEREPID</span>
    <span class="enscript-keyword">if</span> (pid)
    {
        len = <span class="enscript-keyword">sizeof</span>(pid);
        <span class="enscript-keyword">if</span> (getsockopt(request-&gt;sd, SOL_LOCAL, LOCAL_PEEREPID, &amp;request-&gt;process_id, &amp;len) != 0)
        {
            LogMsg(<span class="enscript-string">&quot;handle_connection_delegate_request: getsockopt for LOCAL_PEEREPID failed errno:%d / %s&quot;</span>, errno, strerror(errno));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// to extract the process name from the pid value
</span>        <span class="enscript-keyword">if</span> (proc_pidinfo(request-&gt;process_id, PROC_PIDT_SHORTBSDINFO, 1, &amp;proc, PROC_PIDT_SHORTBSDINFO_SIZE) == 0)
            <span class="enscript-keyword">return</span>;
        mDNSPlatformStrLCopy(request-&gt;pid_name, proc.pbsi_comm, <span class="enscript-keyword">sizeof</span>(request-&gt;pid_name));
        debugf(<span class="enscript-string">&quot;handle_connection_delegate_request: process id %d, name %s&quot;</span>, request-&gt;process_id, request-&gt;pid_name);
    }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCAL_PEEREUUID</span>
    <span class="enscript-keyword">if</span> (!pid)
    {
        len = UUID_SIZE;
        <span class="enscript-keyword">if</span> (getsockopt(request-&gt;sd, SOL_LOCAL, LOCAL_PEEREUUID, request-&gt;uuid, &amp;len) != 0)
        {
            LogMsg(<span class="enscript-string">&quot;handle_connection_delegate_request: getsockopt for LOCAL_PEEREUUID failed errno:%d / %s&quot;</span>, errno, strerror(errno));
            <span class="enscript-keyword">return</span>;
        }
        request-&gt;validUUID = mDNStrue;
    }
#<span class="enscript-reference">endif</span>
}
#<span class="enscript-reference">else</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handle_connection_delegate_request</span>(request_state *request)
{
    (<span class="enscript-type">void</span>) request;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> packedstruct
{
    mStatus err;
    mDNSs32 pid;
} PIDInfo;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceNATPortMappingCreate</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSServiceProtocol</span>(X) ((X) == NATOp_AddrRequest ? 0 : (X) == NATOp_MapUDP ? kDNSServiceProtocol_UDP : kDNSServiceProtocol_TCP)

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">port_mapping_termination_callback</span>(request_state *request)
{
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, DNSServiceProtocol(request-&gt;u.pm.NATinfo.Protocol),
           mDNSVal16(request-&gt;u.pm.NATinfo.IntPort), mDNSVal16(request-&gt;u.pm.ReqExt), request-&gt;u.pm.NATinfo.NATLease,
           request-&gt;process_id, request-&gt;pid_name);

    mDNS_StopNATOperation(&amp;mDNSStorage, &amp;request-&gt;u.pm.NATinfo);
}

<span class="enscript-comment">// Called via function pointer when we get a NAT Traversal (address request or port mapping) response
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">port_mapping_create_request_callback</span>(mDNS *m, NATTraversalInfo *n)
{
    request_state *request = (request_state *)n-&gt;clientContext;
    reply_state *rep;
    <span class="enscript-type">int</span> replyLen;
    <span class="enscript-type">char</span> *data;

    <span class="enscript-keyword">if</span> (!request) { LogMsg(<span class="enscript-string">&quot;port_mapping_create_request_callback called with unknown request_state object&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// calculate reply data length
</span>    replyLen = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    replyLen += 3 * <span class="enscript-keyword">sizeof</span>(mDNSu32);  <span class="enscript-comment">// if index + addr + ttl
</span>    replyLen += <span class="enscript-keyword">sizeof</span>(DNSServiceErrorType);
    replyLen += 2 * <span class="enscript-keyword">sizeof</span>(mDNSu16);  <span class="enscript-comment">// Internal Port + External Port
</span>    replyLen += <span class="enscript-keyword">sizeof</span>(mDNSu8);       <span class="enscript-comment">// protocol
</span>
    rep = create_reply(port_mapping_reply_op, replyLen, request);

    rep-&gt;rhdr-&gt;flags = dnssd_htonl(0);
    rep-&gt;rhdr-&gt;ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, n-&gt;InterfaceID, mDNSfalse));
    rep-&gt;rhdr-&gt;error = dnssd_htonl(n-&gt;Result);

    data = (<span class="enscript-type">char</span> *)&amp;rep-&gt;rhdr[1];

    *data++ = request-&gt;u.pm.NATinfo.ExternalAddress.b[0];
    *data++ = request-&gt;u.pm.NATinfo.ExternalAddress.b[1];
    *data++ = request-&gt;u.pm.NATinfo.ExternalAddress.b[2];
    *data++ = request-&gt;u.pm.NATinfo.ExternalAddress.b[3];
    *data++ = DNSServiceProtocol(request-&gt;u.pm.NATinfo.Protocol);
    *data++ = request-&gt;u.pm.NATinfo.IntPort.b[0];
    *data++ = request-&gt;u.pm.NATinfo.IntPort.b[1];
    *data++ = request-&gt;u.pm.NATinfo.ExternalPort.b[0];
    *data++ = request-&gt;u.pm.NATinfo.ExternalPort.b[1];
    put_uint32(request-&gt;u.pm.NATinfo.Lifetime, &amp;data);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) RESULT &quot;</span> PRI_IPv4_ADDR <span class="enscript-string">&quot;:%u TTL %u&quot;</span>,
           request-&gt;request_id, DNSServiceProtocol(request-&gt;u.pm.NATinfo.Protocol),
           mDNSVal16(request-&gt;u.pm.NATinfo.IntPort), mDNSVal16(request-&gt;u.pm.ReqExt), request-&gt;u.pm.NATinfo.NATLease,
           &amp;request-&gt;u.pm.NATinfo.ExternalAddress, mDNSVal16(request-&gt;u.pm.NATinfo.ExternalPort),
           request-&gt;u.pm.NATinfo.Lifetime);

    append_reply(request, rep);
}

mDNSlocal mStatus <span class="enscript-function-name">handle_port_mapping_request</span>(request_state *request)
{
    mDNSu32 ttl = 0;
    mStatus err = mStatus_NoError;

    DNSServiceFlags flags          = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSu32 interfaceIndex = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    mDNSInterfaceID InterfaceID    = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, interfaceIndex);
    mDNSu8 protocol       = (mDNSu8)get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    (<span class="enscript-type">void</span>)flags; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (interfaceIndex &amp;&amp; !InterfaceID) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (request-&gt;msgptr + 8 &gt; request-&gt;msgend) request-&gt;msgptr = NULL;
    <span class="enscript-keyword">else</span>
    {
        request-&gt;u.pm.NATinfo.IntPort.b[0] = *request-&gt;msgptr++;
        request-&gt;u.pm.NATinfo.IntPort.b[1] = *request-&gt;msgptr++;
        request-&gt;u.pm.ReqExt.b[0]          = *request-&gt;msgptr++;
        request-&gt;u.pm.ReqExt.b[1]          = *request-&gt;msgptr++;
        ttl = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    }

    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d] DNSServiceNATPortMappingCreate(unreadable parameters)&quot;</span>, request-&gt;request_id);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-keyword">if</span> (protocol == 0)  <span class="enscript-comment">// If protocol == 0 (i.e. just request public address) then IntPort, ExtPort, ttl must be zero too
</span>    {
        <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(request-&gt;u.pm.NATinfo.IntPort) || !mDNSIPPortIsZero(request-&gt;u.pm.ReqExt) || ttl) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(request-&gt;u.pm.NATinfo.IntPort)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        <span class="enscript-keyword">if</span> (!(protocol &amp; (kDNSServiceProtocol_UDP | kDNSServiceProtocol_TCP))) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    request-&gt;flags                       = flags;
    request-&gt;interfaceIndex              = interfaceIndex;
    request-&gt;u.pm.NATinfo.Protocol       = !protocol ? NATOp_AddrRequest : (protocol == kDNSServiceProtocol_UDP) ? NATOp_MapUDP : NATOp_MapTCP;
    <span class="enscript-comment">//       u.pm.NATinfo.IntPort        = already set above
</span>    request-&gt;u.pm.NATinfo.RequestedPort  = request-&gt;u.pm.ReqExt;
    request-&gt;u.pm.NATinfo.NATLease       = ttl;
    request-&gt;u.pm.NATinfo.clientCallback = port_mapping_create_request_callback;
    request-&gt;u.pm.NATinfo.clientContext  = request;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, protocol, mDNSVal16(request-&gt;u.pm.NATinfo.IntPort), mDNSVal16(request-&gt;u.pm.ReqExt),
           request-&gt;u.pm.NATinfo.NATLease, request-&gt;process_id, request-&gt;pid_name);
    err = mDNS_StartNATOperation(&amp;mDNSStorage, &amp;request-&gt;u.pm.NATinfo);
    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;ERROR: mDNS_StartNATOperation: %d&quot;</span>, (<span class="enscript-type">int</span>)err);
    <span class="enscript-keyword">else</span> request-&gt;terminate = port_mapping_termination_callback;

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServiceGetAddrInfo</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">addrinfo_termination_callback</span>(request_state *request)
{
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%u] DNSServiceGetAddrInfo(&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;) STOP PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, DM_NAME_PARAM(GetAddrInfoClientRequestGetQName(&amp;request-&gt;u.addrinfo)-&gt;c),
           request-&gt;process_id, request-&gt;pid_name);

    GetAddrInfoClientRequestStop(&amp;request-&gt;u.addrinfo);
}

mDNSlocal mStatus <span class="enscript-function-name">handle_addrinfo_request</span>(request_state *request)
{
    mStatus             err;
    DNSServiceFlags     flags;
    mDNSu32             interfaceIndex;
    mDNSu32             protocols;
    <span class="enscript-type">char</span>                hostname[MAX_ESCAPED_DOMAIN_NAME];

    flags           = get_flags(&amp;request-&gt;msgptr, request-&gt;msgend);
    interfaceIndex  = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    protocols       = get_uint32(&amp;request-&gt;msgptr, request-&gt;msgend);
    <span class="enscript-keyword">if</span> (get_string(&amp;request-&gt;msgptr, request-&gt;msgend, hostname, <span class="enscript-keyword">sizeof</span>(hostname)) &lt; 0)
    {
        err = mStatus_BadParamErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    <span class="enscript-keyword">if</span> (!request-&gt;msgptr)
    {
        LogMsg(<span class="enscript-string">&quot;%3d: DNSServiceGetAddrInfo(unreadable parameters)&quot;</span>, request-&gt;sd);
        err = mStatus_BadParamErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    request-&gt;flags          = flags;
    request-&gt;interfaceIndex = interfaceIndex;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%u] DNSServiceGetAddrInfo(%X, %d, %u, &quot;</span> PRI_S <span class="enscript-string">&quot;) START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           request-&gt;request_id, request-&gt;flags, request-&gt;interfaceIndex, protocols, hostname, request-&gt;process_id,
           request-&gt;pid_name);

    mDNSPlatformMemZero(&amp;request-&gt;u.addrinfo, (mDNSu32)<span class="enscript-keyword">sizeof</span>(request-&gt;u.addrinfo));

    err = GetAddrInfoClientRequestStart(&amp;request-&gt;u.addrinfo, request-&gt;request_id, hostname, interfaceIndex, flags,
        protocols, request-&gt;validUUID ? 0 : request-&gt;process_id, request-&gt;validUUID ? request-&gt;uuid : mDNSNULL,
        request-&gt;uid, queryrecord_result_reply, request);
    <span class="enscript-keyword">if</span> (err) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    request-&gt;terminate = addrinfo_termination_callback;

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Main</span> <span class="enscript-variable-name">Request</span> <span class="enscript-variable-name">Handler</span> <span class="enscript-variable-name">etc</span>.
#<span class="enscript-reference">endif</span>

mDNSlocal request_state *<span class="enscript-function-name">NewRequest</span>(<span class="enscript-type">void</span>)
{
    request_state *request;
    request_state **p = &amp;all_requests;
    request = (request_state *) callocL(<span class="enscript-string">&quot;request_state&quot;</span>, <span class="enscript-keyword">sizeof</span>(*request));
    <span class="enscript-keyword">if</span> (!request) FatalError(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>);
    <span class="enscript-keyword">while</span> (*p) p = &amp;(*p)-&gt;next;
    *p = request;
    <span class="enscript-keyword">return</span>(request);
}

<span class="enscript-comment">// read_msg may be called any time when the transfer state (req-&gt;ts) is t_morecoming.
</span><span class="enscript-comment">// if there is no data on the socket, the socket will be closed and t_terminated will be returned
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">read_msg</span>(request_state *req)
{
    <span class="enscript-keyword">if</span> (req-&gt;ts == t_terminated || req-&gt;ts == t_error)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                  <span class="enscript-string">&quot;[R%u] ERROR: read_msg called with transfer state terminated or error&quot;</span>, req-&gt;request_id);
        req-&gt;ts = t_error;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (req-&gt;ts == t_complete)  <span class="enscript-comment">// this must be death or something is wrong
</span>    {
        <span class="enscript-type">char</span> buf[4];    <span class="enscript-comment">// dummy for death notification
</span>        <span class="enscript-type">int</span> nread = udsSupportReadFD(req-&gt;sd, buf, 4, 0, req-&gt;platform_data);
        <span class="enscript-keyword">if</span> (!nread) { req-&gt;ts = t_terminated; <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">if</span> (nread &lt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">rerror</span>;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                  <span class="enscript-string">&quot;[R%u] ERROR: read data from a completed request&quot;</span>, req-&gt;request_id);
        req-&gt;ts = t_error;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (req-&gt;ts != t_morecoming)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                  <span class="enscript-string">&quot;[R%u] ERROR: read_msg called with invalid transfer state (%d)&quot;</span>, req-&gt;request_id, req-&gt;ts);
        req-&gt;ts = t_error;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (req-&gt;hdr_bytes &lt; <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr))
    {
        mDNSu32 nleft = <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr) - req-&gt;hdr_bytes;
        <span class="enscript-type">int</span> nread = udsSupportReadFD(req-&gt;sd, (<span class="enscript-type">char</span> *)&amp;req-&gt;hdr + req-&gt;hdr_bytes, nleft, 0, req-&gt;platform_data);
        <span class="enscript-keyword">if</span> (nread == 0) { req-&gt;ts = t_terminated; <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">if</span> (nread &lt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">rerror</span>;
        req-&gt;hdr_bytes += nread;
        <span class="enscript-keyword">if</span> (req-&gt;hdr_bytes &gt; <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr))
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                      <span class="enscript-string">&quot;[R%u] ERROR: read_msg - read too many header bytes&quot;</span>, req-&gt;request_id);
            req-&gt;ts = t_error;
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// only read data if header is complete
</span>        <span class="enscript-keyword">if</span> (req-&gt;hdr_bytes == <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr))
        {
            ConvertHeaderBytes(&amp;req-&gt;hdr);
            <span class="enscript-keyword">if</span> (req-&gt;hdr.version != VERSION)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[R%u] ERROR: client version 0x%08X daemon version 0x%08X&quot;</span>, req-&gt;request_id, req-&gt;hdr.version, VERSION);
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-comment">// Largest conceivable single request is a DNSServiceRegisterRecord() or DNSServiceAddRecord()
</span>            <span class="enscript-comment">// with 64kB of rdata. Adding 1009 byte for a maximal domain name, plus a safety margin
</span>            <span class="enscript-comment">// for other overhead, this means any message above 70kB is definitely bogus.
</span>            <span class="enscript-keyword">if</span> (req-&gt;hdr.datalen &gt; 70000)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[R%u] ERROR: read_msg: hdr.datalen %u (0x%X) &gt; 70000&quot;</span>, req-&gt;request_id, req-&gt;hdr.datalen, req-&gt;hdr.datalen);
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }
            req-&gt;msgbuf = (<span class="enscript-type">char</span> *) callocL(<span class="enscript-string">&quot;request_state msgbuf&quot;</span>, req-&gt;hdr.datalen + MSG_PAD_BYTES);
            <span class="enscript-keyword">if</span> (!req-&gt;msgbuf) { my_perror(<span class="enscript-string">&quot;ERROR: calloc&quot;</span>); req-&gt;ts = t_error; <span class="enscript-keyword">return</span>; }
            req-&gt;msgptr = req-&gt;msgbuf;
            req-&gt;msgend = req-&gt;msgbuf + req-&gt;hdr.datalen;
        }
    }

    <span class="enscript-comment">// If our header is complete, but we're still needing more body data, then try to read it now
</span>    <span class="enscript-comment">// Note: For cancel_request req-&gt;hdr.datalen == 0, but there's no error return socket for cancel_request
</span>    <span class="enscript-comment">// Any time we need to get the error return socket we know we'll have at least one data byte
</span>    <span class="enscript-comment">// (even if only the one-byte empty C string placeholder for the old ctrl_path parameter)
</span>    <span class="enscript-keyword">if</span> (req-&gt;hdr_bytes == <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr) &amp;&amp; req-&gt;data_bytes &lt; req-&gt;hdr.datalen)
    {
        mDNSu32 nleft = req-&gt;hdr.datalen - req-&gt;data_bytes;
        <span class="enscript-type">int</span> nread;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
        <span class="enscript-type">struct</span> iovec vec = { req-&gt;msgbuf + req-&gt;data_bytes, nleft };    <span class="enscript-comment">// Tell recvmsg where we want the bytes put
</span>        <span class="enscript-type">struct</span> msghdr msg;
        <span class="enscript-type">struct</span> cmsghdr *cmsg;
        <span class="enscript-type">char</span> cbuf[CMSG_SPACE(4 * <span class="enscript-keyword">sizeof</span>(dnssd_sock_t))];
        msg.msg_name       = 0;
        msg.msg_namelen    = 0;
        msg.msg_iov        = &amp;vec;
        msg.msg_iovlen     = 1;
        msg.msg_control    = cbuf;
        msg.msg_controllen = <span class="enscript-keyword">sizeof</span>(cbuf);
        msg.msg_flags      = 0;
        nread = recvmsg(req-&gt;sd, &amp;msg, 0);
#<span class="enscript-reference">else</span>
        nread = udsSupportReadFD(req-&gt;sd, (<span class="enscript-type">char</span> *)req-&gt;msgbuf + req-&gt;data_bytes, nleft, 0, req-&gt;platform_data);
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (nread == 0) { req-&gt;ts = t_terminated; <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">if</span> (nread &lt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">rerror</span>;
        req-&gt;data_bytes += nread;
        <span class="enscript-keyword">if</span> (req-&gt;data_bytes &gt; req-&gt;hdr.datalen)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                      <span class="enscript-string">&quot;[R%u] ERROR: read_msg - read too many data bytes&quot;</span>, req-&gt;request_id);
            req-&gt;ts = t_error;
            <span class="enscript-keyword">return</span>;
        }
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
        cmsg = CMSG_FIRSTHDR(&amp;msg);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_64BIT_SCM_RIGHTS</span>
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                  <span class="enscript-string">&quot;[R%u] Expecting %d %d %d %d&quot;</span>, req-&gt;request_id, <span class="enscript-keyword">sizeof</span>(cbuf), <span class="enscript-keyword">sizeof</span>(cbuf), SOL_SOCKET, SCM_RIGHTS);
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                  <span class="enscript-string">&quot;[R%u] Got       %d %d %d %d&quot;</span>, req-&gt;request_id, msg.msg_controllen, cmsg ? cmsg-&gt;cmsg_len : -1, cmsg ? cmsg-&gt;cmsg_level : -1, cmsg ? cmsg-&gt;cmsg_type : -1);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">DEBUG_64BIT_SCM_RIGHTS</span>
        <span class="enscript-keyword">if</span> (cmsg &amp;&amp; cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; cmsg-&gt;cmsg_type == SCM_RIGHTS)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-comment">// Strictly speaking BPF_fd belongs solely in the platform support layer, but because
</span>            <span class="enscript-comment">// of privilege separation on Mac OS X we need to get BPF_fd from mDNSResponderHelper,
</span>            <span class="enscript-comment">// and it's convenient to repurpose the existing fd-passing code here for that task
</span>            <span class="enscript-keyword">if</span> (req-&gt;hdr.op == send_bpf)
            {
                dnssd_sock_t x = *(dnssd_sock_t *)CMSG_DATA(cmsg);
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                          <span class="enscript-string">&quot;[R%u] Got len %d, BPF %d&quot;</span>, req-&gt;request_id, cmsg-&gt;cmsg_len, x);
                mDNSPlatformReceiveBPF_fd(x);
            }
            <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            req-&gt;errsd = *(dnssd_sock_t *)CMSG_DATA(cmsg);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_64BIT_SCM_RIGHTS</span>
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                      <span class="enscript-string">&quot;[R%u] read req-&gt;errsd %d&quot;</span>, req-&gt;request_id, req-&gt;errsd);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">DEBUG_64BIT_SCM_RIGHTS</span>
            <span class="enscript-keyword">if</span> (req-&gt;data_bytes &lt; req-&gt;hdr.datalen)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
                          <span class="enscript-string">&quot;[R%u] Client(PID [%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)) sent result code socket %d via SCM_RIGHTS with req-&gt;data_bytes %d &lt; req-&gt;hdr.datalen %d&quot;</span>,
                          req-&gt;request_id, req-&gt;process_id, req-&gt;pid_name, req-&gt;errsd, req-&gt;data_bytes, req-&gt;hdr.datalen);
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }
        }
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-comment">// If our header and data are both complete, see if we need to make our separate error return socket
</span>    <span class="enscript-keyword">if</span> (req-&gt;hdr_bytes == <span class="enscript-keyword">sizeof</span>(ipc_msg_hdr) &amp;&amp; req-&gt;data_bytes == req-&gt;hdr.datalen)
    {
        <span class="enscript-keyword">if</span> (req-&gt;terminate &amp;&amp; req-&gt;hdr.op != cancel_request)
        {
            dnssd_sockaddr_t cliaddr;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
            mDNSOpaque16 port;
            u_long opt = 1;
            port.b[0] = req-&gt;msgptr[0];
            port.b[1] = req-&gt;msgptr[1];
            req-&gt;msgptr += 2;
            cliaddr.sin_family      = AF_INET;
            cliaddr.sin_port        = port.NotAnInteger;
            cliaddr.sin_addr.s_addr = inet_addr(MDNS_TCP_SERVERADDR);
#<span class="enscript-reference">else</span>
            <span class="enscript-type">char</span> ctrl_path[MAX_CTLPATH];
            get_string(&amp;req-&gt;msgptr, req-&gt;msgend, ctrl_path, MAX_CTLPATH);  <span class="enscript-comment">// path is first element in message buffer
</span>            mDNSPlatformMemZero(&amp;cliaddr, <span class="enscript-keyword">sizeof</span>(cliaddr));
            cliaddr.sun_family = AF_LOCAL;
            mDNSPlatformStrLCopy(cliaddr.sun_path, ctrl_path, <span class="enscript-keyword">sizeof</span>(cliaddr.sun_path));
            <span class="enscript-comment">// If the error return path UDS name is empty string, that tells us
</span>            <span class="enscript-comment">// that this is a new version of the library that's going to pass us
</span>            <span class="enscript-comment">// the error return path socket via sendmsg/recvmsg
</span>            <span class="enscript-keyword">if</span> (ctrl_path[0] == 0)
            {
                <span class="enscript-keyword">if</span> (req-&gt;errsd == req-&gt;sd)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[R%u] read_msg: ERROR failed to get errsd via SCM_RIGHTS&quot;</span>, req-&gt;request_id);
                    req-&gt;ts = t_error;
                    <span class="enscript-keyword">return</span>;
                }
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">got_errfd</span>;
            }
#<span class="enscript-reference">endif</span>

            req-&gt;errsd = socket(AF_DNSSD, SOCK_STREAM, 0);
            <span class="enscript-keyword">if</span> (!dnssd_SocketValid(req-&gt;errsd))
            {
                my_throttled_perror(<span class="enscript-string">&quot;ERROR: socket&quot;</span>);
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-keyword">if</span> (connect(req-&gt;errsd, (<span class="enscript-type">struct</span> sockaddr *)&amp;cliaddr, <span class="enscript-keyword">sizeof</span>(cliaddr)) &lt; 0)
            {
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
                <span class="enscript-type">struct</span> stat sb;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[R%u] read_msg: Couldn't connect to error return path socket &quot;</span> PUB_S <span class="enscript-string">&quot; errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                          req-&gt;request_id, cliaddr.sun_path, dnssd_errno, dnssd_strerror(dnssd_errno));
                <span class="enscript-keyword">if</span> (stat(cliaddr.sun_path, &amp;sb) &lt; 0)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[R%u] read_msg: stat failed &quot;</span> PUB_S <span class="enscript-string">&quot; errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              req-&gt;request_id, cliaddr.sun_path, dnssd_errno, dnssd_strerror(dnssd_errno));
                }
                <span class="enscript-keyword">else</span>
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[R%u] read_msg: file &quot;</span> PUB_S <span class="enscript-string">&quot; mode %o (octal) uid %d gid %d&quot;</span>,
                              req-&gt;request_id, cliaddr.sun_path, sb.st_mode, sb.st_uid, sb.st_gid);
                }
#<span class="enscript-reference">endif</span>
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
<span class="enscript-reference">got_errfd</span>:
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
            <span class="enscript-keyword">if</span> (ioctlsocket(req-&gt;errsd, FIONBIO, &amp;opt) != 0)
#<span class="enscript-reference">else</span>
            <span class="enscript-keyword">if</span> (fcntl(req-&gt;errsd, F_SETFL, fcntl(req-&gt;errsd, F_GETFL, 0) | O_NONBLOCK) != 0)
#<span class="enscript-reference">endif</span>
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[R%u] ERROR: could not set control socket to non-blocking mode errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                          req-&gt;request_id, dnssd_errno, dnssd_strerror(dnssd_errno));
                req-&gt;ts = t_error;
                <span class="enscript-keyword">return</span>;
            }
        }

        req-&gt;ts = t_complete;
    }

    <span class="enscript-keyword">return</span>;

<span class="enscript-reference">rerror</span>:
    <span class="enscript-keyword">if</span> (dnssd_errno == dnssd_EWOULDBLOCK || dnssd_errno == dnssd_EINTR) <span class="enscript-keyword">return</span>;
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
              <span class="enscript-string">&quot;[R%u] ERROR: read_msg errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>, req-&gt;request_id, dnssd_errno, dnssd_strerror(dnssd_errno));
    req-&gt;ts = t_error;
}

mDNSlocal mStatus <span class="enscript-function-name">handle_client_request</span>(request_state *req)
{
    mStatus err = mStatus_NoError;
    <span class="enscript-keyword">switch</span>(req-&gt;hdr.op)
    {
            <span class="enscript-comment">// These are all operations that have their own first-class request_state object
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">connection_request</span>:
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                   <span class="enscript-string">&quot;[R%d] DNSServiceCreateConnection START PID[%d](&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                   req-&gt;request_id, req-&gt;process_id, req-&gt;pid_name);
            req-&gt;terminate = connection_termination;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">connection_delegate_request</span>:
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                   <span class="enscript-string">&quot;[R%d] DNSServiceCreateDelegateConnection START PID[%d](&quot;</span> PRI_S <span class="enscript-string">&quot;)&quot;</span>,
                   req-&gt;request_id, req-&gt;process_id, req-&gt;pid_name);
            req-&gt;terminate = connection_termination;
            handle_connection_delegate_request(req);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">resolve_request</span>:              err = handle_resolve_request     (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">query_request</span>:                err = handle_queryrecord_request (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">browse_request</span>:               err = handle_browse_request      (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">reg_service_request</span>:          err = handle_regservice_request  (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">enumeration_request</span>:          err = handle_enum_request        (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">reconfirm_record_request</span>:     err = handle_reconfirm_request   (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">setdomain_request</span>:            err = handle_setdomain_request   (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">getproperty_request</span>:                handle_getproperty_request (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">port_mapping_request</span>:         err = handle_port_mapping_request(req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">addrinfo_request</span>:             err = handle_addrinfo_request    (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">send_bpf</span>:                     <span class="enscript-comment">/* Do nothing for send_bpf */</span>            <span class="enscript-keyword">break</span>;

            <span class="enscript-comment">// These are all operations that work with an existing request_state object
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">reg_record_request</span>:           err = handle_regrecord_request   (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">add_record_request</span>:           err = handle_add_request         (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">update_record_request</span>:        err = handle_update_request      (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">remove_record_request</span>:        err = handle_removerecord_request(req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">cancel_request</span>:                     handle_cancel_request      (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">release_request</span>:              err = handle_release_request     (req);  <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>: LogMsg(<span class="enscript-string">&quot;request_callback: %3d:ERROR: Unsupported UDS req:%d PID[%d][%s]&quot;</span>,
                        req-&gt;sd, req-&gt;hdr.op, req-&gt;process_id, req-&gt;pid_name);
            err = mStatus_BadParamErr;
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> err;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RecordOrientedOp</span>(X) \
    ((X) == reg_record_request || (X) == add_record_request || (X) == update_record_request || (X) == remove_record_request)

<span class="enscript-comment">// The lightweight operations are the ones that don't need a dedicated request_state structure allocated for them
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">LightweightOp</span>(X) (RecordOrientedOp(X) || (X) == cancel_request)

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">request_callback</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">void</span> *info)
{
    mStatus err = 0;
    request_state *req = info;
    mDNSs32 min_size = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    (<span class="enscript-type">void</span>)fd; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">for</span> (;;)
    {
        read_msg(req);
        <span class="enscript-keyword">if</span> (req-&gt;ts == t_morecoming)
            <span class="enscript-keyword">return</span>;
        <span class="enscript-keyword">if</span> (req-&gt;ts == t_terminated || req-&gt;ts == t_error)
        {
            AbortUnlinkAndFree(req);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (req-&gt;ts != t_complete)
        {
            LogMsg(<span class="enscript-string">&quot;request_callback: req-&gt;ts %d != t_complete PID[%d][%s]&quot;</span>, req-&gt;ts, req-&gt;process_id, req-&gt;pid_name);
            AbortUnlinkAndFree(req);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-keyword">switch</span>(req-&gt;hdr.op)            <span class="enscript-comment">//          Interface       + other data
</span>        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">connection_request</span>:       min_size = 0;                                                                           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">connection_delegate_request</span>: min_size = 4; <span class="enscript-comment">/* pid */</span>                                                              <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">reg_service_request</span>:      min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 4 <span class="enscript-comment">/* name, type, domain, host */</span> + 4 <span class="enscript-comment">/* port, textlen */</span>; <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">add_record_request</span>:       min_size +=                   4 <span class="enscript-comment">/* type, rdlen */</span>              + 4 <span class="enscript-comment">/* ttl */</span>;           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">update_record_request</span>:    min_size +=                   2 <span class="enscript-comment">/* rdlen */</span>                    + 4 <span class="enscript-comment">/* ttl */</span>;           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">remove_record_request</span>:                                                                                            <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">browse_request</span>:           min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 2 <span class="enscript-comment">/* type, domain */</span>;                                     <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">resolve_request</span>:          min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 3 <span class="enscript-comment">/* type, type, domain */</span>;                               <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">query_request</span>:            min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 1 <span class="enscript-comment">/* name */</span>                     + 4 <span class="enscript-comment">/* type, class*/</span>;    <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">enumeration_request</span>:      min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32);                                                            <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">reg_record_request</span>:       min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 1 <span class="enscript-comment">/* name */</span> + 6 <span class="enscript-comment">/* type, class, rdlen */</span> + 4 <span class="enscript-comment">/* ttl */</span>;  <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">reconfirm_record_request</span>: min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 1 <span class="enscript-comment">/* name */</span> + 6 <span class="enscript-comment">/* type, class, rdlen */</span>;                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">setdomain_request</span>:        min_size +=                   1 <span class="enscript-comment">/* domain */</span>;                                           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">getproperty_request</span>:      min_size = 2;                                                                           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">port_mapping_request</span>:     min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 4 <span class="enscript-comment">/* udp/tcp */</span> + 4 <span class="enscript-comment">/* int/ext port */</span>    + 4 <span class="enscript-comment">/* ttl */</span>;  <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">addrinfo_request</span>:         min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 4 <span class="enscript-comment">/* v4/v6 */</span>   + 1 <span class="enscript-comment">/* hostname */</span>;                       <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">send_bpf</span>:                 <span class="enscript-comment">// Same as cancel_request below
</span>            <span class="enscript-keyword">case</span> <span class="enscript-reference">cancel_request</span>:           min_size = 0;                                                                           <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">release_request</span>:          min_size += <span class="enscript-keyword">sizeof</span>(mDNSu32) + 3 <span class="enscript-comment">/* type, type, domain */</span>;                               <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>: LogMsg(<span class="enscript-string">&quot;request_callback: ERROR: validate_message - unsupported req type: %d PID[%d][%s]&quot;</span>,
                            req-&gt;hdr.op, req-&gt;process_id, req-&gt;pid_name);
                     min_size = -1;                                                                                                <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> ((mDNSs32)req-&gt;data_bytes &lt; min_size)
        {
            LogMsg(<span class="enscript-string">&quot;request_callback: Invalid message %d bytes; min for %d is %d PID[%d][%s]&quot;</span>,
                    req-&gt;data_bytes, req-&gt;hdr.op, min_size, req-&gt;process_id, req-&gt;pid_name);
            AbortUnlinkAndFree(req);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (LightweightOp(req-&gt;hdr.op) &amp;&amp; !req-&gt;terminate)
        {
            LogMsg(<span class="enscript-string">&quot;request_callback: Reg/Add/Update/Remove %d require existing connection PID[%d][%s]&quot;</span>,
                    req-&gt;hdr.op, req-&gt;process_id, req-&gt;pid_name);
            AbortUnlinkAndFree(req);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// If req-&gt;terminate is already set, this means this operation is sharing an existing connection
</span>        <span class="enscript-keyword">if</span> (req-&gt;terminate &amp;&amp; !LightweightOp(req-&gt;hdr.op))
        {
            request_state *newreq = NewRequest();
            newreq-&gt;primary = req;
            newreq-&gt;sd      = req-&gt;sd;
            newreq-&gt;errsd   = req-&gt;errsd;
            newreq-&gt;uid     = req-&gt;uid;
            newreq-&gt;hdr     = req-&gt;hdr;
            newreq-&gt;msgbuf  = req-&gt;msgbuf;
            newreq-&gt;msgptr  = req-&gt;msgptr;
            newreq-&gt;msgend  = req-&gt;msgend;
            newreq-&gt;request_id = mDNSStorage.next_request_id++; 
            <span class="enscript-comment">// if the parent request is a delegate connection, copy the
</span>            <span class="enscript-comment">// relevant bits
</span>            <span class="enscript-keyword">if</span> (req-&gt;validUUID)
            {
                newreq-&gt;validUUID = mDNStrue;
                mDNSPlatformMemCopy(newreq-&gt;uuid, req-&gt;uuid, UUID_SIZE);
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (req-&gt;process_id)
                {
                    newreq-&gt;process_id = req-&gt;process_id;
                    mDNSPlatformStrLCopy(newreq-&gt;pid_name, req-&gt;pid_name, (mDNSu32)<span class="enscript-keyword">sizeof</span>(newreq-&gt;pid_name));
                }
                <span class="enscript-keyword">else</span>
                {
                    set_peer_pid(newreq);
                }
            }
            req = newreq;
        }

        <span class="enscript-comment">// Check if the request wants no asynchronous replies.
</span>        <span class="enscript-keyword">if</span> (req-&gt;hdr.ipc_flags &amp; IPC_FLAGS_NOREPLY) req-&gt;no_reply = 1;

        <span class="enscript-comment">// If we're shutting down, don't allow new client requests
</span>        <span class="enscript-comment">// We do allow &quot;cancel&quot; and &quot;getproperty&quot; during shutdown
</span>        <span class="enscript-keyword">if</span> (mDNSStorage.ShutdownTime &amp;&amp; req-&gt;hdr.op != cancel_request &amp;&amp; req-&gt;hdr.op != getproperty_request)
            err = mStatus_ServiceNotRunning;
        <span class="enscript-keyword">else</span>
            err = handle_client_request(req);

        <span class="enscript-comment">// req-&gt;msgbuf may be NULL, e.g. for connection_request or remove_record_request
</span>        <span class="enscript-keyword">if</span> (req-&gt;msgbuf) freeL(<span class="enscript-string">&quot;request_state msgbuf&quot;</span>, req-&gt;msgbuf);

        <span class="enscript-comment">// There's no return data for a cancel request (DNSServiceRefDeallocate returns no result)
</span>        <span class="enscript-comment">// For a DNSServiceGetProperty call, the handler already generated the response, so no need to do it again here
</span>        <span class="enscript-keyword">if</span> (req-&gt;hdr.op != cancel_request &amp;&amp; req-&gt;hdr.op != getproperty_request &amp;&amp; req-&gt;hdr.op != send_bpf &amp;&amp; req-&gt;hdr.op != getpid_request)
        {
            <span class="enscript-type">const</span> mStatus err_netorder = dnssd_htonl(err);
            send_all(req-&gt;errsd, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)&amp;err_netorder, <span class="enscript-keyword">sizeof</span>(err_netorder));
            <span class="enscript-keyword">if</span> (req-&gt;errsd != req-&gt;sd)
            {
                dnssd_close(req-&gt;errsd);
                req-&gt;errsd = req-&gt;sd;
                <span class="enscript-comment">// Also need to reset the parent's errsd, if this is a subordinate operation
</span>                <span class="enscript-keyword">if</span> (req-&gt;primary) req-&gt;primary-&gt;errsd = req-&gt;primary-&gt;sd;
            }
        }

        <span class="enscript-comment">// Reset ready to accept the next req on this pipe
</span>        <span class="enscript-keyword">if</span> (req-&gt;primary) req = req-&gt;primary;
        req-&gt;ts         = t_morecoming;
        req-&gt;hdr_bytes  = 0;
        req-&gt;data_bytes = 0;
        req-&gt;msgbuf     = mDNSNULL;
        req-&gt;msgptr     = mDNSNULL;
        req-&gt;msgend     = 0;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">connect_callback</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">void</span> *info)
{
    dnssd_sockaddr_t cliaddr;
    dnssd_socklen_t len = (dnssd_socklen_t) <span class="enscript-keyword">sizeof</span>(cliaddr);
    dnssd_sock_t sd = accept(fd, (<span class="enscript-type">struct</span> sockaddr*) &amp;cliaddr, &amp;len);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_NOSIGPIPE</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> optval = 1;
#<span class="enscript-reference">endif</span>

    (<span class="enscript-type">void</span>)info; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (!dnssd_SocketValid(sd))
    {
        <span class="enscript-keyword">if</span> (dnssd_errno != dnssd_EWOULDBLOCK)
            my_throttled_perror(<span class="enscript-string">&quot;ERROR: accept&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SO_NOSIGPIPE</span>
    <span class="enscript-comment">// Some environments (e.g. OS X) support turning off SIGPIPE for a socket
</span>    <span class="enscript-keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_NOSIGPIPE, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval)) &lt; 0)
        LogMsg(<span class="enscript-string">&quot;%3d: WARNING: setsockopt - SO_NOSIGPIPE %d (%s)&quot;</span>, sd, dnssd_errno, dnssd_strerror(dnssd_errno));
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
    <span class="enscript-keyword">if</span> (ioctlsocket(sd, FIONBIO, &amp;optval) != 0)
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (fcntl(sd, F_SETFL, fcntl(sd, F_GETFL, 0) | O_NONBLOCK) != 0)
#<span class="enscript-reference">endif</span>
    {
        my_perror(<span class="enscript-string">&quot;ERROR: fcntl(sd, F_SETFL, O_NONBLOCK) - aborting client&quot;</span>);
        dnssd_close(sd);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">else</span>
    {
        request_state *request = NewRequest();
        request-&gt;ts    = t_morecoming;
        request-&gt;sd    = sd;
        request-&gt;errsd = sd;
        request-&gt;request_id = mDNSStorage.next_request_id++;
        set_peer_pid(request);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        <span class="enscript-type">struct</span> xucred x;
        socklen_t xucredlen = <span class="enscript-keyword">sizeof</span>(x);
        <span class="enscript-keyword">if</span> (getsockopt(sd, 0, LOCAL_PEERCRED, &amp;x, &amp;xucredlen) &gt;= 0 &amp;&amp; x.cr_version == XUCRED_VERSION)
            request-&gt;uid = x.cr_uid; <span class="enscript-comment">// save the effective userid of the client
</span>        <span class="enscript-keyword">else</span>
            my_perror(<span class="enscript-string">&quot;ERROR: getsockopt, LOCAL_PEERCRED&quot;</span>);

        debugf(<span class="enscript-string">&quot;LOCAL_PEERCRED %d %u %u %d&quot;</span>, xucredlen, x.cr_version, x.cr_uid, x.cr_ngroups);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        LogDebug(<span class="enscript-string">&quot;%3d: connect_callback: Adding FD for uid %u&quot;</span>, request-&gt;sd, request-&gt;uid);
        udsSupportAddFDToEventLoop(sd, request_callback, request, &amp;request-&gt;platform_data);
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">uds_socket_setup</span>(dnssd_sock_t skt)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_NP_EXTENSIONS</span>)
    <span class="enscript-type">struct</span>      so_np_extensions sonpx;
    socklen_t optlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> so_np_extensions);
    sonpx.npx_flags = SONPX_SETOPTSHUT;
    sonpx.npx_mask  = SONPX_SETOPTSHUT;
    <span class="enscript-keyword">if</span> (setsockopt(skt, SOL_SOCKET, SO_NP_EXTENSIONS, &amp;sonpx, optlen) &lt; 0)
        my_perror(<span class="enscript-string">&quot;WARNING: could not set sockopt - SO_NP_EXTENSIONS&quot;</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
    <span class="enscript-comment">// SEH: do we even need to do this on windows?
</span>    <span class="enscript-comment">// This socket will be given to WSAEventSelect which will automatically set it to non-blocking
</span>    u_long opt = 1;
    <span class="enscript-keyword">if</span> (ioctlsocket(skt, FIONBIO, &amp;opt) != 0)
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (fcntl(skt, F_SETFL, fcntl(skt, F_GETFL, 0) | O_NONBLOCK) != 0)
#<span class="enscript-reference">endif</span>
    {
        my_perror(<span class="enscript-string">&quot;ERROR: could not set listen socket to non-blocking mode&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (listen(skt, LISTENQ) != 0)
    {
        my_perror(<span class="enscript-string">&quot;ERROR: could not listen on listen socket&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (mStatus_NoError != udsSupportAddFDToEventLoop(skt, connect_callback, (<span class="enscript-type">void</span> *) NULL, (<span class="enscript-type">void</span> **) NULL))
    {
        my_perror(<span class="enscript-string">&quot;ERROR: could not add listen socket to event loop&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">else</span>
    {
        LogOperation(<span class="enscript-string">&quot;%3d: Listening for incoming Unix Domain Socket client requests&quot;</span>, skt);
        mDNSStorage.uds_listener_skt = skt;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_validatelists</span>(<span class="enscript-type">void</span> *context);
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">udsserver_init</span>(dnssd_sock_t skts[], mDNSu32 count)
{
    dnssd_sockaddr_t laddr;
    <span class="enscript-type">int</span> ret;
    mDNSu32 i = 0;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_PID_FILE</span>
    FILE *fp = fopen(PID_FILE, <span class="enscript-string">&quot;w&quot;</span>);
    <span class="enscript-keyword">if</span> (fp != NULL)
    {
        fprintf(fp, <span class="enscript-string">&quot;%d\n&quot;</span>, getpid());
        fclose(fp);
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
	<span class="enscript-type">static</span> mDNSListValidator validator;
	mDNSPlatformAddListValidator(&amp;validator, udsserver_validatelists, <span class="enscript-string">&quot;udsserver_validatelists&quot;</span>, NULL);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (skts)
    {
        <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++)
            <span class="enscript-keyword">if</span> (dnssd_SocketValid(skts[i]) &amp;&amp; !uds_socket_setup(skts[i]))
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    <span class="enscript-keyword">else</span>
    {
        listenfd = socket(AF_DNSSD, SOCK_STREAM, 0);
        <span class="enscript-keyword">if</span> (!dnssd_SocketValid(listenfd))
        {
            my_perror(<span class="enscript-string">&quot;ERROR: socket(AF_DNSSD, SOCK_STREAM, 0); failed&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
        }

        mDNSPlatformMemZero(&amp;laddr, <span class="enscript-keyword">sizeof</span>(laddr));

        #<span class="enscript-keyword">if</span> defined(USE_TCP_LOOPBACK)
        {
            laddr.sin_family = AF_INET;
            laddr.sin_port = htons(MDNS_TCP_SERVERPORT);
            laddr.sin_addr.s_addr = inet_addr(MDNS_TCP_SERVERADDR);
            ret = bind(listenfd, (<span class="enscript-type">struct</span> sockaddr *) &amp;laddr, <span class="enscript-keyword">sizeof</span>(laddr));
            <span class="enscript-keyword">if</span> (ret &lt; 0)
            {
                my_perror(<span class="enscript-string">&quot;ERROR: bind(listenfd, (struct sockaddr *) &amp;laddr, sizeof(laddr)); failed&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
            }
        }
        #<span class="enscript-keyword">else</span>
        {
            mode_t mask = umask(0);
            unlink(boundPath);  <span class="enscript-comment">// OK if this fails
</span>            laddr.sun_family = AF_LOCAL;
            #ifndef NOT_HAVE_SA_LEN
            <span class="enscript-comment">// According to Stevens (section 3.2), there is no portable way to
</span>            <span class="enscript-comment">// determine whether sa_len is defined on a particular platform.
</span>            laddr.sun_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_un);
            #endif
            <span class="enscript-keyword">if</span> (strlen(boundPath) &gt;= <span class="enscript-keyword">sizeof</span>(laddr.sun_path))
            {
                LogMsg(<span class="enscript-string">&quot;ERROR: MDNS_UDS_SERVERPATH must be &lt; %d characters&quot;</span>, (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(laddr.sun_path));
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
            }
            mDNSPlatformStrLCopy(laddr.sun_path, boundPath, <span class="enscript-keyword">sizeof</span>(laddr.sun_path));
            ret = bind(listenfd, (<span class="enscript-type">struct</span> sockaddr *) &amp;laddr, <span class="enscript-keyword">sizeof</span>(laddr));
            umask(mask);
            <span class="enscript-keyword">if</span> (ret &lt; 0)
            {
                my_perror(<span class="enscript-string">&quot;ERROR: bind(listenfd, (struct sockaddr *) &amp;laddr, sizeof(laddr)); failed&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
            }
        }
        #endif

        <span class="enscript-keyword">if</span> (!uds_socket_setup(listenfd)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PLATFORM_NO_RLIMIT</span>)
    {
        <span class="enscript-comment">// Set maximum number of open file descriptors
</span>    #define MIN_OPENFILES 10240
        <span class="enscript-type">struct</span> rlimit maxfds, newfds;

        <span class="enscript-comment">// Due to bugs in OS X (&lt;rdar://problem/2941095&gt;, &lt;rdar://problem/3342704&gt;, &lt;rdar://problem/3839173&gt;)
</span>        <span class="enscript-comment">// you have to get and set rlimits once before getrlimit will return sensible values
</span>        <span class="enscript-keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;maxfds) &lt; 0) { my_perror(<span class="enscript-string">&quot;ERROR: Unable to get file descriptor limit&quot;</span>); <span class="enscript-keyword">return</span> 0; }
        <span class="enscript-keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;maxfds) &lt; 0) my_perror(<span class="enscript-string">&quot;ERROR: Unable to set maximum file descriptor limit&quot;</span>);

        <span class="enscript-keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;maxfds) &lt; 0) { my_perror(<span class="enscript-string">&quot;ERROR: Unable to get file descriptor limit&quot;</span>); <span class="enscript-keyword">return</span> 0; }
        newfds.rlim_max = (maxfds.rlim_max &gt; MIN_OPENFILES) ? maxfds.rlim_max : MIN_OPENFILES;
        newfds.rlim_cur = (maxfds.rlim_cur &gt; MIN_OPENFILES) ? maxfds.rlim_cur : MIN_OPENFILES;
        <span class="enscript-keyword">if</span> (newfds.rlim_max != maxfds.rlim_max || newfds.rlim_cur != maxfds.rlim_cur)
            <span class="enscript-keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;newfds) &lt; 0) my_perror(<span class="enscript-string">&quot;ERROR: Unable to set maximum file descriptor limit&quot;</span>);

        <span class="enscript-keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;maxfds) &lt; 0) { my_perror(<span class="enscript-string">&quot;ERROR: Unable to get file descriptor limit&quot;</span>); <span class="enscript-keyword">return</span> 0; }
        debugf(<span class="enscript-string">&quot;maxfds.rlim_max %d&quot;</span>, (<span class="enscript-type">long</span>)maxfds.rlim_max);
        debugf(<span class="enscript-string">&quot;maxfds.rlim_cur %d&quot;</span>, (<span class="enscript-type">long</span>)maxfds.rlim_cur);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// We start a &quot;LocalOnly&quot; query looking for Automatic Browse Domain records.
</span>    <span class="enscript-comment">// When Domain Enumeration in uDNS.c finds an &quot;lb&quot; record from the network, its &quot;FoundDomain&quot; routine
</span>    <span class="enscript-comment">// creates a &quot;LocalOnly&quot; record, which results in our AutomaticBrowseDomainChange callback being invoked
</span>    mDNS_GetDomains(&amp;mDNSStorage, &amp;mDNSStorage.AutomaticBrowseDomainQ, mDNS_DomainTypeBrowseAutomatic,
                    mDNSNULL, mDNSInterface_LocalOnly, AutomaticBrowseDomainChange, mDNSNULL);

    <span class="enscript-comment">// Add &quot;local&quot; as recommended registration domain (&quot;dns-sd -E&quot;), recommended browsing domain (&quot;dns-sd -F&quot;), and automatic browsing domain
</span>    RegisterLocalOnlyDomainEnumPTR(&amp;mDNSStorage, &amp;localdomain, mDNS_DomainTypeRegistration);
    RegisterLocalOnlyDomainEnumPTR(&amp;mDNSStorage, &amp;localdomain, mDNS_DomainTypeBrowse);
    AddAutoBrowseDomain(0, &amp;localdomain);

    udsserver_handle_configchange(&amp;mDNSStorage);
    <span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">error</span>:

    my_perror(<span class="enscript-string">&quot;ERROR: udsserver_init&quot;</span>);
    <span class="enscript-keyword">return</span> -1;
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">udsserver_exit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-comment">// Cancel all outstanding client requests
</span>    <span class="enscript-keyword">while</span> (all_requests) AbortUnlinkAndFree(all_requests);

    <span class="enscript-comment">// Clean up any special mDNSInterface_LocalOnly records we created, both the entries for &quot;local&quot; we
</span>    <span class="enscript-comment">// created in udsserver_init, and others we created as a result of reading local configuration data
</span>    <span class="enscript-keyword">while</span> (LocalDomainEnumRecords)
    {
        ARListElem *rem = LocalDomainEnumRecords;
        LocalDomainEnumRecords = LocalDomainEnumRecords-&gt;next;
        mDNS_Deregister(&amp;mDNSStorage, &amp;rem-&gt;ar);
    }

    <span class="enscript-comment">// If the launching environment created no listening socket,
</span>    <span class="enscript-comment">// that means we created it ourselves, so we should clean it up on exit
</span>    <span class="enscript-keyword">if</span> (dnssd_SocketValid(listenfd))
    {
        dnssd_close(listenfd);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">USE_TCP_LOOPBACK</span>)
        <span class="enscript-comment">// Currently, we're unable to remove /var/run/mdnsd because we've changed to userid &quot;nobody&quot;
</span>        <span class="enscript-comment">// to give up unnecessary privilege, but we need to be root to remove this Unix Domain Socket.
</span>        <span class="enscript-comment">// It would be nice if we could find a solution to this problem
</span>        <span class="enscript-keyword">if</span> (unlink(boundPath))
            debugf(<span class="enscript-string">&quot;Unable to remove %s&quot;</span>, MDNS_UDS_SERVERPATH);
#<span class="enscript-reference">endif</span>
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_PID_FILE</span>
    unlink(PID_FILE);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> 0;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogClientInfoToFD</span>(<span class="enscript-type">int</span> fd, request_state *req)
{
    <span class="enscript-type">char</span> reqIDStr[14];
    <span class="enscript-type">char</span> prefix[18];

    mDNS_snprintf(reqIDStr, <span class="enscript-keyword">sizeof</span>(reqIDStr), <span class="enscript-string">&quot;[R%u]&quot;</span>, req-&gt;request_id);

    mDNS_snprintf(prefix, <span class="enscript-keyword">sizeof</span>(prefix), <span class="enscript-string">&quot;%-6s %2s&quot;</span>, reqIDStr, req-&gt;primary ? <span class="enscript-string">&quot;-&gt;&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

    <span class="enscript-keyword">if</span> (!req-&gt;terminate)
        LogToFD(fd, <span class="enscript-string">&quot;%s No operation yet on this socket&quot;</span>, prefix);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == connection_termination)
    {
        <span class="enscript-type">int</span> num_records = 0, num_ops = 0;
        <span class="enscript-type">const</span> registered_record_entry *p;
        request_state *r;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next) num_records++;
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next) <span class="enscript-keyword">if</span> (r-&gt;primary == req) num_ops++;
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)&quot;</span>,
                  prefix, num_records, num_records != 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, num_ops,     num_ops     != 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                  req-&gt;process_id, req-&gt;pid_name);
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
            LogToFD(fd, <span class="enscript-string">&quot; -&gt;  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)&quot;</span>,
                      req-&gt;flags, req-&gt;interfaceIndex, p-&gt;key, ARDisplayString(&amp;mDNSStorage, p-&gt;rr), req-&gt;process_id, req-&gt;pid_name);
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next) <span class="enscript-keyword">if</span> (r-&gt;primary == req) LogClientInfoToFD(fd, r);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
    {
        service_instance *ptr;
        <span class="enscript-keyword">for</span> (ptr = req-&gt;u.servicereg.instances; ptr; ptr = ptr-&gt;next)
            LogToFD(fd, <span class="enscript-string">&quot;%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)&quot;</span>,
                      (ptr == req-&gt;u.servicereg.instances) ? prefix : <span class="enscript-string">&quot;&quot;</span>, req-&gt;flags, req-&gt;interfaceIndex, ptr-&gt;srs.RR_SRV.resrec.name-&gt;c,
                      mDNSVal16(req-&gt;u.servicereg.port),
                      SRS_PORT(&amp;ptr-&gt;srs), req-&gt;process_id, req-&gt;pid_name);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == browse_termination_callback)
    {
        browser_t *blist;
        <span class="enscript-keyword">for</span> (blist = req-&gt;u.browser.browsers; blist; blist = blist-&gt;next)
            LogToFD(fd, <span class="enscript-string">&quot;%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                      (blist == req-&gt;u.browser.browsers) ? prefix : <span class="enscript-string">&quot;&quot;</span>, req-&gt;flags, req-&gt;interfaceIndex, blist-&gt;q.qname.c,
                      req-&gt;process_id, req-&gt;pid_name);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == resolve_termination_callback)
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, req-&gt;u.resolve.qsrv.qname.c, req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == queryrecord_termination_callback)
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, QueryRecordClientRequestGetQName(&amp;req-&gt;u.queryrecord), DNSTypeName(QueryRecordClientRequestGetType(&amp;req-&gt;u.queryrecord)), req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == enum_termination_callback)
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, req-&gt;u.enumeration.q_all.qname.c, req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == port_mapping_termination_callback)
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)&quot;</span>,
                  prefix,
                  req-&gt;flags,
                  req-&gt;interfaceIndex,
                  req-&gt;u.pm.NATinfo.Protocol &amp; NATOp_MapTCP ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;   &quot;</span>,
                  req-&gt;u.pm.NATinfo.Protocol &amp; NATOp_MapUDP ? <span class="enscript-string">&quot;UDP&quot;</span> : <span class="enscript-string">&quot;   &quot;</span>,
                  mDNSVal16(req-&gt;u.pm.NATinfo.IntPort),
                  mDNSVal16(req-&gt;u.pm.ReqExt),
                  &amp;req-&gt;u.pm.NATinfo.ExternalAddress,
                  mDNSVal16(req-&gt;u.pm.NATinfo.ExternalPort),
                  req-&gt;u.pm.NATinfo.NATLease,
                  req-&gt;u.pm.NATinfo.Lifetime,
                  req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == addrinfo_termination_callback)
        LogToFD(fd, <span class="enscript-string">&quot;%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex,
                  req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv4 ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                  req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv6 ? <span class="enscript-string">&quot;v6&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                  GetAddrInfoClientRequestGetQName(&amp;req-&gt;u.addrinfo), req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span>
        LogToFD(fd, <span class="enscript-string">&quot;%s Unrecognized operation %p&quot;</span>, prefix, req-&gt;terminate);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogClientInfo</span>(request_state *req)
{
    <span class="enscript-type">char</span> reqIDStr[14];
    <span class="enscript-type">char</span> prefix[18];

    mDNS_snprintf(reqIDStr, <span class="enscript-keyword">sizeof</span>(reqIDStr), <span class="enscript-string">&quot;[R%u]&quot;</span>, req-&gt;request_id);

    mDNS_snprintf(prefix, <span class="enscript-keyword">sizeof</span>(prefix), <span class="enscript-string">&quot;%-6s %2s&quot;</span>, reqIDStr, req-&gt;primary ? <span class="enscript-string">&quot;-&gt;&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

    <span class="enscript-keyword">if</span> (!req-&gt;terminate)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s No operation yet on this socket&quot;</span>, prefix);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == connection_termination)
    {
        <span class="enscript-type">int</span> num_records = 0, num_ops = 0;
        <span class="enscript-type">const</span> registered_record_entry *p;
        request_state *r;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next) num_records++;
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next) <span class="enscript-keyword">if</span> (r-&gt;primary == req) num_ops++;
        LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)&quot;</span>,
                      prefix, num_records, num_records != 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, num_ops,     num_ops     != 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                      req-&gt;process_id, req-&gt;pid_name);
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
        LogMsgNoIdent(<span class="enscript-string">&quot; -&gt;  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)&quot;</span>,
                      req-&gt;flags, req-&gt;interfaceIndex, p-&gt;key, ARDisplayString(&amp;mDNSStorage, p-&gt;rr), req-&gt;process_id, req-&gt;pid_name);
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next) <span class="enscript-keyword">if</span> (r-&gt;primary == req) LogClientInfo(r);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
    {
        service_instance *ptr;
        <span class="enscript-keyword">for</span> (ptr = req-&gt;u.servicereg.instances; ptr; ptr = ptr-&gt;next)
        LogMsgNoIdent(<span class="enscript-string">&quot;%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)&quot;</span>,
                      (ptr == req-&gt;u.servicereg.instances) ? prefix : <span class="enscript-string">&quot;&quot;</span>, req-&gt;flags, req-&gt;interfaceIndex, ptr-&gt;srs.RR_SRV.resrec.name-&gt;c,
                      mDNSVal16(req-&gt;u.servicereg.port),
                      SRS_PORT(&amp;ptr-&gt;srs), req-&gt;process_id, req-&gt;pid_name);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == browse_termination_callback)
    {
        browser_t *blist;
        <span class="enscript-keyword">for</span> (blist = req-&gt;u.browser.browsers; blist; blist = blist-&gt;next)
        LogMsgNoIdent(<span class="enscript-string">&quot;%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                      (blist == req-&gt;u.browser.browsers) ? prefix : <span class="enscript-string">&quot;&quot;</span>, req-&gt;flags, req-&gt;interfaceIndex, blist-&gt;q.qname.c,
                      req-&gt;process_id, req-&gt;pid_name);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == resolve_termination_callback)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, req-&gt;u.resolve.qsrv.qname.c, req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == queryrecord_termination_callback)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, QueryRecordClientRequestGetQName(&amp;req-&gt;u.queryrecord), DNSTypeName(QueryRecordClientRequestGetType(&amp;req-&gt;u.queryrecord)), req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == enum_termination_callback)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex, req-&gt;u.enumeration.q_all.qname.c, req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == port_mapping_termination_callback)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)&quot;</span>,
                  prefix,
                  req-&gt;flags,
                  req-&gt;interfaceIndex,
                  req-&gt;u.pm.NATinfo.Protocol &amp; NATOp_MapTCP ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;   &quot;</span>,
                  req-&gt;u.pm.NATinfo.Protocol &amp; NATOp_MapUDP ? <span class="enscript-string">&quot;UDP&quot;</span> : <span class="enscript-string">&quot;   &quot;</span>,
                  mDNSVal16(req-&gt;u.pm.NATinfo.IntPort),
                  mDNSVal16(req-&gt;u.pm.ReqExt),
                  &amp;req-&gt;u.pm.NATinfo.ExternalAddress,
                  mDNSVal16(req-&gt;u.pm.NATinfo.ExternalPort),
                  req-&gt;u.pm.NATinfo.NATLease,
                  req-&gt;u.pm.NATinfo.Lifetime,
                  req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == addrinfo_termination_callback)
    LogMsgNoIdent(<span class="enscript-string">&quot;%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)&quot;</span>,
                  prefix, req-&gt;flags, req-&gt;interfaceIndex,
                  req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv4 ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                  req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv6 ? <span class="enscript-string">&quot;v6&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                  GetAddrInfoClientRequestGetQName(&amp;req-&gt;u.addrinfo), req-&gt;process_id, req-&gt;pid_name);
    <span class="enscript-keyword">else</span>
    LogMsgNoIdent(<span class="enscript-string">&quot;%s Unrecognized operation %p&quot;</span>, prefix, req-&gt;terminate);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetMcastClients</span>(request_state *req)
{
    <span class="enscript-keyword">if</span> (req-&gt;terminate == connection_termination)
    {
        <span class="enscript-type">int</span> num_records = 0, num_ops = 0;
        <span class="enscript-type">const</span> registered_record_entry *p;
        request_state *r;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
            num_records++;
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next)
            <span class="enscript-keyword">if</span> (r-&gt;primary == req)
                num_ops++;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(p-&gt;rr))
                n_mrecords++;
        }
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next)
            <span class="enscript-keyword">if</span> (r-&gt;primary == req)
                GetMcastClients(r);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
    {
        service_instance *ptr;
        <span class="enscript-keyword">for</span> (ptr = req-&gt;u.servicereg.instances; ptr; ptr = ptr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(&amp;ptr-&gt;srs.RR_SRV))
                n_mrecords++;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == browse_termination_callback)
    {
        browser_t *blist;
        <span class="enscript-keyword">for</span> (blist = req-&gt;u.browser.browsers; blist; blist = blist-&gt;next)
        {
            <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(blist-&gt;q.TargetQID))
                n_mquests++;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == resolve_termination_callback)
    {
        <span class="enscript-keyword">if</span> ((mDNSOpaque16IsZero(req-&gt;u.resolve.qsrv.TargetQID)) &amp;&amp; (req-&gt;u.resolve.qsrv.ThisQInterval &gt; 0))
            n_mquests++;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == queryrecord_termination_callback)
    {
        <span class="enscript-keyword">if</span> (QueryRecordClientRequestIsMulticast(&amp;req-&gt;u.queryrecord))
            n_mquests++;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == addrinfo_termination_callback)
    {
        <span class="enscript-keyword">if</span> (GetAddrInfoClientRequestIsMulticast(&amp;req-&gt;u.addrinfo))
            n_mquests++;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span>;
    }
}


mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastClientInfo</span>(request_state *req)
{
    <span class="enscript-keyword">if</span> (!req-&gt;terminate)
        LogMcastNoIdent(<span class="enscript-string">&quot;No operation yet on this socket&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == connection_termination)
    {
        <span class="enscript-type">int</span> num_records = 0, num_ops = 0;
        <span class="enscript-type">const</span> registered_record_entry *p;
        request_state *r;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
            num_records++;
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next)
            <span class="enscript-keyword">if</span> (r-&gt;primary == req)
                num_ops++;
        <span class="enscript-keyword">for</span> (p = req-&gt;u.reg_recs; p; p=p-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(p-&gt;rr))
                LogMcastNoIdent(<span class="enscript-string">&quot;R: -&gt;  DNSServiceRegisterRecord:  %##s %s PID[%d](%s)&quot;</span>, p-&gt;rr-&gt;resrec.name-&gt;c,
                                DNSTypeName(p-&gt;rr-&gt;resrec.rrtype), req-&gt;process_id, req-&gt;pid_name, i_mcount++);
        }
        <span class="enscript-keyword">for</span> (r = req-&gt;next; r; r=r-&gt;next)
            <span class="enscript-keyword">if</span> (r-&gt;primary == req)
                LogMcastClientInfo(r);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
    {
        service_instance *ptr;
        <span class="enscript-keyword">for</span> (ptr = req-&gt;u.servicereg.instances; ptr; ptr = ptr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(&amp;ptr-&gt;srs.RR_SRV))
                LogMcastNoIdent(<span class="enscript-string">&quot;R: DNSServiceRegister:  %##s %u/%u PID[%d](%s)&quot;</span>, ptr-&gt;srs.RR_SRV.resrec.name-&gt;c, mDNSVal16(req-&gt;u.servicereg.port),
                                SRS_PORT(&amp;ptr-&gt;srs), req-&gt;process_id, req-&gt;pid_name, i_mcount++);
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == browse_termination_callback)
    {
        browser_t *blist;
        <span class="enscript-keyword">for</span> (blist = req-&gt;u.browser.browsers; blist; blist = blist-&gt;next)
        {
            <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(blist-&gt;q.TargetQID))
                LogMcastNoIdent(<span class="enscript-string">&quot;Q: DNSServiceBrowse  %##s %s PID[%d](%s)&quot;</span>, blist-&gt;q.qname.c, DNSTypeName(blist-&gt;q.qtype),
                                req-&gt;process_id, req-&gt;pid_name, i_mcount++);
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == resolve_termination_callback)
    {
        <span class="enscript-keyword">if</span> ((mDNSOpaque16IsZero(req-&gt;u.resolve.qsrv.TargetQID)) &amp;&amp; (req-&gt;u.resolve.qsrv.ThisQInterval &gt; 0))
            LogMcastNoIdent(<span class="enscript-string">&quot;Q: DNSServiceResolve  %##s %s PID[%d](%s)&quot;</span>, req-&gt;u.resolve.qsrv.qname.c, DNSTypeName(req-&gt;u.resolve.qsrv.qtype),
                            req-&gt;process_id, req-&gt;pid_name, i_mcount++);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == queryrecord_termination_callback)
    {
        <span class="enscript-keyword">if</span> (QueryRecordClientRequestIsMulticast(&amp;req-&gt;u.queryrecord))
        {
            LogMcastNoIdent(<span class="enscript-string">&quot;Q: DNSServiceQueryRecord  %##s %s PID[%d](%s)&quot;</span>,
                          QueryRecordClientRequestGetQName(&amp;req-&gt;u.queryrecord),
                          DNSTypeName(QueryRecordClientRequestGetType(&amp;req-&gt;u.queryrecord)),
                          req-&gt;process_id, req-&gt;pid_name, i_mcount++);
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == addrinfo_termination_callback)
    {
        <span class="enscript-keyword">if</span> (GetAddrInfoClientRequestIsMulticast(&amp;req-&gt;u.addrinfo))
        {
            LogMcastNoIdent(<span class="enscript-string">&quot;Q: DNSServiceGetAddrInfo  %s%s %##s PID[%d](%s)&quot;</span>,
                          req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv4 ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                          req-&gt;u.addrinfo.protocols &amp; kDNSServiceProtocol_IPv6 ? <span class="enscript-string">&quot;v6&quot;</span> : <span class="enscript-string">&quot;  &quot;</span>,
                          GetAddrInfoClientRequestGetQName(&amp;req-&gt;u.addrinfo), req-&gt;process_id, req-&gt;pid_name, i_mcount++);
        }
    }
}

mDNSlocal <span class="enscript-type">char</span> *<span class="enscript-function-name">RecordTypeName</span>(mDNSu8 rtype)
{
    <span class="enscript-keyword">switch</span> (rtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeUnregistered</span>:  <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Unregistered &quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeDeregistering</span>: <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Deregistering&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeUnique</span>:        <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Unique       &quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeAdvisory</span>:      <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Advisory     &quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeShared</span>:        <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Shared       &quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeVerified</span>:      <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Verified     &quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSRecordTypeKnownUnique</span>:   <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;KnownUnique  &quot;</span>);
    <span class="enscript-reference">default</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;Unknown&quot;</span>);
    }
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">LogEtcHostsToFD</span>(<span class="enscript-type">int</span> fd, mDNS *<span class="enscript-type">const</span> m)
{
    mDNSBool showheader = mDNStrue;
    <span class="enscript-type">const</span> AuthRecord *ar;
    mDNSu32 slot;
    AuthGroup *ag;
    <span class="enscript-type">int</span> count = 0;
    <span class="enscript-type">int</span> authslot = 0;
    mDNSBool truncated = 0;

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
    {
        <span class="enscript-keyword">if</span> (m-&gt;rrauth.rrauth_hash[slot]) authslot++;
        <span class="enscript-keyword">for</span> (ag = m-&gt;rrauth.rrauth_hash[slot]; ag; ag = ag-&gt;next)
            <span class="enscript-keyword">for</span> (ar = ag-&gt;members; ar; ar = ar-&gt;next)
            {
                <span class="enscript-keyword">if</span> (ar-&gt;RecordCallback != FreeEtcHosts) <span class="enscript-keyword">continue</span>;
                <span class="enscript-keyword">if</span> (showheader) { showheader = mDNSfalse; LogToFD(fd, <span class="enscript-string">&quot;  State       Interface&quot;</span>); }

                <span class="enscript-comment">// Print a maximum of 50 records
</span>                <span class="enscript-keyword">if</span> (count++ &gt;= 50) { truncated = mDNStrue; <span class="enscript-keyword">continue</span>; }
                <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordLocalOnly)
                {
                    <span class="enscript-keyword">if</span> (ar-&gt;resrec.InterfaceID == mDNSInterface_LocalOnly)
                        LogToFD(fd, <span class="enscript-string">&quot; %s   LO %s&quot;</span>, RecordTypeName(ar-&gt;resrec.RecordType), ARDisplayString(m, ar));
                    <span class="enscript-keyword">else</span>
                    {
                        mDNSu32 scopeid  = (mDNSu32)(uintptr_t)ar-&gt;resrec.InterfaceID;
                        LogToFD(fd, <span class="enscript-string">&quot; %s   %u  %s&quot;</span>, RecordTypeName(ar-&gt;resrec.RecordType), scopeid, ARDisplayString(m, ar));
                    }
                }
            }
    }

    <span class="enscript-keyword">if</span> (showheader) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (truncated) LogToFD(fd, <span class="enscript-string">&quot;&lt;Truncated: to 50 records, Total records %d, Total Auth Groups %d, Auth Slots %d&gt;&quot;</span>, count, m-&gt;rrauth.rrauth_totalused, authslot);
    <span class="enscript-keyword">return</span> count;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogLocalOnlyAuthRecordsToFD</span>(<span class="enscript-type">int</span> fd, mDNS *<span class="enscript-type">const</span> m)
{
    mDNSBool showheader = mDNStrue;
    <span class="enscript-type">const</span> AuthRecord *ar;
    mDNSu32 slot;
    AuthGroup *ag;

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
    {
        <span class="enscript-keyword">for</span> (ag = m-&gt;rrauth.rrauth_hash[slot]; ag; ag = ag-&gt;next)
            <span class="enscript-keyword">for</span> (ar = ag-&gt;members; ar; ar = ar-&gt;next)
            {
                <span class="enscript-keyword">if</span> (ar-&gt;RecordCallback == FreeEtcHosts) <span class="enscript-keyword">continue</span>;
                <span class="enscript-keyword">if</span> (showheader) { showheader = mDNSfalse; LogToFD(fd, <span class="enscript-string">&quot;  State       Interface&quot;</span>); }

                <span class="enscript-comment">// Print a maximum of 400 records
</span>                <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordLocalOnly)
                    LogToFD(fd, <span class="enscript-string">&quot; %s   LO  %s&quot;</span>, RecordTypeName(ar-&gt;resrec.RecordType), ARDisplayString(m, ar));
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordP2P)
                {
                    <span class="enscript-keyword">if</span> (ar-&gt;resrec.InterfaceID == mDNSInterface_BLE)
                        LogToFD(fd, <span class="enscript-string">&quot; %s   BLE %s&quot;</span>, RecordTypeName(ar-&gt;resrec.RecordType), ARDisplayString(m, ar));
                    <span class="enscript-keyword">else</span>
                        LogToFD(fd, <span class="enscript-string">&quot; %s   PP  %s&quot;</span>, RecordTypeName(ar-&gt;resrec.RecordType), ARDisplayString(m, ar));
                }
            }
    }

    <span class="enscript-keyword">if</span> (showheader) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogOneAuthRecordToFD</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">const</span> AuthRecord *ar, mDNSs32 now, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname)
{
    <span class="enscript-keyword">if</span> (AuthRecord_uDNS(ar))
    {
        LogToFD(fd, <span class="enscript-string">&quot;%7d %7d %7d %-7s %4d %s %s&quot;</span>,
                  ar-&gt;ThisAPInterval / mDNSPlatformOneSecond,
                  (ar-&gt;LastAPTime + ar-&gt;ThisAPInterval - now) / mDNSPlatformOneSecond,
                  ar-&gt;expire ? (ar-&gt;expire - now) / mDNSPlatformOneSecond : 0,
                  <span class="enscript-string">&quot;-U-&quot;</span>,
                  ar-&gt;state,
                  ar-&gt;AllowRemoteQuery ? <span class="enscript-string">&quot;☠&quot;</span> : <span class="enscript-string">&quot; &quot;</span>,
                  ARDisplayString(&amp;mDNSStorage, ar));
    }
    <span class="enscript-keyword">else</span>
    {
        LogToFD(fd, <span class="enscript-string">&quot;%7d %7d %7d %-7s 0x%02X %s %s&quot;</span>,
                  ar-&gt;ThisAPInterval / mDNSPlatformOneSecond,
                  ar-&gt;AnnounceCount ? (ar-&gt;LastAPTime + ar-&gt;ThisAPInterval - now) / mDNSPlatformOneSecond : 0,
                  ar-&gt;TimeExpire    ? (ar-&gt;TimeExpire                      - now) / mDNSPlatformOneSecond : 0,
                  ifname ? ifname : <span class="enscript-string">&quot;ALL&quot;</span>,
                  ar-&gt;resrec.RecordType,
                  ar-&gt;AllowRemoteQuery ? <span class="enscript-string">&quot;☠&quot;</span> : <span class="enscript-string">&quot; &quot;</span>,
                  ARDisplayString(&amp;mDNSStorage, ar));
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogAuthRecordsToFD</span>(<span class="enscript-type">int</span> fd,
                                    <span class="enscript-type">const</span> mDNSs32 now, AuthRecord *ResourceRecords, <span class="enscript-type">int</span> *proxy)
{
    mDNSBool showheader = mDNStrue;
    <span class="enscript-type">const</span> AuthRecord *ar;
    OwnerOptData owner = zeroOwner;
    <span class="enscript-keyword">for</span> (ar = ResourceRecords; ar; ar=ar-&gt;next)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> ifname = InterfaceNameForID(&amp;mDNSStorage, ar-&gt;resrec.InterfaceID);
        <span class="enscript-keyword">if</span> ((ar-&gt;WakeUp.HMAC.l[0] != 0) == (proxy != mDNSNULL))
        {
            <span class="enscript-keyword">if</span> (showheader) { showheader = mDNSfalse; LogToFD(fd, <span class="enscript-string">&quot;    Int    Next  Expire if     State&quot;</span>); }
            <span class="enscript-keyword">if</span> (proxy) (*proxy)++;
            <span class="enscript-keyword">if</span> (!mDNSPlatformMemSame(&amp;owner, &amp;ar-&gt;WakeUp, <span class="enscript-keyword">sizeof</span>(owner)))
            {
                owner = ar-&gt;WakeUp;
                <span class="enscript-keyword">if</span> (owner.password.l[0])
                    LogToFD(fd, <span class="enscript-string">&quot;Proxying for H-MAC %.6a I-MAC %.6a Password %.6a seq %d&quot;</span>, &amp;owner.HMAC, &amp;owner.IMAC, &amp;owner.password, owner.seq);
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!mDNSSameEthAddress(&amp;owner.HMAC, &amp;owner.IMAC))
                    LogToFD(fd, <span class="enscript-string">&quot;Proxying for H-MAC %.6a I-MAC %.6a seq %d&quot;</span>,               &amp;owner.HMAC, &amp;owner.IMAC,                  owner.seq);
                <span class="enscript-keyword">else</span>
                    LogToFD(fd, <span class="enscript-string">&quot;Proxying for %.6a seq %d&quot;</span>,                                &amp;owner.HMAC,                               owner.seq);
            }
            <span class="enscript-keyword">if</span> (AuthRecord_uDNS(ar))
            {
                LogOneAuthRecordToFD(fd, ar, now, ifname);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordLocalOnly)
            {
                LogToFD(fd, <span class="enscript-string">&quot;                             LO %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, ar));
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordP2P)
            {
                <span class="enscript-keyword">if</span> (ar-&gt;resrec.InterfaceID == mDNSInterface_BLE)
                    LogToFD(fd, <span class="enscript-string">&quot;                             BLE %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, ar));
                <span class="enscript-keyword">else</span>
                    LogToFD(fd, <span class="enscript-string">&quot;                             PP %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, ar));
            }
            <span class="enscript-keyword">else</span>
            {
                LogOneAuthRecordToFD(fd, ar, now, ifname);
            }
        }
    }
    <span class="enscript-keyword">if</span> (showheader) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintOneCacheRecordToFD</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">const</span> CacheRecord *cr, mDNSu32 slot, <span class="enscript-type">const</span> mDNSu32 remain, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, mDNSu32 *CacheUsed)
{
    LogToFD(fd, <span class="enscript-string">&quot;%3d %s%8d %-7s%s %-6s%s&quot;</span>,
              slot,
              cr-&gt;CRActiveQuestion ? <span class="enscript-string">&quot;*&quot;</span> : <span class="enscript-string">&quot; &quot;</span>,
              remain,
              ifname ? ifname : <span class="enscript-string">&quot;-U-&quot;</span>,
              (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)  ? <span class="enscript-string">&quot;-&quot;</span> :
              (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;+&quot;</span>,
              DNSTypeName(cr-&gt;resrec.rrtype),
              CRDisplayString(&amp;mDNSStorage, cr));
    (*CacheUsed)++;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintCachedRecordsToFD</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">const</span> CacheRecord *cr, mDNSu32 slot, <span class="enscript-type">const</span> mDNSu32 remain, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, mDNSu32 *CacheUsed)
{
    CacheRecord *nsec;
    CacheRecord *soa;
    nsec = cr-&gt;nsec;

    <span class="enscript-comment">// The records that are cached under the main cache record like nsec, soa don't have
</span>    <span class="enscript-comment">// their own lifetime. If the main cache record expires, they also expire.
</span>    <span class="enscript-keyword">while</span> (nsec)
    {
        PrintOneCacheRecordToFD(fd, nsec, slot, remain, ifname, CacheUsed);
        nsec = nsec-&gt;next;
    }
    soa = cr-&gt;soa;
    <span class="enscript-keyword">if</span> (soa)
    {
        PrintOneCacheRecordToFD(fd, soa, slot, remain, ifname, CacheUsed);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LogMDNSStatisticsToFD</span>(<span class="enscript-type">int</span> fd, mDNS *<span class="enscript-type">const</span> m)
{
    LogToFD(fd, <span class="enscript-string">&quot;--- MDNS Statistics ---&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;Name Conflicts                 %u&quot;</span>, m-&gt;mDNSStats.NameConflicts);
    LogToFD(fd, <span class="enscript-string">&quot;KnownUnique Name Conflicts     %u&quot;</span>, m-&gt;mDNSStats.KnownUniqueNameConflicts);
    LogToFD(fd, <span class="enscript-string">&quot;Duplicate Query Suppressions   %u&quot;</span>, m-&gt;mDNSStats.DupQuerySuppressions);
    LogToFD(fd, <span class="enscript-string">&quot;KA Suppressions                %u&quot;</span>, m-&gt;mDNSStats.KnownAnswerSuppressions);
    LogToFD(fd, <span class="enscript-string">&quot;KA Multiple Packets            %u&quot;</span>, m-&gt;mDNSStats.KnownAnswerMultiplePkts);
    LogToFD(fd, <span class="enscript-string">&quot;Poof Cache Deletions           %u&quot;</span>, m-&gt;mDNSStats.PoofCacheDeletions);
    LogToFD(fd, <span class="enscript-string">&quot;--------------------------------&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;Multicast packets Sent         %u&quot;</span>, m-&gt;MulticastPacketsSent);
    LogToFD(fd, <span class="enscript-string">&quot;Multicast packets Received     %u&quot;</span>, m-&gt;MPktNum);
    LogToFD(fd, <span class="enscript-string">&quot;Remote Subnet packets          %u&quot;</span>, m-&gt;RemoteSubnet);
    LogToFD(fd, <span class="enscript-string">&quot;QU questions  received         %u&quot;</span>, m-&gt;mDNSStats.UnicastBitInQueries);
    LogToFD(fd, <span class="enscript-string">&quot;Normal multicast questions     %u&quot;</span>, m-&gt;mDNSStats.NormalQueries);
    LogToFD(fd, <span class="enscript-string">&quot;Answers for questions          %u&quot;</span>, m-&gt;mDNSStats.MatchingAnswersForQueries);
    LogToFD(fd, <span class="enscript-string">&quot;Unicast responses              %u&quot;</span>, m-&gt;mDNSStats.UnicastResponses);
    LogToFD(fd, <span class="enscript-string">&quot;Multicast responses            %u&quot;</span>, m-&gt;mDNSStats.MulticastResponses);
    LogToFD(fd, <span class="enscript-string">&quot;Unicast response Demotions     %u&quot;</span>, m-&gt;mDNSStats.UnicastDemotedToMulticast);
    LogToFD(fd, <span class="enscript-string">&quot;--------------------------------&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;Sleeps                         %u&quot;</span>, m-&gt;mDNSStats.Sleeps);
    LogToFD(fd, <span class="enscript-string">&quot;Wakeups                        %u&quot;</span>, m-&gt;mDNSStats.Wakes);
    LogToFD(fd, <span class="enscript-string">&quot;Interface UP events            %u&quot;</span>, m-&gt;mDNSStats.InterfaceUp);
    LogToFD(fd, <span class="enscript-string">&quot;Interface UP Flap events       %u&quot;</span>, m-&gt;mDNSStats.InterfaceUpFlap);
    LogToFD(fd, <span class="enscript-string">&quot;Interface Down events          %u&quot;</span>, m-&gt;mDNSStats.InterfaceDown);
    LogToFD(fd, <span class="enscript-string">&quot;Interface DownFlap events      %u&quot;</span>, m-&gt;mDNSStats.InterfaceDownFlap);
    LogToFD(fd, <span class="enscript-string">&quot;Cache refresh queries          %u&quot;</span>, m-&gt;mDNSStats.CacheRefreshQueries);
    LogToFD(fd, <span class="enscript-string">&quot;Cache refreshed                %u&quot;</span>, m-&gt;mDNSStats.CacheRefreshed);
    LogToFD(fd, <span class="enscript-string">&quot;Wakeup on Resolves             %u&quot;</span>, m-&gt;mDNSStats.WakeOnResolves);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_info_dump_to_fd</span>(<span class="enscript-type">int</span> fd)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-type">const</span> mDNSs32 now = mDNS_TimeNow(m);
    mDNSu32 CacheUsed = 0, CacheActive = 0, slot;
    <span class="enscript-type">int</span> ProxyA = 0, ProxyD = 0;
    mDNSu32 groupCount = 0;
    mDNSu32 mcastRecordCount = 0;
    mDNSu32 ucastRecordCount = 0;
    <span class="enscript-type">const</span> CacheGroup *cg;
    <span class="enscript-type">const</span> CacheRecord *cr;
    <span class="enscript-type">const</span> DNSQuestion *q;
    <span class="enscript-type">const</span> DNameListElem *d;
    <span class="enscript-type">const</span> SearchListElem *s;

    LogToFD(fd, <span class="enscript-string">&quot;------------ Cache -------------&quot;</span>);
    LogToFD(fd, <span class="enscript-string">&quot;Slt Q     TTL if     U Type rdlen&quot;</span>);
    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; CACHE_HASH_SLOTS; slot++)
    {
        <span class="enscript-keyword">for</span> (cg = m-&gt;rrcache_hash[slot]; cg; cg=cg-&gt;next)
        {
            groupCount++;   <span class="enscript-comment">// Count one cache entity for the CacheGroup object
</span>            <span class="enscript-keyword">for</span> (cr = cg-&gt;members; cr; cr=cr-&gt;next)
            {
                <span class="enscript-type">const</span> mDNSs32 remain = cr-&gt;resrec.rroriginalttl - (now - cr-&gt;TimeRcvd) / mDNSPlatformOneSecond;
                <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname;
                mDNSInterfaceID InterfaceID = cr-&gt;resrec.InterfaceID;
                mDNSu32 *<span class="enscript-type">const</span> countPtr = InterfaceID ? &amp;mcastRecordCount : &amp;ucastRecordCount;
                <span class="enscript-keyword">if</span> (!InterfaceID &amp;&amp; cr-&gt;resrec.rDNSServer &amp;&amp; cr-&gt;resrec.rDNSServer-&gt;scopeType)
                    InterfaceID = cr-&gt;resrec.rDNSServer-&gt;interface;
                ifname = InterfaceNameForID(m, InterfaceID);
                <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion) CacheActive++;
                PrintOneCacheRecordToFD(fd, cr, slot, remain, ifname, countPtr);
                PrintCachedRecordsToFD(fd, cr, slot, remain, ifname, countPtr);
            }
        }
    }

    CacheUsed = groupCount + mcastRecordCount + ucastRecordCount;
    <span class="enscript-keyword">if</span> (m-&gt;rrcache_totalused != CacheUsed)
        LogToFD(fd, <span class="enscript-string">&quot;Cache use mismatch: rrcache_totalused is %lu, true count %lu&quot;</span>, m-&gt;rrcache_totalused, CacheUsed);
    <span class="enscript-keyword">if</span> (m-&gt;rrcache_active != CacheActive)
        LogToFD(fd, <span class="enscript-string">&quot;Cache use mismatch: rrcache_active is %lu, true count %lu&quot;</span>, m-&gt;rrcache_active, CacheActive);
    LogToFD(fd, <span class="enscript-string">&quot;Cache size %u entities; %u in use (%u group, %u multicast, %u unicast); %u referenced by active questions&quot;</span>,
              m-&gt;rrcache_size, CacheUsed, groupCount, mcastRecordCount, ucastRecordCount, CacheActive);

    LogToFD(fd, <span class="enscript-string">&quot;--------- Auth Records ---------&quot;</span>);
    LogAuthRecordsToFD(fd, now, m-&gt;ResourceRecords, mDNSNULL);

    LogToFD(fd, <span class="enscript-string">&quot;--------- LocalOnly, P2P Auth Records ---------&quot;</span>);
    LogLocalOnlyAuthRecordsToFD(fd, m);

    LogToFD(fd, <span class="enscript-string">&quot;--------- /etc/hosts ---------&quot;</span>);
    LogEtcHostsToFD(fd, m);

    LogToFD(fd, <span class="enscript-string">&quot;------ Duplicate Records -------&quot;</span>);
    LogAuthRecordsToFD(fd, now, m-&gt;DuplicateRecords, mDNSNULL);

    LogToFD(fd, <span class="enscript-string">&quot;----- Auth Records Proxied -----&quot;</span>);
    LogAuthRecordsToFD(fd, now, m-&gt;ResourceRecords, &amp;ProxyA);

    LogToFD(fd, <span class="enscript-string">&quot;-- Duplicate Records Proxied ---&quot;</span>);
    LogAuthRecordsToFD(fd, now, m-&gt;DuplicateRecords, &amp;ProxyD);

    LogToFD(fd, <span class="enscript-string">&quot;---------- Questions -----------&quot;</span>);
    <span class="enscript-keyword">if</span> (!m-&gt;Questions) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        CacheUsed = 0;
        CacheActive = 0;
        LogToFD(fd, <span class="enscript-string">&quot;   Int  Next if     T NumAns VDNS                               Qptr               DupOf              SU SQ Type Name&quot;</span>);
        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
        {
            mDNSs32 i = q-&gt;ThisQInterval / mDNSPlatformOneSecond;
            mDNSs32 n = (NextQSendTime(q) - now) / mDNSPlatformOneSecond;
            <span class="enscript-type">char</span> *ifname = InterfaceNameForID(m, q-&gt;InterfaceID);
            CacheUsed++;
            <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval) CacheActive++;
            LogToFD(fd, <span class="enscript-string">&quot;%6d%6d %-7s%s%s %5d 0x%08x%08x%08x%08x 0x%p 0x%p %1d %2d  %-5s%##s%s&quot;</span>,
                      i, n,
                      ifname ? ifname : mDNSOpaque16IsZero(q-&gt;TargetQID) ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;-U-&quot;</span>,
                      mDNSOpaque16IsZero(q-&gt;TargetQID) ? (q-&gt;LongLived ? <span class="enscript-string">&quot;l&quot;</span> : <span class="enscript-string">&quot; &quot;</span>) : (q-&gt;LongLived ? <span class="enscript-string">&quot;L&quot;</span> : <span class="enscript-string">&quot;O&quot;</span>),
                      q-&gt;ValidationRequired ? <span class="enscript-string">&quot;V&quot;</span> : q-&gt;ValidatingResponse ? <span class="enscript-string">&quot;R&quot;</span> : <span class="enscript-string">&quot; &quot;</span>,
                      q-&gt;CurrentAnswers,
                      q-&gt;validDNSServers.l[3], q-&gt;validDNSServers.l[2], q-&gt;validDNSServers.l[1], q-&gt;validDNSServers.l[0],
                      q, q-&gt;DuplicateOf,
                      q-&gt;SuppressUnusable, q-&gt;Suppressed, DNSTypeName(q-&gt;qtype), q-&gt;qname.c,
                      q-&gt;DuplicateOf ? <span class="enscript-string">&quot; (dup)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
        }
        LogToFD(fd, <span class="enscript-string">&quot;%lu question%s; %lu active&quot;</span>, CacheUsed, CacheUsed &gt; 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, CacheActive);
    }

    LogToFD(fd, <span class="enscript-string">&quot;----- LocalOnly, P2P Questions -----&quot;</span>);
    <span class="enscript-keyword">if</span> (!m-&gt;LocalOnlyQuestions) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (q = m-&gt;LocalOnlyQuestions; q; q=q-&gt;next)
        LogToFD(fd, <span class="enscript-string">&quot;                 %3s   %5d  %-6s%##s%s&quot;</span>,
                  q-&gt;InterfaceID == mDNSInterface_LocalOnly ? <span class="enscript-string">&quot;LO &quot;</span>: q-&gt;InterfaceID == mDNSInterface_BLE ? <span class="enscript-string">&quot;BLE&quot;</span>: <span class="enscript-string">&quot;P2P&quot;</span>,
                  q-&gt;CurrentAnswers, DNSTypeName(q-&gt;qtype), q-&gt;qname.c, q-&gt;DuplicateOf ? <span class="enscript-string">&quot; (dup)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;---- Active UDS Client Requests ----&quot;</span>);
    <span class="enscript-keyword">if</span> (!all_requests) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        request_state *req, *r;
        <span class="enscript-keyword">for</span> (req = all_requests; req; req=req-&gt;next)
        {
            <span class="enscript-keyword">if</span> (req-&gt;primary)   <span class="enscript-comment">// If this is a subbordinate operation, check that the parent is in the list
</span>            {
                <span class="enscript-keyword">for</span> (r = all_requests; r &amp;&amp; r != req; r=r-&gt;next) <span class="enscript-keyword">if</span> (r == req-&gt;primary) <span class="enscript-keyword">goto</span> <span class="enscript-reference">foundparent</span>;
                LogToFD(fd, <span class="enscript-string">&quot;%3d: Orhpan operation %p; parent %p not found in request list&quot;</span>, req-&gt;sd);
            }
            <span class="enscript-comment">// For non-subbordinate operations, and subbordinate operations that have lost their parent, write out their info
</span>            LogClientInfoToFD(fd, req);
        <span class="enscript-reference">foundparent</span>:;
        }
    }

    LogToFD(fd, <span class="enscript-string">&quot;-------- NAT Traversals --------&quot;</span>);
    LogToFD(fd, <span class="enscript-string">&quot;ExtAddress %.4a Retry %d Interval %d&quot;</span>,
              &amp;m-&gt;ExtAddress,
              m-&gt;retryGetAddr ? (m-&gt;retryGetAddr - now) / mDNSPlatformOneSecond : 0,
              m-&gt;retryIntervalGetAddr / mDNSPlatformOneSecond);
    <span class="enscript-keyword">if</span> (m-&gt;NATTraversals)
    {
        <span class="enscript-type">const</span> NATTraversalInfo *nat;
        <span class="enscript-keyword">for</span> (nat = m-&gt;NATTraversals; nat; nat=nat-&gt;next)
        {
            LogToFD(fd, <span class="enscript-string">&quot;%p %s Int %5d %s Err %d Retry %5d Interval %5d Expire %5d Req %.4a:%d Ext %.4a:%d&quot;</span>,
                      nat,
                      nat-&gt;Protocol ? (nat-&gt;Protocol == NATOp_MapTCP ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;UDP&quot;</span>) : <span class="enscript-string">&quot;ADD&quot;</span>,
                      mDNSVal16(nat-&gt;IntPort),
                      (nat-&gt;lastSuccessfulProtocol == NATTProtocolNone    ? <span class="enscript-string">&quot;None    &quot;</span> :
                       nat-&gt;lastSuccessfulProtocol == NATTProtocolNATPMP  ? <span class="enscript-string">&quot;NAT-PMP &quot;</span> :
                       nat-&gt;lastSuccessfulProtocol == NATTProtocolUPNPIGD ? <span class="enscript-string">&quot;UPnP/IGD&quot;</span> :
                       nat-&gt;lastSuccessfulProtocol == NATTProtocolPCP     ? <span class="enscript-string">&quot;PCP     &quot;</span> :
                       <span class="enscript-comment">/* else */</span>                                           <span class="enscript-string">&quot;Unknown &quot;</span> ),
                      nat-&gt;Result,
                      nat-&gt;retryPortMap ? (nat-&gt;retryPortMap - now) / mDNSPlatformOneSecond : 0,
                      nat-&gt;retryInterval / mDNSPlatformOneSecond,
                      nat-&gt;ExpiryTime ? (nat-&gt;ExpiryTime - now) / mDNSPlatformOneSecond : 0,
                      &amp;nat-&gt;NewAddress, mDNSVal16(nat-&gt;RequestedPort),
                      &amp;nat-&gt;ExternalAddress, mDNSVal16(nat-&gt;ExternalPort));
        }
    }

    LogToFD(fd, <span class="enscript-string">&quot;--------- AuthInfoList ---------&quot;</span>);
    <span class="enscript-keyword">if</span> (!m-&gt;AuthInfoList) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">const</span> DomainAuthInfo *a;
        <span class="enscript-keyword">for</span> (a = m-&gt;AuthInfoList; a; a = a-&gt;next)
        {
            LogToFD(fd, <span class="enscript-string">&quot;%##s %##s %##s %d %d&quot;</span>,
                      a-&gt;domain.c, a-&gt;keyname.c,
                      a-&gt;hostname.c, (a-&gt;port.b[0] &lt;&lt; 8 | a-&gt;port.b[1]),
                      (a-&gt;deltime ? (a-&gt;deltime - now) : 0));
        }
    }

    LogToFD(fd, <span class="enscript-string">&quot;---------- Misc State ----------&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;PrimaryMAC:   %.6a&quot;</span>, &amp;m-&gt;PrimaryMAC);

    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;SleepState %d (%s) seq %d&quot;</span>,
              m-&gt;SleepState,
              m-&gt;SleepState == SleepState_Awake        ? <span class="enscript-string">&quot;Awake&quot;</span>        :
              m-&gt;SleepState == SleepState_Transferring ? <span class="enscript-string">&quot;Transferring&quot;</span> :
              m-&gt;SleepState == SleepState_Sleeping     ? <span class="enscript-string">&quot;Sleeping&quot;</span>     : <span class="enscript-string">&quot;?&quot;</span>,
              m-&gt;SleepSeqNum);

    <span class="enscript-keyword">if</span> (!m-&gt;SPSSocket) LogToFD(fd, <span class="enscript-string">&quot;Not offering Sleep Proxy Service&quot;</span>);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
    <span class="enscript-keyword">else</span> LogToFD(fd, <span class="enscript-string">&quot;Offering Sleep Proxy Service: %#s&quot;</span>, m-&gt;SPSRecords.RR_SRV.resrec.name-&gt;c);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (m-&gt;ProxyRecords == ProxyA + ProxyD) LogToFD(fd, <span class="enscript-string">&quot;ProxyRecords: %d + %d = %d&quot;</span>, ProxyA, ProxyD, ProxyA + ProxyD);
    <span class="enscript-keyword">else</span> LogToFD(fd, <span class="enscript-string">&quot;ProxyRecords: MISMATCH %d + %d = %d ≠ %d&quot;</span>, ProxyA, ProxyD, ProxyA + ProxyD, m-&gt;ProxyRecords);

    LogToFD(fd, <span class="enscript-string">&quot;------ Auto Browse Domains -----&quot;</span>);
    <span class="enscript-keyword">if</span> (!AutoBrowseDomains) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (d=AutoBrowseDomains; d; d=d-&gt;next) LogToFD(fd, <span class="enscript-string">&quot;%##s&quot;</span>, d-&gt;name.c);

    LogToFD(fd, <span class="enscript-string">&quot;--- Auto Registration Domains --&quot;</span>);
    <span class="enscript-keyword">if</span> (!AutoRegistrationDomains) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (d=AutoRegistrationDomains; d; d=d-&gt;next) LogToFD(fd, <span class="enscript-string">&quot;%##s&quot;</span>, d-&gt;name.c);

    LogToFD(fd, <span class="enscript-string">&quot;--- Search Domains --&quot;</span>);
    <span class="enscript-keyword">if</span> (!SearchList) LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">for</span> (s=SearchList; s; s=s-&gt;next)
        {
            <span class="enscript-type">char</span> *ifname = InterfaceNameForID(m, s-&gt;InterfaceID);
            LogToFD(fd, <span class="enscript-string">&quot;%##s %s&quot;</span>, s-&gt;domain.c, ifname ? ifname : <span class="enscript-string">&quot;&quot;</span>);
        }
    }
    LogToFD(fd, <span class="enscript-string">&quot;--- Trust Anchors ---&quot;</span>);
    <span class="enscript-keyword">if</span> (!m-&gt;TrustAnchors)
    {
        LogToFD(fd, <span class="enscript-string">&quot;&lt;None&gt;&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
    {
        TrustAnchor *ta;
        mDNSu8 fromTimeBuf[64];
        mDNSu8 untilTimeBuf[64];

        <span class="enscript-keyword">for</span> (ta=m-&gt;TrustAnchors; ta; ta=ta-&gt;next)
        {
            mDNSPlatformFormatTime((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)ta-&gt;validFrom, fromTimeBuf, <span class="enscript-keyword">sizeof</span>(fromTimeBuf));
            mDNSPlatformFormatTime((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)ta-&gt;validUntil, untilTimeBuf, <span class="enscript-keyword">sizeof</span>(untilTimeBuf));
            LogToFD(fd, <span class="enscript-string">&quot;%##s %d %d %d %d %s %s&quot;</span>, ta-&gt;zone.c, ta-&gt;rds.keyTag,
                      ta-&gt;rds.alg, ta-&gt;rds.digestType, ta-&gt;digestLen, fromTimeBuf, untilTimeBuf);
        }
    }

    LogToFD(fd, <span class="enscript-string">&quot;--- DNSSEC Statistics ---&quot;</span>);

    LogToFD(fd, <span class="enscript-string">&quot;Unicast Cache size              %u&quot;</span>, m-&gt;rrcache_totalused_unicast);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Cache size              %u&quot;</span>, m-&gt;DNSSECStats.TotalMemUsed);
    <span class="enscript-keyword">if</span> (m-&gt;rrcache_totalused_unicast)
        LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  usage percentage        %u&quot;</span>, ((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(m-&gt;DNSSECStats.TotalMemUsed * 100))/m-&gt;rrcache_totalused_unicast);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Extra Packets (0 to 2)  %u&quot;</span>, m-&gt;DNSSECStats.ExtraPackets0);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Extra Packets (3 to 6)  %u&quot;</span>, m-&gt;DNSSECStats.ExtraPackets3);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Extra Packets (7 to 9)  %u&quot;</span>, m-&gt;DNSSECStats.ExtraPackets7);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Extra Packets ( &gt;= 10)  %u&quot;</span>, m-&gt;DNSSECStats.ExtraPackets10);

    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (0 to 4ms)      %u&quot;</span>, m-&gt;DNSSECStats.Latency0);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (4 to 9ms)      %u&quot;</span>, m-&gt;DNSSECStats.Latency5);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (10 to 19ms)    %u&quot;</span>, m-&gt;DNSSECStats.Latency10);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (20 to 49ms)    %u&quot;</span>, m-&gt;DNSSECStats.Latency20);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (50 to 99ms)    %u&quot;</span>, m-&gt;DNSSECStats.Latency50);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Latency (   &gt;=100ms)    %u&quot;</span>, m-&gt;DNSSECStats.Latency100);

    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Secure Status           %u&quot;</span>, m-&gt;DNSSECStats.SecureStatus);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Insecure Status         %u&quot;</span>, m-&gt;DNSSECStats.InsecureStatus);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Indeterminate Status    %u&quot;</span>, m-&gt;DNSSECStats.IndeterminateStatus);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Bogus Status            %u&quot;</span>, m-&gt;DNSSECStats.BogusStatus);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  NoResponse Status       %u&quot;</span>, m-&gt;DNSSECStats.NoResponseStatus);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Probes sent             %u&quot;</span>, m-&gt;DNSSECStats.NumProbesSent);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Msg Size (&lt;=1024)       %u&quot;</span>, m-&gt;DNSSECStats.MsgSize0);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Msg Size (&lt;=2048)       %u&quot;</span>, m-&gt;DNSSECStats.MsgSize1);
    LogToFD(fd, <span class="enscript-string">&quot;DNSSEC  Msg Size (&gt; 2048)       %u&quot;</span>, m-&gt;DNSSECStats.MsgSize2);

    LogMDNSStatisticsToFD(fd, m);

    LogToFD(fd, <span class="enscript-string">&quot;---- Task Scheduling Timers ----&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    LogToFD(fd, <span class="enscript-string">&quot;BonjourEnabled %d&quot;</span>, m-&gt;BonjourEnabled);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    LogToFD(fd, <span class="enscript-string">&quot;EnableBLEBasedDiscovery %d&quot;</span>, EnableBLEBasedDiscovery);
    LogToFD(fd, <span class="enscript-string">&quot;DefaultToBLETriggered %d&quot;</span>, DefaultToBLETriggered);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>

    <span class="enscript-keyword">if</span> (!m-&gt;NewQuestions)
        LogToFD(fd, <span class="enscript-string">&quot;NewQuestion &lt;NONE&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
        LogToFD(fd, <span class="enscript-string">&quot;NewQuestion DelayAnswering %d %d %##s (%s)&quot;</span>,
                  m-&gt;NewQuestions-&gt;DelayAnswering, m-&gt;NewQuestions-&gt;DelayAnswering-now,
                  m-&gt;NewQuestions-&gt;qname.c, DNSTypeName(m-&gt;NewQuestions-&gt;qtype));

    <span class="enscript-keyword">if</span> (!m-&gt;NewLocalOnlyQuestions)
        LogToFD(fd, <span class="enscript-string">&quot;NewLocalOnlyQuestions &lt;NONE&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
        LogToFD(fd, <span class="enscript-string">&quot;NewLocalOnlyQuestions %##s (%s)&quot;</span>,
                  m-&gt;NewLocalOnlyQuestions-&gt;qname.c, DNSTypeName(m-&gt;NewLocalOnlyQuestions-&gt;qtype));

    <span class="enscript-keyword">if</span> (!m-&gt;NewLocalRecords)
        LogToFD(fd, <span class="enscript-string">&quot;NewLocalRecords &lt;NONE&gt;&quot;</span>);
    <span class="enscript-keyword">else</span>
        LogToFD(fd, <span class="enscript-string">&quot;NewLocalRecords %02X %s&quot;</span>, m-&gt;NewLocalRecords-&gt;resrec.RecordType, ARDisplayString(m, m-&gt;NewLocalRecords));

    LogToFD(fd, <span class="enscript-string">&quot;SPSProxyListChanged%s&quot;</span>, m-&gt;SPSProxyListChanged ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot; &lt;NONE&gt;&quot;</span>);
    LogToFD(fd, <span class="enscript-string">&quot;LocalRemoveEvents%s&quot;</span>,   m-&gt;LocalRemoveEvents   ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot; &lt;NONE&gt;&quot;</span>);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;WABBrowseQueriesCount %d&quot;</span>, m-&gt;WABBrowseQueriesCount);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;WABLBrowseQueriesCount %d&quot;</span>, m-&gt;WABLBrowseQueriesCount);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;WABRegQueriesCount %d&quot;</span>, m-&gt;WABRegQueriesCount);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;AutoTargetServices %u&quot;</span>, m-&gt;AutoTargetServices);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;AutoTargetAWDLIncludedCount %u&quot;</span>, m-&gt;AutoTargetAWDLIncludedCount);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;AutoTargetAWDLOnlyCount     %u&quot;</span>, m-&gt;AutoTargetAWDLOnlyCount);
#<span class="enscript-reference">endif</span>

    LogToFD(fd, <span class="enscript-string">&quot;                         ABS (hex)  ABS (dec)  REL (hex)  REL (dec)&quot;</span>);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;timenow               %08X %11d&quot;</span>, now, now);
    LogToFD(fd, <span class="enscript-string">&quot;m-&gt;timenow_adjust        %08X %11d&quot;</span>, m-&gt;timenow_adjust, m-&gt;timenow_adjust);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledEvent   &quot;</span>, m-&gt;NextScheduledEvent);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextuDNSEvent        &quot;</span>, m-&gt;NextuDNSEvent);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextSRVUpdate        &quot;</span>, m-&gt;NextSRVUpdate);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledNATOp   &quot;</span>, m-&gt;NextScheduledNATOp);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;retryGetAddr         &quot;</span>, m-&gt;retryGetAddr);
#<span class="enscript-reference">endif</span>

    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextCacheCheck       &quot;</span>, m-&gt;NextCacheCheck);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledSPS     &quot;</span>, m-&gt;NextScheduledSPS);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledKA      &quot;</span>, m-&gt;NextScheduledKA);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextBonjourDisableTime &quot;</span>, m-&gt;NextBonjourDisableTime);
#<span class="enscript-reference">endif</span>

    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledSPRetry &quot;</span>, m-&gt;NextScheduledSPRetry);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;DelaySleep           &quot;</span>, m-&gt;DelaySleep);

    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledQuery   &quot;</span>, m-&gt;NextScheduledQuery);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledProbe   &quot;</span>, m-&gt;NextScheduledProbe);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledResponse&quot;</span>, m-&gt;NextScheduledResponse);

    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;SuppressSending      &quot;</span>, m-&gt;SuppressSending);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;SuppressProbes       &quot;</span>, m-&gt;SuppressProbes);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;ProbeFailTime        &quot;</span>, m-&gt;ProbeFailTime);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;DelaySleep           &quot;</span>, m-&gt;DelaySleep);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;SleepLimit           &quot;</span>, m-&gt;SleepLimit);
    LogTimerToFD(fd, <span class="enscript-string">&quot;m-&gt;NextScheduledStopTime &quot;</span>, m-&gt;NextScheduledStopTime);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_validatelists</span>(<span class="enscript-type">void</span> *context)
{
    <span class="enscript-type">const</span> request_state *req, *p;
	(<span class="enscript-type">void</span>)context; <span class="enscript-comment">// unused
</span>    <span class="enscript-keyword">for</span> (req = all_requests; req; req=req-&gt;next)
    {
        <span class="enscript-keyword">if</span> (req-&gt;next == (request_state *)~0 || (req-&gt;sd &lt; 0 &amp;&amp; req-&gt;sd != -2))
            LogMemCorruption(<span class="enscript-string">&quot;UDS request list: %p is garbage (%d)&quot;</span>, req, req-&gt;sd);

        <span class="enscript-keyword">if</span> (req-&gt;primary == req)
            LogMemCorruption(<span class="enscript-string">&quot;UDS request list: req-&gt;primary should not point to self %p/%d&quot;</span>, req, req-&gt;sd);

        <span class="enscript-keyword">if</span> (req-&gt;primary &amp;&amp; req-&gt;replies)
            LogMemCorruption(<span class="enscript-string">&quot;UDS request list: Subordinate request %p/%d/%p should not have replies (%p)&quot;</span>,
                             req, req-&gt;sd, req-&gt;primary &amp;&amp; req-&gt;replies);

        p = req-&gt;primary;
        <span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span>)p &amp; 3)
            LogMemCorruption(<span class="enscript-string">&quot;UDS request list: req %p primary %p is misaligned (%d)&quot;</span>, req, p, req-&gt;sd);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p &amp;&amp; (p-&gt;next == (request_state *)~0 || (p-&gt;sd &lt; 0 &amp;&amp; p-&gt;sd != -2)))
            LogMemCorruption(<span class="enscript-string">&quot;UDS request list: req %p primary %p is garbage (%d)&quot;</span>, req, p, p-&gt;sd);

        reply_state *rep;
        <span class="enscript-keyword">for</span> (rep = req-&gt;replies; rep; rep=rep-&gt;next)
            <span class="enscript-keyword">if</span> (rep-&gt;next == (reply_state *)~0)
                LogMemCorruption(<span class="enscript-string">&quot;UDS req-&gt;replies: %p is garbage&quot;</span>, rep);

        <span class="enscript-keyword">if</span> (req-&gt;terminate == connection_termination)
        {
            registered_record_entry *r;
            <span class="enscript-keyword">for</span> (r = req-&gt;u.reg_recs; r; r=r-&gt;next)
                <span class="enscript-keyword">if</span> (r-&gt;next == (registered_record_entry *)~0)
                    LogMemCorruption(<span class="enscript-string">&quot;UDS req-&gt;u.reg_recs: %p is garbage&quot;</span>, r);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == regservice_termination_callback)
        {
            service_instance *s;
            <span class="enscript-keyword">for</span> (s = req-&gt;u.servicereg.instances; s; s=s-&gt;next)
                <span class="enscript-keyword">if</span> (s-&gt;next == (service_instance *)~0)
                    LogMemCorruption(<span class="enscript-string">&quot;UDS req-&gt;u.servicereg.instances: %p is garbage&quot;</span>, s);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;terminate == browse_termination_callback)
        {
            browser_t *b;
            <span class="enscript-keyword">for</span> (b = req-&gt;u.browser.browsers; b; b=b-&gt;next)
                <span class="enscript-keyword">if</span> (b-&gt;next == (browser_t *)~0)
                    LogMemCorruption(<span class="enscript-string">&quot;UDS req-&gt;u.browser.browsers: %p is garbage&quot;</span>, b);
        }
    }

    DNameListElem *d;
    <span class="enscript-keyword">for</span> (d = SCPrefBrowseDomains; d; d=d-&gt;next)
        <span class="enscript-keyword">if</span> (d-&gt;next == (DNameListElem *)~0 || d-&gt;name.c[0] &gt; 63)
            LogMemCorruption(<span class="enscript-string">&quot;SCPrefBrowseDomains: %p is garbage (%d)&quot;</span>, d, d-&gt;name.c[0]);

    ARListElem *b;
    <span class="enscript-keyword">for</span> (b = LocalDomainEnumRecords; b; b=b-&gt;next)
        <span class="enscript-keyword">if</span> (b-&gt;next == (ARListElem *)~0 || b-&gt;ar.resrec.name-&gt;c[0] &gt; 63)
            LogMemCorruption(<span class="enscript-string">&quot;LocalDomainEnumRecords: %p is garbage (%d)&quot;</span>, b, b-&gt;ar.resrec.name-&gt;c[0]);

    <span class="enscript-keyword">for</span> (d = AutoBrowseDomains; d; d=d-&gt;next)
        <span class="enscript-keyword">if</span> (d-&gt;next == (DNameListElem *)~0 || d-&gt;name.c[0] &gt; 63)
            LogMemCorruption(<span class="enscript-string">&quot;AutoBrowseDomains: %p is garbage (%d)&quot;</span>, d, d-&gt;name.c[0]);

    <span class="enscript-keyword">for</span> (d = AutoRegistrationDomains; d; d=d-&gt;next)
        <span class="enscript-keyword">if</span> (d-&gt;next == (DNameListElem *)~0 || d-&gt;name.c[0] &gt; 63)
            LogMemCorruption(<span class="enscript-string">&quot;AutoRegistrationDomains: %p is garbage (%d)&quot;</span>, d, d-&gt;name.c[0]);
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">send_msg</span>(request_state *<span class="enscript-type">const</span> req)
{
    reply_state *<span class="enscript-type">const</span> rep = req-&gt;replies;      <span class="enscript-comment">// Send the first waiting reply
</span>    ssize_t nwriten;

    ConvertHeaderBytes(rep-&gt;mhdr);
    nwriten = send(req-&gt;sd, (<span class="enscript-type">char</span> *)&amp;rep-&gt;mhdr + rep-&gt;nwriten, rep-&gt;totallen - rep-&gt;nwriten, 0);
    ConvertHeaderBytes(rep-&gt;mhdr);

    <span class="enscript-keyword">if</span> (nwriten &lt; 0)
    {
        <span class="enscript-keyword">if</span> (dnssd_errno == dnssd_EINTR || dnssd_errno == dnssd_EWOULDBLOCK) nwriten = 0;
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PLATFORM_NO_EPIPE</span>)
            <span class="enscript-keyword">if</span> (dnssd_errno == EPIPE)
                <span class="enscript-keyword">return</span>(req-&gt;ts = t_terminated);
            <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
            {
                LogMsg(<span class="enscript-string">&quot;send_msg ERROR: failed to write %d of %d bytes to fd %d errno %d (%s)&quot;</span>,
                       rep-&gt;totallen - rep-&gt;nwriten, rep-&gt;totallen, req-&gt;sd, dnssd_errno, dnssd_strerror(dnssd_errno));
                <span class="enscript-keyword">return</span>(t_error);
            }
        }
    }
    rep-&gt;nwriten += nwriten;
    <span class="enscript-keyword">return</span> (rep-&gt;nwriten == rep-&gt;totallen) ? t_complete : t_morecoming;
}

mDNSexport mDNSs32 <span class="enscript-function-name">udsserver_idle</span>(mDNSs32 nextevent)
{
    mDNSs32 now = mDNS_TimeNow(&amp;mDNSStorage);
    request_state **req = &amp;all_requests;

    <span class="enscript-keyword">while</span> (*req)
    {
        request_state *<span class="enscript-type">const</span> r = *req;

        <span class="enscript-keyword">if</span> (r-&gt;terminate == resolve_termination_callback)
            <span class="enscript-keyword">if</span> (r-&gt;u.resolve.ReportTime &amp;&amp; now - r-&gt;u.resolve.ReportTime &gt;= 0)
            {
                r-&gt;u.resolve.ReportTime = 0;
                <span class="enscript-comment">// if client received results and resolve still active
</span>                <span class="enscript-keyword">if</span> (r-&gt;u.resolve.txt &amp;&amp; r-&gt;u.resolve.srv)
                    LogMsgNoIdent(<span class="enscript-string">&quot;Client application PID[%d](%s) has received results for DNSServiceResolve(%##s) yet remains active over two minutes.&quot;</span>, r-&gt;process_id, r-&gt;pid_name, r-&gt;u.resolve.qsrv.qname.c);
            }

        <span class="enscript-comment">// Note: Only primary req's have reply lists, not subordinate req's.
</span>        <span class="enscript-keyword">while</span> (r-&gt;replies)      <span class="enscript-comment">// Send queued replies
</span>        {
            transfer_state result;
            <span class="enscript-keyword">if</span> (r-&gt;replies-&gt;next)
                r-&gt;replies-&gt;rhdr-&gt;flags |= dnssd_htonl(kDNSServiceFlagsMoreComing);
            result = send_msg(r);   <span class="enscript-comment">// Returns t_morecoming if buffer full because client is not reading
</span>            <span class="enscript-keyword">if</span> (result == t_complete)
            {
                reply_state *fptr = r-&gt;replies;
                r-&gt;replies = r-&gt;replies-&gt;next;
                freeL(<span class="enscript-string">&quot;reply_state/udsserver_idle&quot;</span>, fptr);
                r-&gt;time_blocked = 0; <span class="enscript-comment">// reset failure counter after successful send
</span>                r-&gt;unresponsiveness_reports = 0;
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == t_terminated)
            {
                LogInfo(<span class="enscript-string">&quot;%3d: Could not write data to client PID[%d](%s) because connection is terminated by the client&quot;</span>, r-&gt;sd, r-&gt;process_id, r-&gt;pid_name);
                abort_request(r);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == t_error)
            {
                LogMsg(<span class="enscript-string">&quot;%3d: Could not write data to client PID[%d](%s) because of error - aborting connection&quot;</span>, r-&gt;sd, r-&gt;process_id, r-&gt;pid_name);
                LogClientInfo(r);
                abort_request(r);
            }
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (r-&gt;replies)     <span class="enscript-comment">// If we failed to send everything, check our time_blocked timer
</span>        {
            <span class="enscript-keyword">if</span> (nextevent - now &gt; mDNSPlatformOneSecond)
                nextevent = now + mDNSPlatformOneSecond;

            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%u] Could not send all replies. Will try again in %d ticks.&quot;</span>, r-&gt;request_id, nextevent - now);
            <span class="enscript-keyword">if</span> (mDNSStorage.SleepState != SleepState_Awake)
                r-&gt;time_blocked = 0;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!r-&gt;time_blocked)
                r-&gt;time_blocked = NonZeroTime(now);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (now - r-&gt;time_blocked &gt;= 10 * mDNSPlatformOneSecond * (r-&gt;unresponsiveness_reports+1))
            {
                <span class="enscript-type">int</span> num = 0;
                <span class="enscript-type">struct</span> reply_state *x = r-&gt;replies;
                <span class="enscript-keyword">while</span> (x)
                {
                    num++;
                    x=x-&gt;next;
                }
                LogMsg(<span class="enscript-string">&quot;%3d: Could not write data to client PID[%d](%s) after %ld seconds, %d repl%s waiting&quot;</span>,
                       r-&gt;sd, r-&gt;process_id, r-&gt;pid_name, (now - r-&gt;time_blocked) / mDNSPlatformOneSecond, num, num == 1 ? <span class="enscript-string">&quot;y&quot;</span> : <span class="enscript-string">&quot;ies&quot;</span>);
                <span class="enscript-keyword">if</span> (++r-&gt;unresponsiveness_reports &gt;= 60)
                {
                    LogMsg(<span class="enscript-string">&quot;%3d: Client PID[%d](%s) unresponsive; aborting connection&quot;</span>, r-&gt;sd, r-&gt;process_id, r-&gt;pid_name);
                    LogClientInfo(r);
                    abort_request(r);
                }
            }
        }

        <span class="enscript-keyword">if</span> (!dnssd_SocketValid(r-&gt;sd)) <span class="enscript-comment">// If this request is finished, unlink it from the list and free the memory
</span>        {
            <span class="enscript-comment">// Since we're already doing a list traversal, we unlink the request directly instead of using AbortUnlinkAndFree()
</span>            *req = r-&gt;next;
            freeL(<span class="enscript-string">&quot;request_state/udsserver_idle&quot;</span>, r);
        }
        <span class="enscript-keyword">else</span>
            req = &amp;r-&gt;next;
    }
    <span class="enscript-keyword">return</span> nextevent;
}

<span class="enscript-type">struct</span> CompileTimeAssertionChecks_uds_daemon
{
    <span class="enscript-comment">// Check our structures are reasonable sizes. Including overly-large buffers, or embedding
</span>    <span class="enscript-comment">// other overly-large structures instead of having a pointer to them, can inadvertently
</span>    <span class="enscript-comment">// cause structure sizes (and therefore memory usage) to balloon unreasonably.
</span>    <span class="enscript-type">char</span> sizecheck_request_state          [(<span class="enscript-keyword">sizeof</span>(request_state)           &lt;= 3696) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_registered_record_entry[(<span class="enscript-keyword">sizeof</span>(registered_record_entry) &lt;=   60) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_service_instance       [(<span class="enscript-keyword">sizeof</span>(service_instance)        &lt;= 6552) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_browser_t              [(<span class="enscript-keyword">sizeof</span>(browser_t)               &lt;= 1432) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_reply_hdr              [(<span class="enscript-keyword">sizeof</span>(reply_hdr)               &lt;=   12) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_reply_state            [(<span class="enscript-keyword">sizeof</span>(reply_state)             &lt;=   64) ? 1 : -1];
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../unittests/uds_daemon_ut.c&quot;</span>
#<span class="enscript-reference">endif</span>  //  <span class="enscript-variable-name">UNIT_TEST</span>
</pre>
<hr />
</body></html>