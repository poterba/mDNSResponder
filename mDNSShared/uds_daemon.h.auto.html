<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uds_daemon.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uds_daemon.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="uds_daemon.h">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2002-2018 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UDS_DAEMON_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UDS_DAEMON_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssd_ipc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ClientRequests.h&quot;</span>

<span class="enscript-comment">/* Client request: */</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Types</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">Data</span> <span class="enscript-variable-name">Structures</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
	t_uninitialized,
	t_morecoming,
	t_complete,
	t_error,
	t_terminated
} transfer_state;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> request_state request_state;

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*req_termination_fn)(request_state *request);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> registered_record_entry
{
	<span class="enscript-type">struct</span> registered_record_entry *next;
	mDNSu32 key;
	client_context_t regrec_client_context;
	request_state *request;
	mDNSBool external_advertise;
	mDNSInterfaceID origInterfaceID;
	AuthRecord *rr;             <span class="enscript-comment">// Pointer to variable-sized AuthRecord (Why a pointer? Why not just embed it here?)
</span>} registered_record_entry;

<span class="enscript-comment">// A single registered service: ServiceRecordSet + bookkeeping
</span><span class="enscript-comment">// Note that we duplicate some fields from parent service_info object
</span><span class="enscript-comment">// to facilitate cleanup, when instances and parent may be deallocated at different times.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> service_instance
{
	<span class="enscript-type">struct</span> service_instance *next;
	request_state *request;
	AuthRecord *subtypes;
	mDNSBool renameonmemfree;       <span class="enscript-comment">// Set on config change when we deregister original name
</span>	mDNSBool clientnotified;        <span class="enscript-comment">// Has client been notified of successful registration yet?
</span>	mDNSBool default_local;         <span class="enscript-comment">// is this the &quot;local.&quot; from an empty-string registration?
</span>	mDNSBool external_advertise;    <span class="enscript-comment">// is this is being advertised externally?
</span>	domainname domain;
	ServiceRecordSet srs;           <span class="enscript-comment">// note -- variable-sized object -- must be last field in struct
</span>} service_instance;

<span class="enscript-comment">// for multi-domain default browsing
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> browser_t
{
	<span class="enscript-type">struct</span> browser_t *next;
	domainname domain;
	DNSQuestion q;
} browser_t;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_WIN32</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pid_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> socklen_t;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> (!<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MAXCOMLEN</span>))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXCOMLEN</span> 16
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> request_state
{
	request_state *next;
	request_state *primary;         <span class="enscript-comment">// If this operation is on a shared socket, pointer to primary
</span>	<span class="enscript-comment">// request_state for the original DNSServiceCreateConnection() operation
</span>	dnssd_sock_t sd;
	pid_t process_id;               <span class="enscript-comment">// Client's PID value
</span>	<span class="enscript-type">char</span>  pid_name[MAXCOMLEN];      <span class="enscript-comment">// Client's process name
</span>	mDNSu8 uuid[UUID_SIZE];
	mDNSBool validUUID;
	dnssd_sock_t errsd;
	mDNSu32 uid;
    mDNSu32 request_id;
	<span class="enscript-type">void</span> * platform_data;

	<span class="enscript-comment">// Note: On a shared connection these fields in the primary structure, including hdr, are re-used
</span>	<span class="enscript-comment">// for each new request. This is because, until we've read the ipc_msg_hdr to find out what the
</span>	<span class="enscript-comment">// operation is, we don't know if we're going to need to allocate a new request_state or not.
</span>	transfer_state ts;
	mDNSu32 hdr_bytes;              <span class="enscript-comment">// bytes of header already read
</span>	ipc_msg_hdr hdr;
	mDNSu32 data_bytes;             <span class="enscript-comment">// bytes of message data already read
</span>	<span class="enscript-type">char</span>          *msgbuf;          <span class="enscript-comment">// pointer to data storage to pass to free()
</span>	<span class="enscript-type">const</span> <span class="enscript-type">char</span>    *msgptr;          <span class="enscript-comment">// pointer to data to be read from (may be modified)
</span>	<span class="enscript-type">char</span>          *msgend;          <span class="enscript-comment">// pointer to byte after last byte of message
</span>
	<span class="enscript-comment">// reply, termination, error, and client context info
</span>	<span class="enscript-type">int</span> no_reply;                   <span class="enscript-comment">// don't send asynchronous replies to client
</span>	mDNSs32 time_blocked;           <span class="enscript-comment">// record time of a blocked client
</span>	<span class="enscript-type">int</span> unresponsiveness_reports;
	<span class="enscript-type">struct</span> reply_state *replies;    <span class="enscript-comment">// corresponding (active) reply list
</span>	req_termination_fn terminate;
	DNSServiceFlags flags;
	mDNSu32 interfaceIndex;

	<span class="enscript-type">union</span>
	{
		registered_record_entry *reg_recs;  <span class="enscript-comment">// list of registrations for a connection-oriented request
</span>		<span class="enscript-type">struct</span>
		{
			mDNSInterfaceID interface_id;
			mDNSBool default_domain;
			mDNSBool ForceMCast;
			domainname regtype;
			browser_t *browsers;
		} browser;
		<span class="enscript-type">struct</span>
		{
			mDNSInterfaceID InterfaceID;
			mDNSu16 txtlen;
			<span class="enscript-type">void</span> *txtdata;
			mDNSIPPort port;
			domainlabel name;
			<span class="enscript-type">char</span> type_as_string[MAX_ESCAPED_DOMAIN_NAME];
			domainname type;
			mDNSBool default_domain;
			domainname host;
			mDNSBool autoname;              <span class="enscript-comment">// Set if this name is tied to the Computer Name
</span>			mDNSBool autorename;            <span class="enscript-comment">// Set if this client wants us to automatically rename on conflict
</span>			mDNSBool allowremotequery;      <span class="enscript-comment">// Respond to unicast queries from outside the local link?
</span>			<span class="enscript-type">int</span> num_subtypes;
			service_instance *instances;
		} servicereg;
		<span class="enscript-type">struct</span>
		{
			mDNSIPPort ReqExt;              <span class="enscript-comment">// External port we originally requested, for logging purposes
</span>			NATTraversalInfo NATinfo;
		} pm;
		<span class="enscript-type">struct</span>
		{
			DNSServiceFlags flags;
			DNSQuestion q_all;
			DNSQuestion q_default;
			DNSQuestion q_autoall;
		} enumeration;
		<span class="enscript-type">struct</span>
		{
			DNSQuestion qtxt;
			DNSQuestion qsrv;
			<span class="enscript-type">const</span> ResourceRecord *txt;
			<span class="enscript-type">const</span> ResourceRecord *srv;
			mDNSs32 ReportTime;
			mDNSBool external_advertise;
		} resolve;
        GetAddrInfoClientRequest addrinfo;
        QueryRecordClientRequest queryrecord;
	} u;
};

<span class="enscript-comment">// struct physically sits between ipc message header and call-specific fields in the message buffer
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
	DNSServiceFlags flags;          <span class="enscript-comment">// Note: This field is in NETWORK byte order
</span>	mDNSu32 ifi;                    <span class="enscript-comment">// Note: This field is in NETWORK byte order
</span>	DNSServiceErrorType error;      <span class="enscript-comment">// Note: This field is in NETWORK byte order
</span>} reply_hdr;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> reply_state
{
	<span class="enscript-type">struct</span> reply_state *next;       <span class="enscript-comment">// If there are multiple unsent replies
</span>	mDNSu32 totallen;
	mDNSu32 nwriten;
	ipc_msg_hdr mhdr[1];
	reply_hdr rhdr[1];
} reply_state;

<span class="enscript-comment">/* Client interface: */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SRS_PORT</span>(S) mDNSVal16((S)-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LogTimerToFD</span>(FILE_DESCRIPTOR, MSG, T) LogToFD((FILE_DESCRIPTOR), MSG <span class="enscript-string">&quot; %08X %11d  %08X %11d&quot;</span>, (T), (T), (T)-now, (T)-now)

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udsserver_init</span>(dnssd_sock_t skts[], mDNSu32 count);
<span class="enscript-type">extern</span> mDNSs32 <span class="enscript-function-name">udsserver_idle</span>(mDNSs32 nextevent);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_info_dump_to_fd</span>(<span class="enscript-type">int</span> fd);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udsserver_handle_configchange</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udsserver_exit</span>(<span class="enscript-type">void</span>);    <span class="enscript-comment">// should be called prior to app exit
</span><span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">LogMcastStateInfo</span>(mDNSBool mflag, mDNSBool start, mDNSBool mstatelog);
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LogMcastQ</span>       (mDNS_McastLoggingEnabled == 0) ? ((void)0) : LogMcastQuestion
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LogMcastS</span>       (mDNS_McastLoggingEnabled == 0) ? ((void)0) : LogMcastService
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LogMcast</span>        (mDNS_McastLoggingEnabled == 0) ? ((void)0) : LogMsg
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LogMcastNoIdent</span> (mDNS_McastLoggingEnabled == 0) ? ((void)0) : LogMsgNoIdent

<span class="enscript-comment">/* Routines that uds_daemon expects to link against: */</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*udsEventCallback)(<span class="enscript-type">int</span> fd, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">udsSupportAddFDToEventLoop</span>(dnssd_sock_t fd, udsEventCallback callback, <span class="enscript-type">void</span> *context, <span class="enscript-type">void</span> **platform_data);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>     <span class="enscript-function-name">udsSupportReadFD</span>(dnssd_sock_t fd, <span class="enscript-type">char</span>* buf, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> flags, <span class="enscript-type">void</span> *platform_data);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">udsSupportRemoveFDFromEventLoop</span>(dnssd_sock_t fd, <span class="enscript-type">void</span> *platform_data); <span class="enscript-comment">// Note: This also CLOSES the file descriptor as well
</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">RecordUpdatedNiceLabel</span>(mDNSs32 delay);

<span class="enscript-comment">// Globals and functions defined in uds_daemon.c and also shared with the old &quot;daemon.c&quot; on OS X
</span>
<span class="enscript-type">extern</span> mDNS mDNSStorage;
<span class="enscript-type">extern</span> DNameListElem *AutoRegistrationDomains;
<span class="enscript-type">extern</span> DNameListElem *AutoBrowseDomains;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">CountExistingRegistrations</span>(domainname *srv, mDNSIPPort port);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">FreeExtraRR</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">CountPeerRegistrations</span>(ServiceRecordSet *<span class="enscript-type">const</span> srs);

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> mDNSResponderVersionString_SCCS[];
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSResponderVersionString</span> (mDNSResponderVersionString_SCCS+5)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">SetDebugBoundPath</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">IsDebugSocketInUse</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UDS_DAEMON_H */</span>
</pre>
<hr />
</body></html>