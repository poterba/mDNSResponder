<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dnssd_clientlib.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dnssd_clientlib.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="dnssd_clientlib.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2004-2018 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1.  Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
<span class="enscript-comment">// disable warning &quot;conversion from &lt;data&gt; to uint16_t&quot;
</span>#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">warning</span>(<span class="enscript-variable-name">disable</span>:4244)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">strncasecmp</span> _strnicmp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">strcasecmp</span> _stricmp
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*********************************************************************************************
*
*  Supporting Functions
*
*********************************************************************************************/</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIsDigit</span>(X)     ((X) &gt;= <span class="enscript-string">'0'</span> &amp;&amp; (X) &lt;= <span class="enscript-string">'9'</span>)

<span class="enscript-comment">// DomainEndsInDot returns 1 if name ends with a dot, 0 otherwise
</span><span class="enscript-comment">// (DNSServiceConstructFullName depends this returning 1 for true, rather than any non-zero value meaning true)
</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">DomainEndsInDot</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dom)
{
    <span class="enscript-keyword">while</span> (dom[0] &amp;&amp; dom[1])
    {
        <span class="enscript-keyword">if</span> (dom[0] == <span class="enscript-string">'\\'</span>) <span class="enscript-comment">// advance past escaped byte sequence
</span>        {
            <span class="enscript-keyword">if</span> (mDNSIsDigit(dom[1]) &amp;&amp; mDNSIsDigit(dom[2]) &amp;&amp; mDNSIsDigit(dom[3]))
                dom += 4;           <span class="enscript-comment">// If &quot;\ddd&quot;    then skip four
</span>            <span class="enscript-keyword">else</span> dom += 2;          <span class="enscript-comment">// else if &quot;\x&quot; then skip two
</span>        }
        <span class="enscript-keyword">else</span> dom++;                 <span class="enscript-comment">// else goto next character
</span>    }
    <span class="enscript-keyword">return</span> (dom[0] == <span class="enscript-string">'.'</span>);
}

<span class="enscript-type">static</span> uint8_t *InternalTXTRecordSearch
(
    uint16_t txtLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *txtRecord,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       *key,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>    *keylen
)
{
    uint8_t *p = (uint8_t*)txtRecord;
    uint8_t *e = p + txtLen;
    *keylen = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) strlen(key);
    <span class="enscript-keyword">while</span> (p&lt;e)
    {
        uint8_t *x = p;
        p += 1 + p[0];
        <span class="enscript-keyword">if</span> (p &lt;= e &amp;&amp; *keylen &lt;= x[0] &amp;&amp; !strncasecmp(key, (<span class="enscript-type">char</span>*)x+1, *keylen))
            <span class="enscript-keyword">if</span> (*keylen == x[0] || x[1+*keylen] == <span class="enscript-string">'='</span>) <span class="enscript-keyword">return</span>(x);
    }
    <span class="enscript-keyword">return</span>(NULL);
}

<span class="enscript-comment">/*********************************************************************************************
*
*  General Utility Functions
*
*********************************************************************************************/</span>

<span class="enscript-comment">// Note: Need to make sure we don't write more than kDNSServiceMaxDomainName (1009) bytes to fullName
</span><span class="enscript-comment">// In earlier builds this constant was defined to be 1005, so to avoid buffer overruns on clients
</span><span class="enscript-comment">// compiled with that constant we'll actually limit the output to 1005 bytes.
</span>
DNSServiceErrorType DNSSD_API DNSServiceConstructFullName
(
    <span class="enscript-type">char</span>       *<span class="enscript-type">const</span> fullName,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> service,      <span class="enscript-comment">// May be NULL
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> regtype,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> domain
)
{
    <span class="enscript-type">const</span> size_t len = !regtype ? 0 : strlen(regtype) - DomainEndsInDot(regtype);
    <span class="enscript-type">char</span>       *fn   = fullName;
    <span class="enscript-type">char</span> *<span class="enscript-type">const</span> lim  = fullName + 1005;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s    = service;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *r    = regtype;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *d    = domain;

    <span class="enscript-comment">// regtype must be at least &quot;x._udp&quot; or &quot;x._tcp&quot;
</span>    <span class="enscript-keyword">if</span> (len &lt; 6 || !domain || !domain[0]) <span class="enscript-keyword">return</span> kDNSServiceErr_BadParam;
    <span class="enscript-keyword">if</span> (strncasecmp((regtype + len - 4), <span class="enscript-string">&quot;_tcp&quot;</span>, 4) &amp;&amp; strncasecmp((regtype + len - 4), <span class="enscript-string">&quot;_udp&quot;</span>, 4)) <span class="enscript-keyword">return</span> kDNSServiceErr_BadParam;

    <span class="enscript-keyword">if</span> (service &amp;&amp; *service)
    {
        <span class="enscript-keyword">while</span> (*s)
        {
            <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c = *s++;             <span class="enscript-comment">// Needs to be unsigned, or values like 0xFF will be interpreted as &lt; 32
</span>            <span class="enscript-keyword">if</span> (c &lt;= <span class="enscript-string">' '</span>)                       <span class="enscript-comment">// Escape non-printable characters
</span>            {
                <span class="enscript-keyword">if</span> (fn+4 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
                *fn++ = <span class="enscript-string">'\\'</span>;
                *fn++ = <span class="enscript-string">'0'</span> + (c / 100);
                *fn++ = <span class="enscript-string">'0'</span> + (c /  10) % 10;
                c     = <span class="enscript-string">'0'</span> + (c      ) % 10;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'.'</span> || (c == <span class="enscript-string">'\\'</span>))   <span class="enscript-comment">// Escape dot and backslash literals
</span>            {
                <span class="enscript-keyword">if</span> (fn+2 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
                *fn++ = <span class="enscript-string">'\\'</span>;
            }
            <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">if</span> (fn+1 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
            *fn++ = (<span class="enscript-type">char</span>)c;
        }
        *fn++ = <span class="enscript-string">'.'</span>;
    }

    <span class="enscript-keyword">while</span> (*r) <span class="enscript-keyword">if</span> (fn+1 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;<span class="enscript-keyword">else</span> *fn++ = *r++;
    <span class="enscript-keyword">if</span> (!DomainEndsInDot(regtype)) { <span class="enscript-keyword">if</span> (fn+1 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;<span class="enscript-keyword">else</span> *fn++ = <span class="enscript-string">'.'</span>;}

    <span class="enscript-keyword">while</span> (*d) <span class="enscript-keyword">if</span> (fn+1 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;<span class="enscript-keyword">else</span> *fn++ = *d++;
    <span class="enscript-keyword">if</span> (!DomainEndsInDot(domain)) { <span class="enscript-keyword">if</span> (fn+1 &gt;= lim) <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;<span class="enscript-keyword">else</span> *fn++ = <span class="enscript-string">'.'</span>;}

    *fn = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">return</span> kDNSServiceErr_NoError;

<span class="enscript-reference">fail</span>:
    *fn = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">return</span> kDNSServiceErr_BadParam;
}

<span class="enscript-comment">/*********************************************************************************************
*
*   TXT Record Construction Functions
*
*********************************************************************************************/</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _TXTRecordRefRealType
{
    uint8_t  *buffer;       <span class="enscript-comment">// Pointer to data
</span>    uint16_t buflen;        <span class="enscript-comment">// Length of buffer
</span>    uint16_t datalen;       <span class="enscript-comment">// Length currently in use
</span>    uint16_t malloced;  <span class="enscript-comment">// Non-zero if buffer was allocated via malloc()
</span>} TXTRecordRefRealType;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">txtRec</span> ((TXTRecordRefRealType*)txtRecord)

<span class="enscript-comment">// The opaque storage defined in the public dns_sd.h header is 16 bytes;
</span><span class="enscript-comment">// make sure we don't exceed that.
</span><span class="enscript-type">struct</span> CompileTimeAssertionCheck_dnssd_clientlib
{
    <span class="enscript-type">char</span> assert0[(<span class="enscript-keyword">sizeof</span>(TXTRecordRefRealType) &lt;= 16) ? 1 : -1];
};

<span class="enscript-type">void</span> DNSSD_API TXTRecordCreate
(
    TXTRecordRef     *txtRecord,
    uint16_t bufferLen,
    <span class="enscript-type">void</span>             *buffer
)
{
    txtRec-&gt;buffer   = buffer;
    txtRec-&gt;buflen   = buffer ? bufferLen : (uint16_t)0;
    txtRec-&gt;datalen  = 0;
    txtRec-&gt;malloced = 0;
}

<span class="enscript-type">void</span> DNSSD_API <span class="enscript-function-name">TXTRecordDeallocate</span>(TXTRecordRef *txtRecord)
{
    <span class="enscript-keyword">if</span> (txtRec-&gt;malloced) free(txtRec-&gt;buffer);
}

DNSServiceErrorType DNSSD_API TXTRecordSetValue
(
    TXTRecordRef     *txtRecord,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       *key,
    uint8_t valueSize,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *value
)
{
    uint8_t *start, *p;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *k;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> keysize, keyvalsize;

    <span class="enscript-keyword">for</span> (k = key; *k; k++) <span class="enscript-keyword">if</span> (*k &lt; 0x20 || *k &gt; 0x7E || *k == <span class="enscript-string">'='</span>) <span class="enscript-keyword">return</span>(kDNSServiceErr_Invalid);
    keysize = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(k - key);
    keyvalsize = 1 + keysize + (value ? (1 + valueSize) : 0);
    <span class="enscript-keyword">if</span> (keysize &lt; 1 || keyvalsize &gt; 255) <span class="enscript-keyword">return</span>(kDNSServiceErr_Invalid);
    (<span class="enscript-type">void</span>)TXTRecordRemoveValue(txtRecord, key);
    <span class="enscript-keyword">if</span> (txtRec-&gt;datalen + keyvalsize &gt; txtRec-&gt;buflen)
    {
        <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *newbuf;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> newlen = txtRec-&gt;datalen + keyvalsize;
        <span class="enscript-keyword">if</span> (newlen &gt; 0xFFFF) <span class="enscript-keyword">return</span>(kDNSServiceErr_Invalid);
        newbuf = malloc((size_t)newlen);
        <span class="enscript-keyword">if</span> (!newbuf) <span class="enscript-keyword">return</span>(kDNSServiceErr_NoMemory);
        memcpy(newbuf, txtRec-&gt;buffer, txtRec-&gt;datalen);
        <span class="enscript-keyword">if</span> (txtRec-&gt;malloced) free(txtRec-&gt;buffer);
        txtRec-&gt;buffer = newbuf;
        txtRec-&gt;buflen = (uint16_t)(newlen);
        txtRec-&gt;malloced = 1;
    }
    start = txtRec-&gt;buffer + txtRec-&gt;datalen;
    p = start + 1;
    memcpy(p, key, keysize);
    p += keysize;
    <span class="enscript-keyword">if</span> (value)
    {
        *p++ = <span class="enscript-string">'='</span>;
        memcpy(p, value, valueSize);
        p += valueSize;
    }
    *start = (uint8_t)(p - start - 1);
    txtRec-&gt;datalen += p - start;
    <span class="enscript-keyword">return</span>(kDNSServiceErr_NoError);
}

DNSServiceErrorType DNSSD_API TXTRecordRemoveValue
(
    TXTRecordRef     *txtRecord,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       *key
)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> keylen, itemlen, remainder;
    uint8_t *item = InternalTXTRecordSearch(txtRec-&gt;datalen, txtRec-&gt;buffer, key, &amp;keylen);
    <span class="enscript-keyword">if</span> (!item) <span class="enscript-keyword">return</span>(kDNSServiceErr_NoSuchKey);
    itemlen   = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(1 + item[0]);
    remainder = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)((txtRec-&gt;buffer + txtRec-&gt;datalen) - (item + itemlen));
    <span class="enscript-comment">// Use memmove because memcpy behaviour is undefined for overlapping regions
</span>    memmove(item, item + itemlen, remainder);
    txtRec-&gt;datalen -= itemlen;
    <span class="enscript-keyword">return</span>(kDNSServiceErr_NoError);
}

uint16_t DNSSD_API <span class="enscript-function-name">TXTRecordGetLength</span>  (<span class="enscript-type">const</span> TXTRecordRef *txtRecord) { <span class="enscript-keyword">return</span>(txtRec-&gt;datalen); }
<span class="enscript-type">const</span> <span class="enscript-type">void</span> * DNSSD_API <span class="enscript-function-name">TXTRecordGetBytesPtr</span>(<span class="enscript-type">const</span> TXTRecordRef *txtRecord) { <span class="enscript-keyword">return</span>(txtRec-&gt;buffer); }

<span class="enscript-comment">/*********************************************************************************************
*
*   TXT Record Parsing Functions
*
*********************************************************************************************/</span>

<span class="enscript-type">int</span> DNSSD_API TXTRecordContainsKey
(
    uint16_t txtLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *txtRecord,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       *key
)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> keylen;
    <span class="enscript-keyword">return</span> (InternalTXTRecordSearch(txtLen, txtRecord, key, &amp;keylen) ? 1 : 0);
}

<span class="enscript-type">const</span> <span class="enscript-type">void</span> * DNSSD_API TXTRecordGetValuePtr
(
    uint16_t txtLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *txtRecord,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>       *key,
    uint8_t          *valueLen
)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> keylen;
    uint8_t *item = InternalTXTRecordSearch(txtLen, txtRecord, key, &amp;keylen);
    <span class="enscript-keyword">if</span> (!item || item[0] &lt;= keylen) <span class="enscript-keyword">return</span>(NULL);   <span class="enscript-comment">// If key not found, or found with no value, return NULL
</span>    *valueLen = (uint8_t)(item[0] - (keylen + 1));
    <span class="enscript-keyword">return</span> (item + 1 + keylen + 1);
}

uint16_t DNSSD_API TXTRecordGetCount
(
    uint16_t txtLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *txtRecord
)
{
    uint16_t count = 0;
    uint8_t *p = (uint8_t*)txtRecord;
    uint8_t *e = p + txtLen;
    <span class="enscript-keyword">while</span> (p&lt;e) { p += 1 + p[0]; count++; }
    <span class="enscript-keyword">return</span>((p&gt;e) ? (uint16_t)0 : count);
}

DNSServiceErrorType DNSSD_API TXTRecordGetItemAtIndex
(
    uint16_t txtLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       *txtRecord,
    uint16_t itemIndex,
    uint16_t keyBufLen,
    <span class="enscript-type">char</span>             *key,
    uint8_t          *valueLen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>       **value
)
{
    uint16_t count = 0;
    uint8_t *p = (uint8_t*)txtRecord;
    uint8_t *e = p + txtLen;
    <span class="enscript-keyword">while</span> (p&lt;e &amp;&amp; count&lt;itemIndex) { p += 1 + p[0]; count++; }  <span class="enscript-comment">// Find requested item
</span>    <span class="enscript-keyword">if</span> (p&lt;e &amp;&amp; p + 1 + p[0] &lt;= e)   <span class="enscript-comment">// If valid
</span>    {
        uint8_t *x = p+1;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> len = 0;
        e = p + 1 + p[0];
        <span class="enscript-keyword">while</span> (x+len&lt;e &amp;&amp; x[len] != <span class="enscript-string">'='</span>) len++;
        <span class="enscript-keyword">if</span> (len &gt;= keyBufLen) <span class="enscript-keyword">return</span>(kDNSServiceErr_NoMemory);
        memcpy(key, x, len);
        key[len] = 0;
        <span class="enscript-keyword">if</span> (x+len&lt;e)        <span class="enscript-comment">// If we found '='
</span>        {
            *value = x + len + 1;
            *valueLen = (uint8_t)(p[0] - (len + 1));
        }
        <span class="enscript-keyword">else</span>
        {
            *value = NULL;
            *valueLen = 0;
        }
        <span class="enscript-keyword">return</span>(kDNSServiceErr_NoError);
    }
    <span class="enscript-keyword">return</span>(kDNSServiceErr_Invalid);
}

<span class="enscript-comment">/*********************************************************************************************
*
*   SCCS-compatible version string
*
*********************************************************************************************/</span>

<span class="enscript-comment">// For convenience when using the &quot;strings&quot; command, this is the last thing in the file
</span>
<span class="enscript-comment">// Note: The C preprocessor stringify operator ('#') makes a string from its argument, without macro expansion
</span><span class="enscript-comment">// e.g. If &quot;version&quot; is #define'd to be &quot;4&quot;, then STRINGIFY_AWE(version) will return the string &quot;version&quot;, not &quot;4&quot;
</span><span class="enscript-comment">// To expand &quot;version&quot; to its value before making the string, use STRINGIFY(version) instead
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">STRINGIFY_ARGUMENT_WITHOUT_EXPANSION</span>(s) # s
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STRINGIFY</span>(s) STRINGIFY_ARGUMENT_WITHOUT_EXPANSION(s)

<span class="enscript-comment">// The &quot;used&quot; variable attribute prevents a non-exported variable from being stripped, even if its visibility is hidden,
</span><span class="enscript-comment">// e.g., when compiling with -fvisibility=hidden.
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__GNUC__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSD_USED</span> __attribute__((used))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSD_USED</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// NOT static -- otherwise the compiler may optimize it out
</span><span class="enscript-comment">// The &quot;@(#) &quot; pattern is a special prefix the &quot;what&quot; command looks for
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> VersionString_SCCS_libdnssd[] DNSSD_USED = <span class="enscript-string">&quot;@(#) libdns_sd &quot;</span> STRINGIFY(mDNSResponderVersion) <span class="enscript-string">&quot; (&quot;</span> __DATE__ <span class="enscript-string">&quot; &quot;</span> __TIME__ <span class="enscript-string">&quot;)&quot;</span>;
</pre>
<hr />
</body></html>