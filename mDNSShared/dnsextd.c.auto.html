<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dnsextd.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dnsextd.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="dnsextd.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__APPLE__</span>
<span class="enscript-comment">// In Mac OS X 10.5 and later trying to use the daemon function gives a “‘daemon’ is deprecated”
</span><span class="enscript-comment">// error, which prevents compilation because we build with &quot;-Werror&quot;.
</span><span class="enscript-comment">// Since this is supposed to be portable cross-platform code, we don't care that daemon is
</span><span class="enscript-comment">// deprecated on Mac OS X 10.5, so we use this preprocessor trick to eliminate the error message.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">daemon</span> yes_we_know_that_daemon_is_deprecated_in_os_x_10_5_thankyou
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__APPLE__</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">daemon</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">daemon</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Solaris doesn't have daemon(), so we define it here
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NOT_HAVE_DAEMON</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSPosix/mDNSUNP.h&quot;</span>       // For daemon()
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">NOT_HAVE_DAEMON</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnsextd.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSShared/uds_daemon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSShared/dnssd_ipc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSCore/uDNS.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSShared/DebugServices.h&quot;</span>

<span class="enscript-comment">// Compatibility workaround
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">AF_LOCAL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AF_LOCAL</span> AF_UNIX
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// Constants
</span><span class="enscript-comment">//
</span>mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> ProgramName[] = <span class="enscript-string">&quot;dnsextd&quot;</span>;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOOPBACK</span>                    <span class="enscript-string">&quot;127.0.0.1&quot;</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">LISTENQ</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">LISTENQ</span>                  128                 // tcp connection backlog
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RECV_BUFLEN</span>                 9000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LEASETABLE_INIT_NBUCKETS</span>    256                 // initial hashtable size (doubles as table fills)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EXPIRATION_INTERVAL</span>         300                 // check for expired records every 5 minutes
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SRV_TTL</span>                     7200                // TTL For _dns-update SRV records
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONFIG_FILE</span>                 <span class="enscript-string">&quot;/etc/dnsextd.conf&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_SOCKET_FLAGS</span>            kTCPSocketFlags_UseTLS

<span class="enscript-comment">// LLQ Lease bounds (seconds)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LLQ_MIN_LEASE</span> (15 * 60)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LLQ_MAX_LEASE</span> (120 * 60)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LLQ_LEASE_FUDGE</span> 60

<span class="enscript-comment">// LLQ SOA poll interval (microseconds)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LLQ_MONITOR_ERR_INTERVAL</span> (60 * 1000000)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LLQ_MONITOR_INTERVAL</span> 250000
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SIGINFO</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INFO_SIGNAL</span> SIGINFO
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INFO_SIGNAL</span> SIGUSR1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SAME_INADDR</span>(x,y) (*((mDNSu32 *)&amp;x) == *((mDNSu32 *)&amp;y))

<span class="enscript-comment">//
</span><span class="enscript-comment">// Data Structures
</span><span class="enscript-comment">// Structs/fields that must be locked for thread safety are explicitly commented
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// args passed to UDP request handler thread as void*
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    PktMsg pkt;
    <span class="enscript-type">struct</span> sockaddr_in cliaddr;
    DaemonInfo *d;
    <span class="enscript-type">int</span> sd;
} UDPContext;

<span class="enscript-comment">// args passed to TCP request handler thread as void*
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    PktMsg pkt;
    <span class="enscript-type">struct</span> sockaddr_in cliaddr;
    TCPSocket *sock;           <span class="enscript-comment">// socket connected to client
</span>    DaemonInfo *d;
} TCPContext;

<span class="enscript-comment">// args passed to UpdateAnswerList thread as void*
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    DaemonInfo *d;
    AnswerListElem *a;
} UpdateAnswerListArgs;

<span class="enscript-comment">//
</span><span class="enscript-comment">// Global Variables
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// booleans to determine runtime output
</span><span class="enscript-comment">// read-only after initialization (no mutex protection)
</span><span class="enscript-type">static</span> mDNSBool foreground = 0;
<span class="enscript-type">static</span> mDNSBool verbose = 0;

<span class="enscript-comment">// globals set via signal handler (accessed exclusively by main select loop and signal handler)
</span><span class="enscript-type">static</span> mDNSBool terminate = 0;
<span class="enscript-type">static</span> mDNSBool dumptable = 0;
<span class="enscript-type">static</span> mDNSBool hangup    = 0;

<span class="enscript-comment">// global for config file location
</span><span class="enscript-type">static</span> <span class="enscript-type">char</span> *   cfgfile   = NULL;

<span class="enscript-comment">//
</span><span class="enscript-comment">// Logging Routines
</span><span class="enscript-comment">// Log messages are delivered to syslog unless -f option specified
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// common message logging subroutine
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintLog</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buffer)
{
    <span class="enscript-keyword">if</span> (foreground)
    {
        fprintf(stderr,<span class="enscript-string">&quot;%s\n&quot;</span>, buffer);
        fflush(stderr);
    }
    <span class="enscript-keyword">else</span>
    {
        openlog(<span class="enscript-string">&quot;dnsextd&quot;</span>, LOG_CONS, LOG_DAEMON);
        syslog(LOG_ERR, <span class="enscript-string">&quot;%s&quot;</span>, buffer);
        closelog();
    }
}

<span class="enscript-comment">// Verbose Logging (conditional on -v option)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">VLog</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    <span class="enscript-type">char</span> buffer[512];
    va_list ptr;

    <span class="enscript-keyword">if</span> (!verbose) <span class="enscript-keyword">return</span>;
    va_start(ptr,format);
    buffer[mDNS_vsnprintf((<span class="enscript-type">char</span> *)buffer, <span class="enscript-keyword">sizeof</span>(buffer), format, ptr)] = 0;
    va_end(ptr);
    PrintLog(buffer);
}

<span class="enscript-comment">// Unconditional Logging
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">Log</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    <span class="enscript-type">char</span> buffer[512];
    va_list ptr;

    va_start(ptr,format);
    buffer[mDNS_vsnprintf((<span class="enscript-type">char</span> *)buffer, <span class="enscript-keyword">sizeof</span>(buffer), format, ptr)] = 0;
    va_end(ptr);
    PrintLog(buffer);
}

<span class="enscript-comment">// Error Logging
</span><span class="enscript-comment">// prints message &quot;dnsextd &lt;function&gt;: &lt;operation&gt; - &lt;error message&gt;&quot;
</span><span class="enscript-comment">// must be compiled w/ -D_REENTRANT for thread-safe errno usage
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LogErr</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fn, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *operation)
{
    <span class="enscript-type">char</span> buf[512], errbuf[256];
    strerror_r(errno, errbuf, <span class="enscript-keyword">sizeof</span>(errbuf));
    snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;%s: %s - %s&quot;</span>, fn, operation, errbuf);
    PrintLog(buf);
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Networking Utility Routines
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// Convert DNS Message Header from Network to Host byte order
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HdrNToH</span>(PktMsg *pkt)
{
    <span class="enscript-comment">// Read the integer parts which are in IETF byte-order (MSB first, LSB second)
</span>    mDNSu8 *ptr = (mDNSu8 *)&amp;pkt-&gt;msg.h.numQuestions;
    pkt-&gt;msg.h.numQuestions   = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
    pkt-&gt;msg.h.numAnswers     = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt;  8 | ptr[3]);
    pkt-&gt;msg.h.numAuthorities = (mDNSu16)((mDNSu16)ptr[4] &lt;&lt;  8 | ptr[5]);
    pkt-&gt;msg.h.numAdditionals = (mDNSu16)((mDNSu16)ptr[6] &lt;&lt;  8 | ptr[7]);
}

<span class="enscript-comment">// Convert DNS Message Header from Host to Network byte order
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HdrHToN</span>(PktMsg *pkt)
{
    mDNSu16 numQuestions   = pkt-&gt;msg.h.numQuestions;
    mDNSu16 numAnswers     = pkt-&gt;msg.h.numAnswers;
    mDNSu16 numAuthorities = pkt-&gt;msg.h.numAuthorities;
    mDNSu16 numAdditionals = pkt-&gt;msg.h.numAdditionals;
    mDNSu8 *ptr = (mDNSu8 *)&amp;pkt-&gt;msg.h.numQuestions;

    <span class="enscript-comment">// Put all the integer values in IETF byte-order (MSB first, LSB second)
</span>    *ptr++ = (mDNSu8)(numQuestions   &gt;&gt; 8);
    *ptr++ = (mDNSu8)(numQuestions   &amp;  0xFF);
    *ptr++ = (mDNSu8)(numAnswers     &gt;&gt; 8);
    *ptr++ = (mDNSu8)(numAnswers     &amp;  0xFF);
    *ptr++ = (mDNSu8)(numAuthorities &gt;&gt; 8);
    *ptr++ = (mDNSu8)(numAuthorities &amp;  0xFF);
    *ptr++ = (mDNSu8)(numAdditionals &gt;&gt; 8);
    *ptr++ = (mDNSu8)(numAdditionals &amp;  0xFF);
}


<span class="enscript-comment">// Add socket to event loop
</span>
mDNSlocal mStatus <span class="enscript-function-name">AddSourceToEventLoop</span>( DaemonInfo * self, TCPSocket *sock, EventCallback callback, <span class="enscript-type">void</span> *context )
{
    EventSource * newSource;
    mStatus err = mStatus_NoError;

    <span class="enscript-keyword">if</span> ( self-&gt;eventSources.LinkOffset == 0 )
    {
        InitLinkedList( &amp;self-&gt;eventSources, offsetof( EventSource, next));
    }

    newSource = ( EventSource*) malloc( <span class="enscript-keyword">sizeof</span> *newSource );
    <span class="enscript-keyword">if</span> ( newSource == NULL )
    {
        err = mStatus_NoMemoryErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    newSource-&gt;callback = callback;
    newSource-&gt;context = context;
    newSource-&gt;sock = sock;
    newSource-&gt;fd = mDNSPlatformTCPGetFD( sock );

    AddToTail( &amp;self-&gt;eventSources, newSource );

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">// Remove socket from event loop
</span>
mDNSlocal mStatus <span class="enscript-function-name">RemoveSourceFromEventLoop</span>( DaemonInfo * self, TCPSocket *sock )
{
    EventSource *   source;
    mStatus err;

    <span class="enscript-keyword">for</span> ( source = ( EventSource* ) self-&gt;eventSources.Head; source; source = source-&gt;next )
    {
        <span class="enscript-keyword">if</span> ( source-&gt;sock == sock )
        {
            RemoveFromList( &amp;self-&gt;eventSources, source );

            free( source );
            err = mStatus_NoError;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
    }

    err = mStatus_NoSuchNameErr;

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">// create a socket connected to nameserver
</span><span class="enscript-comment">// caller terminates connection via close()
</span>mDNSlocal TCPSocket *<span class="enscript-function-name">ConnectToServer</span>(DaemonInfo *d)
{
    <span class="enscript-type">int</span> ntries = 0, retry = 0;

    <span class="enscript-keyword">while</span> (1)
    {
        mDNSIPPort port = zeroIPPort;
        <span class="enscript-type">int</span> fd;

        TCPSocket *sock = mDNSPlatformTCPSocket(0, mDNSAddrType_IPv4, &amp;port, NULL, mDNSfalse );
        <span class="enscript-keyword">if</span> ( !sock ) { LogErr(<span class="enscript-string">&quot;ConnectToServer&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span>);  <span class="enscript-keyword">return</span> NULL; }
        fd = mDNSPlatformTCPGetFD( sock );
        <span class="enscript-keyword">if</span> (!connect( fd, (<span class="enscript-type">struct</span> sockaddr *)&amp;d-&gt;ns_addr, <span class="enscript-keyword">sizeof</span>(d-&gt;ns_addr))) <span class="enscript-keyword">return</span> sock;
        mDNSPlatformTCPCloseConnection( sock );
        <span class="enscript-keyword">if</span> (++ntries &lt; 10)
        {
            LogErr(<span class="enscript-string">&quot;ConnectToServer&quot;</span>, <span class="enscript-string">&quot;connect&quot;</span>);
            Log(<span class="enscript-string">&quot;ConnectToServer - retrying connection&quot;</span>);
            <span class="enscript-keyword">if</span> (!retry) retry = 500000 + random() % 500000;
            usleep(retry);
            retry *= 2;
        }
        <span class="enscript-keyword">else</span> { Log(<span class="enscript-string">&quot;ConnectToServer - %d failed attempts.  Aborting.&quot;</span>, ntries); <span class="enscript-keyword">return</span> NULL; }
    }
}

<span class="enscript-comment">// send an entire block of data over a connected socket
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">MySend</span>(TCPSocket *sock, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *msg, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> selectval, n, nsent = 0;
    fd_set wset;
    <span class="enscript-type">struct</span> timeval timeout = { 3, 0 };  <span class="enscript-comment">// until we remove all calls from main thread, keep timeout short
</span>
    <span class="enscript-keyword">while</span> (nsent &lt; len)
    {
        <span class="enscript-type">int</span> fd;

        FD_ZERO(&amp;wset);

        fd = mDNSPlatformTCPGetFD( sock );

        FD_SET( fd, &amp;wset );
        selectval = select( fd+1, NULL, &amp;wset, NULL, &amp;timeout);
        <span class="enscript-keyword">if</span> (selectval &lt; 0) { LogErr(<span class="enscript-string">&quot;MySend&quot;</span>, <span class="enscript-string">&quot;select&quot;</span>);  <span class="enscript-keyword">return</span> -1; }
        <span class="enscript-keyword">if</span> (!selectval || !FD_ISSET(fd, &amp;wset)) { Log(<span class="enscript-string">&quot;MySend - timeout&quot;</span>); <span class="enscript-keyword">return</span> -1; }

        n = mDNSPlatformWriteTCP( sock, ( <span class="enscript-type">char</span>* ) msg + nsent, len - nsent);

        <span class="enscript-keyword">if</span> (n &lt; 0) { LogErr(<span class="enscript-string">&quot;MySend&quot;</span>, <span class="enscript-string">&quot;send&quot;</span>);  <span class="enscript-keyword">return</span> -1; }
        nsent += n;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// Transmit a DNS message, prefixed by its length, over TCP, blocking if necessary
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">SendPacket</span>(TCPSocket *sock, PktMsg *pkt)
{
    <span class="enscript-comment">// send the lenth, in network byte order
</span>    mDNSu16 len = htons((mDNSu16)pkt-&gt;len);
    <span class="enscript-keyword">if</span> (MySend(sock, &amp;len, <span class="enscript-keyword">sizeof</span>(len)) &lt; 0) <span class="enscript-keyword">return</span> -1;

    <span class="enscript-comment">// send the message
</span>    VLog(<span class="enscript-string">&quot;SendPacket Q:%d A:%d A:%d A:%d &quot;</span>,
         ntohs(pkt-&gt;msg.h.numQuestions),
         ntohs(pkt-&gt;msg.h.numAnswers),
         ntohs(pkt-&gt;msg.h.numAuthorities),
         ntohs(pkt-&gt;msg.h.numAdditionals));
    <span class="enscript-keyword">return</span> MySend(sock, &amp;pkt-&gt;msg, pkt-&gt;len);
}

<span class="enscript-comment">// Receive len bytes, waiting until we have all of them.
</span><span class="enscript-comment">// Returns number of bytes read (which should always be the number asked for).
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">my_recv</span>(TCPSocket *sock, <span class="enscript-type">void</span> *<span class="enscript-type">const</span> buf, <span class="enscript-type">const</span> <span class="enscript-type">int</span> len, mDNSBool * closed)
{
    <span class="enscript-comment">// Don't use &quot;MSG_WAITALL&quot;; it returns &quot;Invalid argument&quot; on some Linux versions;
</span>    <span class="enscript-comment">// use an explicit while() loop instead.
</span>    <span class="enscript-comment">// Also, don't try to do '+=' arithmetic on the original &quot;void *&quot; pointer --
</span>    <span class="enscript-comment">// arithmetic on &quot;void *&quot; pointers is compiler-dependent.
</span>
    fd_set rset;
    <span class="enscript-type">struct</span> timeval timeout = { 3, 0 };  <span class="enscript-comment">// until we remove all calls from main thread, keep timeout short
</span>    <span class="enscript-type">int</span> selectval, remaining = len;
    <span class="enscript-type">char</span> *ptr = (<span class="enscript-type">char</span> *)buf;
    ssize_t num_read;

    <span class="enscript-keyword">while</span> (remaining)
    {
        <span class="enscript-type">int</span> fd;

        fd = mDNSPlatformTCPGetFD( sock );

        FD_ZERO(&amp;rset);
        FD_SET(fd, &amp;rset);
        selectval = select(fd+1, &amp;rset, NULL, NULL, &amp;timeout);
        <span class="enscript-keyword">if</span> (selectval &lt; 0) { LogErr(<span class="enscript-string">&quot;my_recv&quot;</span>, <span class="enscript-string">&quot;select&quot;</span>);  <span class="enscript-keyword">return</span> -1; }
        <span class="enscript-keyword">if</span> (!selectval || !FD_ISSET(fd, &amp;rset))
        {
            Log(<span class="enscript-string">&quot;my_recv - timeout&quot;</span>);
            <span class="enscript-keyword">return</span> -1;
        }

        num_read = mDNSPlatformReadTCP( sock, ptr, remaining, closed );

        <span class="enscript-keyword">if</span> (((num_read == 0) &amp;&amp; *closed) || (num_read &lt; 0) || (num_read &gt; remaining)) <span class="enscript-keyword">return</span> -1;
        <span class="enscript-keyword">if</span> (num_read == 0) <span class="enscript-keyword">return</span> 0;
        ptr       += num_read;
        remaining -= num_read;
    }
    <span class="enscript-keyword">return</span>(len);
}

<span class="enscript-comment">// Return a DNS Message read off of a TCP socket, or NULL on failure
</span><span class="enscript-comment">// If storage is non-null, result is placed in that buffer.  Otherwise,
</span><span class="enscript-comment">// returned value is allocated with Malloc, and contains sufficient extra
</span><span class="enscript-comment">// storage for a Lease OPT RR
</span>
mDNSlocal PktMsg*
RecvPacket
(
    TCPSocket * sock,
    PktMsg      *   storage,
    mDNSBool    *   closed
)
{
    <span class="enscript-type">int</span> nread;
    <span class="enscript-type">int</span> allocsize;
    mDNSu16 msglen = 0;
    PktMsg      *   pkt = NULL;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> srclen;
    <span class="enscript-type">int</span> fd;
    mStatus err = 0;

    fd = mDNSPlatformTCPGetFD( sock );

    nread = my_recv( sock, &amp;msglen, <span class="enscript-keyword">sizeof</span>( msglen ), closed );

    require_action_quiet( nread != -1, exit, err = mStatus_UnknownErr );
    require_action_quiet( nread &gt; 0, exit, err = mStatus_NoError );

    msglen = ntohs( msglen );
    require_action_quiet( nread == <span class="enscript-keyword">sizeof</span>( msglen ), exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;Could not read length field of message&quot;</span>) );

    <span class="enscript-keyword">if</span> ( storage )
    {
        require_action_quiet( msglen &lt;= <span class="enscript-keyword">sizeof</span>( storage-&gt;msg ), exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;RecvPacket: provided buffer too small.&quot;</span> ) );
        pkt = storage;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// buffer extra space to add an OPT RR
</span>
        <span class="enscript-keyword">if</span> ( msglen &gt; <span class="enscript-keyword">sizeof</span>(DNSMessage))
        {
            allocsize = <span class="enscript-keyword">sizeof</span>(PktMsg) - <span class="enscript-keyword">sizeof</span>(DNSMessage) + msglen;
        }
        <span class="enscript-keyword">else</span>
        {
            allocsize = <span class="enscript-keyword">sizeof</span>(PktMsg);
        }

        pkt = malloc(allocsize);
        require_action_quiet( pkt, exit, err = mStatus_NoMemoryErr; LogErr( <span class="enscript-string">&quot;RecvPacket&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span> ) );
        mDNSPlatformMemZero( pkt, <span class="enscript-keyword">sizeof</span>( *pkt ) );
    }

    pkt-&gt;len = msglen;
    srclen = <span class="enscript-keyword">sizeof</span>(pkt-&gt;src);

    <span class="enscript-keyword">if</span> ( getpeername( fd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;pkt-&gt;src, &amp;srclen ) || ( srclen != <span class="enscript-keyword">sizeof</span>( pkt-&gt;src ) ) )
    {
        LogErr(<span class="enscript-string">&quot;RecvPacket&quot;</span>, <span class="enscript-string">&quot;getpeername&quot;</span>);
        mDNSPlatformMemZero(&amp;pkt-&gt;src, <span class="enscript-keyword">sizeof</span>(pkt-&gt;src));
    }

    nread = my_recv(sock, &amp;pkt-&gt;msg, msglen, closed );
    require_action_quiet( nread &gt;= 0, exit, err = mStatus_UnknownErr ; LogErr( <span class="enscript-string">&quot;RecvPacket&quot;</span>, <span class="enscript-string">&quot;recv&quot;</span> ) );
    require_action_quiet( nread == msglen, exit, err = mStatus_UnknownErr ; Log( <span class="enscript-string">&quot;Could not read entire message&quot;</span> ) );
    require_action_quiet( pkt-&gt;len &gt;= <span class="enscript-keyword">sizeof</span>( DNSMessageHeader ), exit, err = mStatus_UnknownErr ; Log( <span class="enscript-string">&quot;RecvPacket: Message too short (%d bytes)&quot;</span>, pkt-&gt;len ) );

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( err &amp;&amp; pkt )
    {
        <span class="enscript-keyword">if</span> ( pkt != storage )
        {
            free(pkt);
        }

        pkt = NULL;
    }

    <span class="enscript-keyword">return</span> pkt;
}


mDNSlocal DNSZone*
FindZone
(
    DaemonInfo  *   self,
    domainname  *   name
)
{
    DNSZone * zone;

    <span class="enscript-keyword">for</span> ( zone = self-&gt;zones; zone; zone = zone-&gt;next )
    {
        <span class="enscript-keyword">if</span> ( SameDomainName( &amp;zone-&gt;name, name ) )
        {
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">return</span> zone;
}


mDNSlocal mDNSBool
ZoneHandlesName
(
    <span class="enscript-type">const</span> domainname * zname,
    <span class="enscript-type">const</span> domainname * dname
)
{
    mDNSu16 i = DomainNameLength( zname );
    mDNSu16 j = DomainNameLength( dname );

    <span class="enscript-keyword">if</span> ( ( i == ( MAX_DOMAIN_NAME + 1 ) ) || ( j == ( MAX_DOMAIN_NAME + 1 ) ) || ( i &gt; j )  || ( memcmp( zname-&gt;c, dname-&gt;c + ( j - i ), i ) != 0 ) )
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">return</span> mDNStrue;
}


mDNSlocal mDNSBool <span class="enscript-function-name">IsQuery</span>( PktMsg * pkt )
{
    <span class="enscript-keyword">return</span> ( pkt-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask ) == (mDNSu8) ( kDNSFlag0_QR_Query | kDNSFlag0_OP_StdQuery );
}


mDNSlocal mDNSBool <span class="enscript-function-name">IsUpdate</span>( PktMsg * pkt )
{
    <span class="enscript-keyword">return</span> ( pkt-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask ) == (mDNSu8) ( kDNSFlag0_OP_Update );
}


mDNSlocal mDNSBool <span class="enscript-function-name">IsNotify</span>(PktMsg *pkt)
{
    <span class="enscript-keyword">return</span> ( pkt-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask ) == ( mDNSu8) ( kDNSFlag0_OP_Notify );
}


mDNSlocal mDNSBool <span class="enscript-function-name">IsLLQRequest</span>(PktMsg *pkt)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = NULL, *end = (mDNSu8 *)&amp;pkt-&gt;msg + pkt-&gt;len;
    LargeCacheRecord lcr;
    <span class="enscript-type">int</span> i;
    mDNSBool result = mDNSfalse;

    HdrNToH(pkt);
    <span class="enscript-keyword">if</span> ((mDNSu8)(pkt-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask) != (mDNSu8)(kDNSFlag0_QR_Query | kDNSFlag0_OP_StdQuery)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

    <span class="enscript-keyword">if</span> (!pkt-&gt;msg.h.numAdditionals) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
    ptr = LocateAdditionals(&amp;pkt-&gt;msg, end);
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

    bzero(&amp;lcr, <span class="enscript-keyword">sizeof</span>(lcr));
    <span class="enscript-comment">// find last Additional info.
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; pkt-&gt;msg.h.numAdditionals; i++)
    {
        ptr = GetLargeResourceRecord(NULL, &amp;pkt-&gt;msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;lcr);
        <span class="enscript-keyword">if</span> (!ptr) { Log(<span class="enscript-string">&quot;Unable to read additional record&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
    }

    <span class="enscript-keyword">if</span> ( lcr.r.resrec.rrtype == kDNSType_OPT &amp;&amp; lcr.r.resrec.rdlength &gt;= DNSOpt_LLQData_Space &amp;&amp; lcr.r.resrec.rdata-&gt;u.opt[0].opt == kDNSOpt_LLQ )
    {
        result = mDNStrue;
    }

<span class="enscript-reference">end</span>:
    HdrHToN(pkt);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">// !!!KRS implement properly
</span>mDNSlocal mDNSBool <span class="enscript-function-name">IsLLQAck</span>(PktMsg *pkt)
{
    <span class="enscript-keyword">if</span> ((pkt-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask ) == (mDNSu8) ( kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery ) &amp;&amp;
        pkt-&gt;msg.h.numQuestions &amp;&amp; !pkt-&gt;msg.h.numAnswers &amp;&amp; !pkt-&gt;msg.h.numAuthorities) <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}


mDNSlocal mDNSBool
IsPublicSRV
(
    DaemonInfo  *   self,
    DNSQuestion *   q
)
{
    DNameListElem   *   elem;
    mDNSBool ret     = mDNSfalse;
    <span class="enscript-type">int</span> i       = ( <span class="enscript-type">int</span> ) DomainNameLength( &amp;q-&gt;qname ) - 1;

    <span class="enscript-keyword">for</span> ( elem = self-&gt;public_names; elem; elem = elem-&gt;next )
    {
        <span class="enscript-type">int</span> j = ( <span class="enscript-type">int</span> ) DomainNameLength( &amp;elem-&gt;name ) - 1;

        <span class="enscript-keyword">if</span> ( i &gt; j )
        {
            <span class="enscript-keyword">for</span> ( ; i &gt;= 0; i--, j-- )
            {
                <span class="enscript-keyword">if</span> ( q-&gt;qname.c[ i ] != elem-&gt;name.c[ j ] )
                {
                    ret = mDNStrue;
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                }
            }
        }
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> ret;
}


mDNSlocal <span class="enscript-type">void</span>
SetZone
(
    DaemonInfo  * self,
    PktMsg      * pkt
)
{
    domainname zname;
    <span class="enscript-type">const</span> mDNSu8    *   ptr = pkt-&gt;msg.data;
    mDNSBool exception = mDNSfalse;

    <span class="enscript-comment">// Initialize
</span>
    pkt-&gt;zone           = NULL;
    pkt-&gt;isZonePublic   = mDNStrue;
    zname.c[0]          = <span class="enscript-string">'\0'</span>;

    <span class="enscript-comment">// Figure out what type of packet this is
</span>
    <span class="enscript-keyword">if</span> ( IsQuery( pkt ) )
    {
        DNSQuestion question;

        <span class="enscript-comment">// It's a query
</span>
        getQuestion( &amp;pkt-&gt;msg, ptr, ( ( mDNSu8* ) &amp;pkt-&gt;msg ) + pkt-&gt;len, NULL, &amp;question );

        AppendDomainName( &amp;zname, &amp;question.qname );

        exception = ( ( question.qtype == kDNSType_SOA ) || ( question.qtype == kDNSType_NS ) || ( ( question.qtype == kDNSType_SRV ) &amp;&amp; IsPublicSRV( self, &amp;question ) ) );
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( IsUpdate( pkt ) )
    {
        DNSQuestion question;

        <span class="enscript-comment">// It's an update.  The format of the zone section is the same as the format for the question section
</span>        <span class="enscript-comment">// according to RFC 2136, so we'll just treat this as a question so we can get at the zone.
</span>
        getQuestion( &amp;pkt-&gt;msg, ptr, ( ( mDNSu8* ) &amp;pkt-&gt;msg ) + pkt-&gt;len, NULL, &amp;question );

        AppendDomainName( &amp;zname, &amp;question.qname );

        exception = mDNSfalse;
    }

    <span class="enscript-keyword">if</span> ( zname.c[0] != <span class="enscript-string">'\0'</span> )
    {
        <span class="enscript-comment">// Find the right zone
</span>
        <span class="enscript-keyword">for</span> ( pkt-&gt;zone = self-&gt;zones; pkt-&gt;zone; pkt-&gt;zone = pkt-&gt;zone-&gt;next )
        {
            <span class="enscript-keyword">if</span> ( ZoneHandlesName( &amp;pkt-&gt;zone-&gt;name, &amp;zname ) )
            {
                VLog( <span class="enscript-string">&quot;found correct zone %##s for query&quot;</span>, pkt-&gt;zone-&gt;name.c );

                pkt-&gt;isZonePublic = ( ( pkt-&gt;zone-&gt;type == kDNSZonePublic ) || exception );

                VLog( <span class="enscript-string">&quot;zone %##s is %s&quot;</span>, pkt-&gt;zone-&gt;name.c, ( pkt-&gt;isZonePublic ) ? <span class="enscript-string">&quot;public&quot;</span> : <span class="enscript-string">&quot;private&quot;</span> );

                <span class="enscript-keyword">break</span>;
            }
        }
    }
}


mDNSlocal <span class="enscript-type">int</span>
<span class="enscript-function-name">UDPServerTransaction</span>(<span class="enscript-type">const</span> DaemonInfo *d, <span class="enscript-type">const</span> PktMsg *request, PktMsg *reply, mDNSBool *trunc)
{
    fd_set rset;
    <span class="enscript-type">struct</span> timeval timeout = { 3, 0 };   <span class="enscript-comment">// until we remove all calls from main thread, keep timeout short
</span>    <span class="enscript-type">int</span> sd;
    <span class="enscript-type">int</span> res;
    mStatus err = mStatus_NoError;

    <span class="enscript-comment">// Initialize
</span>
    *trunc = mDNSfalse;

    <span class="enscript-comment">// Create a socket
</span>
    sd = socket( AF_INET, SOCK_DGRAM, 0 );
    require_action( sd &gt;= 0, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;UDPServerTransaction&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

    <span class="enscript-comment">// Send the packet to the nameserver
</span>
    VLog(<span class="enscript-string">&quot;UDPServerTransaction Q:%d A:%d A:%d A:%d &quot;</span>,
         ntohs(request-&gt;msg.h.numQuestions),
         ntohs(request-&gt;msg.h.numAnswers),
         ntohs(request-&gt;msg.h.numAuthorities),
         ntohs(request-&gt;msg.h.numAdditionals));
    res = sendto( sd, (<span class="enscript-type">char</span> *)&amp;request-&gt;msg, request-&gt;len, 0, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;d-&gt;ns_addr, <span class="enscript-keyword">sizeof</span>( d-&gt;ns_addr ) );
    require_action( res == (<span class="enscript-type">int</span>) request-&gt;len, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;UDPServerTransaction&quot;</span>, <span class="enscript-string">&quot;sendto&quot;</span> ) );

    <span class="enscript-comment">// Wait for reply
</span>
    FD_ZERO( &amp;rset );
    FD_SET( sd, &amp;rset );
    res = select( sd + 1, &amp;rset, NULL, NULL, &amp;timeout );
    require_action( res &gt;= 0, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;UDPServerTransaction&quot;</span>, <span class="enscript-string">&quot;select&quot;</span> ) );
    require_action( ( res &gt; 0 ) &amp;&amp; FD_ISSET( sd, &amp;rset ), exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;UDPServerTransaction - timeout&quot;</span> ) );

    <span class="enscript-comment">// Receive reply
</span>
    reply-&gt;len = recvfrom( sd, &amp;reply-&gt;msg, <span class="enscript-keyword">sizeof</span>(reply-&gt;msg), 0, NULL, NULL );
    require_action( ( ( <span class="enscript-type">int</span> ) reply-&gt;len ) &gt;= 0, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;UDPServerTransaction&quot;</span>, <span class="enscript-string">&quot;recvfrom&quot;</span> ) );
    require_action( reply-&gt;len &gt;= <span class="enscript-keyword">sizeof</span>( DNSMessageHeader ), exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;UDPServerTransaction - Message too short (%d bytes)&quot;</span>, reply-&gt;len ) );

    <span class="enscript-comment">// Check for truncation bit
</span>
    <span class="enscript-keyword">if</span> ( reply-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_TC )
    {
        *trunc = mDNStrue;
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( sd &gt;= 0 )
    {
        close( sd );
    }

    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Dynamic Update Utility Routines
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// check if a request and server response complete a successful dynamic update
</span>mDNSlocal mDNSBool <span class="enscript-function-name">SuccessfulUpdateTransaction</span>(PktMsg *request, PktMsg *reply)
{
    <span class="enscript-type">char</span> buf[32];
    <span class="enscript-type">char</span> *vlogmsg = NULL;

    <span class="enscript-comment">// check messages
</span>    <span class="enscript-keyword">if</span> (!request || !reply) { vlogmsg = <span class="enscript-string">&quot;NULL message&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>; }
    <span class="enscript-keyword">if</span> (request-&gt;len &lt; <span class="enscript-keyword">sizeof</span>(DNSMessageHeader) || reply-&gt;len &lt; <span class="enscript-keyword">sizeof</span>(DNSMessageHeader)) { vlogmsg = <span class="enscript-string">&quot;Malformatted message&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>; }

    <span class="enscript-comment">// check request operation
</span>    <span class="enscript-keyword">if</span> ((request-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask) != (request-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask))
    { vlogmsg = <span class="enscript-string">&quot;Request opcode not an update&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>; }

    <span class="enscript-comment">// check result
</span>    <span class="enscript-keyword">if</span> ((reply-&gt;msg.h.flags.b[1] &amp; kDNSFlag1_RC_Mask)) { vlogmsg = <span class="enscript-string">&quot;Reply contains non-zero rcode&quot;</span>;  <span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>; }
    <span class="enscript-keyword">if</span> ((reply-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask) != (kDNSFlag0_OP_Update | kDNSFlag0_QR_Response))
    { vlogmsg = <span class="enscript-string">&quot;Reply opcode not an update response&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>; }

    VLog(<span class="enscript-string">&quot;Successful update from %s&quot;</span>, inet_ntop(AF_INET, &amp;request-&gt;src.sin_addr, buf, 32));
    <span class="enscript-keyword">return</span> mDNStrue;

<span class="enscript-reference">failure</span>:
    VLog(<span class="enscript-string">&quot;Request %s: %s&quot;</span>, inet_ntop(AF_INET, &amp;request-&gt;src.sin_addr, buf, 32), vlogmsg);
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Allocate an appropriately sized CacheRecord and copy data from original.
</span><span class="enscript-comment">// Name pointer in CacheRecord object is set to point to the name specified
</span><span class="enscript-comment">//
</span>mDNSlocal CacheRecord *<span class="enscript-function-name">CopyCacheRecord</span>(<span class="enscript-type">const</span> CacheRecord *orig, domainname *name)
{
    CacheRecord *cr;
    size_t size = <span class="enscript-keyword">sizeof</span>(*cr);
    <span class="enscript-keyword">if</span> (orig-&gt;resrec.rdlength &gt; InlineCacheRDSize) size += orig-&gt;resrec.rdlength - InlineCacheRDSize;
    cr = malloc(size);
    <span class="enscript-keyword">if</span> (!cr) { LogErr(<span class="enscript-string">&quot;CopyCacheRecord&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span> NULL; }
    memcpy(cr, orig, size);
    cr-&gt;resrec.rdata = (RData*)&amp;cr-&gt;smallrdatastorage;
    cr-&gt;resrec.name = name;

    <span class="enscript-keyword">return</span> cr;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// Lease Hashtable Utility Routines
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// double hash table size
</span><span class="enscript-comment">// caller must lock table prior to invocation
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RehashTable</span>(DaemonInfo *d)
{
    RRTableElem *ptr, *tmp, **new;
    <span class="enscript-type">int</span> i, bucket, newnbuckets = d-&gt;nbuckets * 2;

    VLog(<span class="enscript-string">&quot;Rehashing lease table (new size %d buckets)&quot;</span>, newnbuckets);
    new = malloc(<span class="enscript-keyword">sizeof</span>(RRTableElem *) * newnbuckets);
    <span class="enscript-keyword">if</span> (!new) { LogErr(<span class="enscript-string">&quot;RehashTable&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>);  <span class="enscript-keyword">return</span>; }
    mDNSPlatformMemZero(new, newnbuckets * <span class="enscript-keyword">sizeof</span>(RRTableElem *));

    <span class="enscript-keyword">for</span> (i = 0; i &lt; d-&gt;nbuckets; i++)
    {
        ptr = d-&gt;table[i];
        <span class="enscript-keyword">while</span> (ptr)
        {
            bucket = ptr-&gt;rr.resrec.namehash % newnbuckets;
            tmp = ptr;
            ptr = ptr-&gt;next;
            tmp-&gt;next = new[bucket];
            new[bucket] = tmp;
        }
    }
    d-&gt;nbuckets = newnbuckets;
    free(d-&gt;table);
    d-&gt;table = new;
}

<span class="enscript-comment">// print entire contents of hashtable, invoked via SIGINFO
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintLeaseTable</span>(DaemonInfo *d)
{
    <span class="enscript-type">int</span> i;
    RRTableElem *ptr;
    <span class="enscript-type">char</span> rrbuf[MaxMsg], addrbuf[16];
    <span class="enscript-type">struct</span> timeval now;
    <span class="enscript-type">int</span> hr, min, sec;

    <span class="enscript-keyword">if</span> (gettimeofday(&amp;now, NULL)) { LogErr(<span class="enscript-string">&quot;PrintTable&quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (pthread_mutex_lock(&amp;d-&gt;tablelock)) { LogErr(<span class="enscript-string">&quot;PrintTable&quot;</span>, <span class="enscript-string">&quot;pthread_mutex_lock&quot;</span>); <span class="enscript-keyword">return</span>; }

    Log(<span class="enscript-string">&quot;Dumping Lease Table Contents (table contains %d resource records)&quot;</span>, d-&gt;nelems);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; d-&gt;nbuckets; i++)
    {
        <span class="enscript-keyword">for</span> (ptr = d-&gt;table[i]; ptr; ptr = ptr-&gt;next)
        {
            hr = ((ptr-&gt;expire - now.tv_sec) / 60) / 60;
            min = ((ptr-&gt;expire - now.tv_sec) / 60) % 60;
            sec = (ptr-&gt;expire - now.tv_sec) % 60;
            Log(<span class="enscript-string">&quot;Update from %s, Expires in %d:%d:%d\n\t%s&quot;</span>, inet_ntop(AF_INET, &amp;ptr-&gt;cli.sin_addr, addrbuf, 16), hr, min, sec,
                GetRRDisplayString_rdb(&amp;ptr-&gt;rr.resrec, &amp;ptr-&gt;rr.resrec.rdata-&gt;u, rrbuf));
        }
    }
    pthread_mutex_unlock(&amp;d-&gt;tablelock);
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Startup SRV Registration Routines
</span><span class="enscript-comment">// Register _dns-update._udp/_tcp.&lt;zone&gt; SRV records indicating the port on which
</span><span class="enscript-comment">// the daemon accepts requests
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// delete all RRS of a given name/type
</span>mDNSlocal mDNSu8 *<span class="enscript-function-name">putRRSetDeletion</span>(DNSMessage *msg, mDNSu8 *ptr, mDNSu8 *limit,  ResourceRecord *rr)
{
    ptr = putDomainNameAsLabels(msg, ptr, limit, rr-&gt;name);
    <span class="enscript-keyword">if</span> (!ptr || ptr + 10 &gt;= limit) <span class="enscript-keyword">return</span> NULL;  <span class="enscript-comment">// out of space
</span>    ptr[0] = (mDNSu8)(rr-&gt;rrtype  &gt;&gt; 8);
    ptr[1] = (mDNSu8)(rr-&gt;rrtype  &amp;  0xFF);
    ptr[2] = (mDNSu8)((mDNSu16)kDNSQClass_ANY &gt;&gt; 8);
    ptr[3] = (mDNSu8)((mDNSu16)kDNSQClass_ANY &amp;  0xFF);
    mDNSPlatformMemZero(ptr+4, <span class="enscript-keyword">sizeof</span>(rr-&gt;rroriginalttl) + <span class="enscript-keyword">sizeof</span>(rr-&gt;rdlength)); <span class="enscript-comment">// zero ttl/rdata
</span>    msg-&gt;h.mDNS_numUpdates++;
    <span class="enscript-keyword">return</span> ptr + 10;
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">PutUpdateSRV</span>(DaemonInfo *d, DNSZone * zone, PktMsg *pkt, mDNSu8 *ptr, <span class="enscript-type">char</span> *regtype, mDNSIPPort port, mDNSBool registration)
{
    AuthRecord rr;
    <span class="enscript-type">char</span> hostname[1024], buf[MaxMsg];
    mDNSu8 *end = (mDNSu8 *)&amp;pkt-&gt;msg + <span class="enscript-keyword">sizeof</span>(DNSMessage);

    ( <span class="enscript-type">void</span> ) d;

    mDNS_SetupResourceRecord(&amp;rr, NULL, 0, kDNSType_SRV, SRV_TTL, kDNSRecordTypeUnique, AuthRecordAny, NULL, NULL);
    rr.resrec.rrclass = kDNSClass_IN;
    rr.resrec.rdata-&gt;u.srv.priority = 0;
    rr.resrec.rdata-&gt;u.srv.weight   = 0;
    rr.resrec.rdata-&gt;u.srv.port     = port;
    <span class="enscript-keyword">if</span> (gethostname(hostname, 1024) &lt; 0 || !MakeDomainNameFromDNSNameString(&amp;rr.resrec.rdata-&gt;u.srv.target, hostname))
        rr.resrec.rdata-&gt;u.srv.target.c[0] = <span class="enscript-string">'\0'</span>;

    MakeDomainNameFromDNSNameString(&amp;rr.namestorage, regtype);
    AppendDomainName(&amp;rr.namestorage, &amp;zone-&gt;name);
    VLog(<span class="enscript-string">&quot;%s  %s&quot;</span>, registration ? <span class="enscript-string">&quot;Registering SRV record&quot;</span> : <span class="enscript-string">&quot;Deleting existing RRSet&quot;</span>,
         GetRRDisplayString_rdb(&amp;rr.resrec, &amp;rr.resrec.rdata-&gt;u, buf));
    <span class="enscript-keyword">if</span> (registration) ptr = PutResourceRecord(&amp;pkt-&gt;msg, ptr, &amp;pkt-&gt;msg.h.mDNS_numUpdates, &amp;rr.resrec);
    <span class="enscript-keyword">else</span> ptr = putRRSetDeletion(&amp;pkt-&gt;msg, ptr, end, &amp;rr.resrec);
    <span class="enscript-keyword">return</span> ptr;
}


<span class="enscript-comment">// perform dynamic update.
</span><span class="enscript-comment">// specify deletion by passing false for the register parameter, otherwise register the records.
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">UpdateSRV</span>(DaemonInfo *d, mDNSBool registration)
{
    TCPSocket *sock = NULL;
    DNSZone * zone;
    <span class="enscript-type">int</span> err = mStatus_NoError;

    sock = ConnectToServer( d );
    require_action( sock, exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;UpdateSRV: ConnectToServer failed&quot;</span> ) );

    <span class="enscript-keyword">for</span> ( zone = d-&gt;zones; zone; zone = zone-&gt;next )
    {
        PktMsg pkt;
        mDNSu8 *ptr = pkt.msg.data;
        mDNSu8 *end = (mDNSu8 *)&amp;pkt.msg + <span class="enscript-keyword">sizeof</span>(DNSMessage);
        PktMsg *reply = NULL;
        mDNSBool closed;
        mDNSBool ok;

        <span class="enscript-comment">// Initialize message
</span>        InitializeDNSMessage(&amp;pkt.msg.h, zeroID, UpdateReqFlags);
        pkt.src.sin_addr.s_addr = zerov4Addr.NotAnInteger; <span class="enscript-comment">// address field set solely for verbose logging in subroutines
</span>        pkt.src.sin_family = AF_INET;

        <span class="enscript-comment">// format message body
</span>        ptr = putZone(&amp;pkt.msg, ptr, end, &amp;zone-&gt;name, mDNSOpaque16fromIntVal(kDNSClass_IN));
        require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );

        <span class="enscript-keyword">if</span> ( zone-&gt;type == kDNSZonePrivate )
        {
            ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-update-tls._tcp.&quot;</span>, d-&gt;private_port, registration);
            require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
            ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-query-tls._tcp.&quot;</span>, d-&gt;private_port, registration);
            require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
            ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-llq-tls._tcp.&quot;</span>, d-&gt;private_port, registration);
            require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );

            <span class="enscript-keyword">if</span> ( !registration )
            {
                ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-update._udp.&quot;</span>, d-&gt;llq_port, registration);
                require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
                ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-llq._udp.&quot;</span>, d-&gt;llq_port, registration);
                require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> ( !registration )
            {
                ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-update-tls.&quot;</span>, d-&gt;private_port, registration);
                require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
                ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-query-tls.&quot;</span>, d-&gt;private_port, registration);
                require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
                ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-llq-tls.&quot;</span>, d-&gt;private_port, registration);
                require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
            }

            ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-update._udp.&quot;</span>, d-&gt;llq_port, registration);
            require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
            ptr = PutUpdateSRV(d, zone, &amp;pkt, ptr, <span class="enscript-string">&quot;_dns-llq._udp.&quot;</span>, d-&gt;llq_port, registration);
            require_action( ptr, exit, err = mStatus_UnknownErr; Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
        }

        HdrHToN(&amp;pkt);

        <span class="enscript-keyword">if</span> ( zone-&gt;updateKeys )
        {
            DNSDigest_SignMessage( &amp;pkt.msg, &amp;ptr, zone-&gt;updateKeys, 0 );
            require_action( ptr, exit, Log(<span class="enscript-string">&quot;UpdateSRV: Error constructing lease expiration update&quot;</span> ) );
        }

        pkt.len = ptr - (mDNSu8 *)&amp;pkt.msg;

        <span class="enscript-comment">// send message, receive reply
</span>
        err = SendPacket( sock, &amp;pkt );
        require_action( !err, exit, Log( <span class="enscript-string">&quot;UpdateSRV: SendPacket failed&quot;</span> ) );

        reply = RecvPacket( sock, NULL, &amp;closed );
        require_action( reply, exit, err = mStatus_UnknownErr; Log( <span class="enscript-string">&quot;UpdateSRV: RecvPacket returned NULL&quot;</span> ) );

        ok = SuccessfulUpdateTransaction( &amp;pkt, reply );

        <span class="enscript-keyword">if</span> ( !ok )
        {
            Log(<span class="enscript-string">&quot;SRV record registration failed with rcode %d&quot;</span>, reply-&gt;msg.h.flags.b[1] &amp; kDNSFlag1_RC_Mask);
        }

        free( reply );
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( sock )
    {
        mDNSPlatformTCPCloseConnection( sock );
    }

    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">// wrapper routines/macros
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">ClearUpdateSRV</span>(d) UpdateSRV(d, 0)

<span class="enscript-comment">// clear any existing records prior to registration
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">SetUpdateSRV</span>(DaemonInfo *d)
{
    <span class="enscript-type">int</span> err;

    err = ClearUpdateSRV(d);         <span class="enscript-comment">// clear any existing record
</span>    <span class="enscript-keyword">if</span> (!err) err = UpdateSRV(d, 1);
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Argument Parsing and Configuration
</span><span class="enscript-comment">//
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintUsage</span>(<span class="enscript-type">void</span>)
{
    fprintf(stderr, <span class="enscript-string">&quot;Usage: dnsextd [-f &lt;config file&gt;] [-vhd] ...\n&quot;</span>
            <span class="enscript-string">&quot;Use \&quot;dnsextd -h\&quot; for help\n&quot;</span>);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintHelp</span>(<span class="enscript-type">void</span>)
{
    fprintf(stderr, <span class="enscript-string">&quot;\n\n&quot;</span>);
    PrintUsage();

    fprintf(stderr,
            <span class="enscript-string">&quot;dnsextd is a daemon that implements DNS extensions supporting Dynamic DNS Update Leases\n&quot;</span>
            <span class="enscript-string">&quot;and Long Lived Queries, used in Wide-Area DNS Service Discovery, on behalf of name servers\n&quot;</span>
            <span class="enscript-string">&quot;that do not natively support these extensions.  (See dns-sd.org for more info on DNS Service\n&quot;</span>
            <span class="enscript-string">&quot;Discovery, Update Leases, and Long Lived Queries.)\n\n&quot;</span>

            <span class="enscript-string">&quot;dnsextd requires one argument,the zone, which is the domain for which Update Leases\n&quot;</span>
            <span class="enscript-string">&quot;and Long Lived Queries are to be administered.  dnsextd communicates directly with the\n&quot;</span>
            <span class="enscript-string">&quot;primary master server for this zone.\n\n&quot;</span>

            <span class="enscript-string">&quot;The options are as follows:\n\n&quot;</span>

            <span class="enscript-string">&quot;-f    Specify configuration file. The default is /etc/dnsextd.conf.\n\n&quot;</span>

            <span class="enscript-string">&quot;-d    Run daemon in foreground.\n\n&quot;</span>

            <span class="enscript-string">&quot;-h    Print help.\n\n&quot;</span>

            <span class="enscript-string">&quot;-v    Verbose output.\n\n&quot;</span>
            );
}


<span class="enscript-comment">// Note: ProcessArgs called before process is daemonized, and therefore must open no descriptors
</span><span class="enscript-comment">// returns 0 (success) if program is to continue execution
</span><span class="enscript-comment">// output control arguments (-f, -v) do not affect this routine
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">ProcessArgs</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[], DaemonInfo *d)
{
    DNSZone *   zone;
    <span class="enscript-type">int</span> opt;
    <span class="enscript-type">int</span> err = 0;

    cfgfile = strdup( CONFIG_FILE );
    require_action( cfgfile, arg_error, err = mStatus_NoMemoryErr );

    <span class="enscript-comment">// defaults, may be overriden by command option
</span>
    <span class="enscript-comment">// setup our sockaddr
</span>
    mDNSPlatformMemZero( &amp;d-&gt;addr, <span class="enscript-keyword">sizeof</span>( d-&gt;addr ) );
    d-&gt;addr.sin_addr.s_addr = zerov4Addr.NotAnInteger;
    d-&gt;addr.sin_port        = UnicastDNSPort.NotAnInteger;
    d-&gt;addr.sin_family      = AF_INET;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NOT_HAVE_SA_LEN</span>
    d-&gt;addr.sin_len         = <span class="enscript-keyword">sizeof</span>( d-&gt;addr );
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// setup nameserver's sockaddr
</span>
    mDNSPlatformMemZero(&amp;d-&gt;ns_addr, <span class="enscript-keyword">sizeof</span>(d-&gt;ns_addr));
    d-&gt;ns_addr.sin_family   = AF_INET;
    inet_pton( AF_INET, LOOPBACK, &amp;d-&gt;ns_addr.sin_addr );
    d-&gt;ns_addr.sin_port     = NSIPCPort.NotAnInteger;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NOT_HAVE_SA_LEN</span>
    d-&gt;ns_addr.sin_len      = <span class="enscript-keyword">sizeof</span>( d-&gt;ns_addr );
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// setup our ports
</span>
    d-&gt;private_port = PrivateDNSPort;
    d-&gt;llq_port     = DNSEXTPort;

    <span class="enscript-keyword">while</span> ((opt = getopt(argc, argv, <span class="enscript-string">&quot;f:hdv&quot;</span>)) != -1)
    {
        <span class="enscript-keyword">switch</span>(opt)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>: free( cfgfile ); cfgfile = strdup( optarg ); require_action( cfgfile, arg_error, err = mStatus_NoMemoryErr ); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>: PrintHelp();    <span class="enscript-keyword">return</span> -1;
        <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>: foreground = 1; <span class="enscript-keyword">break</span>;            <span class="enscript-comment">// Also used when launched via OS X's launchd mechanism
</span>        <span class="enscript-keyword">case</span> <span class="enscript-string">'v'</span>: verbose = 1;    <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:  <span class="enscript-keyword">goto</span> <span class="enscript-reference">arg_error</span>;
        }
    }

    err = ParseConfig( d, cfgfile );
    require_noerr( err, arg_error );

    <span class="enscript-comment">// Make sure we've specified some zones
</span>
    require_action( d-&gt;zones, arg_error, err = mStatus_UnknownErr );

    <span class="enscript-comment">// if we have a shared secret, use it for the entire zone
</span>
    <span class="enscript-keyword">for</span> ( zone = d-&gt;zones; zone; zone = zone-&gt;next )
    {
        <span class="enscript-keyword">if</span> ( zone-&gt;updateKeys )
        {
            AssignDomainName( &amp;zone-&gt;updateKeys-&gt;domain, &amp;zone-&gt;name );
        }
    }

    <span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">arg_error</span>:

    PrintUsage();
    <span class="enscript-keyword">return</span> -1;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// Initialization Routines
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// Allocate memory, initialize locks and bookkeeping variables
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">InitLeaseTable</span>(DaemonInfo *d)
{
    <span class="enscript-keyword">if</span> (pthread_mutex_init(&amp;d-&gt;tablelock, NULL)) { LogErr(<span class="enscript-string">&quot;InitLeaseTable&quot;</span>, <span class="enscript-string">&quot;pthread_mutex_init&quot;</span>); <span class="enscript-keyword">return</span> -1; }
    d-&gt;nbuckets = LEASETABLE_INIT_NBUCKETS;
    d-&gt;nelems = 0;
    d-&gt;table = malloc(<span class="enscript-keyword">sizeof</span>(RRTableElem *) * LEASETABLE_INIT_NBUCKETS);
    <span class="enscript-keyword">if</span> (!d-&gt;table) { LogErr(<span class="enscript-string">&quot;InitLeaseTable&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span> -1; }
    mDNSPlatformMemZero(d-&gt;table, <span class="enscript-keyword">sizeof</span>(RRTableElem *) * LEASETABLE_INIT_NBUCKETS);
    <span class="enscript-keyword">return</span> 0;
}


mDNSlocal <span class="enscript-type">int</span>
SetupSockets
(
    DaemonInfo * self
)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> kOn = 1;
    <span class="enscript-type">int</span> sockpair[2];
    mDNSBool private = mDNSfalse;
    <span class="enscript-type">struct</span> sockaddr_in daddr;
    DNSZone         *   zone;
    mStatus err = 0;

    <span class="enscript-comment">// set up sockets on which we all ns requests
</span>
    self-&gt;tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
    require_action( dnssd_SocketValid(self-&gt;tcpsd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_REUSEADDR</span>)
    err = setsockopt(self-&gt;tcpsd, SOL_SOCKET, SO_REUSEADDR, &amp;kOn, <span class="enscript-keyword">sizeof</span>(kOn));
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;SO_REUSEADDR self-&gt;tcpsd&quot;</span> ) );
#<span class="enscript-reference">endif</span>

    err = bind( self-&gt;tcpsd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;self-&gt;addr, <span class="enscript-keyword">sizeof</span>( self-&gt;addr ) );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;bind self-&gt;tcpsd&quot;</span> ) );

    err = listen( self-&gt;tcpsd, LISTENQ );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;listen&quot;</span> ) );

    self-&gt;udpsd = socket( AF_INET, SOCK_DGRAM, 0 );
    require_action( dnssd_SocketValid(self-&gt;udpsd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_REUSEADDR</span>)
    err = setsockopt(self-&gt;udpsd, SOL_SOCKET, SO_REUSEADDR, &amp;kOn, <span class="enscript-keyword">sizeof</span>(kOn));
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;SO_REUSEADDR self-&gt;udpsd&quot;</span> ) );
#<span class="enscript-reference">endif</span>

    err = bind( self-&gt;udpsd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;self-&gt;addr, <span class="enscript-keyword">sizeof</span>( self-&gt;addr ) );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;bind self-&gt;udpsd&quot;</span> ) );

    <span class="enscript-comment">// set up sockets on which we receive llq requests
</span>
    mDNSPlatformMemZero(&amp;self-&gt;llq_addr, <span class="enscript-keyword">sizeof</span>(self-&gt;llq_addr));
    self-&gt;llq_addr.sin_family       = AF_INET;
    self-&gt;llq_addr.sin_addr.s_addr  = zerov4Addr.NotAnInteger;
    self-&gt;llq_addr.sin_port         = ( self-&gt;llq_port.NotAnInteger ) ? self-&gt;llq_port.NotAnInteger : DNSEXTPort.NotAnInteger;

    <span class="enscript-keyword">if</span> (self-&gt;llq_addr.sin_port == self-&gt;addr.sin_port)
    {
        self-&gt;llq_tcpsd = self-&gt;tcpsd;
        self-&gt;llq_udpsd = self-&gt;udpsd;
    }
    <span class="enscript-keyword">else</span>
    {
        self-&gt;llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
        require_action( dnssd_SocketValid(self-&gt;llq_tcpsd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_REUSEADDR</span>)
        err = setsockopt(self-&gt;llq_tcpsd, SOL_SOCKET, SO_REUSEADDR, &amp;kOn, <span class="enscript-keyword">sizeof</span>(kOn));
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;SO_REUSEADDR self-&gt;llq_tcpsd&quot;</span> ) );
#<span class="enscript-reference">endif</span>

        err = bind( self-&gt;llq_tcpsd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;self-&gt;llq_addr, <span class="enscript-keyword">sizeof</span>( self-&gt;llq_addr ) );
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;bind self-&gt;llq_tcpsd&quot;</span> ) );

        err = listen( self-&gt;llq_tcpsd, LISTENQ );
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;listen&quot;</span> ) );

        self-&gt;llq_udpsd = socket( AF_INET, SOCK_DGRAM, 0 );
        require_action( dnssd_SocketValid(self-&gt;llq_udpsd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_REUSEADDR</span>)
        err = setsockopt(self-&gt;llq_udpsd, SOL_SOCKET, SO_REUSEADDR, &amp;kOn, <span class="enscript-keyword">sizeof</span>(kOn));
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;SO_REUSEADDR self-&gt;llq_udpsd&quot;</span> ) );
#<span class="enscript-reference">endif</span>

        err = bind(self-&gt;llq_udpsd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;self-&gt;llq_addr, <span class="enscript-keyword">sizeof</span>( self-&gt;llq_addr ) );
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;bind self-&gt;llq_udpsd&quot;</span> ) );
    }

    <span class="enscript-comment">// set up Unix domain socket pair for LLQ polling thread to signal main thread that a change to the zone occurred
</span>
    err = socketpair( AF_LOCAL, SOCK_STREAM, 0, sockpair );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socketpair&quot;</span> ) );

    self-&gt;LLQEventListenSock = sockpair[0];
    self-&gt;LLQEventNotifySock = sockpair[1];

    <span class="enscript-comment">// set up socket on which we receive private requests
</span>
    self-&gt;llq_tcpsd = socket( AF_INET, SOCK_STREAM, 0 );
    require_action( dnssd_SocketValid(self-&gt;tlssd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );
    mDNSPlatformMemZero(&amp;daddr, <span class="enscript-keyword">sizeof</span>(daddr));
    daddr.sin_family        = AF_INET;
    daddr.sin_addr.s_addr   = zerov4Addr.NotAnInteger;
    daddr.sin_port          = ( self-&gt;private_port.NotAnInteger ) ? self-&gt;private_port.NotAnInteger : PrivateDNSPort.NotAnInteger;

    self-&gt;tlssd = socket( AF_INET, SOCK_STREAM, 0 );
    require_action( dnssd_SocketValid(self-&gt;tlssd), exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;socket&quot;</span> ) );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SO_REUSEADDR</span>)
    err = setsockopt(self-&gt;tlssd, SOL_SOCKET, SO_REUSEADDR, &amp;kOn, <span class="enscript-keyword">sizeof</span>(kOn));
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;SO_REUSEADDR self-&gt;tlssd&quot;</span> ) );
#<span class="enscript-reference">endif</span>

    err = bind( self-&gt;tlssd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;daddr, <span class="enscript-keyword">sizeof</span>( daddr ) );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;bind self-&gt;tlssd&quot;</span> ) );

    err = listen( self-&gt;tlssd, LISTENQ );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;listen&quot;</span> ) );

    <span class="enscript-comment">// Do we have any private zones?
</span>
    <span class="enscript-keyword">for</span> ( zone = self-&gt;zones; zone; zone = zone-&gt;next )
    {
        <span class="enscript-keyword">if</span> ( zone-&gt;type == kDNSZonePrivate )
        {
            private = mDNStrue;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span> ( private )
    {
        err = mDNSPlatformTLSSetupCerts();
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;SetupSockets&quot;</span>, <span class="enscript-string">&quot;mDNSPlatformTLSSetupCerts&quot;</span> ) );
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// periodic table updates
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// Delete a resource record from the nameserver via a dynamic update
</span><span class="enscript-comment">// sd is a socket already connected to the server
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeleteOneRecord</span>(DaemonInfo *d, CacheRecord *rr, domainname *zname, TCPSocket *sock)
{
    DNSZone *   zone;
    PktMsg pkt;
    mDNSu8 *ptr = pkt.msg.data;
    mDNSu8 *end = (mDNSu8 *)&amp;pkt.msg + <span class="enscript-keyword">sizeof</span>(DNSMessage);
    <span class="enscript-type">char</span> buf[MaxMsg];
    mDNSBool closed;
    PktMsg *reply = NULL;

    VLog(<span class="enscript-string">&quot;Expiring record %s&quot;</span>, GetRRDisplayString_rdb(&amp;rr-&gt;resrec, &amp;rr-&gt;resrec.rdata-&gt;u, buf));

    InitializeDNSMessage(&amp;pkt.msg.h, zeroID, UpdateReqFlags);

    ptr = putZone(&amp;pkt.msg, ptr, end, zname, mDNSOpaque16fromIntVal(rr-&gt;resrec.rrclass));
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
    ptr = putDeletionRecord(&amp;pkt.msg, ptr, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

    HdrHToN(&amp;pkt);

    zone = FindZone( d, zname );

    <span class="enscript-keyword">if</span> ( zone &amp;&amp; zone-&gt;updateKeys)
    {
        DNSDigest_SignMessage(&amp;pkt.msg, &amp;ptr, zone-&gt;updateKeys, 0 );
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
    }

    pkt.len = ptr - (mDNSu8 *)&amp;pkt.msg;
    pkt.src.sin_addr.s_addr = zerov4Addr.NotAnInteger; <span class="enscript-comment">// address field set solely for verbose logging in subroutines
</span>    pkt.src.sin_family = AF_INET;
    <span class="enscript-keyword">if</span> (SendPacket( sock, &amp;pkt)) { Log(<span class="enscript-string">&quot;DeleteOneRecord: SendPacket failed&quot;</span>); }
    reply = RecvPacket( sock, NULL, &amp;closed );
    <span class="enscript-keyword">if</span> (reply) HdrNToH(reply);
    require_action( reply, end, Log( <span class="enscript-string">&quot;DeleteOneRecord: RecvPacket returned NULL&quot;</span> ) );

    <span class="enscript-keyword">if</span> (!SuccessfulUpdateTransaction(&amp;pkt, reply))
        Log(<span class="enscript-string">&quot;Expiration update failed with rcode %d&quot;</span>, reply ? reply-&gt;msg.h.flags.b[1] &amp; kDNSFlag1_RC_Mask : -1);

<span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (!ptr) { Log(<span class="enscript-string">&quot;DeleteOneRecord: Error constructing lease expiration update&quot;</span>); }
    <span class="enscript-keyword">if</span> (reply) free(reply);
}

<span class="enscript-comment">// iterate over table, deleting expired records (or all records if DeleteAll is true)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeleteRecords</span>(DaemonInfo *d, mDNSBool DeleteAll)
{
    <span class="enscript-type">struct</span> timeval now;
    <span class="enscript-type">int</span> i;
    TCPSocket *sock = ConnectToServer(d);
    <span class="enscript-keyword">if</span> (!sock) { Log(<span class="enscript-string">&quot;DeleteRecords: ConnectToServer failed&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (gettimeofday(&amp;now, NULL)) { LogErr(<span class="enscript-string">&quot;DeleteRecords &quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (pthread_mutex_lock(&amp;d-&gt;tablelock)) { LogErr(<span class="enscript-string">&quot;DeleteRecords&quot;</span>, <span class="enscript-string">&quot;pthread_mutex_lock&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; d-&gt;nbuckets; i++)
    {
        RRTableElem **ptr = &amp;d-&gt;table[i];
        <span class="enscript-keyword">while</span> (*ptr)
        {
            <span class="enscript-keyword">if</span> (DeleteAll || (*ptr)-&gt;expire - now.tv_sec &lt; 0)
            {
                RRTableElem *fptr;
                <span class="enscript-comment">// delete record from server
</span>                DeleteOneRecord(d, &amp;(*ptr)-&gt;rr, &amp;(*ptr)-&gt;zone, sock);
                fptr = *ptr;
                *ptr = (*ptr)-&gt;next;
                free(fptr);
                d-&gt;nelems--;
            }
            <span class="enscript-keyword">else</span> ptr = &amp;(*ptr)-&gt;next;
        }
    }
    pthread_mutex_unlock(&amp;d-&gt;tablelock);
    mDNSPlatformTCPCloseConnection( sock );
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// main update request handling
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// Add, delete, or refresh records in table based on contents of a successfully completed dynamic update
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateLeaseTable</span>(PktMsg *pkt, DaemonInfo *d, mDNSs32 lease)
{
    <span class="enscript-type">int</span> i, allocsize;
    LargeCacheRecord lcr;
    ResourceRecord *rr = &amp;lcr.r.resrec;
    <span class="enscript-type">const</span> mDNSu8 *ptr, *end;
    <span class="enscript-type">struct</span> timeval tv;
    DNSQuestion zone;
    <span class="enscript-type">char</span> buf[MaxMsg];

    <span class="enscript-keyword">if</span> (pthread_mutex_lock(&amp;d-&gt;tablelock)) { LogErr(<span class="enscript-string">&quot;UpdateLeaseTable&quot;</span>, <span class="enscript-string">&quot;pthread_mutex_lock&quot;</span>); <span class="enscript-keyword">return</span>; }
    HdrNToH(pkt);
    ptr = pkt-&gt;msg.data;
    end = (mDNSu8 *)&amp;pkt-&gt;msg + pkt-&gt;len;
    ptr = getQuestion(&amp;pkt-&gt;msg, ptr, end, 0, &amp;zone);
    <span class="enscript-keyword">if</span> (!ptr) { Log(<span class="enscript-string">&quot;UpdateLeaseTable: cannot read zone&quot;</span>);  <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }
    ptr = LocateAuthorities(&amp;pkt-&gt;msg, end);
    <span class="enscript-keyword">if</span> (!ptr) { Log(<span class="enscript-string">&quot;UpdateLeaseTable: Format error&quot;</span>);  <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; pkt-&gt;msg.h.mDNS_numUpdates; i++)
    {
        mDNSBool DeleteAllRRSets = mDNSfalse, DeleteOneRRSet = mDNSfalse, DeleteOneRR = mDNSfalse;

        ptr = GetLargeResourceRecord(NULL, &amp;pkt-&gt;msg, ptr, end, 0, kDNSRecordTypePacketAns, &amp;lcr);
        <span class="enscript-keyword">if</span> (!ptr || lcr.r.resrec.RecordType == kDNSRecordTypePacketNegative) { Log(<span class="enscript-string">&quot;UpdateLeaseTable: GetLargeResourceRecord failed&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }
        <span class="enscript-type">int</span> bucket = rr-&gt;namehash % d-&gt;nbuckets;
        RRTableElem *tmp, **rptr = &amp;d-&gt;table[bucket];

        <span class="enscript-comment">// handle deletions
</span>        <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSQType_ANY &amp;&amp; !rr-&gt;rroriginalttl &amp;&amp; rr-&gt;rrclass == kDNSQClass_ANY &amp;&amp; !rr-&gt;rdlength)
            DeleteAllRRSets = mDNStrue; <span class="enscript-comment">// delete all rrsets for a name
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!rr-&gt;rroriginalttl &amp;&amp; rr-&gt;rrclass == kDNSQClass_ANY &amp;&amp; !rr-&gt;rdlength)
            DeleteOneRRSet = mDNStrue;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!rr-&gt;rroriginalttl &amp;&amp; rr-&gt;rrclass == kDNSClass_NONE)
            DeleteOneRR = mDNStrue;

        <span class="enscript-keyword">if</span> (DeleteAllRRSets || DeleteOneRRSet || DeleteOneRR)
        {
            <span class="enscript-keyword">while</span> (*rptr)
            {
                <span class="enscript-keyword">if</span> (SameDomainName((*rptr)-&gt;rr.resrec.name, rr-&gt;name) &amp;&amp;
                    (DeleteAllRRSets ||
                     (DeleteOneRRSet &amp;&amp; (*rptr)-&gt;rr.resrec.rrtype == rr-&gt;rrtype) ||
                     (DeleteOneRR &amp;&amp; IdenticalResourceRecord(&amp;(*rptr)-&gt;rr.resrec, rr))))
                {
                    tmp = *rptr;
                    VLog(<span class="enscript-string">&quot;Received deletion update for %s&quot;</span>, GetRRDisplayString_rdb(&amp;tmp-&gt;rr.resrec, &amp;tmp-&gt;rr.resrec.rdata-&gt;u, buf));
                    *rptr = (*rptr)-&gt;next;
                    free(tmp);
                    d-&gt;nelems--;
                }
                <span class="enscript-keyword">else</span> rptr = &amp;(*rptr)-&gt;next;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lease &gt; 0)
        {
            <span class="enscript-comment">// see if add or refresh
</span>            <span class="enscript-keyword">while</span> (*rptr &amp;&amp; !IdenticalResourceRecord(&amp;(*rptr)-&gt;rr.resrec, rr)) rptr = &amp;(*rptr)-&gt;next;
            <span class="enscript-keyword">if</span> (*rptr)
            {
                <span class="enscript-comment">// refresh
</span>                <span class="enscript-keyword">if</span> (gettimeofday(&amp;tv, NULL)) { LogErr(<span class="enscript-string">&quot;UpdateLeaseTable&quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }
                (*rptr)-&gt;expire = tv.tv_sec + (<span class="enscript-type">unsigned</span>)lease;
                VLog(<span class="enscript-string">&quot;Refreshing lease for %s&quot;</span>, GetRRDisplayString_rdb(&amp;lcr.r.resrec, &amp;lcr.r.resrec.rdata-&gt;u, buf));
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// New record - add to table
</span>                <span class="enscript-keyword">if</span> (d-&gt;nelems &gt; d-&gt;nbuckets)
                {
                    RehashTable(d);
                    bucket = rr-&gt;namehash % d-&gt;nbuckets;
                }
                <span class="enscript-keyword">if</span> (gettimeofday(&amp;tv, NULL)) { LogErr(<span class="enscript-string">&quot;UpdateLeaseTable&quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }
                allocsize = <span class="enscript-keyword">sizeof</span>(RRTableElem);
                <span class="enscript-keyword">if</span> (rr-&gt;rdlength &gt; InlineCacheRDSize) allocsize += (rr-&gt;rdlength - InlineCacheRDSize);
                tmp = malloc(allocsize);
                <span class="enscript-keyword">if</span> (!tmp) { LogErr(<span class="enscript-string">&quot;UpdateLeaseTable&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>; }
                memcpy(&amp;tmp-&gt;rr, &amp;lcr.r, <span class="enscript-keyword">sizeof</span>(CacheRecord) + rr-&gt;rdlength - InlineCacheRDSize);
                tmp-&gt;rr.resrec.rdata = (RData *)&amp;tmp-&gt;rr.smallrdatastorage;
                AssignDomainName(&amp;tmp-&gt;name, rr-&gt;name);
                tmp-&gt;rr.resrec.name = &amp;tmp-&gt;name;
                tmp-&gt;expire = tv.tv_sec + (<span class="enscript-type">unsigned</span>)lease;
                tmp-&gt;cli.sin_addr = pkt-&gt;src.sin_addr;
                AssignDomainName(&amp;tmp-&gt;zone, &amp;zone.qname);
                tmp-&gt;next = d-&gt;table[bucket];
                d-&gt;table[bucket] = tmp;
                d-&gt;nelems++;
                VLog(<span class="enscript-string">&quot;Adding update for %s to lease table&quot;</span>, GetRRDisplayString_rdb(&amp;lcr.r.resrec, &amp;lcr.r.resrec.rdata-&gt;u, buf));
            }
        }
    }

<span class="enscript-reference">cleanup</span>:
    pthread_mutex_unlock(&amp;d-&gt;tablelock);
    HdrHToN(pkt);
}

<span class="enscript-comment">// Given a successful reply from a server, create a new reply that contains lease information
</span><span class="enscript-comment">// Replies are currently not signed !!!KRS change this
</span>mDNSlocal PktMsg *<span class="enscript-function-name">FormatLeaseReply</span>(DaemonInfo *d, PktMsg *orig, mDNSu32 lease)
{
    PktMsg *<span class="enscript-type">const</span> reply = malloc(<span class="enscript-keyword">sizeof</span>(*reply));
    mDNSu8 *ptr;
    mDNSOpaque16 flags;
    (<span class="enscript-type">void</span>)d;  <span class="enscript-comment">//unused
</span>    
    <span class="enscript-keyword">if</span> (!reply) { LogErr(<span class="enscript-string">&quot;FormatLeaseReply&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span> NULL; }
    flags.b[0] = kDNSFlag0_QR_Response | kDNSFlag0_OP_Update;
    flags.b[1] = 0;

    InitializeDNSMessage(&amp;reply-&gt;msg.h, orig-&gt;msg.h.id, flags);
    reply-&gt;src.sin_addr.s_addr = zerov4Addr.NotAnInteger;            <span class="enscript-comment">// unused except for log messages
</span>    reply-&gt;src.sin_family = AF_INET;
    ptr = putUpdateLease(&amp;reply-&gt;msg, reply-&gt;msg.data, lease);
    <span class="enscript-keyword">if</span> (!ptr) { Log(<span class="enscript-string">&quot;FormatLeaseReply: putUpdateLease failed&quot;</span>); free(reply); <span class="enscript-keyword">return</span> NULL; }
    reply-&gt;len = ptr - (mDNSu8 *)&amp;reply-&gt;msg;
    HdrHToN(reply);
    <span class="enscript-keyword">return</span> reply;
}


<span class="enscript-comment">// pkt is thread-local, not requiring locking
</span>
mDNSlocal PktMsg*
HandleRequest
(
    DaemonInfo  *   self,
    PktMsg      *   request
)
{
    PktMsg      *   reply = NULL;
    PktMsg      *   leaseReply;
    PktMsg buf;
    <span class="enscript-type">char</span> addrbuf[32];
    TCPSocket * sock = NULL;
    mStatus err;
    mDNSu32 lease = 0;
    mDNSBool gotlease;
    <span class="enscript-keyword">if</span> ((request-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask) == kDNSFlag0_OP_Update)
    {
        <span class="enscript-type">int</span> i, adds = 0, dels = 0;
        <span class="enscript-type">const</span> mDNSu8 *ptr, *end = (mDNSu8 *)&amp;request-&gt;msg + request-&gt;len;
        HdrNToH(request);
        gotlease = GetPktLease(&amp;mDNSStorage, &amp;request-&gt;msg, end, &amp;lease);
        ptr = LocateAuthorities(&amp;request-&gt;msg, end);
        <span class="enscript-keyword">for</span> (i = 0; i &lt; request-&gt;msg.h.mDNS_numUpdates; i++)
        {
            LargeCacheRecord lcr;
            ptr = GetLargeResourceRecord(NULL, &amp;request-&gt;msg, ptr, end, 0, kDNSRecordTypePacketAns, &amp;lcr);
            <span class="enscript-keyword">if</span> (lcr.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; lcr.r.resrec.rroriginalttl) adds++;<span class="enscript-keyword">else</span> dels++;
        }
        HdrHToN(request);
        <span class="enscript-keyword">if</span> (adds &amp;&amp; !gotlease)
        {
            <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 UpdateRefused = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_Update, kDNSFlag1_RC_Refused } };
            Log(<span class="enscript-string">&quot;Rejecting Update Request with %d additions but no lease&quot;</span>, adds);
            reply = malloc(<span class="enscript-keyword">sizeof</span>(*reply));
            mDNSPlatformMemZero(&amp;reply-&gt;src, <span class="enscript-keyword">sizeof</span>(reply-&gt;src));
            reply-&gt;len = <span class="enscript-keyword">sizeof</span>(DNSMessageHeader);
            reply-&gt;zone = NULL;
            reply-&gt;isZonePublic = 0;
            InitializeDNSMessage(&amp;reply-&gt;msg.h, request-&gt;msg.h.id, UpdateRefused);
            <span class="enscript-keyword">return</span>(reply);
        }
        <span class="enscript-keyword">if</span> (lease &gt; 7200)   <span class="enscript-comment">// Don't allow lease greater than two hours; typically 90-minute renewal period
</span>            lease = 7200;
    }
    <span class="enscript-comment">// Send msg to server, read reply
</span>
    <span class="enscript-keyword">if</span> ( request-&gt;len &lt;= 512 )
    {
        mDNSBool trunc;

        <span class="enscript-keyword">if</span> ( UDPServerTransaction( self, request, &amp;buf, &amp;trunc) &lt; 0 )
        {
            Log(<span class="enscript-string">&quot;HandleRequest - UDPServerTransaction failed.  Trying TCP&quot;</span>);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( trunc )
        {
            VLog(<span class="enscript-string">&quot;HandleRequest - answer truncated.  Using TCP&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            reply = &amp;buf; <span class="enscript-comment">// success
</span>        }
    }

    <span class="enscript-keyword">if</span> ( !reply )
    {
        mDNSBool closed;
        <span class="enscript-type">int</span> res;

        sock = ConnectToServer( self );
        require_action_quiet( sock, exit, err = mStatus_UnknownErr ; Log( <span class="enscript-string">&quot;Discarding request from %s due to connection errors&quot;</span>, inet_ntop( AF_INET, &amp;request-&gt;src.sin_addr, addrbuf, 32 ) ) );

        res = SendPacket( sock, request );
        require_action_quiet( res &gt;= 0, exit, err = mStatus_UnknownErr ; Log( <span class="enscript-string">&quot;Couldn't relay message from %s to server.  Discarding.&quot;</span>, inet_ntop(AF_INET, &amp;request-&gt;src.sin_addr, addrbuf, 32 ) ) );

        reply = RecvPacket( sock, &amp;buf, &amp;closed );
    }

    <span class="enscript-comment">// IMPORTANT: reply is in network byte order at this point in the code
</span>    <span class="enscript-comment">// We keep it this way because we send it back to the client in the same form
</span>
    <span class="enscript-comment">// Is it an update?
</span>
    <span class="enscript-keyword">if</span> ( reply &amp;&amp; ( ( reply-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask ) == ( kDNSFlag0_OP_Update | kDNSFlag0_QR_Response ) ) )
    {
        <span class="enscript-type">char</span> pingmsg[4];
        mDNSBool ok = SuccessfulUpdateTransaction( request, reply );
        require_action( ok, exit, err = mStatus_UnknownErr; VLog( <span class="enscript-string">&quot;Message from %s not a successful update.&quot;</span>, inet_ntop(AF_INET, &amp;request-&gt;src.sin_addr, addrbuf, 32 ) ) );

        UpdateLeaseTable( request, self, lease );

        <span class="enscript-keyword">if</span> ( lease &gt; 0 )
        {
            leaseReply = FormatLeaseReply( self, reply, lease );

            <span class="enscript-keyword">if</span> ( !leaseReply )
            {
                Log(<span class="enscript-string">&quot;HandleRequest - unable to format lease reply&quot;</span>);
            }

            <span class="enscript-comment">// %%% Looks like a potential memory leak -- who frees the original reply?
</span>            reply = leaseReply;
        }

        <span class="enscript-comment">// tell the main thread there was an update so it can send LLQs
</span>
        <span class="enscript-keyword">if</span> ( send( self-&gt;LLQEventNotifySock, pingmsg, <span class="enscript-keyword">sizeof</span>( pingmsg ), 0 ) != <span class="enscript-keyword">sizeof</span>( pingmsg ) )
        {
            LogErr(<span class="enscript-string">&quot;HandleRequest&quot;</span>, <span class="enscript-string">&quot;send&quot;</span>);
        }
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( sock )
    {
        mDNSPlatformTCPCloseConnection( sock );
    }

    <span class="enscript-keyword">if</span> ( reply == &amp;buf )
    {
        reply = malloc( <span class="enscript-keyword">sizeof</span>( *reply ) );

        <span class="enscript-keyword">if</span> ( reply )
        {
            reply-&gt;len = buf.len;
            memcpy(&amp;reply-&gt;msg, &amp;buf.msg, buf.len);
        }
        <span class="enscript-keyword">else</span>
        {
            LogErr(<span class="enscript-string">&quot;HandleRequest&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>);
        }
    }

    <span class="enscript-keyword">return</span> reply;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// LLQ Support Routines
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// Set fields of an LLQ OPT Resource Record
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FormatLLQOpt</span>(AuthRecord *opt, <span class="enscript-type">int</span> opcode, <span class="enscript-type">const</span> mDNSOpaque64 *<span class="enscript-type">const</span> id, mDNSs32 lease)
{
    mDNSPlatformMemZero(opt, <span class="enscript-keyword">sizeof</span>(*opt));
    mDNS_SetupResourceRecord(opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    opt-&gt;resrec.rrclass = NormalMaxDNSMessageData;
    opt-&gt;resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);  <span class="enscript-comment">// One option in this OPT record
</span>    opt-&gt;resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
    opt-&gt;resrec.rdata-&gt;u.opt[0].opt = kDNSOpt_LLQ;
    opt-&gt;resrec.rdata-&gt;u.opt[0].u.llq.vers  = kLLQ_Vers;
    opt-&gt;resrec.rdata-&gt;u.opt[0].u.llq.llqOp = opcode;
    opt-&gt;resrec.rdata-&gt;u.opt[0].u.llq.err   = LLQErr_NoError;
    opt-&gt;resrec.rdata-&gt;u.opt[0].u.llq.id    = *id;
    opt-&gt;resrec.rdata-&gt;u.opt[0].u.llq.llqlease = lease;
}

<span class="enscript-comment">// Calculate effective remaining lease of an LLQ
</span>mDNSlocal mDNSu32 <span class="enscript-function-name">LLQLease</span>(LLQEntry *e)
{
    <span class="enscript-type">struct</span> timeval t;

    gettimeofday(&amp;t, NULL);
    <span class="enscript-keyword">if</span> (e-&gt;expire &lt; t.tv_sec) <span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> e-&gt;expire - t.tv_sec;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeleteLLQ</span>(DaemonInfo *d, LLQEntry *e)
{
    <span class="enscript-type">int</span> bucket = DomainNameHashValue(&amp;e-&gt;qname) % LLQ_TABLESIZE;
    LLQEntry **ptr = &amp;d-&gt;LLQTable[bucket];
    AnswerListElem *a = e-&gt;AnswerList;
    <span class="enscript-type">char</span> addr[32];

    inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addr, 32);
    VLog(<span class="enscript-string">&quot;Deleting LLQ table entry for %##s client %s&quot;</span>, e-&gt;qname.c, addr);

    <span class="enscript-keyword">if</span> (a &amp;&amp; !(--a-&gt;refcount) &amp;&amp; d-&gt;AnswerTableCount &gt;= LLQ_TABLESIZE)
    {
        <span class="enscript-comment">// currently, generating initial answers blocks the main thread, so we keep the answer list
</span>        <span class="enscript-comment">// even if the ref count drops to zero.  To prevent unbounded table growth, we free shared answers
</span>        <span class="enscript-comment">// if the ref count drops to zero AND there are more table elements than buckets
</span>        <span class="enscript-comment">// !!!KRS update this when we make the table dynamically growable
</span>
        CacheRecord *cr = a-&gt;KnownAnswers, *tmp;
        AnswerListElem **tbl = &amp;d-&gt;AnswerTable[bucket];

        <span class="enscript-keyword">while</span> (cr)
        {
            tmp = cr;
            cr = cr-&gt;next;
            free(tmp);
        }

        <span class="enscript-keyword">while</span> (*tbl &amp;&amp; *tbl != a) tbl = &amp;(*tbl)-&gt;next;
        <span class="enscript-keyword">if</span> (*tbl) { *tbl = (*tbl)-&gt;next; free(a); d-&gt;AnswerTableCount--; }
        <span class="enscript-keyword">else</span> Log(<span class="enscript-string">&quot;Error: DeleteLLQ - AnswerList not found in table&quot;</span>);
    }

    <span class="enscript-comment">// remove LLQ from table, free memory
</span>    <span class="enscript-keyword">while</span>(*ptr &amp;&amp; *ptr != e) ptr = &amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (!*ptr) { Log(<span class="enscript-string">&quot;Error: DeleteLLQ - LLQ not in table&quot;</span>); <span class="enscript-keyword">return</span>; }
    *ptr = (*ptr)-&gt;next;
    free(e);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">SendLLQ</span>(DaemonInfo *d, PktMsg *pkt, <span class="enscript-type">struct</span> sockaddr_in dst, TCPSocket *sock)
{
    <span class="enscript-type">char</span> addr[32];
    <span class="enscript-type">int</span> err = -1;

    HdrHToN(pkt);

    <span class="enscript-keyword">if</span> ( sock )
    {
        <span class="enscript-keyword">if</span> ( SendPacket( sock, pkt ) != 0 )
        {
            LogErr(<span class="enscript-string">&quot;DaemonInfo&quot;</span>, <span class="enscript-string">&quot;MySend&quot;</span>);
            Log(<span class="enscript-string">&quot;Could not send response to client %s&quot;</span>, inet_ntop(AF_INET, &amp;dst.sin_addr, addr, 32));
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (sendto(d-&gt;llq_udpsd, &amp;pkt-&gt;msg, pkt-&gt;len, 0, (<span class="enscript-type">struct</span> sockaddr *)&amp;dst, <span class="enscript-keyword">sizeof</span>(dst)) != (<span class="enscript-type">int</span>)pkt-&gt;len)
        {
            LogErr(<span class="enscript-string">&quot;DaemonInfo&quot;</span>, <span class="enscript-string">&quot;sendto&quot;</span>);
            Log(<span class="enscript-string">&quot;Could not send response to client %s&quot;</span>, inet_ntop(AF_INET, &amp;dst.sin_addr, addr, 32));
        }
    }

    err = 0;
    HdrNToH(pkt);
    <span class="enscript-keyword">return</span> err;
}

mDNSlocal CacheRecord *<span class="enscript-function-name">AnswerQuestion</span>(DaemonInfo *d, AnswerListElem *e)
{
    PktMsg q;
    <span class="enscript-type">int</span> i;
    TCPSocket *sock = NULL;
    <span class="enscript-type">const</span> mDNSu8 *ansptr;
    mDNSu8 *end = q.msg.data;
    PktMsg buf, *reply = NULL;
    LargeCacheRecord lcr;
    CacheRecord *AnswerList = NULL;
    mDNSu8 rcode;

    VLog(<span class="enscript-string">&quot;Querying server for %##s type %d&quot;</span>, e-&gt;name.c, e-&gt;type);

    InitializeDNSMessage(&amp;q.msg.h, zeroID, uQueryFlags);

    end = putQuestion(&amp;q.msg, end, end + AbsoluteMaxDNSMessageData, &amp;e-&gt;name, e-&gt;type, kDNSClass_IN);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: AnswerQuestion - putQuestion returned NULL&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
    q.len = (<span class="enscript-type">int</span>)(end - (mDNSu8 *)&amp;q.msg);

    HdrHToN(&amp;q);

    <span class="enscript-keyword">if</span> (!e-&gt;UseTCP)
    {
        mDNSBool trunc;

        <span class="enscript-keyword">if</span> (UDPServerTransaction(d, &amp;q, &amp;buf, &amp;trunc) &lt; 0)
            Log(<span class="enscript-string">&quot;AnswerQuestion %##s - UDPServerTransaction failed.  Trying TCP&quot;</span>, e-&gt;name.c);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (trunc)
        { VLog(<span class="enscript-string">&quot;AnswerQuestion %##s - answer truncated.  Using TCP&quot;</span>, e-&gt;name.c); e-&gt;UseTCP = mDNStrue; }
        <span class="enscript-keyword">else</span> reply = &amp;buf;  <span class="enscript-comment">// success
</span>    }

    <span class="enscript-keyword">if</span> (!reply)
    {
        mDNSBool closed;

        sock = ConnectToServer(d);
        <span class="enscript-keyword">if</span> (!sock) { Log(<span class="enscript-string">&quot;AnswerQuestion: ConnectToServer failed&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        <span class="enscript-keyword">if</span> (SendPacket( sock, &amp;q)) { Log(<span class="enscript-string">&quot;AnswerQuestion: SendPacket failed&quot;</span>); mDNSPlatformTCPCloseConnection( sock ); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        reply = RecvPacket( sock, NULL, &amp;closed );
        mDNSPlatformTCPCloseConnection( sock );
        require_action( reply, end, Log( <span class="enscript-string">&quot;AnswerQuestion: RecvPacket returned NULL&quot;</span> ) );
    }

    HdrNToH(&amp;q);
    <span class="enscript-keyword">if</span> (reply) HdrNToH(reply);

    <span class="enscript-keyword">if</span> ((reply-&gt;msg.h.flags.b[0] &amp; kDNSFlag0_QROP_Mask) != (kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery))
    { Log(<span class="enscript-string">&quot;AnswerQuestion: %##s type %d - Invalid response flags from server&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
    rcode = (mDNSu8)(reply-&gt;msg.h.flags.b[1] &amp; kDNSFlag1_RC_Mask);
    <span class="enscript-keyword">if</span> (rcode &amp;&amp; rcode != kDNSFlag1_RC_NXDomain) { Log(<span class="enscript-string">&quot;AnswerQuestion: %##s type %d - non-zero rcode %d from server&quot;</span>, e-&gt;name.c, e-&gt;type, rcode); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }

    end = (mDNSu8 *)&amp;reply-&gt;msg + reply-&gt;len;
    ansptr = LocateAnswers(&amp;reply-&gt;msg, end);
    <span class="enscript-keyword">if</span> (!ansptr) { Log(<span class="enscript-string">&quot;Error: AnswerQuestion - LocateAnswers returned NULL&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; reply-&gt;msg.h.numAnswers; i++)
    {
        ansptr = GetLargeResourceRecord(NULL, &amp;reply-&gt;msg, ansptr, end, 0, kDNSRecordTypePacketAns, &amp;lcr);
        <span class="enscript-keyword">if</span> (!ansptr) { Log(<span class="enscript-string">&quot;AnswerQuestions: GetLargeResourceRecord returned NULL&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        <span class="enscript-keyword">if</span> (lcr.r.resrec.RecordType != kDNSRecordTypePacketNegative)
        {
            <span class="enscript-keyword">if</span> (lcr.r.resrec.rrtype != e-&gt;type || lcr.r.resrec.rrclass != kDNSClass_IN || !SameDomainName(lcr.r.resrec.name, &amp;e-&gt;name))
            {
                Log(<span class="enscript-string">&quot;AnswerQuestion: response %##s type #d does not answer question %##s type #d.  Discarding&quot;</span>,
                    lcr.r.resrec.name-&gt;c, lcr.r.resrec.rrtype, e-&gt;name.c, e-&gt;type);
            }
            <span class="enscript-keyword">else</span>
            {
                CacheRecord *cr = CopyCacheRecord(&amp;lcr.r, &amp;e-&gt;name);
                <span class="enscript-keyword">if</span> (!cr) { Log(<span class="enscript-string">&quot;Error: AnswerQuestion - CopyCacheRecord returned NULL&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
                cr-&gt;next = AnswerList;
                AnswerList = cr;
            }
        }
    }

<span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (reply &amp;&amp; reply != &amp;buf) free(reply);
    <span class="enscript-keyword">return</span> AnswerList;
}

<span class="enscript-comment">// Routine forks a thread to set EventList to contain Add/Remove events, and deletes any removes from the KnownAnswer list
</span>mDNSlocal <span class="enscript-type">void</span> *<span class="enscript-function-name">UpdateAnswerList</span>(<span class="enscript-type">void</span> *args)
{
    CacheRecord *cr, *NewAnswers, **na, **ka; <span class="enscript-comment">// &quot;new answer&quot;, &quot;known answer&quot;
</span>    DaemonInfo *d = ((UpdateAnswerListArgs *)args)-&gt;d;
    AnswerListElem *a = ((UpdateAnswerListArgs *)args)-&gt;a;

    free(args);
    args = NULL;

    <span class="enscript-comment">// get up to date answers
</span>    NewAnswers = AnswerQuestion(d, a);

    <span class="enscript-comment">// first pass - mark all answers for deletion
</span>    <span class="enscript-keyword">for</span> (ka = &amp;a-&gt;KnownAnswers; *ka; ka = &amp;(*ka)-&gt;next)
        (*ka)-&gt;resrec.rroriginalttl = (<span class="enscript-type">unsigned</span>)-1; <span class="enscript-comment">// -1 means delete
</span>
    <span class="enscript-comment">// second pass - mark answers pre-existent
</span>    <span class="enscript-keyword">for</span> (ka = &amp;a-&gt;KnownAnswers; *ka; ka = &amp;(*ka)-&gt;next)
    {
        <span class="enscript-keyword">for</span> (na = &amp;NewAnswers; *na; na = &amp;(*na)-&gt;next)
        {
            <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;(*ka)-&gt;resrec, &amp;(*na)-&gt;resrec))
            { (*ka)-&gt;resrec.rroriginalttl = 0; <span class="enscript-keyword">break</span>; }     <span class="enscript-comment">// 0 means no change
</span>        }
    }

    <span class="enscript-comment">// third pass - add new records to Event list
</span>    na = &amp;NewAnswers;
    <span class="enscript-keyword">while</span> (*na)
    {
        <span class="enscript-keyword">for</span> (ka = &amp;a-&gt;KnownAnswers; *ka; ka = &amp;(*ka)-&gt;next)
            <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;(*ka)-&gt;resrec, &amp;(*na)-&gt;resrec)) <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (!*ka)
        {
            <span class="enscript-comment">// answer is not in list - splice from NewAnswers list, add to Event list
</span>            cr = *na;
            *na = (*na)-&gt;next;        <span class="enscript-comment">// splice from list
</span>            cr-&gt;next = a-&gt;EventList;  <span class="enscript-comment">// add spliced record to event list
</span>            a-&gt;EventList = cr;
            cr-&gt;resrec.rroriginalttl = 1; <span class="enscript-comment">// 1 means add
</span>        }
        <span class="enscript-keyword">else</span> na = &amp;(*na)-&gt;next;
    }

    <span class="enscript-comment">// move all the removes from the answer list to the event list
</span>    ka = &amp;a-&gt;KnownAnswers;
    <span class="enscript-keyword">while</span> (*ka)
    {
        <span class="enscript-keyword">if</span> ((*ka)-&gt;resrec.rroriginalttl == (<span class="enscript-type">unsigned</span>)-1)
        {
            cr = *ka;
            *ka = (*ka)-&gt;next;
            cr-&gt;next = a-&gt;EventList;
            a-&gt;EventList = cr;
        }
        <span class="enscript-keyword">else</span> ka = &amp;(*ka)-&gt;next;
    }

    <span class="enscript-comment">// lastly, free the remaining records (known answers) in NewAnswers list
</span>    <span class="enscript-keyword">while</span> (NewAnswers)
    {
        cr = NewAnswers;
        NewAnswers = NewAnswers-&gt;next;
        free(cr);
    }

    <span class="enscript-keyword">return</span> NULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendEvents</span>(DaemonInfo *d, LLQEntry *e)
{
    PktMsg response;
    CacheRecord *cr;
    mDNSu8 *end = (mDNSu8 *)&amp;response.msg.data;
    mDNSOpaque16 msgID;
    <span class="enscript-type">char</span> rrbuf[MaxMsg], addrbuf[32];
    AuthRecord opt;

    <span class="enscript-comment">// Should this really be random?  Do we use the msgID on the receiving end?
</span>    msgID.NotAnInteger = random();
    <span class="enscript-keyword">if</span> (verbose) inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addrbuf, 32);
    InitializeDNSMessage(&amp;response.msg.h, msgID, ResponseFlags);
    end = putQuestion(&amp;response.msg, end, end + AbsoluteMaxDNSMessageData, &amp;e-&gt;qname, e-&gt;qtype, kDNSClass_IN);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: SendEvents - putQuestion returned NULL&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// put adds/removes in packet
</span>    <span class="enscript-keyword">for</span> (cr = e-&gt;AnswerList-&gt;EventList; cr; cr = cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (verbose) GetRRDisplayString_rdb(&amp;cr-&gt;resrec, &amp;cr-&gt;resrec.rdata-&gt;u, rrbuf);
        VLog(<span class="enscript-string">&quot;%s (%s): %s&quot;</span>, addrbuf, (mDNSs32)cr-&gt;resrec.rroriginalttl &lt; 0 ? <span class="enscript-string">&quot;Remove&quot;</span> : <span class="enscript-string">&quot;Add&quot;</span>, rrbuf);
        end = PutResourceRecordTTLJumbo(&amp;response.msg, end, &amp;response.msg.h.numAnswers, &amp;cr-&gt;resrec, cr-&gt;resrec.rroriginalttl);
        <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: SendEvents - PutResourceRecordTTLJumbo returned NULL&quot;</span>); <span class="enscript-keyword">return</span>; }
    }

    FormatLLQOpt(&amp;opt, kLLQOp_Event, &amp;e-&gt;id, LLQLease(e));
    end = PutResourceRecordTTLJumbo(&amp;response.msg, end, &amp;response.msg.h.numAdditionals, &amp;opt.resrec, 0);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: SendEvents - PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span>; }

    response.len = (<span class="enscript-type">int</span>)(end - (mDNSu8 *)&amp;response.msg);
    <span class="enscript-keyword">if</span> (SendLLQ(d, &amp;response, e-&gt;cli, NULL ) &lt; 0) LogMsg(<span class="enscript-string">&quot;Error: SendEvents - SendLLQ&quot;</span>);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintLLQAnswers</span>(DaemonInfo *d)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">char</span> rrbuf[MaxMsg];

    Log(<span class="enscript-string">&quot;Printing LLQ Answer Table contents&quot;</span>);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        AnswerListElem *a = d-&gt;AnswerTable[i];
        <span class="enscript-keyword">while</span>(a)
        {
            <span class="enscript-type">int</span> ancount = 0;
            <span class="enscript-type">const</span> CacheRecord *rr = a-&gt;KnownAnswers;
            <span class="enscript-keyword">while</span> (rr) { ancount++; rr = rr-&gt;next; }
            Log(<span class="enscript-string">&quot;%p : Question %##s;  type %d;  referenced by %d LLQs; %d answers:&quot;</span>, a, a-&gt;name.c, a-&gt;type, a-&gt;refcount, ancount);
            <span class="enscript-keyword">for</span> (rr = a-&gt;KnownAnswers; rr; rr = rr-&gt;next) Log(<span class="enscript-string">&quot;\t%s&quot;</span>, GetRRDisplayString_rdb(&amp;rr-&gt;resrec, &amp;rr-&gt;resrec.rdata-&gt;u, rrbuf));
            a = a-&gt;next;
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintLLQTable</span>(DaemonInfo *d)
{
    LLQEntry *e;
    <span class="enscript-type">char</span> addr[32];
    <span class="enscript-type">int</span> i;

    Log(<span class="enscript-string">&quot;Printing LLQ table contents&quot;</span>);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        e = d-&gt;LLQTable[i];
        <span class="enscript-keyword">while</span>(e)
        {
            <span class="enscript-type">char</span> *state;

            <span class="enscript-keyword">switch</span> (e-&gt;state)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">RequestReceived</span>: state = <span class="enscript-string">&quot;RequestReceived&quot;</span>; <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">ChallengeSent</span>:   state = <span class="enscript-string">&quot;ChallengeSent&quot;</span>;   <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">Established</span>:     state = <span class="enscript-string">&quot;Established&quot;</span>;     <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:              state = <span class="enscript-string">&quot;unknown&quot;</span>;
            }
            inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addr, 32);

            Log(<span class="enscript-string">&quot;LLQ from %s in state %s; %##s; type %d; orig lease %d; remaining lease %d; AnswerList %p)&quot;</span>,
                addr, state, e-&gt;qname.c, e-&gt;qtype, e-&gt;lease, LLQLease(e), e-&gt;AnswerList);
            e = e-&gt;next;
        }
    }
}

<span class="enscript-comment">// Send events to clients as a result of a change in the zone
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GenLLQEvents</span>(DaemonInfo *d)
{
    LLQEntry **e;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">struct</span> timeval t;
    UpdateAnswerListArgs *args;

    VLog(<span class="enscript-string">&quot;Generating LLQ Events&quot;</span>);

    gettimeofday(&amp;t, NULL);

    <span class="enscript-comment">// get all answers up to date
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        AnswerListElem *a = d-&gt;AnswerTable[i];
        <span class="enscript-keyword">while</span>(a)
        {
            args = malloc(<span class="enscript-keyword">sizeof</span>(*args));
            <span class="enscript-keyword">if</span> (!args) { LogErr(<span class="enscript-string">&quot;GenLLQEvents&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span>; }
            args-&gt;d = d;
            args-&gt;a = a;
            <span class="enscript-keyword">if</span> (pthread_create(&amp;a-&gt;tid, NULL, UpdateAnswerList, args) &lt; 0) { LogErr(<span class="enscript-string">&quot;GenLLQEvents&quot;</span>, <span class="enscript-string">&quot;pthread_create&quot;</span>); <span class="enscript-keyword">return</span>; }
            usleep(1);
            a = a-&gt;next;
        }
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        AnswerListElem *a = d-&gt;AnswerTable[i];
        <span class="enscript-keyword">while</span>(a)
        {
            <span class="enscript-keyword">if</span> (pthread_join(a-&gt;tid, NULL)) LogErr(<span class="enscript-string">&quot;GenLLQEvents&quot;</span>, <span class="enscript-string">&quot;pthread_join&quot;</span>);
            a = a-&gt;next;
        }
    }

    <span class="enscript-comment">// for each established LLQ, send events
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        e = &amp;d-&gt;LLQTable[i];
        <span class="enscript-keyword">while</span>(*e)
        {
            <span class="enscript-keyword">if</span> ((*e)-&gt;expire &lt; t.tv_sec) DeleteLLQ(d, *e);
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> ((*e)-&gt;state == Established &amp;&amp; (*e)-&gt;AnswerList-&gt;EventList) SendEvents(d, *e);
                e = &amp;(*e)-&gt;next;
            }
        }
    }

    <span class="enscript-comment">// now that all LLQs are updated, we move Add events from the Event list to the Known Answer list, and free Removes
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; LLQ_TABLESIZE; i++)
    {
        AnswerListElem *a = d-&gt;AnswerTable[i];
        <span class="enscript-keyword">while</span>(a)
        {
            <span class="enscript-keyword">if</span> (a-&gt;EventList)
            {
                CacheRecord *cr = a-&gt;EventList, *tmp;
                <span class="enscript-keyword">while</span> (cr)
                {
                    tmp = cr;
                    cr = cr-&gt;next;
                    <span class="enscript-keyword">if</span> ((<span class="enscript-type">signed</span>)tmp-&gt;resrec.rroriginalttl &lt; 0) free(tmp);
                    <span class="enscript-keyword">else</span>
                    {
                        tmp-&gt;next = a-&gt;KnownAnswers;
                        a-&gt;KnownAnswers = tmp;
                        tmp-&gt;resrec.rroriginalttl = 0;
                    }
                }
                a-&gt;EventList = NULL;
            }
            a = a-&gt;next;
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetAnswerList</span>(DaemonInfo *d, LLQEntry *e)
{
    <span class="enscript-type">int</span> bucket = DomainNameHashValue(&amp;e-&gt;qname) % LLQ_TABLESIZE;
    AnswerListElem *a = d-&gt;AnswerTable[bucket];
    <span class="enscript-keyword">while</span> (a &amp;&amp; (a-&gt;type != e-&gt;qtype ||!SameDomainName(&amp;a-&gt;name, &amp;e-&gt;qname))) a = a-&gt;next;
    <span class="enscript-keyword">if</span> (!a)
    {
        a = malloc(<span class="enscript-keyword">sizeof</span>(*a));
        <span class="enscript-keyword">if</span> (!a) { LogErr(<span class="enscript-string">&quot;SetAnswerList&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span>; }
        AssignDomainName(&amp;a-&gt;name, &amp;e-&gt;qname);
        a-&gt;type = e-&gt;qtype;
        a-&gt;refcount = 0;
        a-&gt;EventList = NULL;
        a-&gt;UseTCP = mDNSfalse;
        a-&gt;next = d-&gt;AnswerTable[bucket];
        d-&gt;AnswerTable[bucket] = a;
        d-&gt;AnswerTableCount++;
        a-&gt;KnownAnswers = AnswerQuestion(d, a);
    }

    e-&gt;AnswerList = a;
    a-&gt;refcount++;
}

<span class="enscript-comment">// Allocate LLQ entry, insert into table
</span>mDNSlocal LLQEntry *<span class="enscript-function-name">NewLLQ</span>(DaemonInfo *d, <span class="enscript-type">struct</span> sockaddr_in cli, domainname *qname, mDNSu16 qtype, mDNSu32 lease )
{
    <span class="enscript-type">char</span> addr[32];
    <span class="enscript-type">struct</span> timeval t;
    <span class="enscript-type">int</span> bucket = DomainNameHashValue(qname) % LLQ_TABLESIZE;
    LLQEntry *e;

    e = malloc(<span class="enscript-keyword">sizeof</span>(*e));
    <span class="enscript-keyword">if</span> (!e) { LogErr(<span class="enscript-string">&quot;NewLLQ&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); <span class="enscript-keyword">return</span> NULL; }

    inet_ntop(AF_INET, &amp;cli.sin_addr, addr, 32);
    VLog(<span class="enscript-string">&quot;Allocating LLQ entry for client %s question %##s type %d&quot;</span>, addr, qname-&gt;c, qtype);

    <span class="enscript-comment">// initialize structure
</span>    e-&gt;cli = cli;
    AssignDomainName(&amp;e-&gt;qname, qname);
    e-&gt;qtype = qtype;
    e-&gt;id    = zeroOpaque64;
    e-&gt;state = RequestReceived;
    e-&gt;AnswerList = NULL;

    <span class="enscript-keyword">if</span> (lease &lt; LLQ_MIN_LEASE) lease = LLQ_MIN_LEASE;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lease &gt; LLQ_MAX_LEASE) lease = LLQ_MAX_LEASE;

    gettimeofday(&amp;t, NULL);
    e-&gt;expire = t.tv_sec + (<span class="enscript-type">int</span>)lease;
    e-&gt;lease = lease;

    <span class="enscript-comment">// add to table
</span>    e-&gt;next = d-&gt;LLQTable[bucket];
    d-&gt;LLQTable[bucket] = e;

    <span class="enscript-keyword">return</span> e;
}

<span class="enscript-comment">// Handle a refresh request from client
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LLQRefresh</span>(DaemonInfo *d, LLQEntry *e, LLQOptData *llq, mDNSOpaque16 msgID, TCPSocket *sock )
{
    AuthRecord opt;
    PktMsg ack;
    mDNSu8 *end = (mDNSu8 *)&amp;ack.msg.data;
    <span class="enscript-type">char</span> addr[32];

    inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addr, 32);
    VLog(<span class="enscript-string">&quot;%s LLQ for %##s from %s&quot;</span>, llq-&gt;llqlease ? <span class="enscript-string">&quot;Refreshing&quot;</span> : <span class="enscript-string">&quot;Deleting&quot;</span>, e-&gt;qname.c, addr);

    <span class="enscript-keyword">if</span> (llq-&gt;llqlease)
    {
        <span class="enscript-type">struct</span> timeval t;
        <span class="enscript-keyword">if</span> (llq-&gt;llqlease &lt; LLQ_MIN_LEASE) llq-&gt;llqlease = LLQ_MIN_LEASE;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (llq-&gt;llqlease &gt; LLQ_MAX_LEASE) llq-&gt;llqlease = LLQ_MIN_LEASE;
        gettimeofday(&amp;t, NULL);
        e-&gt;expire = t.tv_sec + llq-&gt;llqlease;
    }

    ack.src.sin_addr.s_addr = 0; <span class="enscript-comment">// unused
</span>    InitializeDNSMessage(&amp;ack.msg.h, msgID, ResponseFlags);
    end = putQuestion(&amp;ack.msg, end, end + AbsoluteMaxDNSMessageData, &amp;e-&gt;qname, e-&gt;qtype, kDNSClass_IN);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: putQuestion&quot;</span>); <span class="enscript-keyword">return</span>; }

    FormatLLQOpt(&amp;opt, kLLQOp_Refresh, &amp;e-&gt;id, llq-&gt;llqlease ? LLQLease(e) : 0);
    end = PutResourceRecordTTLJumbo(&amp;ack.msg, end, &amp;ack.msg.h.numAdditionals, &amp;opt.resrec, 0);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span>; }

    ack.len = (<span class="enscript-type">int</span>)(end - (mDNSu8 *)&amp;ack.msg);
    <span class="enscript-keyword">if</span> (SendLLQ(d, &amp;ack, e-&gt;cli, sock)) Log(<span class="enscript-string">&quot;Error: LLQRefresh&quot;</span>);

    <span class="enscript-keyword">if</span> (llq-&gt;llqlease) e-&gt;state = Established;
    <span class="enscript-keyword">else</span> DeleteLLQ(d, e);
}

<span class="enscript-comment">// Complete handshake with Ack an initial answers
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LLQCompleteHandshake</span>(DaemonInfo *d, LLQEntry *e, LLQOptData *llq, mDNSOpaque16 msgID, TCPSocket *sock)
{
    <span class="enscript-type">char</span> addr[32];
    CacheRecord *ptr;
    AuthRecord opt;
    PktMsg ack;
    mDNSu8 *end = (mDNSu8 *)&amp;ack.msg.data;
    <span class="enscript-type">char</span> rrbuf[MaxMsg], addrbuf[32];

    inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addr, 32);

    <span class="enscript-keyword">if</span> (!mDNSSameOpaque64(&amp;llq-&gt;id, &amp;e-&gt;id) ||
        llq-&gt;vers  != kLLQ_Vers             ||
        llq-&gt;llqOp != kLLQOp_Setup          ||
        llq-&gt;err   != LLQErr_NoError        ||
        llq-&gt;llqlease &gt; e-&gt;lease + LLQ_LEASE_FUDGE ||
        llq-&gt;llqlease &lt; e-&gt;lease - LLQ_LEASE_FUDGE)
    {
        Log(<span class="enscript-string">&quot;Incorrect challenge response from %s&quot;</span>, addr);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (e-&gt;state == Established) VLog(<span class="enscript-string">&quot;Retransmitting LLQ ack + answers for %##s&quot;</span>, e-&gt;qname.c);
    <span class="enscript-keyword">else</span> VLog(<span class="enscript-string">&quot;Delivering LLQ ack + answers for %##s&quot;</span>, e-&gt;qname.c);

    <span class="enscript-comment">// format ack + answers
</span>    ack.src.sin_addr.s_addr = 0; <span class="enscript-comment">// unused
</span>    InitializeDNSMessage(&amp;ack.msg.h, msgID, ResponseFlags);
    end = putQuestion(&amp;ack.msg, end, end + AbsoluteMaxDNSMessageData, &amp;e-&gt;qname, e-&gt;qtype, kDNSClass_IN);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: putQuestion&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (e-&gt;state != Established) { SetAnswerList(d, e); e-&gt;state = Established; }

    <span class="enscript-keyword">if</span> (verbose) inet_ntop(AF_INET, &amp;e-&gt;cli.sin_addr, addrbuf, 32);
    <span class="enscript-keyword">for</span> (ptr = e-&gt;AnswerList-&gt;KnownAnswers; ptr; ptr = ptr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (verbose) GetRRDisplayString_rdb(&amp;ptr-&gt;resrec, &amp;ptr-&gt;resrec.rdata-&gt;u, rrbuf);
        VLog(<span class="enscript-string">&quot;%s Intitial Answer - %s&quot;</span>, addr, rrbuf);
        end = PutResourceRecordTTLJumbo(&amp;ack.msg, end, &amp;ack.msg.h.numAnswers, &amp;ptr-&gt;resrec, 1);
        <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span>; }
    }

    FormatLLQOpt(&amp;opt, kLLQOp_Setup, &amp;e-&gt;id, LLQLease(e));
    end = PutResourceRecordTTLJumbo(&amp;ack.msg, end, &amp;ack.msg.h.numAdditionals, &amp;opt.resrec, 0);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span>; }

    ack.len = (<span class="enscript-type">int</span>)(end - (mDNSu8 *)&amp;ack.msg);
    <span class="enscript-keyword">if</span> (SendLLQ(d, &amp;ack, e-&gt;cli, sock)) Log(<span class="enscript-string">&quot;Error: LLQCompleteHandshake&quot;</span>);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LLQSetupChallenge</span>(DaemonInfo *d, LLQEntry *e, LLQOptData *llq, mDNSOpaque16 msgID)
{
    <span class="enscript-type">struct</span> timeval t;
    PktMsg challenge;
    mDNSu8 *end = challenge.msg.data;
    AuthRecord opt;

    <span class="enscript-keyword">if</span> (e-&gt;state == ChallengeSent) VLog(<span class="enscript-string">&quot;Retransmitting LLQ setup challenge for %##s&quot;</span>, e-&gt;qname.c);
    <span class="enscript-keyword">else</span> VLog(<span class="enscript-string">&quot;Sending LLQ setup challenge for %##s&quot;</span>, e-&gt;qname.c);

    <span class="enscript-keyword">if</span> (!mDNSOpaque64IsZero(&amp;llq-&gt;id)) { Log(<span class="enscript-string">&quot;Error: LLQSetupChallenge - nonzero ID&quot;</span>); <span class="enscript-keyword">return</span>; } <span class="enscript-comment">// server bug
</span>    <span class="enscript-keyword">if</span> (llq-&gt;llqOp != kLLQOp_Setup) { Log(<span class="enscript-string">&quot;LLQSetupChallenge - incorrrect operation from client&quot;</span>); <span class="enscript-keyword">return</span>; } <span class="enscript-comment">// client error
</span>
    <span class="enscript-keyword">if</span> (mDNSOpaque64IsZero(&amp;e-&gt;id)) <span class="enscript-comment">// don't regenerate random ID for retransmissions
</span>    {
        <span class="enscript-comment">// construct ID &lt;time&gt;&lt;random&gt;
</span>        gettimeofday(&amp;t, NULL);
        e-&gt;id.l[0] = t.tv_sec;
        e-&gt;id.l[1] = random();
    }

    <span class="enscript-comment">// format response (query + LLQ opt rr)
</span>    challenge.src.sin_addr.s_addr = 0; <span class="enscript-comment">// unused
</span>    InitializeDNSMessage(&amp;challenge.msg.h, msgID, ResponseFlags);
    end = putQuestion(&amp;challenge.msg, end, end + AbsoluteMaxDNSMessageData, &amp;e-&gt;qname, e-&gt;qtype, kDNSClass_IN);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: putQuestion&quot;</span>); <span class="enscript-keyword">return</span>; }
    FormatLLQOpt(&amp;opt, kLLQOp_Setup, &amp;e-&gt;id, LLQLease(e));
    end = PutResourceRecordTTLJumbo(&amp;challenge.msg, end, &amp;challenge.msg.h.numAdditionals, &amp;opt.resrec, 0);
    <span class="enscript-keyword">if</span> (!end) { Log(<span class="enscript-string">&quot;Error: PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span>; }
    challenge.len = (<span class="enscript-type">int</span>)(end - (mDNSu8 *)&amp;challenge.msg);
    <span class="enscript-keyword">if</span> (SendLLQ(d, &amp;challenge, e-&gt;cli, NULL)) { Log(<span class="enscript-string">&quot;Error: LLQSetupChallenge&quot;</span>); <span class="enscript-keyword">return</span>; }
    e-&gt;state = ChallengeSent;
}

<span class="enscript-comment">// Take action on an LLQ message from client.  Entry must be initialized and in table
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateLLQ</span>(DaemonInfo *d, LLQEntry *e, LLQOptData *llq, mDNSOpaque16 msgID, TCPSocket *sock )
{
    <span class="enscript-keyword">switch</span>(e-&gt;state)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RequestReceived</span>:
        <span class="enscript-keyword">if</span> ( sock )
        {
            <span class="enscript-type">struct</span> timeval t;
            gettimeofday(&amp;t, NULL);
            e-&gt;id.l[0] = t.tv_sec;      <span class="enscript-comment">// construct ID &lt;time&gt;&lt;random&gt;
</span>            e-&gt;id.l[1] = random();
            llq-&gt;id = e-&gt;id;
            LLQCompleteHandshake( d, e, llq, msgID, sock );

            <span class="enscript-comment">// Set the state to established because we've just set the LLQ up using TCP
</span>            e-&gt;state = Established;
        }
        <span class="enscript-keyword">else</span>
        {
            LLQSetupChallenge(d, e, llq, msgID);
        }
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ChallengeSent</span>:
        <span class="enscript-keyword">if</span> (mDNSOpaque64IsZero(&amp;llq-&gt;id)) LLQSetupChallenge(d, e, llq, msgID);     <span class="enscript-comment">// challenge sent and lost
</span>        <span class="enscript-keyword">else</span> LLQCompleteHandshake(d, e, llq, msgID, sock );
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">Established</span>:
        <span class="enscript-keyword">if</span> (mDNSOpaque64IsZero(&amp;llq-&gt;id))
        {
            <span class="enscript-comment">// client started over.  reset state.
</span>            LLQEntry *newe = NewLLQ(d, e-&gt;cli, &amp;e-&gt;qname, e-&gt;qtype, llq-&gt;llqlease );
            <span class="enscript-keyword">if</span> (!newe) <span class="enscript-keyword">return</span>;
            DeleteLLQ(d, e);
            LLQSetupChallenge(d, newe, llq, msgID);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (llq-&gt;llqOp == kLLQOp_Setup)
        { LLQCompleteHandshake(d, e, llq, msgID, sock); <span class="enscript-keyword">return</span>; }         <span class="enscript-comment">// Ack lost
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (llq-&gt;llqOp == kLLQOp_Refresh)
        { LLQRefresh(d, e, llq, msgID, sock); <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">else</span> { Log(<span class="enscript-string">&quot;Unhandled message for established LLQ&quot;</span>); <span class="enscript-keyword">return</span>; }
    }
}

mDNSlocal LLQEntry *<span class="enscript-function-name">LookupLLQ</span>(DaemonInfo *d, <span class="enscript-type">struct</span> sockaddr_in cli, domainname *qname, mDNSu16 qtype, <span class="enscript-type">const</span> mDNSOpaque64 *<span class="enscript-type">const</span> id)
{
    <span class="enscript-type">int</span> bucket = bucket = DomainNameHashValue(qname) % LLQ_TABLESIZE;
    LLQEntry *ptr = d-&gt;LLQTable[bucket];

    <span class="enscript-keyword">while</span>(ptr)
    {
        <span class="enscript-keyword">if</span> (((ptr-&gt;state == ChallengeSent &amp;&amp; mDNSOpaque64IsZero(id) &amp;&amp; (cli.sin_port == ptr-&gt;cli.sin_port)) || <span class="enscript-comment">// zero-id due to packet loss OK in state ChallengeSent
</span>             mDNSSameOpaque64(id, &amp;ptr-&gt;id)) &amp;&amp;                        <span class="enscript-comment">// id match
</span>            (cli.sin_addr.s_addr == ptr-&gt;cli.sin_addr.s_addr) &amp;&amp; (qtype == ptr-&gt;qtype) &amp;&amp; SameDomainName(&amp;ptr-&gt;qname, qname)) <span class="enscript-comment">// same source, type, qname
</span>            <span class="enscript-keyword">return</span> ptr;
        ptr = ptr-&gt;next;
    }
    <span class="enscript-keyword">return</span> NULL;
}

mDNSlocal <span class="enscript-type">int</span>
RecvNotify
(
    DaemonInfo  *   d,
    PktMsg      *   pkt
)
{
    <span class="enscript-type">int</span> res;
    <span class="enscript-type">int</span> err = 0;

    pkt-&gt;msg.h.flags.b[0] |= kDNSFlag0_QR_Response;

    res = sendto( d-&gt;udpsd, &amp;pkt-&gt;msg, pkt-&gt;len, 0, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;pkt-&gt;src, <span class="enscript-keyword">sizeof</span>( pkt-&gt;src ) );
    require_action( res == ( <span class="enscript-type">int</span> ) pkt-&gt;len, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;RecvNotify&quot;</span>, <span class="enscript-string">&quot;sendto&quot;</span> ) );

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> err;
}


mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">RecvLLQ</span>( DaemonInfo *d, PktMsg *pkt, TCPSocket *sock )
{
    DNSQuestion q;
    LargeCacheRecord opt;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> err = -1;
    <span class="enscript-type">char</span> addr[32];
    <span class="enscript-type">const</span> mDNSu8 *qptr = pkt-&gt;msg.data;
    <span class="enscript-type">const</span> mDNSu8 *end = (mDNSu8 *)&amp;pkt-&gt;msg + pkt-&gt;len;
    <span class="enscript-type">const</span> mDNSu8 *aptr;
    LLQOptData *llq = NULL;
    LLQEntry *e = NULL;

    HdrNToH(pkt);
    aptr = LocateAdditionals(&amp;pkt-&gt;msg, end);   <span class="enscript-comment">// Can't do this until after HdrNToH(pkt);
</span>    inet_ntop(AF_INET, &amp;pkt-&gt;src.sin_addr, addr, 32);

    VLog(<span class="enscript-string">&quot;Received LLQ msg from %s&quot;</span>, addr);
    <span class="enscript-comment">// sanity-check packet
</span>    <span class="enscript-keyword">if</span> (!pkt-&gt;msg.h.numQuestions || !pkt-&gt;msg.h.numAdditionals)
    {
        Log(<span class="enscript-string">&quot;Malformatted LLQ from %s with %d questions, %d additionals&quot;</span>, addr, pkt-&gt;msg.h.numQuestions, pkt-&gt;msg.h.numAdditionals);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
    }

    <span class="enscript-comment">// Locate the OPT record.
</span>    <span class="enscript-comment">// According to RFC 2671, &quot;One OPT pseudo-RR can be added to the additional data section of either a request or a response.&quot;
</span>    <span class="enscript-comment">// This implies that there may be *at most* one OPT record per DNS message, in the Additional Section,
</span>    <span class="enscript-comment">// but not necessarily the *last* entry in the Additional Section.
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; pkt-&gt;msg.h.numAdditionals; i++)
    {
        aptr = GetLargeResourceRecord(NULL, &amp;pkt-&gt;msg, aptr, end, 0, kDNSRecordTypePacketAdd, &amp;opt);
        <span class="enscript-keyword">if</span> (!aptr) { Log(<span class="enscript-string">&quot;Malformatted LLQ from %s: could not get Additional record %u&quot;</span>, addr, i); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        <span class="enscript-keyword">if</span> (opt.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; opt.r.resrec.rrtype == kDNSType_OPT) <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-comment">// validate OPT
</span>    <span class="enscript-keyword">if</span> (opt.r.resrec.rrtype != kDNSType_OPT) { Log(<span class="enscript-string">&quot;Malformatted LLQ from %s: last Additional not an OPT RR&quot;</span>, addr); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
    <span class="enscript-keyword">if</span> (opt.r.resrec.rdlength &lt; pkt-&gt;msg.h.numQuestions * DNSOpt_LLQData_Space) { Log(<span class="enscript-string">&quot;Malformatted LLQ from %s: OPT RR to small (%d bytes for %d questions)&quot;</span>, addr, opt.r.resrec.rdlength, pkt-&gt;msg.h.numQuestions); }

    <span class="enscript-comment">// dispatch each question
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; pkt-&gt;msg.h.numQuestions; i++)
    {
        qptr = getQuestion(&amp;pkt-&gt;msg, qptr, end, 0, &amp;q);
        <span class="enscript-keyword">if</span> (!qptr) { Log(<span class="enscript-string">&quot;Malformatted LLQ from %s: cannot read question %u&quot;</span>, addr, i); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }
        llq = &amp;opt.r.resrec.rdata-&gt;u.opt[i].u.llq; <span class="enscript-comment">// point into OptData at index i
</span>        <span class="enscript-keyword">if</span> (llq-&gt;vers != kLLQ_Vers) { Log(<span class="enscript-string">&quot;LLQ from %s contains bad version %d (expected %d)&quot;</span>, addr, llq-&gt;vers, kLLQ_Vers); <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; }

        e = LookupLLQ(d, pkt-&gt;src, &amp;q.qname, q.qtype, &amp;llq-&gt;id);
        <span class="enscript-keyword">if</span> (!e)
        {
            <span class="enscript-comment">// no entry - if zero ID, create new
</span>            e = NewLLQ(d, pkt-&gt;src, &amp;q.qname, q.qtype, llq-&gt;llqlease );
            <span class="enscript-keyword">if</span> (!e) <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
        }
        UpdateLLQ(d, e, llq, pkt-&gt;msg.h.id, sock);
    }
    err = 0;

<span class="enscript-reference">end</span>:
    HdrHToN(pkt);
    <span class="enscript-keyword">return</span> err;
}


mDNSlocal mDNSBool <span class="enscript-function-name">IsAuthorized</span>( DaemonInfo * d, PktMsg * pkt, DomainAuthInfo ** key, mDNSu16 * rcode, mDNSu16 * tcode )
{
    <span class="enscript-type">const</span> mDNSu8    *   lastPtr = NULL;
    <span class="enscript-type">const</span> mDNSu8    *   ptr = NULL;
    DomainAuthInfo  *   keys;
    mDNSu8          *   end = ( mDNSu8* ) &amp;pkt-&gt;msg + pkt-&gt;len;
    LargeCacheRecord lcr;
    mDNSBool hasTSIG = mDNSfalse;
    mDNSBool strip = mDNSfalse;
    mDNSBool ok = mDNSfalse;
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// Unused parameters
</span>
    ( <span class="enscript-type">void</span> ) d;

    HdrNToH(pkt);

    *key = NULL;
    bzero(&amp;lcr, <span class="enscript-keyword">sizeof</span>(lcr));

    <span class="enscript-keyword">if</span> ( pkt-&gt;msg.h.numAdditionals )
    {
        ptr = LocateAdditionals(&amp;pkt-&gt;msg, end);
        <span class="enscript-keyword">if</span> (ptr)
        {
            <span class="enscript-keyword">for</span> (i = 0; i &lt; pkt-&gt;msg.h.numAdditionals; i++)
            {
                lastPtr = ptr;
                ptr = GetLargeResourceRecord(NULL, &amp;pkt-&gt;msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;lcr);
                <span class="enscript-keyword">if</span> (!ptr)
                {
                    Log(<span class="enscript-string">&quot;Unable to read additional record&quot;</span>);
                    lastPtr = NULL;
                    <span class="enscript-keyword">break</span>;
                }
            }

            hasTSIG = ( ptr &amp;&amp; lcr.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; lcr.r.resrec.rrtype == kDNSType_TSIG );
        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg( <span class="enscript-string">&quot;IsAuthorized: unable to find Additional section&quot;</span> );
        }
    }

    <span class="enscript-comment">// If we don't know what zone this is, then it's authorized.
</span>
    <span class="enscript-keyword">if</span> ( !pkt-&gt;zone )
    {
        ok = mDNStrue;
        strip = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">if</span> ( IsQuery( pkt ) )
    {
        keys = pkt-&gt;zone-&gt;queryKeys;
        strip = mDNStrue;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( IsUpdate( pkt ) )
    {
        keys = pkt-&gt;zone-&gt;updateKeys;
        strip = mDNSfalse;
    }
    <span class="enscript-keyword">else</span>
    {
        ok = mDNStrue;
        strip = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">if</span> ( pkt-&gt;isZonePublic )
    {
        ok = mDNStrue;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// If there are no keys, then we're authorized
</span>
    <span class="enscript-keyword">if</span> ( ( hasTSIG &amp;&amp; !keys ) || ( !hasTSIG &amp;&amp; keys ) )
    {
        Log( <span class="enscript-string">&quot;Invalid TSIG spec %##s for zone %##s&quot;</span>, lcr.r.resrec.name-&gt;c, pkt-&gt;zone-&gt;name.c );
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadKey;
        strip = mDNStrue;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// Find the right key
</span>
    <span class="enscript-keyword">for</span> ( *key = keys; *key; *key = (*key)-&gt;next )
    {
        <span class="enscript-keyword">if</span> ( SameDomainName( lcr.r.resrec.name, &amp;(*key)-&gt;keyname ) )
        {
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span> ( !(*key) )
    {
        Log( <span class="enscript-string">&quot;Invalid TSIG name %##s for zone %##s&quot;</span>, lcr.r.resrec.name-&gt;c, pkt-&gt;zone-&gt;name.c );
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadKey;
        strip = mDNStrue;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// Okay, we have the correct key and a TSIG record.  DNSDigest_VerifyMessage does the heavy
</span>    <span class="enscript-comment">// lifting of message verification
</span>
    pkt-&gt;msg.h.numAdditionals--;

    HdrHToN( pkt );

    ok = DNSDigest_VerifyMessage( &amp;pkt-&gt;msg, ( mDNSu8* ) lastPtr, &amp;lcr, (*key), rcode, tcode );

    HdrNToH( pkt );

    pkt-&gt;msg.h.numAdditionals++;

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( hasTSIG &amp;&amp; strip )
    {
        <span class="enscript-comment">// Strip the TSIG from the message
</span>
        pkt-&gt;msg.h.numAdditionals--;
        pkt-&gt;len = lastPtr - ( mDNSu8* ) ( &amp;pkt-&gt;msg );
    }

    HdrHToN(pkt);

    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-comment">// request handler wrappers for TCP and UDP requests
</span><span class="enscript-comment">// (read message off socket, fork thread that invokes main processing routine and handles cleanup)
</span>
mDNSlocal <span class="enscript-type">void</span>*
UDPMessageHandler
(
    <span class="enscript-type">void</span> * vptr
)
{
    UDPContext  *   context = ( UDPContext* ) vptr;
    PktMsg      *   reply   = NULL;
    <span class="enscript-type">int</span> res;
    mStatus err;

    <span class="enscript-comment">// !!!KRS strictly speaking, we shouldn't use TCP for a UDP request because the server
</span>    <span class="enscript-comment">// may give us a long answer that would require truncation for UDP delivery to client
</span>
    reply = HandleRequest( context-&gt;d, &amp;context-&gt;pkt );
    require_action( reply, exit, err = mStatus_UnknownErr );

    res = sendto( context-&gt;sd, &amp;reply-&gt;msg, reply-&gt;len, 0, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;context-&gt;pkt.src, <span class="enscript-keyword">sizeof</span>( context-&gt;pkt.src ) );
    require_action_quiet( res == ( <span class="enscript-type">int</span> ) reply-&gt;len, exit, LogErr( <span class="enscript-string">&quot;UDPMessageHandler&quot;</span>, <span class="enscript-string">&quot;sendto&quot;</span> ) );

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( reply )
    {
        free( reply );
    }

    free( context );

    pthread_exit( NULL );

    <span class="enscript-keyword">return</span> NULL;
}


mDNSlocal <span class="enscript-type">int</span>
RecvUDPMessage
(
    DaemonInfo  *   self,
    <span class="enscript-type">int</span> sd
)
{
    UDPContext      *   context = NULL;
    pthread_t tid;
    mDNSu16 rcode;
    mDNSu16 tcode;
    DomainAuthInfo  *   key;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> clisize = <span class="enscript-keyword">sizeof</span>( context-&gt;cliaddr );
    <span class="enscript-type">int</span> res;
    mStatus err = mStatus_NoError;

    context = malloc( <span class="enscript-keyword">sizeof</span>( UDPContext ) );
    require_action( context, exit, err = mStatus_NoMemoryErr ; LogErr( <span class="enscript-string">&quot;RecvUDPMessage&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span> ) );

    mDNSPlatformMemZero( context, <span class="enscript-keyword">sizeof</span>( *context ) );
    context-&gt;d = self;
    context-&gt;sd = sd;

    res = recvfrom(sd, &amp;context-&gt;pkt.msg, <span class="enscript-keyword">sizeof</span>(context-&gt;pkt.msg), 0, (<span class="enscript-type">struct</span> sockaddr *)&amp;context-&gt;cliaddr, &amp;clisize);

    require_action( res &gt;= 0, exit, err = mStatus_UnknownErr ; LogErr( <span class="enscript-string">&quot;RecvUDPMessage&quot;</span>, <span class="enscript-string">&quot;recvfrom&quot;</span> ) );
    context-&gt;pkt.len = res;
    require_action( clisize == <span class="enscript-keyword">sizeof</span>( context-&gt;cliaddr ), exit, err = mStatus_UnknownErr ; Log( <span class="enscript-string">&quot;Client address of unknown size %d&quot;</span>, clisize ) );
    context-&gt;pkt.src = context-&gt;cliaddr;

    <span class="enscript-comment">// Set the zone in the packet
</span>
    SetZone( context-&gt;d, &amp;context-&gt;pkt );

    <span class="enscript-comment">// Notify messages handled by main thread
</span>
    <span class="enscript-keyword">if</span> ( IsNotify( &amp;context-&gt;pkt ) )
    {
        <span class="enscript-type">int</span> e = RecvNotify( self, &amp;context-&gt;pkt );
        free(context);
        <span class="enscript-keyword">return</span> e;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( IsAuthorized( context-&gt;d, &amp;context-&gt;pkt, &amp;key, &amp;rcode, &amp;tcode ) )
    {
        <span class="enscript-keyword">if</span> ( IsLLQRequest( &amp;context-&gt;pkt ) )
        {
            <span class="enscript-comment">// LLQ messages handled by main thread
</span>            <span class="enscript-type">int</span> e = RecvLLQ( self, &amp;context-&gt;pkt, NULL );
            free(context);
            <span class="enscript-keyword">return</span> e;
        }

        <span class="enscript-keyword">if</span> ( IsLLQAck(&amp;context-&gt;pkt ) )
        {
            <span class="enscript-comment">// !!!KRS need to do acks + retrans
</span>
            free(context);
            <span class="enscript-keyword">return</span> 0;
        }

        err = pthread_create( &amp;tid, NULL, UDPMessageHandler, context );
        require_action( !err, exit, LogErr( <span class="enscript-string">&quot;RecvUDPMessage&quot;</span>, <span class="enscript-string">&quot;pthread_create&quot;</span> ) );

        pthread_detach(tid);
    }
    <span class="enscript-keyword">else</span>
    {
        PktMsg reply;
        <span class="enscript-type">int</span> e;

        memcpy( &amp;reply, &amp;context-&gt;pkt, <span class="enscript-keyword">sizeof</span>( PktMsg ) );

        reply.msg.h.flags.b[0]  =  kDNSFlag0_QR_Response | kDNSFlag0_AA | kDNSFlag0_RD;
        reply.msg.h.flags.b[1]  =  kDNSFlag1_RA | kDNSFlag1_RC_NXDomain;

        e = sendto( sd, &amp;reply.msg, reply.len, 0, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;context-&gt;pkt.src, <span class="enscript-keyword">sizeof</span>( context-&gt;pkt.src ) );
        require_action_quiet( e == ( <span class="enscript-type">int</span> ) reply.len, exit, LogErr( <span class="enscript-string">&quot;RecvUDPMessage&quot;</span>, <span class="enscript-string">&quot;sendto&quot;</span> ) );

        err = mStatus_NoAuth;
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( err &amp;&amp; context )
    {
        free( context );
    }

    <span class="enscript-keyword">return</span> err;
}


mDNSlocal <span class="enscript-type">void</span>
FreeTCPContext
(
    TCPContext * context
)
{
    <span class="enscript-keyword">if</span> ( context )
    {
        <span class="enscript-keyword">if</span> ( context-&gt;sock )
        {
            mDNSPlatformTCPCloseConnection( context-&gt;sock );
        }

        free( context );
    }
}


mDNSlocal <span class="enscript-type">void</span>*
TCPMessageHandler
(
    <span class="enscript-type">void</span> * vptr
)
{
    TCPContext  *   context = ( TCPContext* ) vptr;
    PktMsg      *   reply = NULL;
    <span class="enscript-type">int</span> res;
    <span class="enscript-type">char</span> buf[32];

    <span class="enscript-comment">//!!!KRS if this read blocks indefinitely, we can run out of threads
</span>    <span class="enscript-comment">// read the request
</span>
    reply = HandleRequest( context-&gt;d, &amp;context-&gt;pkt );
    require_action_quiet( reply, exit, LogMsg( <span class="enscript-string">&quot;TCPMessageHandler: No reply for client %s&quot;</span>, inet_ntop( AF_INET, &amp;context-&gt;cliaddr.sin_addr, buf, 32 ) ) );

    <span class="enscript-comment">// deliver reply to client
</span>
    res = SendPacket( context-&gt;sock, reply );
    require_action( res &gt;= 0, exit, LogMsg(<span class="enscript-string">&quot;TCPMessageHandler: Unable to send reply to client %s&quot;</span>, inet_ntop(AF_INET, &amp;context-&gt;cliaddr.sin_addr, buf, 32 ) ) );

<span class="enscript-reference">exit</span>:

    FreeTCPContext( context );

    <span class="enscript-keyword">if</span> ( reply )
    {
        free( reply );
    }

    pthread_exit(NULL);
}


mDNSlocal <span class="enscript-type">void</span>
RecvTCPMessage
(
    <span class="enscript-type">void</span> * param
)
{
    TCPContext      *   context = ( TCPContext* ) param;
    mDNSu16 rcode;
    mDNSu16 tcode;
    pthread_t tid;
    DomainAuthInfo  *   key;
    PktMsg          *   pkt;
    mDNSBool closed;
    mDNSBool freeContext = mDNStrue;
    mStatus err = mStatus_NoError;

    <span class="enscript-comment">// Receive a packet.  It's okay if we don't actually read a packet, as long as the closed flag is
</span>    <span class="enscript-comment">// set to false.  This is because SSL/TLS layer might gobble up the first packet that we read off the
</span>    <span class="enscript-comment">// wire.  We'll let it do that, and wait for the next packet which will be ours.
</span>
    pkt = RecvPacket( context-&gt;sock, &amp;context-&gt;pkt, &amp;closed );
    <span class="enscript-keyword">if</span> (pkt) HdrNToH(pkt);
    require_action( pkt || !closed, exit, err = mStatus_UnknownErr; LogMsg( <span class="enscript-string">&quot;client disconnected&quot;</span> ) );

    <span class="enscript-keyword">if</span> ( pkt )
    {
        <span class="enscript-comment">// Always do this, regardless of what kind of packet it is.  If we wanted LLQ events to be sent over TCP,
</span>        <span class="enscript-comment">// we would change this line of code.  As it is now, we will reply to an LLQ via TCP, but then events
</span>        <span class="enscript-comment">// are sent over UDP
</span>
        RemoveSourceFromEventLoop( context-&gt;d, context-&gt;sock );

        <span class="enscript-comment">// Set's the DNS Zone that is associated with this message
</span>
        SetZone( context-&gt;d, &amp;context-&gt;pkt );

        <span class="enscript-comment">// IsAuthorized will make sure the message is authorized for the designated zone.
</span>        <span class="enscript-comment">// After verifying the signature, it will strip the TSIG from the message
</span>
        <span class="enscript-keyword">if</span> ( IsAuthorized( context-&gt;d, &amp;context-&gt;pkt, &amp;key, &amp;rcode, &amp;tcode ) )
        {
            <span class="enscript-keyword">if</span> ( IsLLQRequest( &amp;context-&gt;pkt ) )
            {
                <span class="enscript-comment">// LLQ messages handled by main thread
</span>                RecvLLQ( context-&gt;d, &amp;context-&gt;pkt, context-&gt;sock);
            }
            <span class="enscript-keyword">else</span>
            {
                err = pthread_create( &amp;tid, NULL, TCPMessageHandler, context );

                <span class="enscript-keyword">if</span> ( err )
                {
                    LogErr( <span class="enscript-string">&quot;RecvTCPMessage&quot;</span>, <span class="enscript-string">&quot;pthread_create&quot;</span> );
                    err = mStatus_NoError;
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                }

                <span class="enscript-comment">// Let the thread free the context
</span>
                freeContext = mDNSfalse;

                pthread_detach(tid);
            }
        }
        <span class="enscript-keyword">else</span>
        {
            PktMsg reply;

            LogMsg( <span class="enscript-string">&quot;Client %s Not authorized for zone %##s&quot;</span>, inet_ntoa( context-&gt;pkt.src.sin_addr ), pkt-&gt;zone-&gt;name.c );

            memcpy( &amp;reply, &amp;context-&gt;pkt, <span class="enscript-keyword">sizeof</span>( PktMsg ) );

            reply.msg.h.flags.b[0]  =  kDNSFlag0_QR_Response | kDNSFlag0_AA | kDNSFlag0_RD;
            reply.msg.h.flags.b[1]  =  kDNSFlag1_RA | kDNSFlag1_RC_Refused;

            SendPacket( context-&gt;sock, &amp;reply );
        }
    }
    <span class="enscript-keyword">else</span>
    {
        freeContext = mDNSfalse;
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( err )
    {
        RemoveSourceFromEventLoop( context-&gt;d, context-&gt;sock );
    }

    <span class="enscript-keyword">if</span> ( freeContext )
    {
        FreeTCPContext( context );
    }
}


mDNSlocal <span class="enscript-type">int</span>
AcceptTCPConnection
(
    DaemonInfo      *   self,
    <span class="enscript-type">int</span> sd,
    TCPSocketFlags flags
)
{
    TCPContext *    context = NULL;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> clilen = <span class="enscript-keyword">sizeof</span>( context-&gt;cliaddr);
    <span class="enscript-type">int</span> newSock;
    mStatus err = mStatus_NoError;

    context = ( TCPContext* ) malloc( <span class="enscript-keyword">sizeof</span>( TCPContext ) );
    require_action( context, exit, err = mStatus_NoMemoryErr; LogErr( <span class="enscript-string">&quot;AcceptTCPConnection&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span> ) );
    mDNSPlatformMemZero( context, <span class="enscript-keyword">sizeof</span>( <span class="enscript-keyword">sizeof</span>( TCPContext ) ) );
    context-&gt;d       = self;
    newSock = accept( sd, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;context-&gt;cliaddr, &amp;clilen );
    require_action( newSock != -1, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;AcceptTCPConnection&quot;</span>, <span class="enscript-string">&quot;accept&quot;</span> ) );

    context-&gt;sock = mDNSPlatformTCPAccept( flags, newSock );
    require_action( context-&gt;sock, exit, err = mStatus_UnknownErr; LogErr( <span class="enscript-string">&quot;AcceptTCPConnection&quot;</span>, <span class="enscript-string">&quot;mDNSPlatformTCPAccept&quot;</span> ) );

    err = AddSourceToEventLoop( self, context-&gt;sock, RecvTCPMessage, context );
    require_action( !err, exit, LogErr( <span class="enscript-string">&quot;AcceptTCPConnection&quot;</span>, <span class="enscript-string">&quot;AddSourceToEventLoop&quot;</span> ) );

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> ( err &amp;&amp; context )
    {
        free( context );
        context = NULL;
    }

    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">// main event loop
</span><span class="enscript-comment">// listen for incoming requests, periodically check table for expired records, respond to signals
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">Run</span>(DaemonInfo *d)
{
    <span class="enscript-type">int</span> staticMaxFD, nfds;
    fd_set rset;
    <span class="enscript-type">struct</span> timeval timenow, timeout, EventTS, tablecheck = { 0, 0 };
    mDNSBool EventsPending = mDNSfalse;

    VLog(<span class="enscript-string">&quot;Listening for requests...&quot;</span>);

    staticMaxFD = 0;

    <span class="enscript-keyword">if</span> ( d-&gt;tcpsd + 1  &gt; staticMaxFD ) staticMaxFD = d-&gt;tcpsd + 1;
    <span class="enscript-keyword">if</span> ( d-&gt;udpsd + 1  &gt; staticMaxFD ) staticMaxFD = d-&gt;udpsd + 1;
    <span class="enscript-keyword">if</span> ( d-&gt;tlssd + 1  &gt; staticMaxFD ) staticMaxFD = d-&gt;tlssd + 1;
    <span class="enscript-keyword">if</span> ( d-&gt;llq_tcpsd + 1 &gt; staticMaxFD ) staticMaxFD = d-&gt;llq_tcpsd + 1;
    <span class="enscript-keyword">if</span> ( d-&gt;llq_udpsd + 1 &gt; staticMaxFD ) staticMaxFD = d-&gt;llq_udpsd + 1;
    <span class="enscript-keyword">if</span> ( d-&gt;LLQEventListenSock + 1 &gt; staticMaxFD ) staticMaxFD = d-&gt;LLQEventListenSock + 1;

    <span class="enscript-keyword">while</span>(1)
    {
        EventSource * source;
        <span class="enscript-type">int</span> maxFD;

        <span class="enscript-comment">// set timeout
</span>        timeout.tv_sec = timeout.tv_usec = 0;
        <span class="enscript-keyword">if</span> (gettimeofday(&amp;timenow, NULL)) { LogErr(<span class="enscript-string">&quot;Run&quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">return</span> -1; }

        <span class="enscript-keyword">if</span> (EventsPending)
        {
            <span class="enscript-keyword">if</span> (timenow.tv_sec - EventTS.tv_sec &gt;= 5)           <span class="enscript-comment">// if we've been waiting 5 seconds for a &quot;quiet&quot; period to send
</span>            { GenLLQEvents(d); EventsPending = mDNSfalse; }     <span class="enscript-comment">// events, we go ahead and do it now
</span>            <span class="enscript-keyword">else</span> timeout.tv_usec = 500000;                      <span class="enscript-comment">// else do events after 1/2 second with no new events or LLQs
</span>        }
        <span class="enscript-keyword">if</span> (!EventsPending)
        {
            <span class="enscript-comment">// if no pending events, timeout when we need to check for expired records
</span>            <span class="enscript-keyword">if</span> (tablecheck.tv_sec &amp;&amp; timenow.tv_sec - tablecheck.tv_sec &gt;= 0)
            { DeleteRecords(d, mDNSfalse); tablecheck.tv_sec = 0; }     <span class="enscript-comment">// table check overdue
</span>            <span class="enscript-keyword">if</span> (!tablecheck.tv_sec) tablecheck.tv_sec = timenow.tv_sec + EXPIRATION_INTERVAL;
            timeout.tv_sec = tablecheck.tv_sec - timenow.tv_sec;
        }

        FD_ZERO(&amp;rset);
        FD_SET( d-&gt;tcpsd, &amp;rset );
        FD_SET( d-&gt;udpsd, &amp;rset );
        FD_SET( d-&gt;tlssd, &amp;rset );
        FD_SET( d-&gt;llq_tcpsd, &amp;rset );
        FD_SET( d-&gt;llq_udpsd, &amp;rset );
        FD_SET( d-&gt;LLQEventListenSock, &amp;rset );

        maxFD = staticMaxFD;

        <span class="enscript-keyword">for</span> ( source = ( EventSource* ) d-&gt;eventSources.Head; source; source = source-&gt;next )
        {
            FD_SET( source-&gt;fd, &amp;rset );

            <span class="enscript-keyword">if</span> ( source-&gt;fd &gt; maxFD )
            {
                maxFD = source-&gt;fd;
            }
        }

        nfds = select( maxFD + 1, &amp;rset, NULL, NULL, &amp;timeout);
        <span class="enscript-keyword">if</span> (nfds &lt; 0)
        {
            <span class="enscript-keyword">if</span> (errno == EINTR)
            {
                <span class="enscript-keyword">if</span> (terminate)
                {
                    <span class="enscript-comment">// close sockets to prevent clients from making new requests during shutdown
</span>                    close( d-&gt;tcpsd );
                    close( d-&gt;udpsd );
                    close( d-&gt;tlssd );
                    close( d-&gt;llq_tcpsd );
                    close( d-&gt;llq_udpsd );
                    d-&gt;tcpsd = d-&gt;udpsd = d-&gt;tlssd = d-&gt;llq_tcpsd = d-&gt;llq_udpsd = -1;
                    DeleteRecords(d, mDNStrue);
                    <span class="enscript-keyword">return</span> 0;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dumptable)
                {
                    Log( <span class="enscript-string">&quot;Received SIGINFO&quot;</span> );

                    PrintLeaseTable(d);
                    PrintLLQTable(d);
                    PrintLLQAnswers(d);
                    dumptable = 0;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hangup)
                {
                    <span class="enscript-type">int</span> err;

                    Log( <span class="enscript-string">&quot;Received SIGHUP&quot;</span> );

                    err = ParseConfig( d, cfgfile );

                    <span class="enscript-keyword">if</span> ( err )
                    {
                        LogErr( <span class="enscript-string">&quot;Run&quot;</span>, <span class="enscript-string">&quot;ParseConfig&quot;</span> );
                        <span class="enscript-keyword">return</span> -1;
                    }

                    hangup = 0;
                }
                <span class="enscript-keyword">else</span>
                {
                    Log(<span class="enscript-string">&quot;Received unhandled signal - continuing&quot;</span>);
                }
            }
            <span class="enscript-keyword">else</span>
            {
                LogErr(<span class="enscript-string">&quot;Run&quot;</span>, <span class="enscript-string">&quot;select&quot;</span>); <span class="enscript-keyword">return</span> -1;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nfds)
        {
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;udpsd, &amp;rset)) RecvUDPMessage( d, d-&gt;udpsd );
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;llq_udpsd, &amp;rset)) RecvUDPMessage( d, d-&gt;llq_udpsd );
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;tcpsd, &amp;rset)) AcceptTCPConnection( d, d-&gt;tcpsd, 0 );
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;llq_tcpsd, &amp;rset)) AcceptTCPConnection( d, d-&gt;llq_tcpsd, 0 );
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;tlssd, &amp;rset)) AcceptTCPConnection( d, d-&gt;tlssd, TCP_SOCKET_FLAGS );
            <span class="enscript-keyword">if</span> (FD_ISSET(d-&gt;LLQEventListenSock, &amp;rset))
            {
                <span class="enscript-comment">// clear signalling data off socket
</span>                <span class="enscript-type">char</span> buf[256];
                recv(d-&gt;LLQEventListenSock, buf, 256, 0);
                <span class="enscript-keyword">if</span> (!EventsPending)
                {
                    EventsPending = mDNStrue;
                    <span class="enscript-keyword">if</span> (gettimeofday(&amp;EventTS, NULL)) { LogErr(<span class="enscript-string">&quot;Run&quot;</span>, <span class="enscript-string">&quot;gettimeofday&quot;</span>); <span class="enscript-keyword">return</span> -1; }
                }
            }

            <span class="enscript-keyword">for</span> ( source = ( EventSource* ) d-&gt;eventSources.Head; source; source = source-&gt;next )
            {
                <span class="enscript-keyword">if</span> ( FD_ISSET( source-&gt;fd, &amp;rset ) )
                {
                    source-&gt;callback( source-&gt;context );
                    <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// in case we removed this guy from the event loop
</span>                }
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// timeout
</span>            <span class="enscript-keyword">if</span> (EventsPending) { GenLLQEvents(d); EventsPending = mDNSfalse; }
            <span class="enscript-keyword">else</span> { DeleteRecords(d, mDNSfalse); tablecheck.tv_sec = 0; }
        }
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// signal handler sets global variables, which are inspected by main event loop
</span><span class="enscript-comment">// (select automatically returns due to the handled signal)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HndlSignal</span>(<span class="enscript-type">int</span> sig)
{
    <span class="enscript-keyword">if</span> (sig == SIGTERM || sig == SIGINT ) { terminate = 1; <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (sig == INFO_SIGNAL)               { dumptable = 1; <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (sig == SIGHUP)                    { hangup    = 1; <span class="enscript-keyword">return</span>; }
}

mDNSlocal mStatus
SetPublicSRV
(
    DaemonInfo  *   d,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>  *   name
)
{
    DNameListElem * elem;
    mStatus err = mStatus_NoError;

    elem = ( DNameListElem* ) malloc( <span class="enscript-keyword">sizeof</span>( DNameListElem ) );
    require_action( elem, exit, err = mStatus_NoMemoryErr );
    MakeDomainNameFromDNSNameString( &amp;elem-&gt;name, name );
    elem-&gt;next = d-&gt;public_names;
    d-&gt;public_names = elem;

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[])
{
    <span class="enscript-type">int</span> started_via_launchd = 0;
    DaemonInfo *d;
    <span class="enscript-type">struct</span> rlimit rlim;

    Log(<span class="enscript-string">&quot;dnsextd starting&quot;</span>);

    d = malloc(<span class="enscript-keyword">sizeof</span>(*d));
    <span class="enscript-keyword">if</span> (!d) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;malloc&quot;</span>); exit(1); }
    mDNSPlatformMemZero(d, <span class="enscript-keyword">sizeof</span>(DaemonInfo));

    <span class="enscript-comment">// Setup the public SRV record names
</span>
    SetPublicSRV(d, <span class="enscript-string">&quot;_dns-update._udp.&quot;</span>);
    SetPublicSRV(d, <span class="enscript-string">&quot;_dns-llq._udp.&quot;</span>);
    SetPublicSRV(d, <span class="enscript-string">&quot;_dns-update-tls._tcp.&quot;</span>);
    SetPublicSRV(d, <span class="enscript-string">&quot;_dns-query-tls._tcp.&quot;</span>);
    SetPublicSRV(d, <span class="enscript-string">&quot;_dns-llq-tls._tcp.&quot;</span>);

    <span class="enscript-comment">// Setup signal handling
</span>
    <span class="enscript-keyword">if</span> (signal(SIGHUP,      HndlSignal) == SIG_ERR) perror(<span class="enscript-string">&quot;Can't catch SIGHUP&quot;</span>);
    <span class="enscript-keyword">if</span> (signal(SIGTERM,     HndlSignal) == SIG_ERR) perror(<span class="enscript-string">&quot;Can't catch SIGTERM&quot;</span>);
    <span class="enscript-keyword">if</span> (signal(INFO_SIGNAL, HndlSignal) == SIG_ERR) perror(<span class="enscript-string">&quot;Can't catch SIGINFO&quot;</span>);
    <span class="enscript-keyword">if</span> (signal(SIGINT,      HndlSignal) == SIG_ERR) perror(<span class="enscript-string">&quot;Can't catch SIGINT&quot;</span>);
    <span class="enscript-keyword">if</span> (signal(SIGPIPE,     SIG_IGN  )  == SIG_ERR) perror(<span class="enscript-string">&quot;Can't ignore SIGPIPE&quot;</span>);

    <span class="enscript-comment">// remove open file limit
</span>    rlim.rlim_max = RLIM_INFINITY;
    rlim.rlim_cur = RLIM_INFINITY;
    <span class="enscript-keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) &lt; 0)
    {
        LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;setrlimit&quot;</span>);
        Log(<span class="enscript-string">&quot;Using default file descriptor resource limit&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (argc &gt; 1 &amp;&amp; !strcasecmp(argv[1], <span class="enscript-string">&quot;-launchd&quot;</span>))
    {
        Log(<span class="enscript-string">&quot;started_via_launchd&quot;</span>);
        started_via_launchd = 1;
        argv++;
        argc--;
    }
    <span class="enscript-keyword">if</span> (ProcessArgs(argc, argv, d) &lt; 0) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;ProcessArgs&quot;</span>); exit(1); }

    <span class="enscript-keyword">if</span> (!foreground &amp;&amp; !started_via_launchd)
    {
        <span class="enscript-keyword">if</span> (daemon(0,0))
        {
            LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;daemon&quot;</span>);
            foreground = 1;
        }
    }

    <span class="enscript-keyword">if</span> (InitLeaseTable(d) &lt; 0) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;InitLeaseTable&quot;</span>); exit(1); }
    <span class="enscript-keyword">if</span> (SetupSockets(d) &lt; 0) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;SetupSockets&quot;</span>); exit(1); }
    <span class="enscript-keyword">if</span> (SetUpdateSRV(d) &lt; 0) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;SetUpdateSRV&quot;</span>); exit(1); }

    Run(d);

    Log(<span class="enscript-string">&quot;dnsextd stopping&quot;</span>);

    <span class="enscript-keyword">if</span> (ClearUpdateSRV(d) &lt; 0) { LogErr(<span class="enscript-string">&quot;main&quot;</span>, <span class="enscript-string">&quot;ClearUpdateSRV&quot;</span>); exit(1); }  <span class="enscript-comment">// clear update srv's even if Run or pthread_create returns an error
</span>    free(d);
    exit(0);
}


<span class="enscript-comment">// These are stubbed out implementations of up-call routines that the various platform support layers
</span><span class="enscript-comment">// call.  These routines are fully implemented in both mDNS.c and uDNS.c, but dnsextd doesn't
</span><span class="enscript-comment">// link this code in.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// It's an error for these routines to actually be called, so perhaps we should log any call
</span><span class="enscript-comment">// to them.
</span><span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreInitComplete</span>( mDNS * <span class="enscript-type">const</span> m, mStatus result) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) result; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ConfigChanged</span>(mDNS *<span class="enscript-type">const</span> m)  { ( <span class="enscript-type">void</span> ) m; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreMachineSleep</span>(mDNS * <span class="enscript-type">const</span> m, mDNSBool wake) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) wake; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceive</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                     <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport,
                     <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dstaddr, <span class="enscript-type">const</span> mDNSIPPort dstport, <span class="enscript-type">const</span> mDNSInterfaceID iid)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) msg; ( <span class="enscript-type">void</span> ) end; ( <span class="enscript-type">void</span> ) srcaddr; ( <span class="enscript-type">void</span> ) srcport; ( <span class="enscript-type">void</span> ) dstaddr; ( <span class="enscript-type">void</span> ) dstport; ( <span class="enscript-type">void</span> ) iid; }
DNSServer *<span class="enscript-function-name">mDNS_AddDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">const</span> mDNSInterfaceID interface, <span class="enscript-type">const</span> <span class="enscript-type">int</span> serviceID, <span class="enscript-type">const</span> mDNSAddr *addr, <span class="enscript-type">const</span> mDNSIPPort port, 
                             mDNSu32 scopedType, mDNSu32 timeout, mDNSBool isCell, mDNSBool isExpensive, mDNSBool isConstrained,  mDNSBool isCLAT46, mDNSu32 resGroupID, mDNSBool reqA, mDNSBool reqAAAA, mDNSBool reqDO)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) d; ( <span class="enscript-type">void</span> ) interface; ( <span class="enscript-type">void</span> ) serviceID; ( <span class="enscript-type">void</span> ) addr; ( <span class="enscript-type">void</span> ) port; ( <span class="enscript-type">void</span> ) scopedType; ( <span class="enscript-type">void</span> ) timeout; (<span class="enscript-type">void</span>) isCell; (<span class="enscript-type">void</span>) isExpensive; (<span class="enscript-type">void</span>) isConstrained; (<span class="enscript-type">void</span>) isCLAT46;
    (<span class="enscript-type">void</span>) resGroupID; (<span class="enscript-type">void</span>) reqA; (<span class="enscript-type">void</span>) reqAAAA; (<span class="enscript-type">void</span>) reqDO; <span class="enscript-keyword">return</span>(NULL); }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddSearchDomain</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain, mDNSInterfaceID InterfaceID) { (<span class="enscript-type">void</span>)domain; (<span class="enscript-type">void</span>) InterfaceID;}
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn, mDNSRecordCallback *StatusCallback, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *StatusContext)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) fqdn; ( <span class="enscript-type">void</span> ) StatusCallback; ( <span class="enscript-type">void</span> ) StatusContext; }
mDNSs32 <span class="enscript-function-name">mDNS_Execute</span>   (mDNS *<span class="enscript-type">const</span> m) { ( <span class="enscript-type">void</span> ) m; <span class="enscript-keyword">return</span> 0; }
mDNSs32 <span class="enscript-function-name">mDNS_TimeNow</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m) { ( <span class="enscript-type">void</span> ) m; <span class="enscript-keyword">return</span> 0; }
mStatus <span class="enscript-function-name">mDNS_Deregister</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) rr; <span class="enscript-keyword">return</span> 0; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_DeregisterInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed activationSpeed)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) set; ( <span class="enscript-type">void</span> ) activationSpeed; }
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> mDNS_DomainTypeNames[1] = {};
mStatus <span class="enscript-function-name">mDNS_GetDomains</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question, mDNS_DomainType DomainType, <span class="enscript-type">const</span> domainname *dom,
                        <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) question; ( <span class="enscript-type">void</span> ) DomainType; ( <span class="enscript-type">void</span> ) dom; ( <span class="enscript-type">void</span> ) InterfaceID; ( <span class="enscript-type">void</span> ) Callback; ( <span class="enscript-type">void</span> ) Context; <span class="enscript-keyword">return</span> 0; }
mStatus <span class="enscript-function-name">mDNS_Register</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) rr; <span class="enscript-keyword">return</span> 0; }
mStatus <span class="enscript-function-name">mDNS_RegisterInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed activationSpeed)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) set; ( <span class="enscript-type">void</span> ) activationSpeed; <span class="enscript-keyword">return</span> 0; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RemoveDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) fqdn; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetFQDN</span>(mDNS * <span class="enscript-type">const</span> m) { ( <span class="enscript-type">void</span> ) m; }
<span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetPrimaryInterfaceInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSAddr *v4addr,  <span class="enscript-type">const</span> mDNSAddr *v6addr, <span class="enscript-type">const</span> mDNSAddr *router)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) v4addr; ( <span class="enscript-type">void</span> ) v6addr; ( <span class="enscript-type">void</span> ) router; }
mStatus <span class="enscript-function-name">uDNS_SetupDNSConfig</span>( mDNS *<span class="enscript-type">const</span> m ) { ( <span class="enscript-type">void</span> ) m; <span class="enscript-keyword">return</span> 0; }
mStatus <span class="enscript-function-name">mDNS_SetSecretForDomain</span>(mDNS *m, DomainAuthInfo *info,
                                <span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> domainname *keyname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64keydata, <span class="enscript-type">const</span> domainname *hostname, mDNSIPPort *port)
{ ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) info; ( <span class="enscript-type">void</span> ) domain; ( <span class="enscript-type">void</span> ) keyname; ( <span class="enscript-type">void</span> ) b64keydata; ( <span class="enscript-type">void</span> ) hostname; (<span class="enscript-type">void</span>) port; <span class="enscript-keyword">return</span> 0; }
mStatus <span class="enscript-function-name">mDNS_StopQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question) { ( <span class="enscript-type">void</span> ) m; ( <span class="enscript-type">void</span> ) question; <span class="enscript-keyword">return</span> 0; }
<span class="enscript-type">void</span> <span class="enscript-function-name">TriggerEventCompletion</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">TriggerEventCompletion</span>() {}
mDNS mDNSStorage;


<span class="enscript-comment">// For convenience when using the &quot;strings&quot; command, this is the last thing in the file
</span><span class="enscript-comment">// The &quot;@(#) &quot; pattern is a special prefix the &quot;what&quot; command looks for
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> mDNSResponderVersionString_SCCS[] = <span class="enscript-string">&quot;@(#) dnsextd &quot;</span> STRINGIFY(mDNSResponderVersion) <span class="enscript-string">&quot; (&quot;</span> __DATE__ <span class="enscript-string">&quot; &quot;</span> __TIME__ <span class="enscript-string">&quot;)&quot;</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">_BUILDING_XCODE_PROJECT_</span>
<span class="enscript-comment">// If the process crashes, then this string will be magically included in the automatically-generated crash log
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> *__crashreporter_info__ = mDNSResponderVersionString_SCCS + 5;
<span class="enscript-function-name">asm</span> (<span class="enscript-string">&quot;.desc ___crashreporter_info__, 0x10&quot;</span>);
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>