<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dnsextd_parser.y</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dnsextd_parser.y&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="dnsextd_parser.y">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2006-2010 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

%{
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;mDNSEmbeddedAPI.h&quot;
#include &quot;DebugServices.h&quot;
#include &quot;dnsextd.h&quot;

void yyerror( const char* error );
int  yylex(void);


typedef struct StringListElem
{
	char					*	string;
	struct StringListElem	*	next;
} StringListElem;


typedef struct OptionsInfo
{
	char	server_address[ 256 ];
	int		server_port;
	char	source_address[ 256 ];
	int		source_port;
	int		private_port;
	int		llq_port;
} OptionsInfo;


typedef struct ZoneInfo
{
	char	name[ 256 ];
	char	certificate_name[ 256 ];
	char	allow_clients_file[ 256 ];
	char	allow_clients[ 256 ];
	char	key[ 256 ];
} ZoneInfo;


typedef struct KeySpec
{
	char 				name[ 256 ];
	char				algorithm[ 256 ];
	char				secret[ 256 ];
	struct KeySpec	*	next;
} KeySpec;


typedef struct ZoneSpec
{
	char				name[ 256 ];
	DNSZoneSpecType		type;
	StringListElem	*	allowUpdate;
	StringListElem	*	allowQuery;
	char				key[ 256 ];
	struct ZoneSpec	*	next;
} ZoneSpec;


static StringListElem	*	g_stringList = NULL;
static StringListElem	*	g_addrList = NULL;
static KeySpec			*	g_keys;
static ZoneSpec			*	g_zones;
static ZoneSpec				g_zoneSpec;
static const char		*	g_filename;

#define YYPARSE_PARAM  context

void
SetupOptions
	(
	OptionsInfo	*	info,
	void		*	context
	);

%}

%union
{
	int			number;
	char	*	string;
}

%token	OPTIONS 
%token	LISTEN_ON 
%token	NAMESERVER
%token	PORT 
%token	ADDRESS 
%token	LLQ 
%token	PUBLIC
%token  PRIVATE
%token  ALLOWUPDATE
%token  ALLOWQUERY
%token	KEY 
%token  ALGORITHM
%token  SECRET
%token  ISSUER
%token  SERIAL
%token	ZONE
%token  TYPE
%token	ALLOW
%token	OBRACE 
%token	EBRACE 
%token	SEMICOLON
%token 	IN
%token	&lt;string&gt;	DOTTED_DECIMAL_ADDRESS 
%token	&lt;string&gt;	WILDCARD 
%token	&lt;string&gt;	DOMAINNAME 
%token	&lt;string&gt;	HOSTNAME 
%token	&lt;string&gt;	QUOTEDSTRING
%token	&lt;number&gt; 	NUMBER 

%type	&lt;string&gt;	addressstatement
%type	&lt;string&gt;	networkaddress

%%

commands:
        |        
        commands command SEMICOLON
        ;


command:
		options_set
		|
        zone_set 
		|
		key_set
        ;


options_set:
		OPTIONS optionscontent
		{
			// SetupOptions( &amp;g_optionsInfo, context );
		}
		;

optionscontent:
		OBRACE optionsstatements EBRACE
		;

optionsstatements:
		|
		optionsstatements optionsstatement SEMICOLON
		;


optionsstatement:
		statements
		|
		LISTEN_ON addresscontent
		{
		}
		|
		LISTEN_ON PORT NUMBER addresscontent
		{
			mDNSIPPort listen_port = mDNSOpaque16fromIntVal( $3 );
			DaemonInfo* d = ( DaemonInfo* ) context;
			d-&gt;addr.sin_port = ( listen_port.NotAnInteger) ? listen_port.NotAnInteger : UnicastDNSPort.NotAnInteger;
			StringListElem* addr = g_addrList;
			while (addr != NULL)
			{
				StringListElem* next;
				// The first ipv4 address in {,} is used; the rest are ignored.
				if (inet_pton( AF_INET, addr-&gt;string, &amp;d-&gt;addr.sin_addr ) == 0) {
					inet_pton( AF_INET, &quot;127.0.0.1&quot;, &amp;d-&gt;ns_addr.sin_addr );
					LogMsg(&quot;LISTEN_ON: An invalid ipv4 address, %s, detected.&quot;, addr-&gt;string);
				}
				next = addr-&gt;next;
				free(addr);
				addr = next;
			}
		}
		|
		NAMESERVER ADDRESS networkaddress
		{
		}
		|
		NAMESERVER ADDRESS networkaddress PORT NUMBER
		{
		}
		|
		PRIVATE PORT NUMBER
		{
			( ( DaemonInfo* ) context )-&gt;private_port = mDNSOpaque16fromIntVal( $3 );
		}
		|
		LLQ PORT NUMBER
		{
			( ( DaemonInfo* ) context )-&gt;llq_port = mDNSOpaque16fromIntVal( $3 );
		}
		;

key_set:
        KEY QUOTEDSTRING OBRACE SECRET QUOTEDSTRING SEMICOLON EBRACE
        {
			KeySpec	* keySpec;

			keySpec = ( KeySpec* ) malloc( sizeof( KeySpec ) );

			if ( !keySpec )
				{
				LogMsg(&quot;ERROR: memory allocation failure&quot;);
				YYABORT;
				}

			strncpy( keySpec-&gt;name, $2, sizeof( keySpec-&gt;name ) );
			strncpy( keySpec-&gt;secret, $5, sizeof( keySpec-&gt;secret ) );

			keySpec-&gt;next	= g_keys;
			g_keys			= keySpec;
        }
        ;

zone_set:
		ZONE QUOTEDSTRING zonecontent
		{
			ZoneSpec * zoneSpec;

			zoneSpec = ( ZoneSpec* ) malloc( sizeof( ZoneSpec ) );

			if ( !zoneSpec )
				{
				LogMsg(&quot;ERROR: memory allocation failure&quot;);
				YYABORT;
				}

			strncpy( zoneSpec-&gt;name, $2, sizeof( zoneSpec-&gt;name ) );
			zoneSpec-&gt;type = g_zoneSpec.type;
			strcpy( zoneSpec-&gt;key, g_zoneSpec.key );
			zoneSpec-&gt;allowUpdate = g_zoneSpec.allowUpdate;
			zoneSpec-&gt;allowQuery = g_zoneSpec.allowQuery;

			zoneSpec-&gt;next = g_zones;
			g_zones = zoneSpec;
		}
		|
		ZONE QUOTEDSTRING IN zonecontent
        {
			ZoneSpec * zoneSpec;

			zoneSpec = ( ZoneSpec* ) malloc( sizeof( ZoneSpec ) );

			if ( !zoneSpec )
				{
				LogMsg(&quot;ERROR: memory allocation failure&quot;);
				YYABORT;
				}

			strncpy( zoneSpec-&gt;name, $2, sizeof( zoneSpec-&gt;name ) );
			zoneSpec-&gt;type = g_zoneSpec.type;
			strcpy( zoneSpec-&gt;key, g_zoneSpec.key );
			zoneSpec-&gt;allowUpdate = g_zoneSpec.allowUpdate;
			zoneSpec-&gt;allowQuery = g_zoneSpec.allowQuery;

			zoneSpec-&gt;next = g_zones;
			g_zones = zoneSpec;
		}
        ;

zonecontent:
		OBRACE zonestatements EBRACE 

zonestatements:
        |
        zonestatements zonestatement SEMICOLON
        ;

zonestatement:
		TYPE PUBLIC
		{
			g_zoneSpec.type = kDNSZonePublic;
		}
		|
		TYPE PRIVATE
		{
			g_zoneSpec.type = kDNSZonePrivate;
		}
		|
		ALLOWUPDATE keycontent
		{
			g_zoneSpec.allowUpdate = g_stringList;
			g_stringList = NULL;
		}
		|
		ALLOWQUERY keycontent
		{
			g_zoneSpec.allowQuery = g_stringList;
			g_stringList = NULL;
		}
        ;

addresscontent:
		OBRACE addressstatements EBRACE
		{
		}

addressstatements:
		|
		addressstatements addressstatement SEMICOLON
		{
		}
		;

addressstatement:
		DOTTED_DECIMAL_ADDRESS
		{
			StringListElem * elem;

			elem = ( StringListElem* ) malloc( sizeof( StringListElem ) );

			if ( !elem )
			{
				LogMsg(&quot;ERROR: memory allocation failure&quot;);
				YYABORT;
			}

			elem-&gt;string = $1;

			elem-&gt;next		= g_addrList;
			g_addrList		= elem;
		}
		;


keycontent:
		OBRACE keystatements EBRACE
		{
		}

keystatements:
		|
		keystatements keystatement SEMICOLON
		{
		}
		;

keystatement:
		KEY DOMAINNAME
		{
			StringListElem * elem;

			elem = ( StringListElem* ) malloc( sizeof( StringListElem ) );

			if ( !elem )
				{
				LogMsg(&quot;ERROR: memory allocation failure&quot;);
				YYABORT;
				}

			elem-&gt;string = $2;

			elem-&gt;next		= g_stringList;
			g_stringList	= elem;
		}
		;


networkaddress:
		DOTTED_DECIMAL_ADDRESS
		|
		HOSTNAME
		|
		WILDCARD
		;

block: 
		OBRACE zonestatements EBRACE SEMICOLON
        ;

statements:
        |
		statements statement
        ;

statement:
		block
		{
			$&lt;string&gt;$ = NULL;
		}
		|
		QUOTEDSTRING
		{
			$&lt;string&gt;$ = $1;
		}
%%

int yywrap(void);

extern int yylineno;

void yyerror( const char *str )
{
        fprintf( stderr,&quot;%s:%d: error: %s\n&quot;, g_filename, yylineno, str );
}
 
int yywrap()
{
        return 1;
} 


int
ParseConfig
	(
	DaemonInfo	*	d,
	const char	*	file
	)
	{
	extern FILE		*	yyin;
	DNSZone			*	zone;
	DomainAuthInfo	*	key;
	KeySpec			*	keySpec;
	ZoneSpec		*	zoneSpec;
	int					err = 0;

	g_filename = file;

	// Tear down the current zone specifiers

	zone = d-&gt;zones;

	while ( zone )
		{
		DNSZone * next = zone-&gt;next;

		key = zone-&gt;updateKeys;

		while ( key )
			{
			DomainAuthInfo * nextKey = key-&gt;next;

			free( key );

			key = nextKey;
			}

		key = zone-&gt;queryKeys;

		while ( key )
			{
			DomainAuthInfo * nextKey = key-&gt;next;

			free( key );

			key = nextKey;
			}

		free( zone );

		zone = next;
		}

	d-&gt;zones = NULL;
	
	yyin = fopen( file, &quot;r&quot; );
	require_action( yyin, exit, err = 0 );

	err = yyparse( ( void* ) d );
	require_action( !err, exit, err = 1 );

	for ( zoneSpec = g_zones; zoneSpec; zoneSpec = zoneSpec-&gt;next )
		{
		StringListElem  *   elem;
		mDNSu8			*	ok;

		zone = ( DNSZone* ) malloc( sizeof( DNSZone ) );
		require_action( zone, exit, err = 1 );
		memset( zone, 0, sizeof( DNSZone ) );

		zone-&gt;next	= d-&gt;zones;
		d-&gt;zones	= zone;

		// Fill in the domainname

		ok = MakeDomainNameFromDNSNameString( &amp;zone-&gt;name, zoneSpec-&gt;name );
		require_action( ok, exit, err = 1 );

		// Fill in the type

		zone-&gt;type = zoneSpec-&gt;type;

		// Fill in the allow-update keys

		for ( elem = zoneSpec-&gt;allowUpdate; elem; elem = elem-&gt;next )
			{
			mDNSBool found = mDNSfalse;

			for ( keySpec = g_keys; keySpec; keySpec = keySpec-&gt;next )
				{
				if ( strcmp( elem-&gt;string, keySpec-&gt;name ) == 0 )
					{
					DomainAuthInfo	*	authInfo = malloc( sizeof( DomainAuthInfo ) );
					mDNSs32				keylen;
					require_action( authInfo, exit, err = 1 );
					memset( authInfo, 0, sizeof( DomainAuthInfo ) );

					ok = MakeDomainNameFromDNSNameString( &amp;authInfo-&gt;keyname, keySpec-&gt;name );
					if (!ok) { free(authInfo); err = 1; goto exit; }

					keylen = DNSDigest_ConstructHMACKeyfromBase64( authInfo, keySpec-&gt;secret );
					if (keylen &lt; 0) { free(authInfo); err = 1; goto exit; }

					authInfo-&gt;next = zone-&gt;updateKeys;
					zone-&gt;updateKeys = authInfo;

					found = mDNStrue;

					break;
					}
				}

			// Log this
			require_action( found, exit, err = 1 );
			}

		// Fill in the allow-query keys

		for ( elem = zoneSpec-&gt;allowQuery; elem; elem = elem-&gt;next )
			{
			mDNSBool found = mDNSfalse;

			for ( keySpec = g_keys; keySpec; keySpec = keySpec-&gt;next )
				{
				if ( strcmp( elem-&gt;string, keySpec-&gt;name ) == 0 )
					{
					DomainAuthInfo	*	authInfo = malloc( sizeof( DomainAuthInfo ) );
					mDNSs32				keylen;
					require_action( authInfo, exit, err = 1 );
					memset( authInfo, 0, sizeof( DomainAuthInfo ) );

					ok = MakeDomainNameFromDNSNameString( &amp;authInfo-&gt;keyname, keySpec-&gt;name );
					if (!ok) { free(authInfo); err = 1; goto exit; }

					keylen = DNSDigest_ConstructHMACKeyfromBase64( authInfo, keySpec-&gt;secret );
					if (keylen &lt; 0) { free(authInfo); err = 1; goto exit; }

					authInfo-&gt;next = zone-&gt;queryKeys;
					zone-&gt;queryKeys = authInfo;

					found = mDNStrue;

					break;
					}
				}

			// Log this
			require_action( found, exit, err = 1 );
			}
		}

exit:

	return err;
	}


void
SetupOptions
	(
	OptionsInfo	*	info,
	void		*	context
	)
	{
	DaemonInfo * d = ( DaemonInfo* ) context;

	if ( strlen( info-&gt;source_address ) )
		{
		inet_pton( AF_INET, info-&gt;source_address, &amp;d-&gt;addr.sin_addr );
		}

	if ( info-&gt;source_port )
		{
		d-&gt;addr.sin_port = htons( ( mDNSu16 ) info-&gt;source_port );
		}
				
	if ( strlen( info-&gt;server_address ) )
		{
		inet_pton( AF_INET, info-&gt;server_address, &amp;d-&gt;ns_addr.sin_addr );
		}

	if ( info-&gt;server_port )
		{
		d-&gt;ns_addr.sin_port = htons( ( mDNSu16 ) info-&gt;server_port );
		}

	if ( info-&gt;private_port )
		{
		d-&gt;private_port = mDNSOpaque16fromIntVal( info-&gt;private_port );
		}

	if ( info-&gt;llq_port )
		{
		d-&gt;llq_port = mDNSOpaque16fromIntVal( info-&gt;llq_port );
		}
	}
</pre>
<hr />
</body></html>