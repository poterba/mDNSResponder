<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mDNSMacOSX.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mDNSMacOSX.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="mDNSMacOSX.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4; c-file-style: &quot;bsd&quot;; c-basic-offset: 4; fill-column: 108; indent-tabs-mode: nil; -*-
 *
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// mDNSMacOSX.c:
</span><span class="enscript-comment">// Supporting routines to run mDNS on a CFRunLoop platform
</span><span class="enscript-comment">// ***************************************************************************
</span>
<span class="enscript-comment">// For debugging, set LIST_ALL_INTERFACES to 1 to display all found interfaces,
</span><span class="enscript-comment">// including ones that mDNSResponder chooses not to use.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LIST_ALL_INTERFACES</span> 0

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>        // Defines the interface provided to the client layer above
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uDNS.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSMacOSX.h&quot;</span>             // Defines the specific types needed to run mDNS on this platform
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd.h&quot;</span>                 // For mDNSInterface_LocalOnly etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd_internal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;PlatformCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uds_daemon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoSupport.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>                 // For va_list support
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>                 // For arc4random
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>           // For IFT_ETHER
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>                // For BIOCSETIF etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;time.h&gt;</span>                   // platform support for UTC time
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>              // for inet_aton
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netdb.h&gt;</span>                  // for getaddrinfo
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>             // for SIOCGIFEFLAGS
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>             // For IP_RECVTTL
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IP_RECVTTL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_RECVTTL</span> 24               // bool; receive reception TTL w/dgram
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>       // For n_long, required by &lt;netinet/ip.h&gt; below
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>             // For IPTOS_LOWDELAY etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>       // For IN6_IFF_TENTATIVE etc.

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;DebugServices.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnsinfo.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ifaddrs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMessage.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/ps/IOPowerSources.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/ps/IOPowerSourcesPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/ps/IOPSKeys.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_error.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;helper.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;P2PPacketFilter.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;SystemConfiguration/SCPrivate.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;MobileWiFi/WiFiManagerClient.h&gt;</span> // For WiFiManagerClientRef etc, declarations.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dlfcn.h&gt;</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">IGNORE_HOSTS_FILE</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;system_utilities.h&quot;</span>               // For os_variant_has_internal_diagnostics().
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Include definition of opaque_presence_indication for KEV_DL_NODE_PRESENCE handling logic.
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Kernel/IOKit/apple80211/apple80211_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ne_session.h&gt;</span> // for ne_session_set_socket_attributes()
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/platform/IOPlatformSupportPrivate.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;unittest.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kInterfaceSpecificOption</span> <span class="enscript-string">&quot;interface=&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_IOREG_KEY</span>               <span class="enscript-string">&quot;mDNS_KEY&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_IOREG_VALUE</span>             <span class="enscript-string">&quot;2009-07-30&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_IOREG_KA_KEY</span>            <span class="enscript-string">&quot;mDNS_Keepalive&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_USER_CLIENT_CREATE_TYPE</span> 'mDNS'

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DARK_WAKE_TIME</span> 16 // Time we hold an idle sleep assertion for maintenance after a wake notification

<span class="enscript-comment">// cache the InterfaceID of the AWDL interface 
</span>mDNSInterfaceID AWDLInterfaceID;

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// Globals
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Globals</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// By default we don't offer sleep proxy service
</span><span class="enscript-comment">// If OfferSleepProxyService is set non-zero (typically via command-line switch),
</span><span class="enscript-comment">// then we'll offer sleep proxy service on desktop Macs that are set to never sleep.
</span><span class="enscript-comment">// We currently do not offer sleep proxy service on laptops, or on machines that are set to go to sleep.
</span>mDNSexport <span class="enscript-type">int</span> OfferSleepProxyService = 0;
mDNSexport <span class="enscript-type">int</span> DisableSleepProxyClient = 0;
mDNSexport <span class="enscript-type">int</span> UseInternalSleepProxy = 1;       <span class="enscript-comment">// Set to non-zero to use internal (in-NIC) Sleep Proxy
</span>
mDNSexport <span class="enscript-type">int</span> OSXVers, iOSVers;
mDNSexport <span class="enscript-type">int</span> KQueueFD;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
<span class="enscript-type">static</span> CFArrayRef ServerCerts;
OSStatus <span class="enscript-function-name">SSLSetAllowAnonymousCiphers</span>(SSLContextRef context, Boolean enable);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>

<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_IPv4;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_IPv6;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_Hostnames;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_Computername;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_DNS;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_StateInterfacePrefix;
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_DynamicDNS       = CFSTR(<span class="enscript-string">&quot;Setup:/Network/DynamicDNS&quot;</span>);
<span class="enscript-type">static</span> CFStringRef NetworkChangedKey_PowerSettings    = CFSTR(<span class="enscript-string">&quot;State:/IOKit/PowerManagement/CurrentSettings&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">char</span> HINFO_HWstring_buffer[32];
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *HINFO_HWstring = <span class="enscript-string">&quot;Device&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> HINFO_HWstring_prefixlen = 6;

mDNSexport <span class="enscript-type">int</span> WatchDogReportingThreshold = 250;

dispatch_queue_t SSLqueue;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-type">static</span> mDNSu8 SPMetricPortability   = 99;
<span class="enscript-type">static</span> mDNSu8 SPMetricMarginalPower = 99;
<span class="enscript-type">static</span> mDNSu8 SPMetricTotalPower    = 99;
<span class="enscript-type">static</span> mDNSu8 SPMetricFeatures      = 1; <span class="enscript-comment">/* The current version supports TCP Keep Alive Feature */</span>
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">UNICAST_DOTLOCAL</span>)
domainname ActiveDirectoryPrimaryDomain;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ActiveDirectoryPrimaryDomainLabelCount;
<span class="enscript-type">static</span> mDNSAddr ActiveDirectoryPrimaryDomainServer;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Don't send triggers too often. We arbitrarily limit it to three minutes.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_TRIGGER_INTERVAL</span> (180 * mDNSPlatformOneSecond)

<span class="enscript-type">const</span> <span class="enscript-type">char</span> dnsprefix[] = <span class="enscript-string">&quot;dns:&quot;</span>;

<span class="enscript-comment">// String Array used to write list of private domains to Dynamic Store
</span><span class="enscript-type">static</span> CFArrayRef privateDnsArray = NULL;

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// Functions
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// We only attempt to send and receive multicast packets on interfaces that are
</span><span class="enscript-comment">// (a) flagged as multicast-capable
</span><span class="enscript-comment">// (b) *not* flagged as point-to-point (e.g. modem)
</span><span class="enscript-comment">// Typically point-to-point interfaces are modems (including mobile-phone pseudo-modems), and we don't want
</span><span class="enscript-comment">// to run up the user's bill sending multicast traffic over a link where there's only a single device at the
</span><span class="enscript-comment">// other end, and that device (e.g. a modem bank) is probably not answering Multicast DNS queries anyway.
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MulticastInterface</span>(i) ((i)-&gt;m-&gt;BonjourEnabled &amp;&amp; ((i)-&gt;ifa_flags &amp; IFF_MULTICAST) &amp;&amp; !((i)-&gt;ifa_flags &amp; IFF_POINTOPOINT))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MulticastInterface</span>(i) (((i)-&gt;ifa_flags &amp; IFF_MULTICAST) &amp;&amp; !((i)-&gt;ifa_flags &amp; IFF_POINTOPOINT))
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SPSInterface</span>(i)       ((i)-&gt;ifinfo.McastTxRx &amp;&amp; !((i)-&gt;ifa_flags &amp; IFF_LOOPBACK) &amp;&amp; !(i)-&gt;D2DInterface)

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetNetworkChanged</span>(mDNSs32 delay);

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">NotifyOfElusiveBug</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *title, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg)  <span class="enscript-comment">// Both strings are UTF-8 text
</span>{
    <span class="enscript-comment">// Unless ForceAlerts is defined, we only show these bug report alerts on machines that have a 17.x.x.x address
</span>    #<span class="enscript-keyword">if</span> !ForceAlerts
    {
        <span class="enscript-comment">// Determine if we're at Apple (17.*.*.*)
</span>        NetworkInterfaceInfoOSX *i;
        <span class="enscript-keyword">for</span> (i = mDNSStorage.p-&gt;InterfaceList; i; i = i-&gt;next)
            <span class="enscript-keyword">if</span> (i-&gt;ifinfo.ip.type == mDNSAddrType_IPv4 &amp;&amp; i-&gt;ifinfo.ip.ip.v4.b[0] == 17)
                <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (!i) 
            <span class="enscript-keyword">return</span>; <span class="enscript-comment">// If not at Apple, don't show the alert
</span>    }
    #endif

    LogMsg(<span class="enscript-string">&quot;NotifyOfElusiveBug: %s&quot;</span>, title);
    LogMsg(<span class="enscript-string">&quot;NotifyOfElusiveBug: %s&quot;</span>, msg);

    <span class="enscript-comment">// If we display our alert early in the boot process, then it vanishes once the desktop appears.
</span>    <span class="enscript-comment">// To avoid this, we don't try to display alerts in the first three minutes after boot.
</span>    <span class="enscript-keyword">if</span> ((mDNSu32)(mDNSPlatformRawTime()) &lt; (mDNSu32)(mDNSPlatformOneSecond * 180))
    { 
        LogMsg(<span class="enscript-string">&quot;Suppressing notification early in boot: %d&quot;</span>, mDNSPlatformRawTime()); 
        <span class="enscript-keyword">return</span>; 
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CFUSERNOTIFICATION</span>
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> notifyCount = 0; <span class="enscript-comment">// To guard against excessive display of warning notifications
</span>    <span class="enscript-keyword">if</span> (notifyCount &lt; 5) 
    { 
        notifyCount++; 
        mDNSNotify(title, msg); 
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_CFUSERNOTIFICATION */</span>

}

<span class="enscript-comment">// Write a syslog message and display an alert, then if ForceAlerts is set, generate a stack trace
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span> &gt;= 1
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LogMemCorruption</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    <span class="enscript-type">char</span> buffer[512];
    va_list ptr;
    va_start(ptr,format);
    buffer[mDNS_vsnprintf((<span class="enscript-type">char</span> *)buffer, <span class="enscript-keyword">sizeof</span>(buffer), format, ptr)] = 0;
    va_end(ptr);
    LogMsg(<span class="enscript-string">&quot;!!!! %s !!!!&quot;</span>, buffer);
    NotifyOfElusiveBug(<span class="enscript-string">&quot;Memory Corruption&quot;</span>, buffer);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ForceAlerts</span>
    *(<span class="enscript-type">volatile</span> <span class="enscript-type">long</span>*)0 = 0;  <span class="enscript-comment">// Trick to crash and get a stack trace right here, if that's what we want
</span>#<span class="enscript-reference">endif</span>
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Like LogMemCorruption above, but only display the alert if ForceAlerts is set and we're going to generate a stack trace
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LogFatalError</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    <span class="enscript-type">char</span> buffer[512];
    va_list ptr;
    va_start(ptr,format);
    buffer[mDNS_vsnprintf((<span class="enscript-type">char</span> *)buffer, <span class="enscript-keyword">sizeof</span>(buffer), format, ptr)] = 0;
    va_end(ptr);
    LogMsg(<span class="enscript-string">&quot;!!!! %s !!!!&quot;</span>, buffer);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ForceAlerts</span>
    NotifyOfElusiveBug(<span class="enscript-string">&quot;Fatal Error. See /Library/Logs/DiagnosticReports&quot;</span>, buffer);
    *(<span class="enscript-type">volatile</span> <span class="enscript-type">long</span>*)0 = 0;  <span class="enscript-comment">// Trick to crash and get a stack trace right here, if that's what we want
</span>#<span class="enscript-reference">endif</span>
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Returns true if it is an AppleTV based hardware running iOS, false otherwise
</span>mDNSlocal mDNSBool <span class="enscript-function-name">IsAppleTV</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_TV</span>
    <span class="enscript-keyword">return</span> mDNStrue;
#<span class="enscript-reference">else</span> 
    <span class="enscript-keyword">return</span> mDNSfalse;
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">struct</span> ifaddrs *<span class="enscript-function-name">myGetIfAddrs</span>(<span class="enscript-type">int</span> refresh)
{
    <span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddrs *ifa = NULL;

    <span class="enscript-keyword">if</span> (refresh &amp;&amp; ifa)
    {
        freeifaddrs(ifa);
        ifa = NULL;
    }

    <span class="enscript-keyword">if</span> (ifa == NULL) 
        getifaddrs(&amp;ifa);
    <span class="enscript-keyword">return</span> ifa;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DynamicStoreWrite</span>(<span class="enscript-type">int</span> key, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* subkey, uintptr_t value, <span class="enscript-type">signed</span> <span class="enscript-type">long</span> valueCnt)
{
    CFStringRef sckey       = NULL;
    Boolean release_sckey   = FALSE;
    CFDataRef bytes         = NULL;
    CFPropertyListRef plist = NULL;

    <span class="enscript-keyword">switch</span> ((<span class="enscript-type">enum</span> mDNSDynamicStoreSetConfigKey)key)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSMulticastConfig</span>:
            sckey = CFSTR(<span class="enscript-string">&quot;State:/Network/&quot;</span> kDNSServiceCompMulticastDNS);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSDynamicConfig</span>:
            sckey = CFSTR(<span class="enscript-string">&quot;State:/Network/DynamicDNS&quot;</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSPrivateConfig</span>:
            sckey = CFSTR(<span class="enscript-string">&quot;State:/Network/&quot;</span> kDNSServiceCompPrivateDNS);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSBackToMyMacConfig</span>:
            sckey = CFSTR(<span class="enscript-string">&quot;State:/Network/BackToMyMac&quot;</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSSleepProxyServersState</span>:
        {
            CFMutableStringRef tmp = CFStringCreateMutable(kCFAllocatorDefault, 0);
            CFStringAppend(tmp, CFSTR(<span class="enscript-string">&quot;State:/Network/Interface/&quot;</span>));
            CFStringAppendCString(tmp, subkey, kCFStringEncodingUTF8);
            CFStringAppend(tmp, CFSTR(<span class="enscript-string">&quot;/SleepProxyServers&quot;</span>));
            sckey = CFStringCreateCopy(kCFAllocatorDefault, tmp);
            release_sckey = TRUE;
            CFRelease(tmp);
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSDebugState</span>:
            sckey = CFSTR(<span class="enscript-string">&quot;State:/Network/mDNSResponder/DebugState&quot;</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            LogMsg(<span class="enscript-string">&quot;unrecognized key %d&quot;</span>, key);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">if</span> (NULL == (bytes = CFDataCreateWithBytesNoCopy(NULL, (<span class="enscript-type">void</span> *)value,
                                                     valueCnt, kCFAllocatorNull)))
    {
        LogMsg(<span class="enscript-string">&quot;CFDataCreateWithBytesNoCopy of value failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">if</span> (NULL == (plist = CFPropertyListCreateWithData(NULL, bytes, kCFPropertyListImmutable, NULL, NULL)))
    {
        LogMsg(<span class="enscript-string">&quot;CFPropertyListCreateWithData of bytes failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    CFRelease(bytes);
    bytes = NULL;
    SCDynamicStoreSetValue(NULL, sckey, plist);

<span class="enscript-reference">fin</span>:
    <span class="enscript-keyword">if</span> (NULL != bytes)
        CFRelease(bytes);
    <span class="enscript-keyword">if</span> (NULL != plist)
        CFRelease(plist);
    <span class="enscript-keyword">if</span> (release_sckey &amp;&amp; sckey)
        CFRelease(sckey);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSDynamicStoreSetConfig</span>(<span class="enscript-type">int</span> key, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *subkey, CFPropertyListRef value)
{
    CFPropertyListRef valueCopy;
    <span class="enscript-type">char</span> *subkeyCopy  = NULL;
    <span class="enscript-keyword">if</span> (!value)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// We need to copy the key and value before we dispatch off the block below as the
</span>    <span class="enscript-comment">// caller will free the memory once we return from this function.
</span>    valueCopy = CFPropertyListCreateDeepCopy(NULL, value, kCFPropertyListImmutable);
    <span class="enscript-keyword">if</span> (!valueCopy)
    {   
        LogMsg(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig: ERROR valueCopy NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (subkey)
    {
        <span class="enscript-type">int</span> len    = strlen(subkey);
        subkeyCopy = mDNSPlatformMemAllocate(len + 1);
        <span class="enscript-keyword">if</span> (!subkeyCopy)
        {
            LogMsg(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig: ERROR subkeyCopy NULL&quot;</span>);
            CFRelease(valueCopy);
            <span class="enscript-keyword">return</span>;
        }
        mDNSPlatformMemCopy(subkeyCopy, subkey, len);
        subkeyCopy[len] = 0;
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        CFWriteStreamRef stream = NULL;
        CFDataRef bytes = NULL;
        CFIndex ret;
        KQueueLock();

        <span class="enscript-keyword">if</span> (NULL == (stream = CFWriteStreamCreateWithAllocatedBuffers(NULL, NULL)))
        {
            LogMsg(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig : CFWriteStreamCreateWithAllocatedBuffers failed (Object creation failed)&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">END</span>;
        }
        CFWriteStreamOpen(stream);
        ret = CFPropertyListWrite(valueCopy, stream, kCFPropertyListBinaryFormat_v1_0, 0, NULL);
        <span class="enscript-keyword">if</span> (ret == 0)
        {
            LogMsg(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig : CFPropertyListWriteToStream failed (Could not write property list to stream)&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">END</span>;
        }
        <span class="enscript-keyword">if</span> (NULL == (bytes = CFWriteStreamCopyProperty(stream, kCFStreamPropertyDataWritten)))
        {
            LogMsg(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig : CFWriteStreamCopyProperty failed (Object creation failed) &quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">END</span>;
        }
        CFWriteStreamClose(stream);
        CFRelease(stream);
        stream = NULL;
        DynamicStoreWrite(key, subkeyCopy ? subkeyCopy : <span class="enscript-string">&quot;&quot;</span>, (uintptr_t)CFDataGetBytePtr(bytes), CFDataGetLength(bytes));

    <span class="enscript-reference">END</span>:
        CFRelease(valueCopy);
        <span class="enscript-keyword">if</span> (NULL != stream)
        {
            CFWriteStreamClose(stream);
            CFRelease(stream);
        }
        <span class="enscript-keyword">if</span> (NULL != bytes)
            CFRelease(bytes); 
        <span class="enscript-keyword">if</span> (subkeyCopy)
            mDNSPlatformMemFree(subkeyCopy);

        KQueueUnlock(<span class="enscript-string">&quot;mDNSDynamicStoreSetConfig&quot;</span>);
    });
}

<span class="enscript-comment">// To match *either* a v4 or v6 instance of this interface name, pass AF_UNSPEC for type
</span>mDNSlocal NetworkInterfaceInfoOSX *<span class="enscript-function-name">SearchForInterfaceByName</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, <span class="enscript-type">int</span> type)
{
    NetworkInterfaceInfoOSX *i;
    <span class="enscript-keyword">for</span> (i = mDNSStorage.p-&gt;InterfaceList; i; i = i-&gt;next)
        <span class="enscript-keyword">if</span> (i-&gt;Exists &amp;&amp; !strcmp(i-&gt;ifinfo.ifname, ifname) &amp;&amp;
            ((type == AF_UNSPEC                                         ) ||
             (type == AF_INET  &amp;&amp; i-&gt;ifinfo.ip.type == mDNSAddrType_IPv4) ||
             (type == AF_INET6 &amp;&amp; i-&gt;ifinfo.ip.type == mDNSAddrType_IPv6))) <span class="enscript-keyword">return</span>(i);
    <span class="enscript-keyword">return</span>(NULL);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">myIfIndexToName</span>(u_short ifindex, <span class="enscript-type">char</span> *name)
{
    <span class="enscript-type">struct</span> ifaddrs *ifa;
    <span class="enscript-keyword">for</span> (ifa = myGetIfAddrs(0); ifa; ifa = ifa-&gt;ifa_next)
        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_LINK)
            <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr_dl*)ifa-&gt;ifa_addr)-&gt;sdl_index == ifindex)
            { strlcpy(name, ifa-&gt;ifa_name, IF_NAMESIZE); <span class="enscript-keyword">return</span> 0; }
    <span class="enscript-keyword">return</span> -1;
}

mDNSexport NetworkInterfaceInfoOSX *<span class="enscript-function-name">IfindexToInterfaceInfoOSX</span>(mDNSInterfaceID ifindex)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSu32 scope_id = (mDNSu32)(uintptr_t)ifindex;
    NetworkInterfaceInfoOSX *i;

    <span class="enscript-comment">// Don't get tricked by inactive interfaces
</span>    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
        <span class="enscript-keyword">if</span> (i-&gt;Registered &amp;&amp; i-&gt;scope_id == scope_id) <span class="enscript-keyword">return</span>(i);

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport mdns_interface_monitor_t <span class="enscript-function-name">GetInterfaceMonitorForIndex</span>(uint32_t ifIndex)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;

    <span class="enscript-comment">// We assume that interface should always be real interface, and should never be 0.
</span>    <span class="enscript-keyword">if</span> (ifIndex == 0) <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;InterfaceMonitors)
    {
        m-&gt;p-&gt;InterfaceMonitors = CFArrayCreateMutable(kCFAllocatorDefault, 0, &amp;mdns_cfarray_callbacks);
        <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;InterfaceMonitors)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR, <span class="enscript-string">&quot;Failed to create InterfaceMonitors array&quot;</span>);
            <span class="enscript-keyword">return</span> NULL;
        }
    }

    <span class="enscript-comment">// Search for interface monitor given the interface index.
</span>    mdns_interface_monitor_t monitor;
    <span class="enscript-keyword">for</span> (CFIndex i = 0, n = CFArrayGetCount(m-&gt;p-&gt;InterfaceMonitors); i &lt; n; i++)
    {
        monitor = (mdns_interface_monitor_t) CFArrayGetValueAtIndex(m-&gt;p-&gt;InterfaceMonitors, i);
        <span class="enscript-keyword">if</span> (mdns_interface_monitor_get_interface_index(monitor) == ifIndex) <span class="enscript-keyword">return</span> monitor;
    }

    <span class="enscript-comment">// If we come here, it means the interface is a new interface that needs to be monitored.
</span>    monitor = mdns_interface_monitor_create(ifIndex);
    <span class="enscript-keyword">if</span> (!monitor)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR, <span class="enscript-string">&quot;Failed to create an interface monitor for index %u&quot;</span>, ifIndex);
        <span class="enscript-keyword">return</span> NULL;
    }
    CFArrayAppendValue(m-&gt;p-&gt;InterfaceMonitors, monitor);

    <span class="enscript-comment">// Put the monitor into serial queue.
</span>    mdns_interface_monitor_set_queue(monitor, dispatch_get_main_queue());

    <span class="enscript-comment">// When the interface configuration is changed, this block will be called.
</span>    mdns_interface_monitor_set_update_handler(monitor,
    ^(mdns_interface_flags_t changeFlags)
    {
        <span class="enscript-type">const</span> mdns_interface_flags_t relevantFlags =
            mdns_interface_flag_expensive   |
            mdns_interface_flag_constrained |
            mdns_interface_flag_clat46;
        <span class="enscript-keyword">if</span> ((changeFlags &amp; relevantFlags) == 0) <span class="enscript-keyword">return</span>;

        KQueueLock();
        <span class="enscript-type">const</span> CFRange range = CFRangeMake(0, CFArrayGetCount(m-&gt;p-&gt;InterfaceMonitors));
        <span class="enscript-keyword">if</span> (CFArrayContainsValue(m-&gt;p-&gt;InterfaceMonitors, range, monitor))
        {
            m-&gt;p-&gt;if_interface_changed = mDNStrue;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">OS_LOG</span>)
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;Monitored interface changed: %@&quot;</span>, monitor);
#<span class="enscript-reference">endif</span>
            <span class="enscript-comment">// Let mDNSResponder update its network configuration.
</span>            mDNS_Lock(m);
            SetNetworkChanged((mDNSPlatformOneSecond + 39) / 40);   <span class="enscript-comment">// 25 ms delay
</span>            mDNS_Unlock(m);
        }
        KQueueUnlock(<span class="enscript-string">&quot;interface monitor update handler&quot;</span>);
    });

    mdns_interface_monitor_set_event_handler(monitor,
    ^(mdns_event_t event, OSStatus error)
    {
        <span class="enscript-keyword">switch</span> (event)
        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">mdns_event_invalidated</span>:
                mdns_release(monitor);
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">mdns_event_error</span>:
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR, <span class="enscript-string">&quot;Interface monitor for index %u error: %ld&quot;</span>,
                    mdns_interface_monitor_get_interface_index(monitor), (<span class="enscript-type">long</span>) error);
                KQueueLock();
                <span class="enscript-keyword">if</span> (m-&gt;p-&gt;InterfaceMonitors)
                {
                    <span class="enscript-type">const</span> CFRange range = CFRangeMake(0, CFArrayGetCount(m-&gt;p-&gt;InterfaceMonitors));
                    <span class="enscript-type">const</span> CFIndex i = CFArrayGetFirstIndexOfValue(m-&gt;p-&gt;InterfaceMonitors, range, monitor);
                    <span class="enscript-keyword">if</span> (i &gt;= 0) CFArrayRemoveValueAtIndex(m-&gt;p-&gt;InterfaceMonitors, i);
                }
                KQueueUnlock(<span class="enscript-string">&quot;interface monitor event handler&quot;</span>);
                mdns_interface_monitor_invalidate(monitor);
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                <span class="enscript-keyword">break</span>;
        }
    });
    mdns_interface_monitor_activate(monitor);

    <span class="enscript-keyword">return</span> monitor;
}

mDNSexport mDNSInterfaceID <span class="enscript-function-name">mDNSPlatformInterfaceIDfromInterfaceIndex</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu32 ifindex)
{
    (<span class="enscript-type">void</span>) m;
    <span class="enscript-keyword">if</span> (ifindex == kDNSServiceInterfaceIndexLocalOnly) <span class="enscript-keyword">return</span>(mDNSInterface_LocalOnly);
    <span class="enscript-keyword">if</span> (ifindex == kDNSServiceInterfaceIndexP2P      ) <span class="enscript-keyword">return</span>(mDNSInterface_P2P);
    <span class="enscript-keyword">if</span> (ifindex == kDNSServiceInterfaceIndexBLE      ) <span class="enscript-keyword">return</span>(mDNSInterface_BLE);
    <span class="enscript-keyword">if</span> (ifindex == kDNSServiceInterfaceIndexAny      ) <span class="enscript-keyword">return</span>(mDNSNULL);

    NetworkInterfaceInfoOSX* ifi = IfindexToInterfaceInfoOSX((mDNSInterfaceID)(uintptr_t)ifindex);
    <span class="enscript-keyword">if</span> (!ifi)
    {
        <span class="enscript-comment">// Not found. Make sure our interface list is up to date, then try again.
</span>        LogInfo(<span class="enscript-string">&quot;mDNSPlatformInterfaceIDfromInterfaceIndex: InterfaceID for interface index %d not found; Updating interface list&quot;</span>, ifindex);
        mDNSMacOSXNetworkChanged();
        ifi = IfindexToInterfaceInfoOSX((mDNSInterfaceID)(uintptr_t)ifindex);
    }

    <span class="enscript-keyword">if</span> (!ifi) <span class="enscript-keyword">return</span>(mDNSNULL);

    <span class="enscript-keyword">return</span>(ifi-&gt;ifinfo.InterfaceID);
}


mDNSexport mDNSu32 <span class="enscript-function-name">mDNSPlatformInterfaceIndexfromInterfaceID</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID id, mDNSBool suppressNetworkChange)
{
    NetworkInterfaceInfoOSX *i;
    <span class="enscript-keyword">if</span> (id == mDNSInterface_Any      ) <span class="enscript-keyword">return</span>(0);
    <span class="enscript-keyword">if</span> (id == mDNSInterface_LocalOnly) <span class="enscript-keyword">return</span>(kDNSServiceInterfaceIndexLocalOnly);
    <span class="enscript-keyword">if</span> (id == mDNSInterface_P2P      ) <span class="enscript-keyword">return</span>(kDNSServiceInterfaceIndexP2P);
    <span class="enscript-keyword">if</span> (id == mDNSInterface_BLE      ) <span class="enscript-keyword">return</span>(kDNSServiceInterfaceIndexBLE);

    mDNSu32 scope_id = (mDNSu32)(uintptr_t)id;

    <span class="enscript-comment">// Don't use i-&gt;Registered here, because we DO want to find inactive interfaces, which have no Registered set
</span>    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
        <span class="enscript-keyword">if</span> (i-&gt;scope_id == scope_id) <span class="enscript-keyword">return</span>(i-&gt;scope_id);

    <span class="enscript-comment">// If we are supposed to suppress network change, return &quot;id&quot; back
</span>    <span class="enscript-keyword">if</span> (suppressNetworkChange) <span class="enscript-keyword">return</span> scope_id;

    <span class="enscript-comment">// Not found. Make sure our interface list is up to date, then try again.
</span>    LogInfo(<span class="enscript-string">&quot;Interface index for InterfaceID %p not found; Updating interface list&quot;</span>, id);
    mDNSMacOSXNetworkChanged();
    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
        <span class="enscript-keyword">if</span> (i-&gt;scope_id == scope_id) <span class="enscript-keyword">return</span>(i-&gt;scope_id);

    <span class="enscript-keyword">return</span>(0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">UDP</span> &amp; <span class="enscript-variable-name">TCP</span> <span class="enscript-variable-name">send</span> &amp; <span class="enscript-variable-name">receive</span>
#<span class="enscript-reference">endif</span>

mDNSlocal mDNSBool <span class="enscript-function-name">AddrRequiresPPPConnection</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr)
{
    mDNSBool result = mDNSfalse;
    SCNetworkConnectionFlags flags;
    CFDataRef remote_addr;
    CFMutableDictionaryRef options;
    SCNetworkReachabilityRef ReachRef = NULL;

    options = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
    remote_addr = CFDataCreate(NULL, (<span class="enscript-type">const</span> UInt8 *)addr, addr-&gt;sa_len);
    CFDictionarySetValue(options, kSCNetworkReachabilityOptionRemoteAddress, remote_addr);
    CFDictionarySetValue(options, kSCNetworkReachabilityOptionServerBypass, kCFBooleanTrue);
    ReachRef = SCNetworkReachabilityCreateWithOptions(kCFAllocatorDefault, options);
    CFRelease(options);
    CFRelease(remote_addr);

    <span class="enscript-keyword">if</span> (!ReachRef) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: RequiresConnection - SCNetworkReachabilityCreateWithOptions&quot;</span>); 
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; 
    }
    <span class="enscript-keyword">if</span> (!SCNetworkReachabilityGetFlags(ReachRef, &amp;flags)) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: AddrRequiresPPPConnection - SCNetworkReachabilityGetFlags&quot;</span>); 
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; 
    }
    result = flags &amp; kSCNetworkFlagsConnectionRequired;

<span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (ReachRef) 
        CFRelease(ReachRef);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">// Set traffic class for socket
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">setTrafficClass</span>(<span class="enscript-type">int</span> socketfd, mDNSBool useBackgroundTrafficClass)
{
    <span class="enscript-type">int</span> traffic_class;

    <span class="enscript-keyword">if</span> (useBackgroundTrafficClass)
        traffic_class = SO_TC_BK_SYS;
    <span class="enscript-keyword">else</span>
        traffic_class = SO_TC_CTL;

    (<span class="enscript-type">void</span>) setsockopt(socketfd, SOL_SOCKET, SO_TRAFFIC_CLASS, (<span class="enscript-type">void</span> *)&amp;traffic_class, <span class="enscript-keyword">sizeof</span>(traffic_class));
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
UNITTEST_SETSOCKOPT
#<span class="enscript-reference">else</span>
mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">mDNSPlatformGetSocktFd</span>(<span class="enscript-type">void</span> *sockCxt, mDNSTransport_Type transType, mDNSAddr_Type addrType)
{
    <span class="enscript-keyword">if</span> (transType == mDNSTransport_UDP)
    {
        UDPSocket* sock = (UDPSocket*) sockCxt;
        <span class="enscript-keyword">return</span> (addrType == mDNSAddrType_IPv4) ? sock-&gt;ss.sktv4 : sock-&gt;ss.sktv6;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (transType == mDNSTransport_TCP)
    {
        TCPSocket* sock = (TCPSocket*) sockCxt;
        <span class="enscript-keyword">return</span> sock-&gt;fd;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;mDNSPlatformGetSocktFd: invalid transport %d&quot;</span>, transType);
        <span class="enscript-keyword">return</span> kInvalidSocketRef;
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSetSocktOpt</span>(<span class="enscript-type">void</span> *sockCxt, mDNSTransport_Type transType, mDNSAddr_Type addrType, <span class="enscript-type">const</span> DNSQuestion *q)
{
    <span class="enscript-type">int</span> sockfd;
    <span class="enscript-type">char</span> unenc_name[MAX_ESCAPED_DOMAIN_NAME];

    <span class="enscript-comment">// verify passed-in arguments exist and that sockfd is valid
</span>    <span class="enscript-keyword">if</span> (q == mDNSNULL || sockCxt == mDNSNULL || (sockfd = mDNSPlatformGetSocktFd(sockCxt, transType, addrType)) &lt; 0)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (q-&gt;pid)
    {
        <span class="enscript-keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_DELEGATED, &amp;q-&gt;pid, <span class="enscript-keyword">sizeof</span>(q-&gt;pid)) == -1)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformSetSocktOpt: Delegate PID failed %s for PID %d&quot;</span>, strerror(errno), q-&gt;pid);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_DELEGATED_UUID, &amp;q-&gt;uuid, <span class="enscript-keyword">sizeof</span>(q-&gt;uuid)) == -1)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformSetSocktOpt: Delegate UUID failed %s&quot;</span>, strerror(errno));
    }

    <span class="enscript-comment">// set the domain on the socket
</span>    ConvertDomainNameToCString(&amp;q-&gt;qname, unenc_name);
    <span class="enscript-keyword">if</span> (!(ne_session_set_socket_attributes(sockfd, unenc_name, NULL)))
        LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetSocktOpt: ne_session_set_socket_attributes()-&gt; setting domain failed for %s&quot;</span>, unenc_name);

    <span class="enscript-type">int</span> nowake = 1;
    <span class="enscript-keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_NOWAKEFROMSLEEP, &amp;nowake, <span class="enscript-keyword">sizeof</span>(nowake)) == -1)
        LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetSocktOpt: SO_NOWAKEFROMSLEEP failed %s&quot;</span>, strerror(errno));
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">UNIT_TEST</span>

<span class="enscript-comment">// Note: If InterfaceID is NULL, it means, &quot;send this packet through our anonymous unicast socket&quot;
</span><span class="enscript-comment">// Note: If InterfaceID is non-NULL it means, &quot;send this packet through our port 5353 socket on the specified interface&quot;
</span><span class="enscript-comment">// OR send via our primary v4 unicast socket
</span><span class="enscript-comment">// UPDATE: The UDPSocket *src parameter now allows the caller to specify the source socket
</span>mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformSendUDP</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                       mDNSInterfaceID InterfaceID, UDPSocket *src, <span class="enscript-type">const</span> mDNSAddr *dst, 
                                       mDNSIPPort dstPort, mDNSBool useBackgroundTrafficClass)
{
    NetworkInterfaceInfoOSX *info = mDNSNULL;
    <span class="enscript-type">struct</span> sockaddr_storage to;
    <span class="enscript-type">int</span> s = -1, err;
    mStatus result = mStatus_NoError;
    <span class="enscript-type">int</span> sendto_errno;
    <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> dns_msg = msg;

    <span class="enscript-keyword">if</span> (InterfaceID)
    {
        info = IfindexToInterfaceInfoOSX(InterfaceID);
        <span class="enscript-keyword">if</span> (info == NULL)
        {
            <span class="enscript-comment">// We may not have registered interfaces with the &quot;core&quot; as we may not have
</span>            <span class="enscript-comment">// seen any interface notifications yet. This typically happens during wakeup
</span>            <span class="enscript-comment">// where we might try to send DNS requests (non-SuppressUnusable questions internal
</span>            <span class="enscript-comment">// to mDNSResponder) before we receive network notifications.
</span>            LogInfo(<span class="enscript-string">&quot;mDNSPlatformSendUDP: Invalid interface index %p&quot;</span>, InterfaceID);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }
    }

    <span class="enscript-type">char</span> *ifa_name = InterfaceID ? info-&gt;ifinfo.ifname : <span class="enscript-string">&quot;unicast&quot;</span>;

    <span class="enscript-keyword">if</span> (dst-&gt;type == mDNSAddrType_IPv4)
    {
        <span class="enscript-type">struct</span> sockaddr_in *sin_to = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;to;
        sin_to-&gt;sin_len            = <span class="enscript-keyword">sizeof</span>(*sin_to);
        sin_to-&gt;sin_family         = AF_INET;
        sin_to-&gt;sin_port           = dstPort.NotAnInteger;
        sin_to-&gt;sin_addr.s_addr    = dst-&gt;ip.v4.NotAnInteger;
        s = (src ? src-&gt;ss : m-&gt;p-&gt;permanentsockets).sktv4;

        <span class="enscript-keyword">if</span> (!mDNSAddrIsDNSMulticast(dst))
        {
        #ifdef IP_BOUND_IF
            <span class="enscript-type">const</span> mDNSu32 ifindex = info ? info-&gt;scope_id : IFSCOPE_NONE;
            setsockopt(s, IPPROTO_IP, IP_BOUND_IF, &amp;ifindex, <span class="enscript-keyword">sizeof</span>(ifindex));
        #<span class="enscript-keyword">else</span>
            <span class="enscript-type">static</span> <span class="enscript-type">int</span> displayed = 0;
            <span class="enscript-keyword">if</span> (displayed &lt; 1000)
            {
                displayed++;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[Q%u] IP_BOUND_IF socket option not defined -- cannot specify interface for unicast packets&quot;</span>,
                          mDNSVal16(dns_msg-&gt;h.id));
            }
        #endif
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (info)
        {
        #ifdef IP_MULTICAST_IFINDEX
            err = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IFINDEX, &amp;info-&gt;scope_id, <span class="enscript-keyword">sizeof</span>(info-&gt;scope_id));
            <span class="enscript-comment">// We get an error when we compile on a machine that supports this option and run the binary on
</span>            <span class="enscript-comment">// a different machine that does not support it
</span>            <span class="enscript-keyword">if</span> (err &lt; 0)
            {
                <span class="enscript-keyword">if</span> (errno != ENOPROTOOPT)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP: setsockopt: IP_MUTLTICAST_IFINDEX returned %d&quot;</span>,
                              mDNSVal16(dns_msg-&gt;h.id), errno);
                }
                err = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;info-&gt;ifa_v4addr, <span class="enscript-keyword">sizeof</span>(info-&gt;ifa_v4addr));
                <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; !m-&gt;NetworkChanged)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[Q%u] setsockopt - IP_MULTICAST_IF error &quot;</span> PRI_IPv4_ADDR <span class="enscript-string">&quot; %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              mDNSVal16(dns_msg-&gt;h.id), &amp;info-&gt;ifa_v4addr, err, errno, strerror(errno));
                }
            }
        #<span class="enscript-keyword">else</span>
            err = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;info-&gt;ifa_v4addr, <span class="enscript-keyword">sizeof</span>(info-&gt;ifa_v4addr));
            <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; !m-&gt;NetworkChanged)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[Q%u] setsockopt - IP_MULTICAST_IF error &quot;</span> PRI_IPv4_ADDR <span class="enscript-string">&quot; %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                          mDNSVal16(dns_msg-&gt;h.id), &amp;info-&gt;ifa_v4addr, err, errno, strerror(errno));
            }
        #endif
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst-&gt;type == mDNSAddrType_IPv6)
    {
        <span class="enscript-type">struct</span> sockaddr_in6 *sin6_to = (<span class="enscript-type">struct</span> sockaddr_in6*)&amp;to;
        sin6_to-&gt;sin6_len            = <span class="enscript-keyword">sizeof</span>(*sin6_to);
        sin6_to-&gt;sin6_family         = AF_INET6;
        sin6_to-&gt;sin6_port           = dstPort.NotAnInteger;
        sin6_to-&gt;sin6_flowinfo       = 0;
        sin6_to-&gt;sin6_addr           = *(<span class="enscript-type">struct</span> in6_addr*)&amp;dst-&gt;ip.v6;
        sin6_to-&gt;sin6_scope_id       = info ? info-&gt;scope_id : 0;
        s = (src ? src-&gt;ss : m-&gt;p-&gt;permanentsockets).sktv6;
        <span class="enscript-keyword">if</span> (info &amp;&amp; mDNSAddrIsDNSMulticast(dst))    <span class="enscript-comment">// Specify outgoing interface
</span>        {
            err = setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_IF, &amp;info-&gt;scope_id, <span class="enscript-keyword">sizeof</span>(info-&gt;scope_id));
            <span class="enscript-keyword">if</span> (err &lt; 0)
            {
                <span class="enscript-type">const</span> <span class="enscript-type">int</span> setsockopt_errno = errno;
                <span class="enscript-type">char</span> name[IFNAMSIZ];
                <span class="enscript-keyword">if</span> (if_indextoname(info-&gt;scope_id, name) != NULL)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[Q%u] setsockopt - IPV6_MULTICAST_IF error %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              mDNSVal16(dns_msg-&gt;h.id), err, setsockopt_errno, strerror(setsockopt_errno));
                }
                <span class="enscript-keyword">else</span>
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[Q%u] setsockopt - IPV6_MUTLICAST_IF scopeid %d, not a valid interface&quot;</span>,
                              mDNSVal16(dns_msg-&gt;h.id), info-&gt;scope_id);
                }
            }
        }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPV6_BOUND_IF</span>
        <span class="enscript-keyword">if</span> (info)   <span class="enscript-comment">// Specify outgoing interface for non-multicast destination
</span>        {
            <span class="enscript-keyword">if</span> (!mDNSAddrIsDNSMulticast(dst))
            {
                <span class="enscript-keyword">if</span> (info-&gt;scope_id == 0)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[Q%u] IPV6_BOUND_IF socket option not set -- info %p (&quot;</span> PUB_S <span class="enscript-string">&quot;) scope_id is zero&quot;</span>,
                              mDNSVal16(dns_msg-&gt;h.id), info, ifa_name);
                }
                <span class="enscript-keyword">else</span>
                {
                    setsockopt(s, IPPROTO_IPV6, IPV6_BOUND_IF, &amp;info-&gt;scope_id, <span class="enscript-keyword">sizeof</span>(info-&gt;scope_id));
                }
            }
        }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">else</span>
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_FAULT,
                  <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP: dst is not an IPv4 or IPv6 address!&quot;</span>, mDNSVal16(dns_msg-&gt;h.id));
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    <span class="enscript-keyword">if</span> (s &gt;= 0)
    {
        verbosedebugf(<span class="enscript-string">&quot;mDNSPlatformSendUDP: sending on InterfaceID %p %5s/%ld to %#a:%d skt %d&quot;</span>,
                      InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort), s);
    }
    <span class="enscript-keyword">else</span>
    {
        verbosedebugf(<span class="enscript-string">&quot;mDNSPlatformSendUDP: NOT sending on InterfaceID %p %5s/%ld (socket of this type not available)&quot;</span>,
                      InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort));
    }

    <span class="enscript-comment">// Note: When sending, mDNSCore may often ask us to send both a v4 multicast packet and then a v6 multicast packet
</span>    <span class="enscript-comment">// If we don't have the corresponding type of socket available, then return mStatus_Invalid
</span>    <span class="enscript-keyword">if</span> (s &lt; 0) <span class="enscript-keyword">return</span>(mStatus_Invalid);

    <span class="enscript-comment">// switch to background traffic class for this message if requested
</span>    <span class="enscript-keyword">if</span> (useBackgroundTrafficClass)
        setTrafficClass(s, useBackgroundTrafficClass);

    err = sendto(s, msg, (UInt8*)end - (UInt8*)msg, 0, (<span class="enscript-type">struct</span> sockaddr *)&amp;to, to.ss_len);
    sendto_errno = (err &lt; 0) ? errno : 0;

    <span class="enscript-comment">// set traffic class back to default value
</span>    <span class="enscript-keyword">if</span> (useBackgroundTrafficClass)
        setTrafficClass(s, mDNSfalse);

    <span class="enscript-keyword">if</span> (err &lt; 0)
    {
        <span class="enscript-type">static</span> <span class="enscript-type">int</span> MessageCount = 0;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                  <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP -&gt; sendto(%d) failed to send packet on InterfaceID %p &quot;</span> PUB_S <span class="enscript-string">&quot;/%d to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d skt %d error %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;) %u&quot;</span>,
                  mDNSVal16(dns_msg-&gt;h.id), s, InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort), s, err, sendto_errno, strerror(sendto_errno), (mDNSu32)(m-&gt;timenow));
        <span class="enscript-keyword">if</span> (!mDNSAddressIsAllDNSLinkGroup(dst))
        {
            <span class="enscript-keyword">if</span> ((sendto_errno == EHOSTUNREACH) || (sendto_errno == ENETUNREACH)) <span class="enscript-keyword">return</span>(mStatus_HostUnreachErr);
            <span class="enscript-keyword">if</span> ((sendto_errno == EHOSTDOWN)    || (sendto_errno == ENETDOWN))    <span class="enscript-keyword">return</span>(mStatus_TransientErr);
        }
        <span class="enscript-comment">// Don't report EHOSTUNREACH in the first three minutes after boot
</span>        <span class="enscript-comment">// This is because mDNSResponder intentionally starts up early in the boot process (See &lt;rdar://problem/3409090&gt;)
</span>        <span class="enscript-comment">// but this means that sometimes it starts before configd has finished setting up the multicast routing entries.
</span>        <span class="enscript-keyword">if</span> (sendto_errno == EHOSTUNREACH &amp;&amp; (mDNSu32)(mDNSPlatformRawTime()) &lt; (mDNSu32)(mDNSPlatformOneSecond * 180)) <span class="enscript-keyword">return</span>(mStatus_TransientErr);
        <span class="enscript-comment">// Don't report EADDRNOTAVAIL (&quot;Can't assign requested address&quot;) if we're in the middle of a network configuration change
</span>        <span class="enscript-keyword">if</span> (sendto_errno == EADDRNOTAVAIL &amp;&amp; m-&gt;NetworkChanged) <span class="enscript-keyword">return</span>(mStatus_TransientErr);
        <span class="enscript-keyword">if</span> (sendto_errno == EHOSTUNREACH || sendto_errno == EADDRNOTAVAIL || sendto_errno == ENETDOWN)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                      <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP sendto(%d) failed to send packet on InterfaceID %p &quot;</span> PUB_S <span class="enscript-string">&quot;/%d to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d skt %d error %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;) %u&quot;</span>,
                      mDNSVal16(dns_msg-&gt;h.id), s, InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort), s, err, sendto_errno, strerror(sendto_errno), (mDNSu32)(m-&gt;timenow));
        }
        <span class="enscript-keyword">else</span>
        {
            MessageCount++;
            <span class="enscript-keyword">if</span> (MessageCount &lt; 50) <span class="enscript-comment">// Cap and ensure NO spamming of LogMsgs
</span>            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                          <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p &quot;</span> PUB_S <span class="enscript-string">&quot;/%d to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d skt %d error %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;) %u MessageCount is %d&quot;</span>,
                          mDNSVal16(dns_msg-&gt;h.id), s, InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort), s, err, sendto_errno, strerror(sendto_errno), (mDNSu32)(m-&gt;timenow), MessageCount);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-comment">// If logging is enabled, remove the cap and log aggressively
</span>            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[Q%u] mDNSPlatformSendUDP: sendto(%d) failed to send packet on InterfaceID %p &quot;</span> PUB_S <span class="enscript-string">&quot;/%d to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d skt %d error %d errno %d (&quot;</span> PUB_S <span class="enscript-string">&quot;) %u MessageCount is %d&quot;</span>,
                          mDNSVal16(dns_msg-&gt;h.id), s, InterfaceID, ifa_name, dst-&gt;type, dst, mDNSVal16(dstPort), s, err, sendto_errno, strerror(sendto_errno), (mDNSu32)(m-&gt;timenow), MessageCount);
            }
        }

        result = mStatus_UnknownErr;
    }

    <span class="enscript-keyword">return</span>(result);
}

mDNSexport ssize_t <span class="enscript-function-name">myrecvfrom</span>(<span class="enscript-type">const</span> <span class="enscript-type">int</span> s, <span class="enscript-type">void</span> *<span class="enscript-type">const</span> buffer, <span class="enscript-type">const</span> size_t max,
                             <span class="enscript-type">struct</span> sockaddr *<span class="enscript-type">const</span> from, size_t *<span class="enscript-type">const</span> fromlen, mDNSAddr *dstaddr, <span class="enscript-type">char</span> ifname[IF_NAMESIZE], mDNSu8 *ttl)
{
    <span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numLogMessages = 0;
    <span class="enscript-type">struct</span> iovec databuffers = { (<span class="enscript-type">char</span> *)buffer, max };
    <span class="enscript-type">struct</span> msghdr msg;
    ssize_t n;
    <span class="enscript-type">struct</span> cmsghdr *cmPtr;
    <span class="enscript-type">char</span> ancillary[1024];

    *ttl = 255;  <span class="enscript-comment">// If kernel fails to provide TTL data (e.g. Jaguar doesn't) then assume the TTL was 255 as it should be
</span>
    <span class="enscript-comment">// Set up the message
</span>    msg.msg_name       = (caddr_t)from;
    msg.msg_namelen    = *fromlen;
    msg.msg_iov        = &amp;databuffers;
    msg.msg_iovlen     = 1;
    msg.msg_control    = (caddr_t)&amp;ancillary;
    msg.msg_controllen = <span class="enscript-keyword">sizeof</span>(ancillary);
    msg.msg_flags      = 0;

    <span class="enscript-comment">// Receive the data
</span>    n = recvmsg(s, &amp;msg, 0);
    <span class="enscript-keyword">if</span> (n&lt;0)
    {
        <span class="enscript-keyword">if</span> (errno != EWOULDBLOCK &amp;&amp; numLogMessages++ &lt; 100) LogMsg(<span class="enscript-string">&quot;mDNSMacOSX.c: recvmsg(%d) returned error %d errno %d&quot;</span>, s, n, errno);
        <span class="enscript-keyword">return</span>(-1);
    }
    <span class="enscript-keyword">if</span> (msg.msg_controllen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cmsghdr))
    {
        <span class="enscript-keyword">if</span> (numLogMessages++ &lt; 100) LogMsg(<span class="enscript-string">&quot;mDNSMacOSX.c: recvmsg(%d) returned %d msg.msg_controllen %d &lt; sizeof(struct cmsghdr) %lu, errno %d&quot;</span>,
                                           s, n, msg.msg_controllen, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cmsghdr), errno);
        <span class="enscript-keyword">return</span>(-1);
    }
    <span class="enscript-keyword">if</span> (msg.msg_flags &amp; MSG_CTRUNC)
    {
        <span class="enscript-keyword">if</span> (numLogMessages++ &lt; 100) LogMsg(<span class="enscript-string">&quot;mDNSMacOSX.c: recvmsg(%d) msg.msg_flags &amp; MSG_CTRUNC&quot;</span>, s);
        <span class="enscript-keyword">return</span>(-1);
    }

    *fromlen = msg.msg_namelen;

    <span class="enscript-comment">// Parse each option out of the ancillary data.
</span>    <span class="enscript-keyword">for</span> (cmPtr = CMSG_FIRSTHDR(&amp;msg); cmPtr; cmPtr = CMSG_NXTHDR(&amp;msg, cmPtr))
    {
        <span class="enscript-comment">// debugf(&quot;myrecvfrom cmsg_level %d cmsg_type %d&quot;, cmPtr-&gt;cmsg_level, cmPtr-&gt;cmsg_type);
</span>        <span class="enscript-keyword">if</span> (cmPtr-&gt;cmsg_level == IPPROTO_IP &amp;&amp; cmPtr-&gt;cmsg_type == IP_RECVDSTADDR)
        {
            dstaddr-&gt;type = mDNSAddrType_IPv4;
            dstaddr-&gt;ip.v4 = *(mDNSv4Addr*)CMSG_DATA(cmPtr);
            <span class="enscript-comment">//LogMsg(&quot;mDNSMacOSX.c: recvmsg IP_RECVDSTADDR %.4a&quot;, &amp;dstaddr-&gt;ip.v4);
</span>        }
        <span class="enscript-keyword">if</span> (cmPtr-&gt;cmsg_level == IPPROTO_IP &amp;&amp; cmPtr-&gt;cmsg_type == IP_RECVIF)
        {
            <span class="enscript-type">struct</span> sockaddr_dl *sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)CMSG_DATA(cmPtr);
            <span class="enscript-keyword">if</span> (sdl-&gt;sdl_nlen &lt; IF_NAMESIZE)
            {
                mDNSPlatformMemCopy(ifname, sdl-&gt;sdl_data, sdl-&gt;sdl_nlen);
                ifname[sdl-&gt;sdl_nlen] = 0;
                <span class="enscript-comment">// debugf(&quot;IP_RECVIF sdl_index %d, sdl_data %s len %d&quot;, sdl-&gt;sdl_index, ifname, sdl-&gt;sdl_nlen);
</span>            }
        }
        <span class="enscript-keyword">if</span> (cmPtr-&gt;cmsg_level == IPPROTO_IP &amp;&amp; cmPtr-&gt;cmsg_type == IP_RECVTTL)
            *ttl = *(u_char*)CMSG_DATA(cmPtr);
        <span class="enscript-keyword">if</span> (cmPtr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp; cmPtr-&gt;cmsg_type == IPV6_PKTINFO)
        {
            <span class="enscript-type">struct</span> in6_pktinfo *ip6_info = (<span class="enscript-type">struct</span> in6_pktinfo*)CMSG_DATA(cmPtr);
            dstaddr-&gt;type = mDNSAddrType_IPv6;
            dstaddr-&gt;ip.v6 = *(mDNSv6Addr*)&amp;ip6_info-&gt;ipi6_addr;
            myIfIndexToName(ip6_info-&gt;ipi6_ifindex, ifname);
        }
        <span class="enscript-keyword">if</span> (cmPtr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp; cmPtr-&gt;cmsg_type == IPV6_HOPLIMIT)
            *ttl = *(<span class="enscript-type">int</span>*)CMSG_DATA(cmPtr);
    }

    <span class="enscript-keyword">return</span>(n);
}

<span class="enscript-comment">// What is this for, and why does it use xor instead of a simple equality check? -- SC
</span>mDNSlocal mDNSInterfaceID <span class="enscript-function-name">FindMyInterface</span>(<span class="enscript-type">const</span> mDNSAddr *addr)
{
    NetworkInterfaceInfo *intf;

    <span class="enscript-keyword">if</span> (addr-&gt;type == mDNSAddrType_IPv4)
    {
        <span class="enscript-keyword">for</span> (intf = mDNSStorage.HostInterfaces; intf; intf = intf-&gt;next)
        {
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == addr-&gt;type &amp;&amp; intf-&gt;McastTxRx)
            {
                <span class="enscript-keyword">if</span> ((intf-&gt;ip.ip.v4.NotAnInteger ^ addr-&gt;ip.v4.NotAnInteger) == 0)
                {
                    <span class="enscript-keyword">return</span>(intf-&gt;InterfaceID);
                }
            }
        }
    }

    <span class="enscript-keyword">if</span> (addr-&gt;type == mDNSAddrType_IPv6)
    {
        <span class="enscript-keyword">for</span> (intf = mDNSStorage.HostInterfaces; intf; intf = intf-&gt;next)
        {
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == addr-&gt;type &amp;&amp; intf-&gt;McastTxRx)
            {
                <span class="enscript-keyword">if</span> (((intf-&gt;ip.ip.v6.l[0] ^ addr-&gt;ip.v6.l[0]) == 0) &amp;&amp;
                    ((intf-&gt;ip.ip.v6.l[1] ^ addr-&gt;ip.v6.l[1]) == 0) &amp;&amp;
                    ((intf-&gt;ip.ip.v6.l[2] ^ addr-&gt;ip.v6.l[2]) == 0) &amp;&amp;
                    (((intf-&gt;ip.ip.v6.l[3] ^ addr-&gt;ip.v6.l[3]) == 0)))
                    {
                        <span class="enscript-keyword">return</span>(intf-&gt;InterfaceID);
                    }
            }
        }
    }
    <span class="enscript-keyword">return</span>(mDNSInterface_Any);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">myKQSocketCallBack</span>(<span class="enscript-type">int</span> s1, <span class="enscript-type">short</span> filter, <span class="enscript-type">void</span> *context, mDNSBool encounteredEOF)
{
    KQSocketSet *<span class="enscript-type">const</span> ss = (KQSocketSet *)context;
    mDNS *<span class="enscript-type">const</span> m = ss-&gt;m;
    <span class="enscript-type">int</span> err = 0, count = 0, closed = 0, recvfrom_errno = 0;

    <span class="enscript-keyword">if</span> (filter != EVFILT_READ)
        LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack: Why is filter %d not EVFILT_READ (%d)?&quot;</span>, filter, EVFILT_READ);

    <span class="enscript-keyword">if</span> (s1 != ss-&gt;sktv4 &amp;&amp; s1 != ss-&gt;sktv6)
    {
        LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack: native socket %d&quot;</span>, s1);
        LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack: sktv4 %d sktv6 %d&quot;</span>, ss-&gt;sktv4, ss-&gt;sktv6);
    }

    <span class="enscript-keyword">if</span> (encounteredEOF)
    {
        LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack: socket %d is no longer readable (EOF)&quot;</span>, s1);
        <span class="enscript-keyword">if</span> (s1 == ss-&gt;sktv4)
        {
            ss-&gt;sktv4EOF = mDNStrue;
            KQueueSet(ss-&gt;sktv4, EV_DELETE, EVFILT_READ, &amp;ss-&gt;kqsv4);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s1 == ss-&gt;sktv6)
        {
            ss-&gt;sktv6EOF = mDNStrue;
            KQueueSet(ss-&gt;sktv6, EV_DELETE, EVFILT_READ, &amp;ss-&gt;kqsv6);
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">while</span> (!closed)
    {
        mDNSAddr senderAddr, destAddr = zeroAddr;
        mDNSIPPort senderPort;
        <span class="enscript-type">struct</span> sockaddr_storage from;
        size_t fromlen = <span class="enscript-keyword">sizeof</span>(from);
        <span class="enscript-type">char</span> packetifname[IF_NAMESIZE] = <span class="enscript-string">&quot;&quot;</span>;
        mDNSu8 ttl;
        err = myrecvfrom(s1, &amp;m-&gt;imsg, <span class="enscript-keyword">sizeof</span>(m-&gt;imsg), (<span class="enscript-type">struct</span> sockaddr *)&amp;from, &amp;fromlen, &amp;destAddr, packetifname, &amp;ttl);
        <span class="enscript-keyword">if</span> (err &lt; 0)
        {
            recvfrom_errno = errno;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> ((destAddr.type == mDNSAddrType_IPv4 &amp;&amp; (destAddr.ip.v4.b[0] &amp; 0xF0) == 0xE0) ||
            (destAddr.type == mDNSAddrType_IPv6 &amp;&amp; (destAddr.ip.v6.b[0]         == 0xFF))) m-&gt;p-&gt;num_mcasts++;

        count++;
        <span class="enscript-keyword">if</span> (from.ss_family == AF_INET)
        {
            <span class="enscript-type">struct</span> sockaddr_in *s = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;from;
            senderAddr.type = mDNSAddrType_IPv4;
            senderAddr.ip.v4.NotAnInteger = s-&gt;sin_addr.s_addr;
            senderPort.NotAnInteger = s-&gt;sin_port;
            <span class="enscript-comment">//LogInfo(&quot;myKQSocketCallBack received IPv4 packet from %#-15a to %#-15a on skt %d %s&quot;, &amp;senderAddr, &amp;destAddr, s1, packetifname);
</span>        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (from.ss_family == AF_INET6)
        {
            <span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6*)&amp;from;
            senderAddr.type = mDNSAddrType_IPv6;
            senderAddr.ip.v6 = *(mDNSv6Addr*)&amp;sin6-&gt;sin6_addr;
            senderPort.NotAnInteger = sin6-&gt;sin6_port;
            <span class="enscript-comment">//LogInfo(&quot;myKQSocketCallBack received IPv6 packet from %#-15a to %#-15a on skt %d %s&quot;, &amp;senderAddr, &amp;destAddr, s1, packetifname);
</span>        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack from is unknown address family %d&quot;</span>, from.ss_family);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// Note: When handling multiple packets in a batch, MUST reset InterfaceID before handling each packet
</span>        mDNSInterfaceID InterfaceID = mDNSNULL;
        NetworkInterfaceInfoOSX *intf = m-&gt;p-&gt;InterfaceList;
        <span class="enscript-keyword">while</span> (intf) 
        {
            <span class="enscript-keyword">if</span> (intf-&gt;Exists &amp;&amp; !strcmp(intf-&gt;ifinfo.ifname, packetifname))
                <span class="enscript-keyword">break</span>;
            intf = intf-&gt;next;
        }

        <span class="enscript-comment">// When going to sleep we deregister all our interfaces, but if the machine
</span>        <span class="enscript-comment">// takes a few seconds to sleep we may continue to receive multicasts
</span>        <span class="enscript-comment">// during that time, which would confuse mDNSCoreReceive, because as far
</span>        <span class="enscript-comment">// as it's concerned, we should have no active interfaces any more.
</span>        <span class="enscript-comment">// Hence we ignore multicasts for which we can find no matching InterfaceID.
</span>        <span class="enscript-keyword">if</span> (intf)
            InterfaceID = intf-&gt;ifinfo.InterfaceID;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mDNSAddrIsDNSMulticast(&amp;destAddr))
            <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (!InterfaceID)
        {
            InterfaceID = FindMyInterface(&amp;destAddr);
        }

<span class="enscript-comment">//      LogMsg(&quot;myKQSocketCallBack got packet from %#a to %#a on interface %#a/%s&quot;,
</span><span class="enscript-comment">//          &amp;senderAddr, &amp;destAddr, &amp;ss-&gt;info-&gt;ifinfo.ip, ss-&gt;info-&gt;ifinfo.ifname);
</span>
        <span class="enscript-comment">// mDNSCoreReceive may close the socket we're reading from.  We must break out of our
</span>        <span class="enscript-comment">// loop when that happens, or we may try to read from an invalid FD.  We do this by
</span>        <span class="enscript-comment">// setting the closeFlag pointer in the socketset, so CloseSocketSet can inform us
</span>        <span class="enscript-comment">// if it closes the socketset.
</span>        ss-&gt;closeFlag = &amp;closed;

        <span class="enscript-keyword">if</span> (ss-&gt;proxy)
        {
            m-&gt;p-&gt;UDPProxyCallback(&amp;m-&gt;p-&gt;UDPProxy, &amp;m-&gt;imsg.m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)&amp;m-&gt;imsg + err, &amp;senderAddr,
                senderPort, &amp;destAddr, ss-&gt;port, InterfaceID, NULL);
        }
        <span class="enscript-keyword">else</span>
        {
            mDNSCoreReceive(m, &amp;m-&gt;imsg.m, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)&amp;m-&gt;imsg + err, &amp;senderAddr, senderPort, &amp;destAddr, ss-&gt;port, InterfaceID);
        }

        <span class="enscript-comment">// if we didn't close, we can safely dereference the socketset, and should to
</span>        <span class="enscript-comment">// reset the closeFlag, since it points to something on the stack
</span>        <span class="enscript-keyword">if</span> (!closed) ss-&gt;closeFlag = mDNSNULL;
    }

    <span class="enscript-comment">// If a client application's sockets are marked as defunct
</span>    <span class="enscript-comment">// sockets we have delegated to it with SO_DELEGATED will also go defunct.
</span>    <span class="enscript-comment">// We get an ENOTCONN error for defunct sockets and should just close the socket in that case.
</span>    <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; recvfrom_errno == ENOTCONN)
    {
        LogInfo(<span class="enscript-string">&quot;myKQSocketCallBack: ENOTCONN, closing socket&quot;</span>);
        close(s1);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (recvfrom_errno != EWOULDBLOCK || count == 0))
    {
        <span class="enscript-comment">// Something is busted here.
</span>        <span class="enscript-comment">// kqueue says there is a packet, but myrecvfrom says there is not.
</span>        <span class="enscript-comment">// Try calling select() to get another opinion.
</span>        <span class="enscript-comment">// Find out about other socket parameter that can help understand why select() says the socket is ready for read
</span>        <span class="enscript-comment">// All of this is racy, as data may have arrived after the call to select()
</span>        <span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numLogMessages = 0;
        <span class="enscript-type">int</span> so_error = -1;
        <span class="enscript-type">int</span> so_nread = -1;
        <span class="enscript-type">int</span> fionread = -1;
        socklen_t solen;
        fd_set readfds;
        <span class="enscript-type">struct</span> timeval timeout;
        <span class="enscript-type">int</span> selectresult;
        FD_ZERO(&amp;readfds);
        FD_SET(s1, &amp;readfds);
        timeout.tv_sec  = 0;
        timeout.tv_usec = 0;
        selectresult = select(s1+1, &amp;readfds, NULL, NULL, &amp;timeout);
        solen = (socklen_t)<span class="enscript-keyword">sizeof</span>(so_error);
        <span class="enscript-keyword">if</span> (getsockopt(s1, SOL_SOCKET, SO_ERROR, &amp;so_error, &amp;solen) == -1)
            LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack getsockopt(SO_ERROR) error %d&quot;</span>, errno);
        solen = (socklen_t)<span class="enscript-keyword">sizeof</span>(so_nread);
        <span class="enscript-keyword">if</span> (getsockopt(s1, SOL_SOCKET, SO_NREAD, &amp;so_nread, &amp;solen) == -1)
            LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack getsockopt(SO_NREAD) error %d&quot;</span>, errno);
        <span class="enscript-keyword">if</span> (ioctl(s1, FIONREAD, &amp;fionread) == -1)
            LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack ioctl(FIONREAD) error %d&quot;</span>, errno);
        <span class="enscript-keyword">if</span> (numLogMessages++ &lt; 100)
            LogMsg(<span class="enscript-string">&quot;myKQSocketCallBack recvfrom skt %d error %d errno %d (%s) select %d (%spackets waiting) so_error %d so_nread %d fionread %d count %d&quot;</span>,
                   s1, err, recvfrom_errno, strerror(recvfrom_errno), selectresult, FD_ISSET(s1, &amp;readfds) ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;*NO* &quot;</span>, so_error, so_nread, fionread, count);
        <span class="enscript-keyword">if</span> (numLogMessages &gt; 5)
            NotifyOfElusiveBug(<span class="enscript-string">&quot;Flaw in Kernel (select/recvfrom mismatch)&quot;</span>,
                               <span class="enscript-string">&quot;Congratulations, you've reproduced an elusive bug.\r&quot;</span>
                               <span class="enscript-string">&quot;Please send email to <a href="mailto:radar-3387020@group.apple.com">radar-3387020@group.apple.com</a>.)\r&quot;</span>
                               <span class="enscript-string">&quot;If possible, please leave your machine undisturbed so that someone can come to investigate the problem.&quot;</span>);

        sleep(1);       <span class="enscript-comment">// After logging this error, rate limit so we don't flood syslog
</span>    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">doTcpSocketCallback</span>(TCPSocket *sock)
{
    mDNSBool c = !sock-&gt;connected;
    <span class="enscript-keyword">if</span> (!sock-&gt;connected &amp;&amp; sock-&gt;err == mStatus_NoError)
    {
        sock-&gt;connected = mDNStrue;
    }
    sock-&gt;callback(sock, sock-&gt;context, c, sock-&gt;err);
    <span class="enscript-comment">// Note: the callback may call CloseConnection here, which frees the context structure!
</span>}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>

mDNSlocal OSStatus <span class="enscript-function-name">tlsWriteSock</span>(SSLConnectionRef connection, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, size_t *dataLength)
{
    <span class="enscript-type">int</span> ret = send(((TCPSocket *)connection)-&gt;fd, data, *dataLength, 0);
    <span class="enscript-keyword">if</span> (ret &gt;= 0 &amp;&amp; (size_t)ret &lt; *dataLength) { *dataLength = ret; <span class="enscript-keyword">return</span>(errSSLWouldBlock); }
    <span class="enscript-keyword">if</span> (ret &gt;= 0)                              { *dataLength = ret; <span class="enscript-keyword">return</span>(noErr); }
    *dataLength = 0;
    <span class="enscript-keyword">if</span> (errno == EAGAIN                      ) <span class="enscript-keyword">return</span>(errSSLWouldBlock);
    <span class="enscript-keyword">if</span> (errno == ENOENT                      ) <span class="enscript-keyword">return</span>(errSSLClosedGraceful);
    <span class="enscript-keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="enscript-keyword">return</span>(errSSLClosedAbort);
    LogMsg(<span class="enscript-string">&quot;ERROR: tlsWriteSock: %d error %d (%s)\n&quot;</span>, ((TCPSocket *)connection)-&gt;fd, errno, strerror(errno));
    <span class="enscript-keyword">return</span>(errSSLClosedAbort);
}

mDNSlocal OSStatus <span class="enscript-function-name">tlsReadSock</span>(SSLConnectionRef connection, <span class="enscript-type">void</span> *data, size_t *dataLength)
{
    <span class="enscript-type">int</span> ret = recv(((TCPSocket *)connection)-&gt;fd, data, *dataLength, 0);
    <span class="enscript-keyword">if</span> (ret &gt; 0 &amp;&amp; (size_t)ret &lt; *dataLength) { *dataLength = ret; <span class="enscript-keyword">return</span>(errSSLWouldBlock); }
    <span class="enscript-keyword">if</span> (ret &gt; 0)                              { *dataLength = ret; <span class="enscript-keyword">return</span>(noErr); }
    *dataLength = 0;
    <span class="enscript-keyword">if</span> (ret == 0 || errno == ENOENT    ) <span class="enscript-keyword">return</span>(errSSLClosedGraceful);
    <span class="enscript-keyword">if</span> (            errno == EAGAIN    ) <span class="enscript-keyword">return</span>(errSSLWouldBlock);
    <span class="enscript-keyword">if</span> (            errno == ECONNRESET) <span class="enscript-keyword">return</span>(errSSLClosedAbort);
    LogMsg(<span class="enscript-string">&quot;ERROR: tlsSockRead: error %d (%s)\n&quot;</span>, errno, strerror(errno));
    <span class="enscript-keyword">return</span>(errSSLClosedAbort);
}

mDNSlocal OSStatus <span class="enscript-function-name">tlsSetupSock</span>(TCPSocket *sock, SSLProtocolSide pside, SSLConnectionType ctype)
{
    <span class="enscript-type">char</span> domname_cstr[MAX_ESCAPED_DOMAIN_NAME];

    sock-&gt;tlsContext = SSLCreateContext(kCFAllocatorDefault, pside, ctype);
    <span class="enscript-keyword">if</span> (!sock-&gt;tlsContext) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: SSLCreateContext failed&quot;</span>); 
        <span class="enscript-keyword">return</span>(mStatus_UnknownErr); 
    }

    mStatus err = SSLSetIOFuncs(sock-&gt;tlsContext, tlsReadSock, tlsWriteSock);
    <span class="enscript-keyword">if</span> (err) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: SSLSetIOFuncs failed with error code: %d&quot;</span>, err); 
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; 
    }

    err = SSLSetConnection(sock-&gt;tlsContext, (SSLConnectionRef) sock);
    <span class="enscript-keyword">if</span> (err) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: SSLSetConnection failed with error code: %d&quot;</span>, err); 
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; 
    }

    <span class="enscript-comment">// Set the default ciphersuite configuration
</span>    err = SSLSetSessionConfig(sock-&gt;tlsContext, CFSTR(<span class="enscript-string">&quot;default&quot;</span>));
    <span class="enscript-keyword">if</span> (err) 
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: SSLSetSessionConfig failed with error code: %d&quot;</span>, err);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }

    <span class="enscript-comment">// We already checked for NULL in hostname and this should never happen. Hence, returning -1
</span>    <span class="enscript-comment">// (error not in OSStatus space) is okay.
</span>    <span class="enscript-keyword">if</span> (!sock-&gt;hostname || !sock-&gt;hostname-&gt;c[0]) 
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: hostname NULL&quot;</span>); 
        err = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }

    ConvertDomainNameToCString(sock-&gt;hostname, domname_cstr);
    err = SSLSetPeerDomainName(sock-&gt;tlsContext, domname_cstr, strlen(domname_cstr));
    <span class="enscript-keyword">if</span> (err) 
    { 
        LogMsg(<span class="enscript-string">&quot;ERROR: tlsSetupSock: SSLSetPeerDomainname: %s failed with error code: %d&quot;</span>, domname_cstr, err); 
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; 
    }

    <span class="enscript-keyword">return</span>(err);

<span class="enscript-reference">fail</span>:
    <span class="enscript-keyword">if</span> (sock-&gt;tlsContext)
        CFRelease(sock-&gt;tlsContext);
    <span class="enscript-keyword">return</span>(err);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">doSSLHandshake</span>(TCPSocket *sock)
{
    mStatus err = SSLHandshake(sock-&gt;tlsContext);

    <span class="enscript-comment">//Can't have multiple threads in mDNS core. When MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM is
</span>    <span class="enscript-comment">//defined, KQueueLock is a noop. Hence we need to serialize here
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">//NOTE: We just can't serialize doTcpSocketCallback alone on the main queue.
</span>    <span class="enscript-comment">//We need the rest of the logic also. Otherwise, we can enable the READ
</span>    <span class="enscript-comment">//events below, dispatch a doTcpSocketCallback on the main queue. Assume it is
</span>    <span class="enscript-comment">//ConnFailed which means we are going to free the tcpInfo. While it
</span>    <span class="enscript-comment">//is waiting to be dispatched, another read event can come into tcpKQSocketCallback
</span>    <span class="enscript-comment">//and potentially call doTCPCallback with error which can close the fd and free the
</span>    <span class="enscript-comment">//tcpInfo. Later when the thread gets dispatched it will crash because the tcpInfo
</span>    <span class="enscript-comment">//is already freed.
</span>
    dispatch_async(dispatch_get_main_queue(), ^{

                       LogInfo(<span class="enscript-string">&quot;doSSLHandshake %p: got lock&quot;</span>, sock); <span class="enscript-comment">// Log *after* we get the lock
</span>
                       <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_to_be_closed)
                       {
                           LogInfo(<span class="enscript-string">&quot;SSLHandshake completed after close&quot;</span>);
                           mDNSPlatformTCPCloseConnection(sock);
                       }
                       <span class="enscript-keyword">else</span>
                       {
                           <span class="enscript-keyword">if</span> (sock-&gt;fd != -1) KQueueSet(sock-&gt;fd, EV_ADD, EVFILT_READ, sock-&gt;kqEntry);
                           <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;doSSLHandshake: sock-&gt;fd is -1&quot;</span>);

                           <span class="enscript-keyword">if</span> (err == errSSLWouldBlock)
                               sock-&gt;handshake = handshake_required;
                           <span class="enscript-keyword">else</span>
                           {
                               <span class="enscript-keyword">if</span> (err)
                               {
                                   LogMsg(<span class="enscript-string">&quot;SSLHandshake failed: %d%s&quot;</span>, err, err == errSSLPeerInternalError ? <span class="enscript-string">&quot; (server busy)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
                                   CFRelease(sock-&gt;tlsContext);
                                   sock-&gt;tlsContext = NULL;
                               }

                               sock-&gt;err = err ? mStatus_ConnFailed : 0;
                               sock-&gt;handshake = handshake_completed;

                               LogInfo(<span class="enscript-string">&quot;doSSLHandshake: %p calling doTcpSocketCallback fd %d&quot;</span>, sock, sock-&gt;fd);
                               doTcpSocketCallback(sock);
                           }
                       }

                       LogInfo(<span class="enscript-string">&quot;SSLHandshake %p: dropping lock for fd %d&quot;</span>, sock, sock-&gt;fd);
                       <span class="enscript-keyword">return</span>;
                   });
}
#<span class="enscript-reference">else</span> // <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
mDNSlocal <span class="enscript-type">void</span> *<span class="enscript-function-name">doSSLHandshake</span>(TCPSocket *sock)
{
    <span class="enscript-comment">// Warning: Touching sock without the kqueue lock!
</span>    <span class="enscript-comment">// We're protected because sock-&gt;handshake == handshake_in_progress
</span>    mStatus err = SSLHandshake(sock-&gt;tlsContext);

    KQueueLock();
    debugf(<span class="enscript-string">&quot;doSSLHandshake %p: got lock&quot;</span>, sock); <span class="enscript-comment">// Log *after* we get the lock
</span>
    <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_to_be_closed)
    {
        LogInfo(<span class="enscript-string">&quot;SSLHandshake completed after close&quot;</span>);
        mDNSPlatformTCPCloseConnection(sock);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (sock-&gt;fd != -1) KQueueSet(sock-&gt;fd, EV_ADD, EVFILT_READ, &amp;sock-&gt;kqEntry);
        <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;doSSLHandshake: sock-&gt;fd is -1&quot;</span>);

        <span class="enscript-keyword">if</span> (err == errSSLWouldBlock)
            sock-&gt;handshake = handshake_required;
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (err)
            {
                LogMsg(<span class="enscript-string">&quot;SSLHandshake failed: %d%s&quot;</span>, err, err == errSSLPeerInternalError ? <span class="enscript-string">&quot; (server busy)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
                CFRelease(sock-&gt;tlsContext);
                sock-&gt;tlsContext = NULL;
            }

            sock-&gt;err = err ? mStatus_ConnFailed : 0;
            sock-&gt;handshake = handshake_completed;

            debugf(<span class="enscript-string">&quot;doSSLHandshake: %p calling doTcpSocketCallback fd %d&quot;</span>, sock, sock-&gt;fd);
            doTcpSocketCallback(sock);
        }
    }

    debugf(<span class="enscript-string">&quot;SSLHandshake %p: dropping lock for fd %d&quot;</span>, sock, sock-&gt;fd);
    KQueueUnlock(<span class="enscript-string">&quot;doSSLHandshake&quot;</span>);
    <span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">spawnSSLHandshake</span>(TCPSocket* sock)
{
    debugf(<span class="enscript-string">&quot;spawnSSLHandshake %p: entry&quot;</span>, sock);

    <span class="enscript-keyword">if</span> (sock-&gt;handshake != handshake_required) LogMsg(<span class="enscript-string">&quot;spawnSSLHandshake: handshake status not required: %d&quot;</span>, sock-&gt;handshake);
    sock-&gt;handshake = handshake_in_progress;
    KQueueSet(sock-&gt;fd, EV_DELETE, EVFILT_READ, &amp;sock-&gt;kqEntry);

    <span class="enscript-comment">// Dispatch it on a separate queue to help avoid blocking other threads/queues, and
</span>    <span class="enscript-comment">// to limit the number of threads used for SSLHandshake
</span>    dispatch_async(SSLqueue, ^{doSSLHandshake(sock);});

    debugf(<span class="enscript-string">&quot;spawnSSLHandshake %p: done for %d&quot;</span>, sock, sock-&gt;fd);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">tcpKQSocketCallback</span>(__unused <span class="enscript-type">int</span> fd, <span class="enscript-type">short</span> filter, <span class="enscript-type">void</span> *context, __unused mDNSBool encounteredEOF)
{
    TCPSocket *sock = context;
    sock-&gt;err = mStatus_NoError;

    <span class="enscript-comment">//if (filter == EVFILT_READ ) LogMsg(&quot;myKQSocketCallBack: tcpKQSocketCallback %d is EVFILT_READ&quot;, filter);
</span>    <span class="enscript-comment">//if (filter == EVFILT_WRITE) LogMsg(&quot;myKQSocketCallBack: tcpKQSocketCallback %d is EVFILT_WRITE&quot;, filter);
</span>    <span class="enscript-comment">// EV_ONESHOT doesn't seem to work, so we add the filter with EV_ADD, and explicitly delete it here with EV_DELETE
</span>    <span class="enscript-keyword">if</span> (filter == EVFILT_WRITE) 
    {
        <span class="enscript-comment">// sock-&gt;connected gets set by doTcpSocketCallback(), which may be called from here, or may be called
</span>        <span class="enscript-comment">// from the TLS connect code.   If we asked for a writability test, we are connecting
</span>        <span class="enscript-comment">// (sock-&gt;connected == mDNSFalse).
</span>        <span class="enscript-keyword">if</span> (sock-&gt;connected)
        {
            LogInfo(<span class="enscript-string">&quot;ERROR: TCPConnectCallback called with write event when socket is connected.&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-type">int</span> result = 0;
            socklen_t len = (socklen_t)<span class="enscript-keyword">sizeof</span>(result);
            <span class="enscript-keyword">if</span> (getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;result, &amp;len) &lt; 0)
            {
                LogInfo(<span class="enscript-string">&quot;ERROR: TCPConnectCallback - unable to get connect error: socket %d: Error %d (%s)&quot;</span>,
                        sock-&gt;fd, errno, strerror(errno));
                sock-&gt;err = mStatus_ConnFailed;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (result != 0)
                {
                    sock-&gt;err = mStatus_ConnFailed;
                    <span class="enscript-keyword">if</span> (result == EHOSTUNREACH || result == EADDRNOTAVAIL || result == ENETDOWN)
                    {
                        LogInfo(<span class="enscript-string">&quot;ERROR: TCPConnectCallback - connect failed: socket %d: Error %d (%s)&quot;</span>,
                                sock-&gt;fd, result, strerror(result));
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        LogMsg(<span class="enscript-string">&quot;ERROR: TCPConnectCallback - connect failed: socket %d: Error %d (%s)&quot;</span>,
                               sock-&gt;fd, result, strerror(result));
                    }
                }
            }
        }
        KQueueSet(sock-&gt;fd, EV_DELETE, EVFILT_WRITE, &amp;sock-&gt;kqEntry);

        <span class="enscript-comment">// If we set the EVFILT_READ event in mDNSPlatformTCPConnect, it's possible to get a read event
</span>        <span class="enscript-comment">// before the write event--apparently the socket is both readable and writable once that happens,
</span>        <span class="enscript-comment">// even if the connect fails.   If we set it here, after we've gotten a successful connection, then
</span>        <span class="enscript-comment">// we shouldn't run into that problem.
</span>        <span class="enscript-keyword">if</span> (sock-&gt;err == mStatus_NoError &amp;&amp;
            KQueueSet(sock-&gt;fd, EV_ADD, EVFILT_READ, &amp;sock-&gt;kqEntry))
        {
            <span class="enscript-comment">// And of course if that fails, we can't use the connection even though we have it.
</span>            LogMsg(<span class="enscript-string">&quot;ERROR: tcpKQSocketCallback - KQueueSet failed&quot;</span>);
            sock-&gt;err = mStatus_TransientErr;
        }
    }
    
    <span class="enscript-keyword">if</span> (sock-&gt;flags &amp; kTCPSocketFlags_UseTLS)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        <span class="enscript-comment">// Don't try to set up TLS if the connect failed.
</span>        <span class="enscript-keyword">if</span> (sock-&gt;err == mStatus_NoError) {
            <span class="enscript-keyword">if</span> (!sock-&gt;setup) 
            {
                sock-&gt;setup = mDNStrue; 
                sock-&gt;err = tlsSetupSock(sock, kSSLClientSide, kSSLStreamType);
                <span class="enscript-keyword">if</span> (sock-&gt;err)
                {
                    LogMsg(<span class="enscript-string">&quot;ERROR: tcpKQSocketCallback: tlsSetupSock failed with error code: %d&quot;</span>, sock-&gt;err);
                    <span class="enscript-keyword">return</span>;
                }
            }
            <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_required) 
            { 
                spawnSSLHandshake(sock); 
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_in_progress || sock-&gt;handshake == handshake_to_be_closed)
            {
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sock-&gt;handshake != handshake_completed)
            {
                <span class="enscript-keyword">if</span> (!sock-&gt;err) 
                    sock-&gt;err = mStatus_UnknownErr;
                LogMsg(<span class="enscript-string">&quot;tcpKQSocketCallback called with unexpected SSLHandshake status: %d&quot;</span>, sock-&gt;handshake);
            }
        }
#<span class="enscript-reference">else</span>  <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span> 
        sock-&gt;err = mStatus_UnsupportedErr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
    }

    doTcpSocketCallback(sock);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">KQueueSet</span>(<span class="enscript-type">int</span> fd, u_short flags, <span class="enscript-type">short</span> filter, KQueueEntry *<span class="enscript-type">const</span> entryRef)
{
    dispatch_queue_t queue = dispatch_get_main_queue();
    dispatch_source_t source;
    <span class="enscript-keyword">if</span> (flags == EV_DELETE)
    {
        <span class="enscript-keyword">if</span> (filter == EVFILT_READ)
        {
            dispatch_source_cancel(entryRef-&gt;readSource);
            dispatch_release(entryRef-&gt;readSource);
            entryRef-&gt;readSource = mDNSNULL;
            debugf(<span class="enscript-string">&quot;KQueueSet: source cancel for read %p, %p&quot;</span>, entryRef-&gt;readSource, entryRef-&gt;writeSource);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter == EVFILT_WRITE)
        {
            dispatch_source_cancel(entryRef-&gt;writeSource);
            dispatch_release(entryRef-&gt;writeSource);
            entryRef-&gt;writeSource = mDNSNULL;
            debugf(<span class="enscript-string">&quot;KQueueSet: source cancel for write %p, %p&quot;</span>, entryRef-&gt;readSource, entryRef-&gt;writeSource);
        }
        <span class="enscript-keyword">else</span>
            LogMsg(<span class="enscript-string">&quot;KQueueSet: ERROR: Wrong filter value %d for EV_DELETE&quot;</span>, filter);
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (flags != EV_ADD) LogMsg(<span class="enscript-string">&quot;KQueueSet: Invalid flags %d&quot;</span>, flags);

    <span class="enscript-keyword">if</span> (filter == EVFILT_READ)
    {
        source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, queue);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter == EVFILT_WRITE)
    {
        source = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE, fd, 0, queue);
    }
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;KQueueSet: ERROR: Wrong filter value %d for EV_ADD&quot;</span>, filter);
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">if</span> (!source) <span class="enscript-keyword">return</span> -1;
    dispatch_source_set_event_handler(source, ^{

                                          mDNSs32 stime = mDNSPlatformRawTime();
                                          entryRef-&gt;KQcallback(fd, filter, entryRef-&gt;KQcontext);
                                          mDNSs32 etime = mDNSPlatformRawTime();
                                          <span class="enscript-keyword">if</span> (etime - stime &gt;= WatchDogReportingThreshold)
                                              LogInfo(<span class="enscript-string">&quot;KQEntryCallback Block: WARNING: took %dms to complete&quot;</span>, etime - stime);

                                          <span class="enscript-comment">// Trigger the event delivery to the application. Even though we trigger the
</span>                                          <span class="enscript-comment">// event completion after handling every event source, these all will hopefully
</span>                                          <span class="enscript-comment">// get merged
</span>                                          TriggerEventCompletion();

                                      });
    dispatch_source_set_cancel_handler(source, ^{
                                           <span class="enscript-keyword">if</span> (entryRef-&gt;fdClosed)
                                           {
                                               <span class="enscript-comment">//LogMsg(&quot;CancelHandler: closing fd %d&quot;, fd);
</span>                                               close(fd);
                                           }
                                       });
    dispatch_resume(source);
    <span class="enscript-keyword">if</span> (filter == EVFILT_READ)
        entryRef-&gt;readSource = source;
    <span class="enscript-keyword">else</span>
        entryRef-&gt;writeSource = source;

    <span class="enscript-keyword">return</span> 0;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">KQueueLock</span>()
{
}
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">KQueueUnlock</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> <span class="enscript-type">const</span> *task)
{
    (<span class="enscript-type">void</span>)task; <span class="enscript-comment">//unused
</span>}
#<span class="enscript-reference">else</span>

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">KQueueSet</span>(<span class="enscript-type">int</span> fd, u_short flags, <span class="enscript-type">short</span> filter, <span class="enscript-type">const</span> KQueueEntry *<span class="enscript-type">const</span> entryRef)
{
    <span class="enscript-type">struct</span> kevent new_event;
    EV_SET(&amp;new_event, fd, filter, flags, 0, 0, (<span class="enscript-type">void</span>*)entryRef);
    <span class="enscript-keyword">return</span> (kevent(KQueueFD, &amp;new_event, 1, NULL, 0, NULL) &lt; 0) ? errno : 0;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">KQueueLock</span>()
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    pthread_mutex_lock(&amp;m-&gt;p-&gt;BigMutex);
    m-&gt;p-&gt;BigMutexStartTime = mDNSPlatformRawTime();
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">KQueueUnlock</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* task)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSs32 end = mDNSPlatformRawTime();
    (<span class="enscript-type">void</span>)task;
    <span class="enscript-keyword">if</span> (end - m-&gt;p-&gt;BigMutexStartTime &gt;= WatchDogReportingThreshold)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_WARNING,
            <span class="enscript-string">&quot;WARNING: &quot;</span> PUB_S <span class="enscript-string">&quot; took %d ms to complete&quot;</span>, task, end - m-&gt;p-&gt;BigMutexStartTime);
    }

    pthread_mutex_unlock(&amp;m-&gt;p-&gt;BigMutex);

    <span class="enscript-type">char</span> wake = 1;
    <span class="enscript-keyword">if</span> (send(m-&gt;p-&gt;WakeKQueueLoopFD, &amp;wake, <span class="enscript-keyword">sizeof</span>(wake), 0) == -1)
        LogMsg(<span class="enscript-string">&quot;ERROR: KQueueWake: send failed with error code: %d (%s)&quot;</span>, errno, strerror(errno));
}
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformCloseFD</span>(KQueueEntry *kq, <span class="enscript-type">int</span> fd)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
        (<span class="enscript-type">void</span>) fd; <span class="enscript-comment">//unused
</span>    <span class="enscript-keyword">if</span> (kq-&gt;readSource)
    {
        dispatch_source_cancel(kq-&gt;readSource);
        kq-&gt;readSource = mDNSNULL;
    }
    <span class="enscript-keyword">if</span> (kq-&gt;writeSource)
    {
        dispatch_source_cancel(kq-&gt;writeSource);
        kq-&gt;writeSource = mDNSNULL;
    }
    <span class="enscript-comment">// Close happens in the cancellation handler
</span>    debugf(<span class="enscript-string">&quot;mDNSPlatformCloseFD: resetting sources for %d&quot;</span>, fd);
    kq-&gt;fdClosed = mDNStrue;
#<span class="enscript-reference">else</span>
    (<span class="enscript-type">void</span>)kq; <span class="enscript-comment">//unused
</span>    close(fd);
#<span class="enscript-reference">endif</span>
}

mDNSlocal mStatus <span class="enscript-function-name">SetupTCPSocket</span>(TCPSocket *sock, mDNSAddr_Type addrtype, mDNSIPPort *port, mDNSBool useBackgroundTrafficClass)
{
    <span class="enscript-type">int</span> skt;

    skt = -1;
    <span class="enscript-keyword">if</span> (!mDNSPosixTCPSocketSetup(&amp;skt, addrtype, port, &amp;sock-&gt;port))
    {
        <span class="enscript-keyword">if</span> (skt != -1) close(skt);
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }
            
    <span class="enscript-comment">// for TCP sockets, the traffic class is set once and not changed
</span>    setTrafficClass(skt, useBackgroundTrafficClass);

    sock-&gt;fd = skt;
    sock-&gt;kqEntry.KQcallback = tcpKQSocketCallback;
    sock-&gt;kqEntry.KQcontext  = sock;
    sock-&gt;kqEntry.KQtask     = <span class="enscript-string">&quot;mDNSPlatformTCPSocket&quot;</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    sock-&gt;kqEntry.readSource = mDNSNULL;
    sock-&gt;kqEntry.writeSource = mDNSNULL;
    sock-&gt;kqEntry.fdClosed = mDNSfalse;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSexport TCPSocket *<span class="enscript-function-name">mDNSPlatformTCPSocket</span>(TCPSocketFlags flags, mDNSAddr_Type addrtype, mDNSIPPort *port, domainname *hostname, mDNSBool useBackgroundTrafficClass)
{
    mStatus err;
    mDNSu32 lowWater = 16384;
    size_t len = <span class="enscript-keyword">sizeof</span> (TCPSocket);
    <span class="enscript-keyword">if</span> (hostname) {
        len += <span class="enscript-keyword">sizeof</span> (domainname);
    }

    TCPSocket *sock = (TCPSocket *) callocL(<span class="enscript-string">&quot;TCPSocket/mDNSPlatformTCPSocket&quot;</span>, len);
    <span class="enscript-keyword">if</span> (!sock) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPSocket: memory allocation failure&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    <span class="enscript-keyword">if</span> (hostname)
    {
        sock-&gt;hostname = (domainname *)(sock + 1); <span class="enscript-comment">// Allocated together so can be freed together
</span>        debugf(<span class="enscript-string">&quot;mDNSPlatformTCPSocket: hostname %##s&quot;</span>, hostname-&gt;c);
        AssignDomainName(sock-&gt;hostname, hostname);
    }

    err = SetupTCPSocket(sock, addrtype, port, useBackgroundTrafficClass);

    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPSocket: socket error %d errno %d (%s)&quot;</span>, sock-&gt;fd, errno, strerror(errno));
        freeL(<span class="enscript-string">&quot;TCPSocket/mDNSPlatformTCPSocket&quot;</span>, sock);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }

    <span class="enscript-keyword">if</span> (setsockopt(sock-&gt;fd, IPPROTO_TCP, TCP_NOTSENT_LOWAT, &amp;lowWater, <span class="enscript-keyword">sizeof</span> lowWater) &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPSocket: TCP_NOTSENT_LOWAT returned %d&quot;</span>, errno);
               mDNSPlatformTCPCloseConnection(sock);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    
    sock-&gt;callback          = mDNSNULL;
    sock-&gt;flags             = flags;
    sock-&gt;context           = mDNSNULL;
    sock-&gt;setup             = mDNSfalse;
    sock-&gt;connected         = mDNSfalse;
    sock-&gt;handshake         = handshake_required;
    sock-&gt;m                 =  &amp;mDNSStorage;
    sock-&gt;err               = mStatus_NoError;

    <span class="enscript-keyword">return</span> sock;
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformTCPConnect</span>(TCPSocket *sock, <span class="enscript-type">const</span> mDNSAddr *dst, mDNSOpaque16 dstport, mDNSInterfaceID InterfaceID, TCPConnectionCallback callback, <span class="enscript-type">void</span> *context)
{
    mStatus err = mStatus_NoError;
    <span class="enscript-type">struct</span> sockaddr_storage ss;

    sock-&gt;callback          = callback;
    sock-&gt;context           = context;
    sock-&gt;setup             = mDNSfalse;
    sock-&gt;connected         = mDNSfalse;
    sock-&gt;handshake         = handshake_required;
    sock-&gt;err               = mStatus_NoError;

    <span class="enscript-keyword">if</span> (dst-&gt;type == mDNSAddrType_IPv4)
    {
        <span class="enscript-type">struct</span> sockaddr_in *saddr = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;ss;
        mDNSPlatformMemZero(saddr, <span class="enscript-keyword">sizeof</span>(*saddr));
        saddr-&gt;sin_family      = AF_INET;
        saddr-&gt;sin_port        = dstport.NotAnInteger;
        saddr-&gt;sin_len         = <span class="enscript-keyword">sizeof</span>(*saddr);
        saddr-&gt;sin_addr.s_addr = dst-&gt;ip.v4.NotAnInteger;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">struct</span> sockaddr_in6 *saddr6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ss;
        mDNSPlatformMemZero(saddr6, <span class="enscript-keyword">sizeof</span>(*saddr6));
        saddr6-&gt;sin6_family      = AF_INET6;
        saddr6-&gt;sin6_port        = dstport.NotAnInteger;
        saddr6-&gt;sin6_len         = <span class="enscript-keyword">sizeof</span>(*saddr6);
        saddr6-&gt;sin6_addr        = *(<span class="enscript-type">struct</span> in6_addr *)&amp;dst-&gt;ip.v6;
    }

    <span class="enscript-comment">// Watch for connect complete (write is ready)
</span>    <span class="enscript-comment">// EV_ONESHOT doesn't seem to work, so we add the filter with EV_ADD, and explicitly delete it in tcpKQSocketCallback using EV_DELETE
</span>    <span class="enscript-keyword">if</span> (KQueueSet(sock-&gt;fd, EV_ADD <span class="enscript-comment">/* | EV_ONESHOT */</span>, EVFILT_WRITE, &amp;sock-&gt;kqEntry))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPConnect - KQueueSet failed&quot;</span>);
        <span class="enscript-keyword">return</span> errno;
    }

    <span class="enscript-keyword">if</span> (fcntl(sock-&gt;fd, F_SETFL, fcntl(sock-&gt;fd, F_GETFL, 0) | O_NONBLOCK) &lt; 0) <span class="enscript-comment">// set non-blocking
</span>    {
        LogMsg(<span class="enscript-string">&quot;ERROR: setsockopt O_NONBLOCK - %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }

    <span class="enscript-comment">// We bind to the interface and all subsequent packets including the SYN will be sent out
</span>    <span class="enscript-comment">// on this interface
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: If we are in Active Directory domain, we may try TCP (if the response can't fit in
</span>    <span class="enscript-comment">// UDP).
</span>    <span class="enscript-keyword">if</span> (InterfaceID)
    {
        NetworkInterfaceInfoOSX *info = IfindexToInterfaceInfoOSX(InterfaceID);
        <span class="enscript-keyword">if</span> (dst-&gt;type == mDNSAddrType_IPv4)
        {
        #ifdef IP_BOUND_IF
            <span class="enscript-keyword">if</span> (info) setsockopt(sock-&gt;fd, IPPROTO_IP, IP_BOUND_IF, &amp;info-&gt;scope_id, <span class="enscript-keyword">sizeof</span>(info-&gt;scope_id));
            <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPConnect: Invalid interface index %p&quot;</span>, InterfaceID); <span class="enscript-keyword">return</span> mStatus_BadParamErr; }
        #<span class="enscript-keyword">else</span>
            (<span class="enscript-type">void</span>)InterfaceID; <span class="enscript-comment">// Unused
</span>            (<span class="enscript-type">void</span>)info; <span class="enscript-comment">// Unused
</span>        #endif
        }
        <span class="enscript-keyword">else</span>
        {
        #ifdef IPV6_BOUND_IF
            <span class="enscript-keyword">if</span> (info) setsockopt(sock-&gt;fd, IPPROTO_IPV6, IPV6_BOUND_IF, &amp;info-&gt;scope_id, <span class="enscript-keyword">sizeof</span>(info-&gt;scope_id));
            <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPConnect: Invalid interface index %p&quot;</span>, InterfaceID); <span class="enscript-keyword">return</span> mStatus_BadParamErr; }
        #<span class="enscript-keyword">else</span>
            (<span class="enscript-type">void</span>)InterfaceID; <span class="enscript-comment">// Unused
</span>            (<span class="enscript-type">void</span>)info; <span class="enscript-comment">// Unused
</span>        #endif
        }
    }

    <span class="enscript-comment">// mDNSPlatformReadTCP/WriteTCP (unlike the UDP counterpart) does not provide the destination address
</span>    <span class="enscript-comment">// from which we can infer the destination address family. Hence we need to remember that here.
</span>    <span class="enscript-comment">// Instead of remembering the address family, we remember the right fd.
</span>    sock-&gt;fd = sock-&gt;fd;
    <span class="enscript-comment">// initiate connection wth peer
</span>    <span class="enscript-keyword">if</span> (connect(sock-&gt;fd, (<span class="enscript-type">struct</span> sockaddr *)&amp;ss, ss.ss_len) &lt; 0)
    {
        <span class="enscript-keyword">if</span> (errno == EINPROGRESS) <span class="enscript-keyword">return</span> mStatus_ConnPending;
        <span class="enscript-keyword">if</span> (errno == EHOSTUNREACH || errno == EADDRNOTAVAIL || errno == ENETDOWN)
            LogInfo(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%s)&quot;</span>, sock-&gt;fd, errno, strerror(errno));
        <span class="enscript-keyword">else</span>
            LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPConnect - connect failed: socket %d: Error %d (%s) length %d&quot;</span>, sock-&gt;fd, errno, strerror(errno), ss.ss_len);
        <span class="enscript-keyword">return</span> mStatus_ConnFailed;
    }

    LogMsg(<span class="enscript-string">&quot;NOTE: mDNSPlatformTCPConnect completed synchronously&quot;</span>);
    <span class="enscript-comment">// kQueue should notify us, but this LogMsg is to help track down if it doesn't
</span>    <span class="enscript-comment">// Experimentation shows that even a connection to a local listener returns EINPROGRESS, so this
</span>    <span class="enscript-comment">// will likely never happen.
</span>
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">// Replace the existing socket callback with a new one, or establish a callback where none was present.
</span>mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformTCPSocketSetCallback</span>(TCPSocket *sock, TCPConnectionCallback callback, <span class="enscript-type">void</span> *context)
{
    sock-&gt;callback = callback;
    sock-&gt;context = context;

    <span class="enscript-comment">// dnsextd currently reaches into the TCPSocket structure layer to do its own thing; this won't work for
</span>    <span class="enscript-comment">// any code (e.g., the Discovery Proxy or Discovery Relay) that actually uses the mDNSPlatform layer as
</span>    <span class="enscript-comment">// an opaque layer.   So for that code, we have this.   dnsextd should probably be platformized if it's
</span>    <span class="enscript-comment">// still relevant.
</span>    <span class="enscript-keyword">if</span> (!sock-&gt;callback) {
        <span class="enscript-comment">// Watch for incoming data
</span>        <span class="enscript-keyword">if</span> (KQueueSet(sock-&gt;fd, EV_ADD, EVFILT_READ, &amp;sock-&gt;kqEntry))
        {
            LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPConnect - KQueueSet failed&quot;</span>);
            <span class="enscript-keyword">return</span> mStatus_UnknownErr;
        }
    }
    
    sock-&gt;kqEntry.KQcallback = tcpKQSocketCallback;
    sock-&gt;kqEntry.KQcontext  = sock;
    sock-&gt;kqEntry.KQtask     = <span class="enscript-string">&quot;mDNSPlatformTCPSocket&quot;</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    sock-&gt;kqEntry.readSource = mDNSNULL;
    sock-&gt;kqEntry.writeSource = mDNSNULL;
    sock-&gt;kqEntry.fdClosed = mDNSfalse;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

<span class="enscript-comment">// Why doesn't mDNSPlatformTCPAccept actually call accept() ?
</span><span class="enscript-comment">// mDNSPlatformTCPAccept is only called by dnsextd.c.   It's called _after_ accept has returned
</span><span class="enscript-comment">// a connected socket.   The purpose appears to be to allocate and initialize the TCPSocket structure
</span><span class="enscript-comment">// and set up TLS, if required for this connection.   dnsextd appears to be the only thing in mDNSResponder
</span><span class="enscript-comment">// that accepts incoming TLS connections.
</span>mDNSexport TCPSocket *<span class="enscript-function-name">mDNSPlatformTCPAccept</span>(TCPSocketFlags flags, <span class="enscript-type">int</span> fd)
{
    mStatus err = mStatus_NoError;

    TCPSocket *sock = (TCPSocket *) callocL(<span class="enscript-string">&quot;TCPSocket/mDNSPlatformTCPAccept&quot;</span>, <span class="enscript-keyword">sizeof</span>(*sock));
    <span class="enscript-keyword">if</span> (!sock) <span class="enscript-keyword">return</span>(mDNSNULL);

    sock-&gt;fd = fd;
    sock-&gt;flags = flags;

    <span class="enscript-keyword">if</span> (flags &amp; kTCPSocketFlags_UseTLS)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        <span class="enscript-keyword">if</span> (!ServerCerts) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPAccept: unable to find TLS certificates&quot;</span>); err = mStatus_UnknownErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

        err = tlsSetupSock(sock, kSSLServerSide, kSSLStreamType);
        <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPAccept: tlsSetupSock failed with error code: %d&quot;</span>, err); <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

        err = SSLSetCertificate(sock-&gt;tlsContext, ServerCerts);
        <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTCPAccept: SSLSetCertificate failed with error code: %d&quot;</span>, err); <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
#<span class="enscript-reference">else</span>
        err = mStatus_UnsupportedErr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
    }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
<span class="enscript-reference">exit</span>:
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (err) { freeL(<span class="enscript-string">&quot;TCPSocket/mDNSPlatformTCPAccept&quot;</span>, sock); <span class="enscript-keyword">return</span>(mDNSNULL); }
    <span class="enscript-keyword">return</span>(sock);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">tcpListenCallback</span>(<span class="enscript-type">int</span> fd, __unused <span class="enscript-type">short</span> filter, <span class="enscript-type">void</span> *context, __unused mDNSBool encounteredEOF)
{
    TCPListener *listener = context;
    TCPSocket *sock;
    
    sock = mDNSPosixDoTCPListenCallback(fd, listener-&gt;addressType, listener-&gt;socketFlags,
                                 listener-&gt;callback, listener-&gt;context);
    
    <span class="enscript-keyword">if</span> (sock != mDNSNULL)
    {
        KQueueSet(sock-&gt;fd, EV_ADD, EVFILT_READ, &amp;sock-&gt;kqEntry);
 
        sock-&gt;kqEntry.KQcallback = tcpKQSocketCallback;
        sock-&gt;kqEntry.KQcontext  = sock;
        sock-&gt;kqEntry.KQtask     = <span class="enscript-string">&quot;mDNSPlatformTCPListen&quot;</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
        sock-&gt;kqEntry.readSource = mDNSNULL;
        sock-&gt;kqEntry.writeSource = mDNSNULL;
        sock-&gt;kqEntry.fdClosed = mDNSfalse;
#<span class="enscript-reference">endif</span>
    }
}

mDNSexport TCPListener *<span class="enscript-function-name">mDNSPlatformTCPListen</span>(mDNSAddr_Type addrtype, mDNSIPPort *port, mDNSAddr *addr,
                                              TCPSocketFlags socketFlags, mDNSBool reuseAddr, <span class="enscript-type">int</span> queueLength,
                                              TCPAcceptedCallback callback, <span class="enscript-type">void</span> *context)
{
    TCPListener *ret;
    <span class="enscript-type">int</span> fd = -1;

    <span class="enscript-keyword">if</span> (!mDNSPosixTCPListen(&amp;fd, addrtype, port, addr, reuseAddr, queueLength)) {
        <span class="enscript-keyword">if</span> (fd != -1) {
            close(fd);
        }
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    
    <span class="enscript-comment">// Allocate a listener structure
</span>    ret = (TCPListener *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span> *ret);
    <span class="enscript-keyword">if</span> (ret == mDNSNULL)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformTCPListen: no memory for TCPListener struct.&quot;</span>);
        close(fd);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    ret-&gt;fd = fd;
    ret-&gt;callback = callback;
    ret-&gt;context = context;
    ret-&gt;socketFlags = socketFlags;

    <span class="enscript-comment">// Watch for incoming data
</span>    KQueueSet(ret-&gt;fd, EV_ADD, EVFILT_READ, &amp;ret-&gt;kqEntry);
    ret-&gt;kqEntry.KQcallback = tcpListenCallback;
    ret-&gt;kqEntry.KQcontext  = ret;
    ret-&gt;kqEntry.KQtask     = <span class="enscript-string">&quot;mDNSPlatformTCPListen&quot;</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    ret-&gt;kqEntry.readSource = mDNSNULL;
    ret-&gt;kqEntry.writeSource = mDNSNULL;
    ret-&gt;kqEntry.fdClosed = mDNSfalse;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> ret;
}

mDNSexport mDNSu16 <span class="enscript-function-name">mDNSPlatformGetUDPPort</span>(UDPSocket *sock)
{
    mDNSu16 port;

    port = -1;
    <span class="enscript-keyword">if</span> (sock)
    {
        port = sock-&gt;ss.port.NotAnInteger;
    }
    <span class="enscript-keyword">return</span> port;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CloseSocketSet</span>(KQSocketSet *ss)
{
    <span class="enscript-keyword">if</span> (ss-&gt;sktv4 != -1)
    {
        mDNSPlatformCloseFD(&amp;ss-&gt;kqsv4,  ss-&gt;sktv4);
        ss-&gt;sktv4 = -1;
    }
    <span class="enscript-keyword">if</span> (ss-&gt;sktv6 != -1)
    {
        mDNSPlatformCloseFD(&amp;ss-&gt;kqsv6,  ss-&gt;sktv6);
        ss-&gt;sktv6 = -1;
    }
    <span class="enscript-keyword">if</span> (ss-&gt;closeFlag) *ss-&gt;closeFlag = 1;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformTCPCloseConnection</span>(TCPSocket *sock)
{
    <span class="enscript-keyword">if</span> (sock)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        <span class="enscript-keyword">if</span> (sock-&gt;tlsContext)
        {
            <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_in_progress) <span class="enscript-comment">// SSLHandshake thread using this sock (esp. tlsContext)
</span>            {
                LogInfo(<span class="enscript-string">&quot;mDNSPlatformTCPCloseConnection: called while handshake in progress&quot;</span>);
                <span class="enscript-comment">// When we come back from SSLHandshake, we will notice that a close was here and
</span>                <span class="enscript-comment">// call this function again which will do the cleanup then.
</span>                sock-&gt;handshake = handshake_to_be_closed;
                <span class="enscript-keyword">return</span>;
            }

            SSLClose(sock-&gt;tlsContext);
            CFRelease(sock-&gt;tlsContext);
            sock-&gt;tlsContext = NULL;
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
        <span class="enscript-keyword">if</span> (sock-&gt;fd != -1) {
            shutdown(sock-&gt;fd, 2);
            mDNSPlatformCloseFD(&amp;sock-&gt;kqEntry, sock-&gt;fd);
            sock-&gt;fd = -1;
        }
        
        freeL(<span class="enscript-string">&quot;TCPSocket/mDNSPlatformTCPCloseConnection&quot;</span>, sock);
    }
}

mDNSexport <span class="enscript-type">long</span> <span class="enscript-function-name">mDNSPlatformReadTCP</span>(TCPSocket *sock, <span class="enscript-type">void</span> *buf, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> buflen, mDNSBool *closed)
{
    ssize_t nread = 0;
    *closed = mDNSfalse;

    <span class="enscript-comment">// We can get here if the caller set up a TCP connection but didn't check the status when it got the
</span>    <span class="enscript-comment">// callback.
</span>    <span class="enscript-keyword">if</span> (!sock-&gt;connected) {
        <span class="enscript-keyword">return</span> mStatus_DefunctConnection;
    }
    
    <span class="enscript-keyword">if</span> (sock-&gt;flags &amp; kTCPSocketFlags_UseTLS)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_required) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformReadTCP called while handshake required&quot;</span>); <span class="enscript-keyword">return</span> 0; }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_in_progress) <span class="enscript-keyword">return</span> 0;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sock-&gt;handshake != handshake_completed) LogMsg(<span class="enscript-string">&quot;mDNSPlatformReadTCP called with unexpected SSLHandshake status: %d&quot;</span>, sock-&gt;handshake);

        <span class="enscript-comment">//LogMsg(&quot;Starting SSLRead %d %X&quot;, sock-&gt;fd, fcntl(sock-&gt;fd, F_GETFL, 0));
</span>        mStatus err = SSLRead(sock-&gt;tlsContext, buf, buflen, (size_t *)&amp;nread);
        <span class="enscript-comment">//LogMsg(&quot;SSLRead returned %d (%d) nread %d buflen %d&quot;, err, errSSLWouldBlock, nread, buflen);
</span>        <span class="enscript-keyword">if</span> (err == errSSLClosedGraceful) { nread = 0; *closed = mDNStrue; }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err &amp;&amp; err != errSSLWouldBlock)
        { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformReadTCP - SSLRead: %d&quot;</span>, err); nread = -1; *closed = mDNStrue; }
#<span class="enscript-reference">else</span>
        nread = -1;
        *closed = mDNStrue;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
    }
    <span class="enscript-keyword">else</span>
    {
        nread = mDNSPosixReadTCP(sock-&gt;fd, buf, buflen, closed);
    }

    <span class="enscript-keyword">return</span> nread;
}

mDNSexport <span class="enscript-type">long</span> <span class="enscript-function-name">mDNSPlatformWriteTCP</span>(TCPSocket *sock, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> len)
{
    <span class="enscript-type">int</span> nsent;

    <span class="enscript-keyword">if</span> (!sock-&gt;connected) {
        <span class="enscript-keyword">return</span> mStatus_DefunctConnection;
    }

    <span class="enscript-keyword">if</span> (sock-&gt;flags &amp; kTCPSocketFlags_UseTLS)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        size_t processed;
        <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_required) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformWriteTCP called while handshake required&quot;</span>); <span class="enscript-keyword">return</span> 0; }
        <span class="enscript-keyword">if</span> (sock-&gt;handshake == handshake_in_progress) <span class="enscript-keyword">return</span> 0;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sock-&gt;handshake != handshake_completed) LogMsg(<span class="enscript-string">&quot;mDNSPlatformWriteTCP called with unexpected SSLHandshake status: %d&quot;</span>, sock-&gt;handshake);

        mStatus err = SSLWrite(sock-&gt;tlsContext, msg, len, &amp;processed);

        <span class="enscript-keyword">if</span> (!err) nsent = (<span class="enscript-type">int</span>) processed;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err == errSSLWouldBlock) nsent = 0;
        <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformWriteTCP - SSLWrite returned %d&quot;</span>, err); nsent = -1; }
#<span class="enscript-reference">else</span>
        nsent = -1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
    }
    <span class="enscript-keyword">else</span>
    {
        nsent = mDNSPosixWriteTCP(sock-&gt;fd, msg, len);
    }
    <span class="enscript-keyword">return</span> nsent;
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">mDNSPlatformTCPGetFD</span>(TCPSocket *sock)
{
    <span class="enscript-keyword">return</span> sock-&gt;fd;
}

<span class="enscript-comment">// This function checks to see if the socket is writable.   It will be writable if the kernel TCP output
</span><span class="enscript-comment">// buffer is less full than TCP_NOTSENT_LOWAT.   This should be half or less of the actual kernel buffer
</span><span class="enscript-comment">// size.   This check is done in cases where data should be written if there's space, for example in the
</span><span class="enscript-comment">// Discovery Relay code, where we may be receiving mDNS messages at arbitrary times, and generally there
</span><span class="enscript-comment">// should be buffer space to relay them, but in exceptional cases there might not be.   In this case it's
</span>
mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformTCPWritable</span>(TCPSocket *sock)
{
    <span class="enscript-type">int</span> kfd = kqueue();
    <span class="enscript-type">struct</span> kevent kin, kout;
    <span class="enscript-type">int</span> count;
    <span class="enscript-type">struct</span> timespec ts;
    
    <span class="enscript-keyword">if</span> (kfd &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: kqueue failed: %m&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    ts.tv_sec = 0;
    ts.tv_nsec = 0;
    EV_SET(&amp;kin, sock-&gt;fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);
    count = kevent(kfd, &amp;kin, 1, &amp;kout, 1, &amp;ts);
    close(kfd);
    <span class="enscript-keyword">if</span> (count == 1 &amp;&amp; (<span class="enscript-type">int</span>)kout.ident == sock-&gt;fd &amp;&amp; kout.filter == EVFILT_WRITE)
    {
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// If mDNSIPPort port is non-zero, then it's a multicast socket on the specified interface
</span><span class="enscript-comment">// If mDNSIPPort port is zero, then it's a randomly assigned port number, used for sending unicast queries
</span>mDNSlocal mStatus <span class="enscript-function-name">SetupSocket</span>(KQSocketSet *cp, <span class="enscript-type">const</span> mDNSIPPort port, u_short sa_family, mDNSIPPort *<span class="enscript-type">const</span> outport)
{
    <span class="enscript-type">int</span>         *s        = (sa_family == AF_INET) ? &amp;cp-&gt;sktv4 : &amp;cp-&gt;sktv6;
    KQueueEntry *k        = (sa_family == AF_INET) ? &amp;cp-&gt;kqsv4 : &amp;cp-&gt;kqsv6;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> on = 1;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> twofivefive = 255;
    mStatus err = mStatus_NoError;
    <span class="enscript-type">char</span> *errstr = mDNSNULL;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> mtu = 0;
    <span class="enscript-type">int</span> saved_errno;

    cp-&gt;closeFlag = mDNSNULL;

    <span class="enscript-type">int</span> skt = socket(sa_family, SOCK_DGRAM, IPPROTO_UDP);
    <span class="enscript-keyword">if</span> (skt &lt; 3) { <span class="enscript-keyword">if</span> (errno != EAFNOSUPPORT) LogMsg(<span class="enscript-string">&quot;SetupSocket: socket error %d errno %d (%s)&quot;</span>, skt, errno, strerror(errno));<span class="enscript-keyword">return</span>(skt); }

    <span class="enscript-comment">// set default traffic class
</span>    setTrafficClass(skt, mDNSfalse);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SO_RECV_ANYIF</span>
    <span class="enscript-comment">// Enable inbound packets on IFEF_AWDL interface.
</span>    <span class="enscript-comment">// Only done for multicast sockets, since we don't expect unicast socket operations
</span>    <span class="enscript-comment">// on the IFEF_AWDL interface. Operation is a no-op for other interface types.
</span>    <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, MulticastDNSPort)) 
    {
        err = setsockopt(skt, SOL_SOCKET, SO_RECV_ANYIF, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - SO_RECV_ANYIF&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SO_RECV_ANYIF</span>

    <span class="enscript-comment">// ... with a shared UDP port, if it's for multicast receiving
</span>    <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, MulticastDNSPort) || mDNSSameIPPort(port, NATPMPAnnouncementPort))
    {
        err = setsockopt(skt, SOL_SOCKET, SO_REUSEPORT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - SO_REUSEPORT&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    }

    <span class="enscript-comment">// Don't want to wake from sleep for inbound packets on the mDNS sockets
</span>    <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, MulticastDNSPort)) 
    {
        <span class="enscript-type">int</span> nowake = 1;
        <span class="enscript-keyword">if</span> (setsockopt(skt, SOL_SOCKET, SO_NOWAKEFROMSLEEP, &amp;nowake, <span class="enscript-keyword">sizeof</span>(nowake)) == -1)
            LogInfo(<span class="enscript-string">&quot;SetupSocket: SO_NOWAKEFROMSLEEP failed %s&quot;</span>, strerror(errno));
    }

    <span class="enscript-keyword">if</span> (sa_family == AF_INET)
    {
        <span class="enscript-comment">// We want to receive destination addresses
</span>        err = setsockopt(skt, IPPROTO_IP, IP_RECVDSTADDR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IP_RECVDSTADDR&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// We want to receive interface identifiers
</span>        err = setsockopt(skt, IPPROTO_IP, IP_RECVIF, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IP_RECVIF&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// We want to receive packet TTL value so we can check it
</span>        err = setsockopt(skt, IPPROTO_IP, IP_RECVTTL, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IP_RECVTTL&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// Send unicast packets with TTL 255
</span>        err = setsockopt(skt, IPPROTO_IP, IP_TTL, &amp;twofivefive, <span class="enscript-keyword">sizeof</span>(twofivefive));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IP_TTL&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// And multicast packets with TTL 255 too
</span>        err = setsockopt(skt, IPPROTO_IP, IP_MULTICAST_TTL, &amp;twofivefive, <span class="enscript-keyword">sizeof</span>(twofivefive));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IP_MULTICAST_TTL&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// And start listening for packets
</span>        <span class="enscript-type">struct</span> sockaddr_in listening_sockaddr;
        listening_sockaddr.sin_family      = AF_INET;
        listening_sockaddr.sin_port        = port.NotAnInteger;     <span class="enscript-comment">// Pass in opaque ID without any byte swapping
</span>        listening_sockaddr.sin_addr.s_addr = mDNSSameIPPort(port, NATPMPAnnouncementPort) ? AllHosts_v4.NotAnInteger : 0;
        err = bind(skt, (<span class="enscript-type">struct</span> sockaddr *) &amp;listening_sockaddr, <span class="enscript-keyword">sizeof</span>(listening_sockaddr));
        <span class="enscript-keyword">if</span> (err) { errstr = <span class="enscript-string">&quot;bind&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
        <span class="enscript-keyword">if</span> (outport) outport-&gt;NotAnInteger = listening_sockaddr.sin_port;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa_family == AF_INET6)
    {
        <span class="enscript-comment">// NAT-PMP Announcements make no sense on IPv6, and we don't support IPv6 for PCP, so bail early w/o error
</span>        <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, NATPMPAnnouncementPort)) { <span class="enscript-keyword">if</span> (outport) *outport = zeroIPPort; close(skt); <span class="enscript-keyword">return</span> mStatus_NoError; }

        <span class="enscript-comment">// We want to receive destination addresses and receive interface identifiers
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_RECVPKTINFO, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_RECVPKTINFO&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// We want to receive packet hop count value so we can check it
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_RECVHOPLIMIT&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// We want to receive only IPv6 packets. Without this option we get IPv4 packets too,
</span>        <span class="enscript-comment">// with mapped addresses of the form 0:0:0:0:0:FFFF:xxxx:xxxx, where xxxx:xxxx is the IPv4 address
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_V6ONLY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_V6ONLY&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// Send unicast packets with TTL 255
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &amp;twofivefive, <span class="enscript-keyword">sizeof</span>(twofivefive));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_UNICAST_HOPS&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// And multicast packets with TTL 255 too
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;twofivefive, <span class="enscript-keyword">sizeof</span>(twofivefive));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_MULTICAST_HOPS&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// Want to receive our own packets
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
        <span class="enscript-keyword">if</span> (err &lt; 0) { errstr = <span class="enscript-string">&quot;setsockopt - IPV6_MULTICAST_LOOP&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

        <span class="enscript-comment">// Disable default option to send mDNSv6 packets at min IPv6 MTU: RFC 3542, Sec 11
</span>        err = setsockopt(skt, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;mtu, <span class="enscript-keyword">sizeof</span>(mtu));
        <span class="enscript-keyword">if</span> (err &lt; 0) <span class="enscript-comment">// Since it is an optimization if we fail just log the err, no need to close the skt
</span>            LogMsg(<span class="enscript-string">&quot;SetupSocket: setsockopt - IPV6_USE_MIN_MTU: IP6PO_MINMTU_DISABLE socket %d err %d errno %d (%s)&quot;</span>, 
                    skt, err, errno, strerror(errno));
        
        <span class="enscript-comment">// And start listening for packets
</span>        <span class="enscript-type">struct</span> sockaddr_in6 listening_sockaddr6;
        mDNSPlatformMemZero(&amp;listening_sockaddr6, <span class="enscript-keyword">sizeof</span>(listening_sockaddr6));
        listening_sockaddr6.sin6_len         = <span class="enscript-keyword">sizeof</span>(listening_sockaddr6);
        listening_sockaddr6.sin6_family      = AF_INET6;
        listening_sockaddr6.sin6_port        = port.NotAnInteger;       <span class="enscript-comment">// Pass in opaque ID without any byte swapping
</span>        listening_sockaddr6.sin6_flowinfo    = 0;
        listening_sockaddr6.sin6_addr        = in6addr_any; <span class="enscript-comment">// Want to receive multicasts AND unicasts on this socket
</span>        listening_sockaddr6.sin6_scope_id    = 0;
        err = bind(skt, (<span class="enscript-type">struct</span> sockaddr *) &amp;listening_sockaddr6, <span class="enscript-keyword">sizeof</span>(listening_sockaddr6));
        <span class="enscript-keyword">if</span> (err) { errstr = <span class="enscript-string">&quot;bind&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
        <span class="enscript-keyword">if</span> (outport) outport-&gt;NotAnInteger = listening_sockaddr6.sin6_port;
    }

    fcntl(skt, F_SETFL, fcntl(skt, F_GETFL, 0) | O_NONBLOCK); <span class="enscript-comment">// set non-blocking
</span>    fcntl(skt, F_SETFD, 1); <span class="enscript-comment">// set close-on-exec
</span>    *s = skt;
    k-&gt;KQcallback = myKQSocketCallBack;
    k-&gt;KQcontext  = cp;
    k-&gt;KQtask     = <span class="enscript-string">&quot;UDP packet reception&quot;</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    k-&gt;readSource = mDNSNULL;
    k-&gt;writeSource = mDNSNULL;
    k-&gt;fdClosed = mDNSfalse;
#<span class="enscript-reference">endif</span>
    KQueueSet(*s, EV_ADD, EVFILT_READ, k);

    <span class="enscript-keyword">return</span>(mStatus_NoError);

<span class="enscript-reference">fail</span>:
    saved_errno = errno;
    <span class="enscript-comment">// For &quot;bind&quot; failures, only write log messages for our shared mDNS port, or for binding to zero
</span>    <span class="enscript-keyword">if</span> (strcmp(errstr, <span class="enscript-string">&quot;bind&quot;</span>) || mDNSSameIPPort(port, MulticastDNSPort) || mDNSIPPortIsZero(port))
        LogMsg(<span class="enscript-string">&quot;%s skt %d port %d error %d errno %d (%s)&quot;</span>, errstr, skt, mDNSVal16(port), err, saved_errno, strerror(saved_errno));

    <span class="enscript-comment">// If we got a &quot;bind&quot; failure of EADDRINUSE, inform the caller as it might need to try another random port
</span>    <span class="enscript-keyword">if</span> (!strcmp(errstr, <span class="enscript-string">&quot;bind&quot;</span>) &amp;&amp; saved_errno == EADDRINUSE)
    {
        err = EADDRINUSE;
        <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, MulticastDNSPort))
            NotifyOfElusiveBug(<span class="enscript-string">&quot;Setsockopt SO_REUSEPORT failed&quot;</span>,
                               <span class="enscript-string">&quot;Congratulations, you've reproduced an elusive bug.\r&quot;</span>
                               <span class="enscript-string">&quot;Please contact the current assignee of &lt;rdar://problem/3814904&gt;.\r&quot;</span>
                               <span class="enscript-string">&quot;Alternatively, you can send email to <a href="mailto:radar-3387020@group.apple.com">radar-3387020@group.apple.com</a>. (Note number is different.)\r&quot;</span>
                               <span class="enscript-string">&quot;If possible, please leave your machine undisturbed so that someone can come to investigate the problem.&quot;</span>);
    }

    mDNSPlatformCloseFD(k, skt);
    <span class="enscript-keyword">return</span>(err);
}

mDNSexport UDPSocket *<span class="enscript-function-name">mDNSPlatformUDPSocket</span>(<span class="enscript-type">const</span> mDNSIPPort requestedport)
{
    mStatus err;
    mDNSIPPort port = requestedport;
    mDNSBool randomizePort = mDNSIPPortIsZero(requestedport);
    <span class="enscript-type">int</span> i = 10000; <span class="enscript-comment">// Try at most 10000 times to get a unique random port
</span>    UDPSocket *p = (UDPSocket *) callocL(<span class="enscript-string">&quot;UDPSocket&quot;</span>, <span class="enscript-keyword">sizeof</span>(*p));
    <span class="enscript-keyword">if</span> (!p) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformUDPSocket: memory exhausted&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    p-&gt;ss.port  = zeroIPPort;
    p-&gt;ss.m     = &amp;mDNSStorage;
    p-&gt;ss.sktv4 = -1;
    p-&gt;ss.sktv6 = -1;
    p-&gt;ss.proxy = mDNSfalse;

    <span class="enscript-keyword">do</span>
    {
        <span class="enscript-comment">// The kernel doesn't do cryptographically strong random port allocation, so we do it ourselves here
</span>        <span class="enscript-keyword">if</span> (randomizePort) port = mDNSOpaque16fromIntVal(0xC000 + mDNSRandom(0x3FFF));
        err = SetupSocket(&amp;p-&gt;ss, port, AF_INET, &amp;p-&gt;ss.port);
        <span class="enscript-keyword">if</span> (!err)
        {
            err = SetupSocket(&amp;p-&gt;ss, port, AF_INET6, &amp;p-&gt;ss.port);
            <span class="enscript-keyword">if</span> (err) { mDNSPlatformCloseFD(&amp;p-&gt;ss.kqsv4, p-&gt;ss.sktv4); p-&gt;ss.sktv4 = -1; }
        }
        i--;
    } <span class="enscript-keyword">while</span> (err == EADDRINUSE &amp;&amp; randomizePort &amp;&amp; i);

    <span class="enscript-keyword">if</span> (err)
    {
        <span class="enscript-comment">// In customer builds we don't want to log failures with port 5351, because this is a known issue
</span>        <span class="enscript-comment">// of failing to bind to this port when Internet Sharing has already bound to it
</span>        <span class="enscript-comment">// We also don't want to log about port 5350, due to a known bug when some other
</span>        <span class="enscript-comment">// process is bound to it.
</span>        <span class="enscript-keyword">if</span> (mDNSSameIPPort(requestedport, NATPMPPort) || mDNSSameIPPort(requestedport, NATPMPAnnouncementPort))
            LogInfo(<span class="enscript-string">&quot;mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)&quot;</span>, mDNSVal16(requestedport), err, errno, strerror(errno));
        <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;mDNSPlatformUDPSocket: SetupSocket %d failed error %d errno %d (%s)&quot;</span>, mDNSVal16(requestedport), err, errno, strerror(errno));
        freeL(<span class="enscript-string">&quot;UDPSocket&quot;</span>, p);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }
    <span class="enscript-keyword">return</span>(p);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
UNITTEST_UDPCLOSE
#<span class="enscript-reference">else</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformUDPClose</span>(UDPSocket *sock)
{
    CloseSocketSet(&amp;sock-&gt;ss);
    freeL(<span class="enscript-string">&quot;UDPSocket&quot;</span>, sock);
}
#<span class="enscript-reference">endif</span>

mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformUDPSocketEncounteredEOF</span>(<span class="enscript-type">const</span> UDPSocket *sock)
{
    <span class="enscript-keyword">return</span> (sock-&gt;ss.sktv4EOF || sock-&gt;ss.sktv6EOF);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">BPF</span> <span class="enscript-variable-name">Raw</span> <span class="enscript-variable-name">packet</span> <span class="enscript-variable-name">sending</span>/<span class="enscript-variable-name">receiving</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSendRawPacket</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (!InterfaceID) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendRawPacket: No InterfaceID specified&quot;</span>); <span class="enscript-keyword">return</span>; }
    NetworkInterfaceInfoOSX *info;

    info = IfindexToInterfaceInfoOSX(InterfaceID);
    <span class="enscript-keyword">if</span> (info == NULL)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendRawPacket: Invalid interface index %p&quot;</span>, InterfaceID);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (info-&gt;BPF_fd &lt; 0)
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendRawPacket: %s BPF_fd %d not ready&quot;</span>, info-&gt;ifinfo.ifname, info-&gt;BPF_fd);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">//LogMsg(&quot;mDNSPlatformSendRawPacket %d bytes on %s&quot;, end - (mDNSu8 *)msg, info-&gt;ifinfo.ifname);
</span>        <span class="enscript-keyword">if</span> (write(info-&gt;BPF_fd, msg, end - (mDNSu8 *)msg) &lt; 0)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendRawPacket: BPF write(%d) failed %d (%s)&quot;</span>, info-&gt;BPF_fd, errno, strerror(errno));
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSetLocalAddressCacheEntry</span>(<span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> tpa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> tha, mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (!InterfaceID) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformSetLocalAddressCacheEntry: No InterfaceID specified&quot;</span>); <span class="enscript-keyword">return</span>; }
    NetworkInterfaceInfoOSX *info;
    info = IfindexToInterfaceInfoOSX(InterfaceID);
    <span class="enscript-keyword">if</span> (info == NULL) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformSetLocalAddressCacheEntry: Invalid interface index %p&quot;</span>, InterfaceID); <span class="enscript-keyword">return</span>; }
    <span class="enscript-comment">// Manually inject an entry into our local ARP cache.
</span>    <span class="enscript-comment">// (We can't do this by sending an ARP broadcast, because the kernel only pays attention to incoming ARP packets, not outgoing.)
</span>    <span class="enscript-keyword">if</span> (!mDNS_AddressIsLocalSubnet(&amp;mDNSStorage, InterfaceID, tpa))
        LogSPS(<span class="enscript-string">&quot;Don't need address cache entry for %s %#a %.6a&quot;</span>,            info-&gt;ifinfo.ifname, tpa, tha);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">int</span> result = mDNSSetLocalAddressCacheEntry(info-&gt;scope_id, tpa-&gt;type, tpa-&gt;ip.v6.b, tha-&gt;b);
        <span class="enscript-keyword">if</span> (result) LogMsg(<span class="enscript-string">&quot;Set local address cache entry for %s %#a %.6a failed: %d&quot;</span>, info-&gt;ifinfo.ifname, tpa, tha, result);
        <span class="enscript-keyword">else</span> LogSPS(<span class="enscript-string">&quot;Set local address cache entry for %s %#a %.6a&quot;</span>,            info-&gt;ifinfo.ifname, tpa, tha);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CloseBPF</span>(NetworkInterfaceInfoOSX *<span class="enscript-type">const</span> i)
{
    LogSPS(<span class="enscript-string">&quot;%s closing BPF fd %d&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;BPF_fd);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    <span class="enscript-comment">// close will happen in the cancel handler
</span>    dispatch_source_cancel(i-&gt;BPF_source);
#<span class="enscript-reference">else</span>

    <span class="enscript-comment">// Note: MUST NOT close() the underlying native BSD sockets.
</span>    <span class="enscript-comment">// CFSocketInvalidate() will do that for us, in its own good time, which may not necessarily be immediately, because
</span>    <span class="enscript-comment">// it first has to unhook the sockets from its select() call on its other thread, before it can safely close them.
</span>    CFRunLoopRemoveSource(CFRunLoopGetMain(), i-&gt;BPF_rls, kCFRunLoopDefaultMode);
    CFRelease(i-&gt;BPF_rls);
    CFSocketInvalidate(i-&gt;BPF_cfs);
    CFRelease(i-&gt;BPF_cfs);
#<span class="enscript-reference">endif</span>
    i-&gt;BPF_fd = -1;
    <span class="enscript-keyword">if</span> (i-&gt;BPF_mcfd &gt;= 0) { close(i-&gt;BPF_mcfd); i-&gt;BPF_mcfd = -1; }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">bpf_callback_common</span>(NetworkInterfaceInfoOSX *info)
{
    KQueueLock();

    <span class="enscript-comment">// Now we've got the lock, make sure the kqueue thread didn't close the fd out from under us (will not be a problem once the OS X
</span>    <span class="enscript-comment">// kernel has a mechanism for dispatching all events to a single thread, but for now we have to guard against this race condition).
</span>    <span class="enscript-keyword">if</span> (info-&gt;BPF_fd &lt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    ssize_t n = read(info-&gt;BPF_fd, &amp;info-&gt;m-&gt;imsg, info-&gt;BPF_len);
    <span class="enscript-type">const</span> mDNSu8 *ptr = (<span class="enscript-type">const</span> mDNSu8 *)&amp;info-&gt;m-&gt;imsg;
    <span class="enscript-type">const</span> mDNSu8 *end = (<span class="enscript-type">const</span> mDNSu8 *)&amp;info-&gt;m-&gt;imsg + n;
    debugf(<span class="enscript-string">&quot;%3d: bpf_callback got %d bytes on %s&quot;</span>, info-&gt;BPF_fd, n, info-&gt;ifinfo.ifname);

    <span class="enscript-keyword">if</span> (n&lt;0)
    {
        <span class="enscript-comment">/* &lt;rdar://problem/10287386&gt;
         * sometimes there can be a race condition btw when the bpf socket
         * gets data and the callback get scheduled and when we call BIOCSETF (which
         * clears the socket).  this can cause the read to hang for a really long time
         * and effectively prevent us from responding to requests for long periods of time.
         * to prevent this make the socket non blocking and just bail if we dont get anything
         */</span>
        <span class="enscript-keyword">if</span> (errno == EAGAIN)
        {
            LogMsg(<span class="enscript-string">&quot;bpf_callback got EAGAIN bailing&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
        LogMsg(<span class="enscript-string">&quot;Closing %s BPF fd %d due to error %d (%s)&quot;</span>, info-&gt;ifinfo.ifname, info-&gt;BPF_fd, errno, strerror(errno));
        CloseBPF(info);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">while</span> (ptr &lt; end)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_hdr *<span class="enscript-type">const</span> bh = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_hdr *)ptr;
        debugf(<span class="enscript-string">&quot;%3d: bpf_callback ptr %p bh_hdrlen %d data %p bh_caplen %4d bh_datalen %4d next %p remaining %4d&quot;</span>,
               info-&gt;BPF_fd, ptr, bh-&gt;bh_hdrlen, ptr + bh-&gt;bh_hdrlen, bh-&gt;bh_caplen, bh-&gt;bh_datalen,
               ptr + BPF_WORDALIGN(bh-&gt;bh_hdrlen + bh-&gt;bh_caplen), end - (ptr + BPF_WORDALIGN(bh-&gt;bh_hdrlen + bh-&gt;bh_caplen)));
        <span class="enscript-comment">// Note that BPF guarantees that the NETWORK LAYER header will be word aligned, not the link-layer header.
</span>        <span class="enscript-comment">// Given that An Ethernet header is 14 bytes, this means that if the network layer header (e.g. IP header,
</span>        <span class="enscript-comment">// ARP message, etc.) is 4-byte aligned, then necessarily the Ethernet header will be NOT be 4-byte aligned.
</span>        mDNSCoreReceiveRawPacket(info-&gt;m, ptr + bh-&gt;bh_hdrlen, ptr + bh-&gt;bh_hdrlen + bh-&gt;bh_caplen, info-&gt;ifinfo.InterfaceID);
        ptr += BPF_WORDALIGN(bh-&gt;bh_hdrlen + bh-&gt;bh_caplen);
    }
<span class="enscript-reference">exit</span>:
    KQueueUnlock(<span class="enscript-string">&quot;bpf_callback&quot;</span>);
}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">bpf_callback_dispatch</span>(NetworkInterfaceInfoOSX *<span class="enscript-type">const</span> info)
{
    bpf_callback_common(info);
}
#<span class="enscript-reference">else</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">bpf_callback</span>(<span class="enscript-type">const</span> CFSocketRef cfs, <span class="enscript-type">const</span> CFSocketCallBackType CallBackType, <span class="enscript-type">const</span> CFDataRef address, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> data, <span class="enscript-type">void</span> *<span class="enscript-type">const</span> context)
{
    (<span class="enscript-type">void</span>)cfs;
    (<span class="enscript-type">void</span>)CallBackType;
    (<span class="enscript-type">void</span>)address;
    (<span class="enscript-type">void</span>)data;
    bpf_callback_common((NetworkInterfaceInfoOSX *)context);
}
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSendKeepalive</span>(mDNSAddr *sadd, mDNSAddr *dadd, mDNSIPPort *lport, mDNSIPPort *rport, mDNSu32 seq, mDNSu32 ack, mDNSu16 win)
{
    LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendKeepalive called\n&quot;</span>);
    mDNSSendKeepalive(sadd-&gt;ip.v6.b, dadd-&gt;ip.v6.b, lport-&gt;NotAnInteger, rport-&gt;NotAnInteger, seq, ack, win);
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformClearSPSData</span>(<span class="enscript-type">void</span>)
{
    CFStringRef  spsAddressKey  = NULL;
    CFStringRef  ownerOPTRecKey = NULL;
    SCDynamicStoreRef addrStore = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:SPSAddresses&quot;</span>), NULL, NULL);
    SCDynamicStoreRef optStore  = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:SPSOPTRecord&quot;</span>), NULL, NULL);

    spsAddressKey = SCDynamicStoreKeyCreateNetworkInterfaceEntity (kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, CFSTR(<span class="enscript-string">&quot;BonjourSleepProxyAddress&quot;</span>));
    <span class="enscript-keyword">if</span> (spsAddressKey != NULL)
    {
        CFArrayRef keyList = SCDynamicStoreCopyKeyList(addrStore, spsAddressKey);
        <span class="enscript-keyword">if</span> (keyList != NULL)
        {
            <span class="enscript-keyword">if</span> (SCDynamicStoreSetMultiple(addrStore, NULL, keyList, NULL) == false)
                LogSPS(<span class="enscript-string">&quot;mDNSPlatformClearSPSData: Unable to remove %s : error %s&quot;</span>, CFStringGetCStringPtr( spsAddressKey, kCFStringEncodingASCII), SCErrorString(SCError()));
        }
        <span class="enscript-keyword">if</span> (keyList) CFRelease(keyList);
    }
    ownerOPTRecKey= SCDynamicStoreKeyCreateNetworkInterfaceEntity (kCFAllocatorDefault, kSCDynamicStoreDomainState, kSCCompAnyRegex, CFSTR(<span class="enscript-string">&quot;BonjourSleepProxyOPTRecord&quot;</span>));
    <span class="enscript-keyword">if</span>(ownerOPTRecKey != NULL)
    {
        CFArrayRef keyList = SCDynamicStoreCopyKeyList(addrStore, ownerOPTRecKey);
        <span class="enscript-keyword">if</span> (keyList != NULL)
        {
            <span class="enscript-keyword">if</span> (SCDynamicStoreSetMultiple(optStore, NULL, keyList, NULL) == false)
                LogSPS(<span class="enscript-string">&quot;mDNSPlatformClearSPSData: Unable to remove %s : error %s&quot;</span>, CFStringGetCStringPtr(ownerOPTRecKey, kCFStringEncodingASCII), SCErrorString(SCError()));
        }
        <span class="enscript-keyword">if</span> (keyList) CFRelease(keyList);
    }

    <span class="enscript-keyword">if</span> (addrStore)   CFRelease(addrStore);
    <span class="enscript-keyword">if</span> (optStore)    CFRelease(optStore);
    <span class="enscript-keyword">if</span> (spsAddressKey)  CFRelease(spsAddressKey);
    <span class="enscript-keyword">if</span> (ownerOPTRecKey) CFRelease(ownerOPTRecKey);
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">getMACAddress</span>(<span class="enscript-type">int</span> family, v6addr_t raddr, v6addr_t gaddr, <span class="enscript-type">int</span> *gfamily, ethaddr_t eth)
{
    <span class="enscript-type">struct</span>
    {
        <span class="enscript-type">struct</span> rt_msghdr m_rtm;
        <span class="enscript-type">char</span>   m_space[512];
    } m_rtmsg;
    
    <span class="enscript-type">struct</span> rt_msghdr *rtm = &amp;(m_rtmsg.m_rtm);
    <span class="enscript-type">char</span>  *cp  = m_rtmsg.m_space;
    <span class="enscript-type">int</span>    seq = 6367, sock, rlen, i;
    <span class="enscript-type">struct</span> sockaddr_in      *sin  = NULL;
    <span class="enscript-type">struct</span> sockaddr_in6     *sin6 = NULL;
    <span class="enscript-type">struct</span> sockaddr_dl      *sdl  = NULL;
    <span class="enscript-type">struct</span> sockaddr_storage  sins;
    <span class="enscript-type">struct</span> sockaddr_dl       sdl_m;
    
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NEXTADDR</span>(w, s, len)         \
if (rtm-&gt;rtm_addrs &amp; (w))       \
{                               \
bcopy((char *)s, cp, len);  \
cp += len;                  \
}
    
    bzero(&amp;sins,  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage));
    bzero(&amp;sdl_m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_dl));
    bzero((<span class="enscript-type">char</span> *)&amp;m_rtmsg, <span class="enscript-keyword">sizeof</span>(m_rtmsg));
    
    sock = socket(PF_ROUTE, SOCK_RAW, 0);
    <span class="enscript-keyword">if</span> (sock &lt; 0)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> socket_errno = errno;
        LogMsg(<span class="enscript-string">&quot;getMACAddress: Can not open the socket - %s&quot;</span>, strerror(socket_errno));
        <span class="enscript-keyword">return</span> socket_errno;
    }
    
    rtm-&gt;rtm_addrs   |= RTA_DST | RTA_GATEWAY;
    rtm-&gt;rtm_type     = RTM_GET;
    rtm-&gt;rtm_flags    = 0;
    rtm-&gt;rtm_version  = RTM_VERSION;
    rtm-&gt;rtm_seq      = ++seq;
    
    sdl_m.sdl_len     = <span class="enscript-keyword">sizeof</span>(sdl_m);
    sdl_m.sdl_family  = AF_LINK;
    <span class="enscript-keyword">if</span> (family == AF_INET)
    {
        sin = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;sins;
        sin-&gt;sin_family = AF_INET;
        sin-&gt;sin_len    = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
        memcpy(&amp;sin-&gt;sin_addr, raddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
        NEXTADDR(RTA_DST, sin, sin-&gt;sin_len);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (family == AF_INET6)
    {
        sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sins;
        sin6-&gt;sin6_len    = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
        sin6-&gt;sin6_family = AF_INET6;
        memcpy(&amp;sin6-&gt;sin6_addr, raddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        NEXTADDR(RTA_DST, sin6, sin6-&gt;sin6_len);
    }
    NEXTADDR(RTA_GATEWAY, &amp;sdl_m, sdl_m.sdl_len);
    rtm-&gt;rtm_msglen = rlen = cp - (<span class="enscript-type">char</span> *)&amp;m_rtmsg;
    
    <span class="enscript-keyword">if</span> (write(sock, (<span class="enscript-type">char</span> *)&amp;m_rtmsg, rlen) &lt; 0)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> write_errno = errno;
        LogMsg(<span class="enscript-string">&quot;getMACAddress: writing to routing socket: %s&quot;</span>, strerror(write_errno));
        close(sock);
        <span class="enscript-keyword">return</span> write_errno;
    }
    
    <span class="enscript-keyword">do</span>
    {
        rlen = read(sock, (<span class="enscript-type">char</span> *)&amp;m_rtmsg, <span class="enscript-keyword">sizeof</span>(m_rtmsg));
    }
    <span class="enscript-keyword">while</span> (rlen &gt; 0 &amp;&amp; (rtm-&gt;rtm_seq != seq || rtm-&gt;rtm_pid != getpid()));
    
    <span class="enscript-keyword">if</span> (rlen &lt; 0)
        LogMsg(<span class="enscript-string">&quot;getMACAddress: Read from routing socket failed&quot;</span>);
    
    <span class="enscript-keyword">if</span> (family == AF_INET)
    {
        sin = (<span class="enscript-type">struct</span> sockaddr_in *) (rtm + 1);
        sdl = (<span class="enscript-type">struct</span> sockaddr_dl *) (sin-&gt;sin_len + (<span class="enscript-type">char</span> *) sin);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (family == AF_INET6)
    {
        sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *) (rtm +1);
        sdl  = (<span class="enscript-type">struct</span> sockaddr_dl  *) (sin6-&gt;sin6_len + (<span class="enscript-type">char</span> *) sin6);
    }
    
    <span class="enscript-keyword">if</span> (!sdl)
    {
        LogMsg(<span class="enscript-string">&quot;getMACAddress: sdl is NULL for family %d&quot;</span>, family);
        close(sock);
        <span class="enscript-keyword">return</span> -1;
    }
    
    <span class="enscript-comment">// If the address is not on the local net, we get the IP address of the gateway.
</span>    <span class="enscript-comment">// We would have to repeat the process to get the MAC address of the gateway
</span>    *gfamily = sdl-&gt;sdl_family;
    <span class="enscript-keyword">if</span> (sdl-&gt;sdl_family == AF_INET)
    {
        <span class="enscript-keyword">if</span> (sin)
        {
            <span class="enscript-type">struct</span> sockaddr_in *new_sin = (<span class="enscript-type">struct</span> sockaddr_in *)(sin-&gt;sin_len +(<span class="enscript-type">char</span>*) sin);
            memcpy(gaddr, &amp;new_sin-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg(<span class="enscript-string">&quot;getMACAddress: sin is NULL&quot;</span>);
        }
        close(sock);
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sdl-&gt;sdl_family == AF_INET6)
    {
        <span class="enscript-keyword">if</span> (sin6)
        {
            <span class="enscript-type">struct</span> sockaddr_in6 *new_sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(sin6-&gt;sin6_len +(<span class="enscript-type">char</span>*) sin6);
            memcpy(gaddr, &amp;new_sin6-&gt;sin6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg(<span class="enscript-string">&quot;getMACAddress: sin6 is NULL&quot;</span>);
        }
        close(sock);
        <span class="enscript-keyword">return</span> -1;
    }
    
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)LLADDR(sdl);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ETHER_ADDR_LEN; i++)
        (eth)[i] = *(ptr +i);
    
    close(sock);
    
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">GetRemoteMacinternal</span>(<span class="enscript-type">int</span> family, v6addr_t raddr, ethaddr_t eth)
{
    <span class="enscript-type">int</span>      ret = 0;
    v6addr_t gateway;
    <span class="enscript-type">int</span>      gfamily = 0;
    <span class="enscript-type">int</span>      count = 0;

    <span class="enscript-keyword">do</span>
    {
        ret = getMACAddress(family, raddr, gateway, &amp;gfamily, eth);
        <span class="enscript-keyword">if</span> (ret == -1)
        {
            memcpy(raddr, gateway, (gfamily == AF_INET) ? 4 : 16);
            family = gfamily;
            count++;
        }
    }
    <span class="enscript-keyword">while</span> ((ret == -1) &amp;&amp; (count &lt; 5));
    <span class="enscript-keyword">return</span> ret;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">StoreSPSMACAddressinternal</span>(<span class="enscript-type">int</span> family, v6addr_t spsaddr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname)
{
    ethaddr_t              eth;
    <span class="enscript-type">char</span>                   spsip[INET6_ADDRSTRLEN];
    <span class="enscript-type">int</span>                    ret        = 0;
    CFStringRef            sckey      = NULL;
    SCDynamicStoreRef      store      = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:StoreSPSMACAddress&quot;</span>), NULL, NULL);
    SCDynamicStoreRef      ipstore    = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:GetIPv6Addresses&quot;</span>), NULL, NULL);
    CFMutableDictionaryRef dict       = NULL;
    CFStringRef            entityname = NULL;
    CFDictionaryRef        ipdict     = NULL;
    CFArrayRef             addrs      = NULL;
    
    <span class="enscript-keyword">if</span> ((store == NULL) || (ipstore == NULL))
    {
        LogMsg(<span class="enscript-string">&quot;StoreSPSMACAddressinternal: Unable to accesss SC Dynamic Store&quot;</span>);
        ret = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    <span class="enscript-comment">// Get the MAC address of the Sleep Proxy Server
</span>    memset(eth, 0, <span class="enscript-keyword">sizeof</span>(eth));
    ret = GetRemoteMacinternal(family, spsaddr, eth);
    <span class="enscript-keyword">if</span> (ret !=  0)
    {
        LogMsg(<span class="enscript-string">&quot;StoreSPSMACAddressinternal: Failed to determine the MAC address&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    <span class="enscript-comment">// Create/Update the dynamic store entry for the specified interface
</span>    sckey = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR(<span class="enscript-string">&quot;%s%s%s&quot;</span>), <span class="enscript-string">&quot;State:/Network/Interface/&quot;</span>, ifname, <span class="enscript-string">&quot;/BonjourSleepProxyAddress&quot;</span>);
    dict  = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
    <span class="enscript-keyword">if</span> (!dict)
    {
        LogMsg(<span class="enscript-string">&quot;StoreSPSMACAddressinternal: SPSCreateDict() Could not create CFDictionary dict&quot;</span>);
        ret = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    CFStringRef macaddr = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR(<span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>), eth[0], eth[1], eth[2], eth[3], eth[4], eth[5]);
    CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;MACAddress&quot;</span>), macaddr);
    <span class="enscript-keyword">if</span> (NULL != macaddr)
        CFRelease(macaddr);
    
    <span class="enscript-keyword">if</span>( NULL == inet_ntop(family, (<span class="enscript-type">void</span> *)spsaddr, spsip, <span class="enscript-keyword">sizeof</span>(spsip)))
    {
        LogMsg(<span class="enscript-string">&quot;StoreSPSMACAddressinternal: inet_ntop failed: %s&quot;</span>, strerror(errno));
        ret = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    CFStringRef ipaddr = CFStringCreateWithCString(NULL, spsip, kCFStringEncodingUTF8);
    CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;IPAddress&quot;</span>), ipaddr);
    <span class="enscript-keyword">if</span> (NULL != ipaddr)
        CFRelease(ipaddr);
    
    <span class="enscript-comment">// Get the current IPv6 addresses on this interface and store them so NAs can be sent on wakeup
</span>    <span class="enscript-keyword">if</span> ((entityname = CFStringCreateWithFormat(NULL, NULL, CFSTR(<span class="enscript-string">&quot;State:/Network/Interface/%s/IPv6&quot;</span>), ifname)) != NULL)
    {
        <span class="enscript-keyword">if</span> ((ipdict = SCDynamicStoreCopyValue(ipstore, entityname)) != NULL)
        {
            <span class="enscript-keyword">if</span>((addrs = CFDictionaryGetValue(ipdict, CFSTR(<span class="enscript-string">&quot;Addresses&quot;</span>))) != NULL)
            {
                addrs = CFRetain(addrs);
                CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;RegisteredAddresses&quot;</span>), addrs);
            }
        }
    }
    SCDynamicStoreSetValue(store, sckey, dict);
    
<span class="enscript-reference">fin</span>:
    <span class="enscript-keyword">if</span> (store)      CFRelease(store);
    <span class="enscript-keyword">if</span> (ipstore)    CFRelease(ipstore);
    <span class="enscript-keyword">if</span> (sckey)      CFRelease(sckey);
    <span class="enscript-keyword">if</span> (dict)       CFRelease(dict);
    <span class="enscript-keyword">if</span> (ipdict)     CFRelease(ipdict);
    <span class="enscript-keyword">if</span> (entityname) CFRelease(entityname);
    <span class="enscript-keyword">if</span> (addrs)      CFRelease(addrs);
    
    <span class="enscript-keyword">return</span> ret;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSStoreSPSMACAddress</span>(<span class="enscript-type">int</span> family, v6addr_t spsaddr, <span class="enscript-type">char</span> *ifname)
{
    <span class="enscript-type">struct</span>
    {
        v6addr_t saddr;
    } addr;
    <span class="enscript-type">int</span> err = 0;
    
    mDNSPlatformMemCopy(addr.saddr, spsaddr, <span class="enscript-keyword">sizeof</span>(v6addr_t));
    
    err = StoreSPSMACAddressinternal(family, (uint8_t *)addr.saddr, ifname);
    <span class="enscript-keyword">if</span> (err != 0)
        LogMsg(<span class="enscript-string">&quot;mDNSStoreSPSMACAddress : failed&quot;</span>);
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformStoreSPSMACAddr</span>(mDNSAddr *spsaddr, <span class="enscript-type">char</span> *ifname)
{
    <span class="enscript-type">int</span> family = (spsaddr-&gt;type == mDNSAddrType_IPv4) ? AF_INET : AF_INET6;
    
    LogInfo(<span class="enscript-string">&quot;mDNSPlatformStoreSPSMACAddr : Storing %#a on interface %s&quot;</span>, spsaddr, ifname);
    mDNSStoreSPSMACAddress(family, spsaddr-&gt;ip.v6.b, ifname);
    
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}


mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformStoreOwnerOptRecord</span>(<span class="enscript-type">char</span> *ifname, DNSMessage* msg, <span class="enscript-type">int</span> length)
{
    <span class="enscript-type">int</span>                    ret   = 0;
    CFStringRef            sckey = NULL;
    SCDynamicStoreRef      store = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:StoreOwnerOPTRecord&quot;</span>), NULL, NULL);
    CFMutableDictionaryRef dict  = NULL;

    <span class="enscript-keyword">if</span> (store == NULL)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformStoreOwnerOptRecord: Unable to accesss SC Dynamic Store&quot;</span>);
        ret = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }

    <span class="enscript-comment">// Create/Update the dynamic store entry for the specified interface
</span>    sckey = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR(<span class="enscript-string">&quot;%s%s%s&quot;</span>), <span class="enscript-string">&quot;State:/Network/Interface/&quot;</span>, ifname, <span class="enscript-string">&quot;/BonjourSleepProxyOPTRecord&quot;</span>);
    dict  = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
    <span class="enscript-keyword">if</span> (!dict)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformStoreOwnerOptRecord: Could not create CFDictionary dictionary to store OPT Record&quot;</span>);       
        ret =-1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }

    CFDataRef optRec = NULL;
    optRec = CFDataCreate(NULL, (<span class="enscript-type">const</span> uint8_t *)msg, (CFIndex)length);
    CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;OwnerOPTRecord&quot;</span>), optRec);
    <span class="enscript-keyword">if</span> (NULL != optRec) CFRelease(optRec);

    SCDynamicStoreSetValue(store, sckey, dict);

<span class="enscript-reference">fin</span>:
    <span class="enscript-keyword">if</span> (NULL != store)  CFRelease(store);
    <span class="enscript-keyword">if</span> (NULL != sckey)  CFRelease(sckey);
    <span class="enscript-keyword">if</span> (NULL != dict)   CFRelease(dict);
    <span class="enscript-keyword">return</span> ret;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSGet_RemoteMAC</span>(<span class="enscript-type">int</span> family, v6addr_t raddr)
{
    ethaddr_t            eth;
    IPAddressMACMapping *addrMapping;
    <span class="enscript-type">int</span> kr = KERN_FAILURE;
    <span class="enscript-type">struct</span>
    {
        v6addr_t addr;
    } dst;

    bzero(eth, <span class="enscript-keyword">sizeof</span>(ethaddr_t));
    mDNSPlatformMemCopy(dst.addr, raddr, <span class="enscript-keyword">sizeof</span>(v6addr_t));

    kr = GetRemoteMacinternal(family, (uint8_t *)dst.addr, eth);

    <span class="enscript-comment">// If the call to get the remote MAC address succeeds, allocate and copy
</span>    <span class="enscript-comment">// the values and schedule a task to update the MAC address in the TCP Keepalive record.
</span>    <span class="enscript-keyword">if</span> (kr == 0)
    {
        addrMapping = (IPAddressMACMapping *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*addrMapping));
        <span class="enscript-comment">// This memory allocation is not checked for failure
</span>        <span class="enscript-comment">// It also shoudnt need to be a memory allocation at all -- why not just use a stack variable? -- SC
</span>        snprintf(addrMapping-&gt;ethaddr, <span class="enscript-keyword">sizeof</span>(addrMapping-&gt;ethaddr), <span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,
                     eth[0], eth[1], eth[2], eth[3], eth[4], eth[5]);
        <span class="enscript-comment">// Why is the address represented using text? The UpdateRMAC routine just parses it back into a six-byte MAC address. -- SC
</span>        <span class="enscript-keyword">if</span> (family == AF_INET)
        {
            addrMapping-&gt;ipaddr.type = mDNSAddrType_IPv4;
            mDNSPlatformMemCopy(addrMapping-&gt;ipaddr.ip.v4.b, raddr, <span class="enscript-keyword">sizeof</span>(v6addr_t));
            <span class="enscript-comment">// This is the wrong size. Its using sizeof(v6addr_t) for an IPv4 address -- SC
</span>        }
        <span class="enscript-keyword">else</span>
        {
            addrMapping-&gt;ipaddr.type = mDNSAddrType_IPv6;
            mDNSPlatformMemCopy(addrMapping-&gt;ipaddr.ip.v6.b, raddr, <span class="enscript-keyword">sizeof</span>(v6addr_t));
        }
        UpdateRMAC(&amp;mDNSStorage, addrMapping);
    }
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformGetRemoteMacAddr</span>(mDNSAddr *raddr)
{
    <span class="enscript-type">int</span> family = (raddr-&gt;type == mDNSAddrType_IPv4) ? AF_INET : AF_INET6;
    
    LogInfo(<span class="enscript-string">&quot;mDNSPlatformGetRemoteMacAddr calling mDNSGet_RemoteMAC&quot;</span>);
    mDNSGet_RemoteMAC(family, raddr-&gt;ip.v6.b);
    
    <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformRetrieveTCPInfo</span>(mDNSAddr *laddr, mDNSIPPort *lport, mDNSAddr *raddr, mDNSIPPort *rport, mDNSTCPInfo *mti)
{
    mDNSs32 intfid;
    mDNSs32 error  = 0;
    <span class="enscript-type">int</span>     family = (laddr-&gt;type == mDNSAddrType_IPv4) ? AF_INET : AF_INET6;

    error = mDNSRetrieveTCPInfo(family, laddr-&gt;ip.v6.b, lport-&gt;NotAnInteger, raddr-&gt;ip.v6.b, rport-&gt;NotAnInteger, (uint32_t *)&amp;(mti-&gt;seq), (uint32_t *)&amp;(mti-&gt;ack), (uint16_t *)&amp;(mti-&gt;window), (int32_t*)&amp;intfid);
    <span class="enscript-keyword">if</span> (error != KERN_SUCCESS)
    {
        LogMsg(<span class="enscript-string">&quot;%s: mDNSRetrieveTCPInfo returned : %d&quot;</span>, __func__, error);
        <span class="enscript-keyword">return</span> error;
    }
    mti-&gt;IntfId = mDNSPlatformInterfaceIDfromInterfaceIndex(&amp;mDNSStorage, intfid);
    <span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BPF_SetOffset</span>(from, cond, to) (from)-&gt;cond = (to) - 1 - (from)

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">CountProxyTargets</span>(NetworkInterfaceInfoOSX *x, <span class="enscript-type">int</span> *p4, <span class="enscript-type">int</span> *p6)
{
    <span class="enscript-type">int</span> numv4 = 0, numv6 = 0;
    AuthRecord *rr;

    <span class="enscript-keyword">for</span> (rr = mDNSStorage.ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == x-&gt;ifinfo.InterfaceID &amp;&amp; rr-&gt;AddressProxy.type == mDNSAddrType_IPv4)
        {
            <span class="enscript-keyword">if</span> (p4) LogSPS(<span class="enscript-string">&quot;CountProxyTargets: fd %d %-7s IP%2d %.4a&quot;</span>, x-&gt;BPF_fd, x-&gt;ifinfo.ifname, numv4, &amp;rr-&gt;AddressProxy.ip.v4);
            numv4++;
        }

    <span class="enscript-keyword">for</span> (rr = mDNSStorage.ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == x-&gt;ifinfo.InterfaceID &amp;&amp; rr-&gt;AddressProxy.type == mDNSAddrType_IPv6)
        {
            <span class="enscript-keyword">if</span> (p6) LogSPS(<span class="enscript-string">&quot;CountProxyTargets: fd %d %-7s IP%2d %.16a&quot;</span>, x-&gt;BPF_fd, x-&gt;ifinfo.ifname, numv6, &amp;rr-&gt;AddressProxy.ip.v6);
            numv6++;
        }

    <span class="enscript-keyword">if</span> (p4) *p4 = numv4;
    <span class="enscript-keyword">if</span> (p6) *p6 = numv6;
    <span class="enscript-keyword">return</span>(numv4 + numv6);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformUpdateProxyList</span>(<span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    NetworkInterfaceInfoOSX *x;

    <span class="enscript-comment">// Note: We can't use IfIndexToInterfaceInfoOSX because that looks for Registered also.
</span>    <span class="enscript-keyword">for</span> (x = m-&gt;p-&gt;InterfaceList; x; x = x-&gt;next) <span class="enscript-keyword">if</span> ((x-&gt;ifinfo.InterfaceID == InterfaceID) &amp;&amp; (x-&gt;BPF_fd &gt;= 0)) <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">if</span> (!x) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: ERROR InterfaceID %p not found&quot;</span>, InterfaceID); <span class="enscript-keyword">return</span>; }

    #define MAX_BPF_ADDRS 250
    <span class="enscript-type">int</span> numv4 = 0, numv6 = 0;

    <span class="enscript-keyword">if</span> (CountProxyTargets(x, &amp;numv4, &amp;numv6) &gt; MAX_BPF_ADDRS)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: ERROR Too many address proxy records v4 %d v6 %d&quot;</span>, numv4, numv6);
        <span class="enscript-keyword">if</span> (numv4 &gt; MAX_BPF_ADDRS) numv4 = MAX_BPF_ADDRS;
        numv6 = MAX_BPF_ADDRS - numv4;
    }

    LogSPS(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: fd %d %-7s MAC  %.6a %d v4 %d v6&quot;</span>, x-&gt;BPF_fd, x-&gt;ifinfo.ifname, &amp;x-&gt;ifinfo.MAC, numv4, numv6);

    <span class="enscript-comment">// Caution: This is a static structure, so we need to be careful that any modifications we make to it
</span>    <span class="enscript-comment">// are done in such a way that they work correctly when mDNSPlatformUpdateProxyList is called multiple times
</span>    <span class="enscript-type">static</span> <span class="enscript-type">struct</span> bpf_insn filter[17 + MAX_BPF_ADDRS] =
    {
        BPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, 12),              <span class="enscript-comment">// 0 Read Ethertype (bytes 12,13)
</span>
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0x0806, 0, 1),      <span class="enscript-comment">// 1 If Ethertype == ARP goto next, else 3
</span>        BPF_STMT(BPF_RET + BPF_K,             42),              <span class="enscript-comment">// 2 Return 42-byte ARP
</span>
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0x0800, 4, 0),      <span class="enscript-comment">// 3 If Ethertype == IPv4 goto 8 (IPv4 address list check) else next
</span>
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0x86DD, 0, 9),      <span class="enscript-comment">// 4 If Ethertype == IPv6 goto next, else exit
</span>        BPF_STMT(BPF_LD  + BPF_H   + BPF_ABS, 20),              <span class="enscript-comment">// 5 Read Protocol and Hop Limit (bytes 20,21)
</span>        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0x3AFF, 0, 9),      <span class="enscript-comment">// 6 If (Prot,TTL) == (3A,FF) goto next, else IPv6 address list check
</span>        BPF_STMT(BPF_RET + BPF_K,             86),              <span class="enscript-comment">// 7 Return 86-byte ND
</span>
        <span class="enscript-comment">// Is IPv4 packet; check if it's addressed to any IPv4 address we're proxying for
</span>        BPF_STMT(BPF_LD  + BPF_W   + BPF_ABS, 30),              <span class="enscript-comment">// 8 Read IPv4 Dst (bytes 30,31,32,33)
</span>    };

    <span class="enscript-comment">// Special filter program to use when there are no address proxy records
</span>    <span class="enscript-type">static</span> <span class="enscript-type">struct</span> bpf_insn nullfilter[] =
    {
        BPF_STMT(BPF_RET | BPF_K, 0)                            <span class="enscript-comment">// 0 Match no packets and return size 0
</span>    };

    <span class="enscript-type">struct</span> bpf_program prog;
    <span class="enscript-keyword">if</span> (!numv4 &amp;&amp; !numv6)
    {
        LogSPS(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: No need for filter&quot;</span>);
        <span class="enscript-keyword">if</span> (m-&gt;timenow == 0) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: m-&gt;timenow == 0&quot;</span>);

        <span class="enscript-comment">// Cancel any previous ND group memberships we had
</span>        <span class="enscript-keyword">if</span> (x-&gt;BPF_mcfd &gt;= 0)
        {
            close(x-&gt;BPF_mcfd);
            x-&gt;BPF_mcfd = -1;
        }

        <span class="enscript-comment">// Schedule check to see if we can close this BPF_fd now
</span>        <span class="enscript-keyword">if</span> (!m-&gt;NetworkChanged) m-&gt;NetworkChanged = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond * 2);
        <span class="enscript-keyword">if</span> (x-&gt;BPF_fd &lt; 0) <span class="enscript-keyword">return</span>;      <span class="enscript-comment">// If we've already closed our BPF_fd, no need to generate an error message below
</span>        prog.bf_len   = 1;
        prog.bf_insns = nullfilter;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">struct</span> bpf_insn *pc   = &amp;filter[9];
        <span class="enscript-type">struct</span> bpf_insn *chk6 = pc   + numv4 + 1;   <span class="enscript-comment">// numv4 address checks, plus a &quot;return 0&quot;
</span>        <span class="enscript-type">struct</span> bpf_insn *fail = chk6 + 1 + numv6;   <span class="enscript-comment">// Get v6 Dst LSW, plus numv6 address checks
</span>        <span class="enscript-type">struct</span> bpf_insn *ret4 = fail + 1;
        <span class="enscript-type">struct</span> bpf_insn *ret6 = ret4 + 4;

        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn rf  = BPF_STMT(BPF_RET + BPF_K, 0);                <span class="enscript-comment">// No match: Return nothing
</span>
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn g6  = BPF_STMT(BPF_LD  + BPF_W   + BPF_ABS, 50);   <span class="enscript-comment">// Read IPv6 Dst LSW (bytes 50,51,52,53)
</span>
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn r4a = BPF_STMT(BPF_LDX + BPF_B   + BPF_MSH, 14);   <span class="enscript-comment">// Get IP Header length (normally 20)
</span>        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn r4b = BPF_STMT(BPF_LD  + BPF_IMM,           54);   <span class="enscript-comment">// A = 54 (14-byte Ethernet plus 20-byte TCP + 20 bytes spare)
</span>        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn r4c = BPF_STMT(BPF_ALU + BPF_ADD + BPF_X,    0);   <span class="enscript-comment">// A += IP Header length
</span>        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn r4d = BPF_STMT(BPF_RET + BPF_A, 0);                <span class="enscript-comment">// Success: Return Ethernet + IP + TCP + 20 bytes spare (normally 74)
</span>
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bpf_insn r6a = BPF_STMT(BPF_RET + BPF_K, 94);               <span class="enscript-comment">// Success: Return Eth + IPv6 + TCP + 20 bytes spare
</span>
        BPF_SetOffset(&amp;filter[4], jf, fail);    <span class="enscript-comment">// If Ethertype not ARP, IPv4, or IPv6, fail
</span>        BPF_SetOffset(&amp;filter[6], jf, chk6);    <span class="enscript-comment">// If IPv6 but not ICMPv6, go to IPv6 address list check
</span>
        <span class="enscript-comment">// BPF Byte-Order Note
</span>        <span class="enscript-comment">// The BPF API designers apparently thought that programmers would not be smart enough to use htons
</span>        <span class="enscript-comment">// and htonl correctly to convert numeric values to network byte order on little-endian machines,
</span>        <span class="enscript-comment">// so instead they chose to make the API implicitly byte-swap *ALL* values, even literal byte strings
</span>        <span class="enscript-comment">// that shouldn't be byte-swapped, like ASCII text, Ethernet addresses, IP addresses, etc.
</span>        <span class="enscript-comment">// As a result, if we put Ethernet addresses and IP addresses in the right byte order, the BPF API
</span>        <span class="enscript-comment">// will byte-swap and make them backwards, and then our filter won't work. So, we have to arrange
</span>        <span class="enscript-comment">// that on little-endian machines we deliberately put addresses in memory with the bytes backwards,
</span>        <span class="enscript-comment">// so that when the BPF API goes through and swaps them all, they end up back as they should be.
</span>        <span class="enscript-comment">// In summary, if we byte-swap all the non-numeric fields that shouldn't be swapped, and we *don't*
</span>        <span class="enscript-comment">// swap any of the numeric values that *should* be byte-swapped, then the filter will work correctly.
</span>
        <span class="enscript-comment">// IPSEC capture size notes:
</span>        <span class="enscript-comment">//  8 bytes UDP header
</span>        <span class="enscript-comment">//  4 bytes Non-ESP Marker
</span>        <span class="enscript-comment">// 28 bytes IKE Header
</span>        <span class="enscript-comment">// --
</span>        <span class="enscript-comment">// 40 Total. Capturing TCP Header + 20 gets us enough bytes to receive the IKE Header in a UDP-encapsulated IKE packet.
</span>
        AuthRecord *rr;
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;AddressProxy.type == mDNSAddrType_IPv4)
            {
                mDNSv4Addr a = rr-&gt;AddressProxy.ip.v4;
                pc-&gt;code = BPF_JMP + BPF_JEQ + BPF_K;
                BPF_SetOffset(pc, jt, ret4);
                pc-&gt;jf   = 0;
                pc-&gt;k    = (bpf_u_int32)a.b[0] &lt;&lt; 24 | (bpf_u_int32)a.b[1] &lt;&lt; 16 | (bpf_u_int32)a.b[2] &lt;&lt; 8 | (bpf_u_int32)a.b[3];
                pc++;
            }
        *pc++ = rf;

        <span class="enscript-keyword">if</span> (pc != chk6) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: pc %p != chk6 %p&quot;</span>, pc, chk6);
        *pc++ = g6; <span class="enscript-comment">// chk6 points here
</span>
        <span class="enscript-comment">// First cancel any previous ND group memberships we had, then create a fresh socket
</span>        <span class="enscript-keyword">if</span> (x-&gt;BPF_mcfd &gt;= 0) close(x-&gt;BPF_mcfd);
        x-&gt;BPF_mcfd = socket(AF_INET6, SOCK_DGRAM, 0);

        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;AddressProxy.type == mDNSAddrType_IPv6)
            {
                <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> a = &amp;rr-&gt;AddressProxy.ip.v6;
                pc-&gt;code = BPF_JMP + BPF_JEQ + BPF_K;
                BPF_SetOffset(pc, jt, ret6);
                pc-&gt;jf   = 0;
                pc-&gt;k    = (bpf_u_int32)a-&gt;b[0x0C] &lt;&lt; 24 | (bpf_u_int32)a-&gt;b[0x0D] &lt;&lt; 16 | (bpf_u_int32)a-&gt;b[0x0E] &lt;&lt; 8 | (bpf_u_int32)a-&gt;b[0x0F];
                pc++;

                <span class="enscript-type">struct</span> ipv6_mreq i6mr;
                i6mr.ipv6mr_interface = x-&gt;scope_id;
                i6mr.ipv6mr_multiaddr = *(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr*)&amp;NDP_prefix;
                i6mr.ipv6mr_multiaddr.s6_addr[0xD] = a-&gt;b[0xD];
                i6mr.ipv6mr_multiaddr.s6_addr[0xE] = a-&gt;b[0xE];
                i6mr.ipv6mr_multiaddr.s6_addr[0xF] = a-&gt;b[0xF];

                <span class="enscript-comment">// Do precautionary IPV6_LEAVE_GROUP first, necessary to clear stale kernel state
</span>                mStatus err = setsockopt(x-&gt;BPF_mcfd, IPPROTO_IPV6, IPV6_LEAVE_GROUP, &amp;i6mr, <span class="enscript-keyword">sizeof</span>(i6mr));
                <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRNOTAVAIL))
                    LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u&quot;</span>, err, errno, strerror(errno), &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);

                err = setsockopt(x-&gt;BPF_mcfd, IPPROTO_IPV6, IPV6_JOIN_GROUP, &amp;i6mr, <span class="enscript-keyword">sizeof</span>(i6mr));
                <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRINUSE))   <span class="enscript-comment">// Joining same group twice can give &quot;Address already in use&quot; error -- no need to report that
</span>                    LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: IPV6_JOIN_GROUP error %d errno %d (%s) group %.16a on %u&quot;</span>, err, errno, strerror(errno), &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);

                LogSPS(<span class="enscript-string">&quot;Joined IPv6 ND multicast group %.16a for %.16a&quot;</span>, &amp;i6mr.ipv6mr_multiaddr, a);
            }

        <span class="enscript-keyword">if</span> (pc != fail) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: pc %p != fail %p&quot;</span>, pc, fail);
        *pc++ = rf;     <span class="enscript-comment">// fail points here
</span>
        <span class="enscript-keyword">if</span> (pc != ret4) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: pc %p != ret4 %p&quot;</span>, pc, ret4);
        *pc++ = r4a;    <span class="enscript-comment">// ret4 points here
</span>        *pc++ = r4b;
        *pc++ = r4c;
        *pc++ = r4d;

        <span class="enscript-keyword">if</span> (pc != ret6) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: pc %p != ret6 %p&quot;</span>, pc, ret6);
        *pc++ = r6a;    <span class="enscript-comment">// ret6 points here
</span>#<span class="enscript-reference">if</span> 0
        <span class="enscript-comment">// For debugging BPF filter program
</span>        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> q;
        <span class="enscript-keyword">for</span> (q=0; q&lt;prog.bf_len; q++)
            LogSPS(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: %2d { 0x%02x, %d, %d, 0x%08x },&quot;</span>, q, prog.bf_insns[q].code, prog.bf_insns[q].jt, prog.bf_insns[q].jf, prog.bf_insns[q].k);
#<span class="enscript-reference">endif</span>
        prog.bf_len   = (u_int)(pc - filter);
        prog.bf_insns = filter;
    }

    <span class="enscript-keyword">if</span> (ioctl(x-&gt;BPF_fd, BIOCSETFNR, &amp;prog) &lt; 0) LogMsg(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) failed %d (%s)&quot;</span>, prog.bf_len, errno, strerror(errno));
    <span class="enscript-keyword">else</span> LogSPS(<span class="enscript-string">&quot;mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) successful&quot;</span>, prog.bf_len);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformReceiveBPF_fd</span>(<span class="enscript-type">int</span> fd)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNS_Lock(m);

    NetworkInterfaceInfoOSX *i;
    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next) <span class="enscript-keyword">if</span> (i-&gt;BPF_fd == -2) <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">if</span> (!i) { LogSPS(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: No Interfaces awaiting BPF fd %d; closing&quot;</span>, fd); close(fd); }
    <span class="enscript-keyword">else</span>
    {
        LogSPS(<span class="enscript-string">&quot;%s using   BPF fd %d&quot;</span>, i-&gt;ifinfo.ifname, fd);

        <span class="enscript-type">struct</span> bpf_version v;
        <span class="enscript-keyword">if</span> (ioctl(fd, BIOCVERSION, &amp;v) &lt; 0)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (BPF_MAJOR_VERSION != v.bv_major || BPF_MINOR_VERSION != v.bv_minor)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION header %d.%d kernel %d.%d&quot;</span>,
                   fd, i-&gt;ifinfo.ifname, BPF_MAJOR_VERSION, BPF_MINOR_VERSION, v.bv_major, v.bv_minor);

        <span class="enscript-keyword">if</span> (ioctl(fd, BIOCGBLEN, &amp;i-&gt;BPF_len) &lt; 0)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCGBLEN failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));

        <span class="enscript-keyword">if</span> (i-&gt;BPF_len &gt; <span class="enscript-keyword">sizeof</span>(m-&gt;imsg))
        {
            i-&gt;BPF_len = <span class="enscript-keyword">sizeof</span>(m-&gt;imsg);
            <span class="enscript-keyword">if</span> (ioctl(fd, BIOCSBLEN, &amp;i-&gt;BPF_len) &lt; 0)
                LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));
            <span class="enscript-keyword">else</span>
                LogSPS(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN %d&quot;</span>, fd, i-&gt;ifinfo.ifname, i-&gt;BPF_len);
        }

        <span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int opt_one = 1;
        <span class="enscript-keyword">if</span> (ioctl(fd, BIOCIMMEDIATE, &amp;opt_one) &lt; 0)
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCIMMEDIATE failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));

        <span class="enscript-comment">//if (ioctl(fd, BIOCPROMISC, &amp;opt_one) &lt; 0)
</span>        <span class="enscript-comment">//  LogMsg(&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCPROMISC failed %d (%s)&quot;, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));
</span>
        <span class="enscript-comment">//if (ioctl(fd, BIOCSHDRCMPLT, &amp;opt_one) &lt; 0)
</span>        <span class="enscript-comment">//  LogMsg(&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCSHDRCMPLT failed %d (%s)&quot;, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));
</span>
        <span class="enscript-comment">/*  &lt;rdar://problem/10287386&gt;
         *  make socket non blocking see comments in bpf_callback_common for more info
         */</span>
        <span class="enscript-keyword">if</span> (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK) &lt; 0) <span class="enscript-comment">// set non-blocking
</span>        {
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s O_NONBLOCK failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno));
        }

        <span class="enscript-type">struct</span> ifreq ifr;
        mDNSPlatformMemZero(&amp;ifr, <span class="enscript-keyword">sizeof</span>(ifr));
        strlcpy(ifr.ifr_name, i-&gt;ifinfo.ifname, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name));
        <span class="enscript-keyword">if</span> (ioctl(fd, BIOCSETIF, &amp;ifr) &lt; 0)
        { LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: %d %s BIOCSETIF failed %d (%s)&quot;</span>, fd, i-&gt;ifinfo.ifname, errno, strerror(errno)); i-&gt;BPF_fd = -3; }
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
            i-&gt;BPF_fd  = fd;
            i-&gt;BPF_source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, dispatch_get_main_queue());
            <span class="enscript-keyword">if</span> (!i-&gt;BPF_source) {LogMsg(<span class="enscript-string">&quot;mDNSPlatformReceiveBPF_fd: dispatch source create failed&quot;</span>); <span class="enscript-keyword">return</span>;}
            dispatch_source_set_event_handler(i-&gt;BPF_source, ^{bpf_callback_dispatch(i);});
            dispatch_source_set_cancel_handler(i-&gt;BPF_source, ^{close(fd);});
            dispatch_resume(i-&gt;BPF_source);
#<span class="enscript-reference">else</span>
            CFSocketContext myCFSocketContext = { 0, i, NULL, NULL, NULL };
            i-&gt;BPF_fd  = fd;
            i-&gt;BPF_cfs = CFSocketCreateWithNative(kCFAllocatorDefault, fd, kCFSocketReadCallBack, bpf_callback, &amp;myCFSocketContext);
            i-&gt;BPF_rls = CFSocketCreateRunLoopSource(kCFAllocatorDefault, i-&gt;BPF_cfs, 0);
            CFRunLoopAddSource(CFRunLoopGetMain(), i-&gt;BPF_rls, kCFRunLoopDefaultMode);
#<span class="enscript-reference">endif</span>
            mDNSPlatformUpdateProxyList(i-&gt;ifinfo.InterfaceID);
        }
    }

    mDNS_Unlock(m);
}

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Key</span> <span class="enscript-variable-name">Management</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
mDNSlocal CFArrayRef <span class="enscript-function-name">CopyCertChain</span>(SecIdentityRef identity)
{
    CFMutableArrayRef certChain = NULL;
    <span class="enscript-keyword">if</span> (!identity) { LogMsg(<span class="enscript-string">&quot;CopyCertChain: identity is NULL&quot;</span>); <span class="enscript-keyword">return</span>(NULL); }
    SecCertificateRef cert;
    OSStatus err = SecIdentityCopyCertificate(identity, &amp;cert);
    <span class="enscript-keyword">if</span> (err || !cert) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecIdentityCopyCertificate() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
    <span class="enscript-keyword">else</span>
    {
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wdeprecated-declarations&quot;</span>
        SecPolicySearchRef searchRef;
        err = SecPolicySearchCreate(CSSM_CERT_X_509v3, &amp;CSSMOID_APPLE_X509_BASIC, NULL, &amp;searchRef);
        <span class="enscript-keyword">if</span> (err || !searchRef) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecPolicySearchCreate() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
        <span class="enscript-keyword">else</span>
        {
            SecPolicyRef policy;
            err = SecPolicySearchCopyNext(searchRef, &amp;policy);
            <span class="enscript-keyword">if</span> (err || !policy) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecPolicySearchCopyNext() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
            <span class="enscript-keyword">else</span>
            {
                CFArrayRef wrappedCert = CFArrayCreate(NULL, (<span class="enscript-type">const</span> <span class="enscript-type">void</span>**) &amp;cert, 1, &amp;kCFTypeArrayCallBacks);
                <span class="enscript-keyword">if</span> (!wrappedCert) LogMsg(<span class="enscript-string">&quot;CopyCertChain: wrappedCert is NULL&quot;</span>);
                <span class="enscript-keyword">else</span>
                {
                    SecTrustRef trust;
                    err = SecTrustCreateWithCertificates(wrappedCert, policy, &amp;trust);
                    <span class="enscript-keyword">if</span> (err || !trust) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecTrustCreateWithCertificates() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
                    <span class="enscript-keyword">else</span>
                    {
                        err = SecTrustEvaluate(trust, NULL);
                        <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecTrustEvaluate() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
                        <span class="enscript-keyword">else</span>
                        {
                            CFArrayRef rawCertChain;
                            CSSM_TP_APPLE_EVIDENCE_INFO *statusChain = NULL;
                            err = SecTrustGetResult(trust, NULL, &amp;rawCertChain, &amp;statusChain);
                            <span class="enscript-keyword">if</span> (err || !rawCertChain || !statusChain) LogMsg(<span class="enscript-string">&quot;CopyCertChain: SecTrustGetResult() returned %d&quot;</span>, (<span class="enscript-type">int</span>) err);
                            <span class="enscript-keyword">else</span>
                            {
                                certChain = CFArrayCreateMutableCopy(NULL, 0, rawCertChain);
                                <span class="enscript-keyword">if</span> (!certChain) LogMsg(<span class="enscript-string">&quot;CopyCertChain: certChain is NULL&quot;</span>);
                                <span class="enscript-keyword">else</span>
                                {
                                    <span class="enscript-comment">// Replace the SecCertificateRef at certChain[0] with a SecIdentityRef per documentation for SSLSetCertificate:
</span>                                    <span class="enscript-comment">// &lt;<a href="http://devworld.apple.com/documentation/Security/Reference/secureTransportRef/index.html">http://devworld.apple.com/documentation/Security/Reference/secureTransportRef/index.html</a>&gt;
</span>                                    CFArraySetValueAtIndex(certChain, 0, identity);
                                    <span class="enscript-comment">// Remove root from cert chain, but keep any and all intermediate certificates that have been signed by the root certificate
</span>                                    <span class="enscript-keyword">if</span> (CFArrayGetCount(certChain) &gt; 1) CFArrayRemoveValueAtIndex(certChain, CFArrayGetCount(certChain) - 1);
                                }
                                CFRelease(rawCertChain);
                                <span class="enscript-comment">// Do not free statusChain:
</span>                                <span class="enscript-comment">// &lt;<a href="http://developer.apple.com/documentation/Security/Reference/certifkeytrustservices/Reference/reference.html">http://developer.apple.com/documentation/Security/Reference/certifkeytrustservices/Reference/reference.html</a>&gt; says:
</span>                                <span class="enscript-comment">// certChain: Call the CFRelease function to release this object when you are finished with it.
</span>                                <span class="enscript-comment">// statusChain: Do not attempt to free this pointer; it remains valid until the trust management object is released...
</span>                            }
                        }
                        CFRelease(trust);
                    }
                    CFRelease(wrappedCert);
                }
                CFRelease(policy);
            }
            CFRelease(searchRef);
        }
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>
        CFRelease(cert);
    }
    <span class="enscript-keyword">return</span> certChain;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformTLSSetupCerts</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
#<span class="enscript-reference">else</span>
    SecIdentityRef identity = nil;
    SecIdentitySearchRef srchRef = nil;
    OSStatus err;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wdeprecated-declarations&quot;</span>
    <span class="enscript-comment">// search for &quot;any&quot; identity matching specified key use
</span>    <span class="enscript-comment">// In this app, we expect there to be exactly one
</span>    err = SecIdentitySearchCreate(NULL, CSSM_KEYUSE_DECRYPT, &amp;srchRef);
    <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTLSSetupCerts: SecIdentitySearchCreate returned %d&quot;</span>, (<span class="enscript-type">int</span>) err); <span class="enscript-keyword">return</span> err; }

    err = SecIdentitySearchCopyNext(srchRef, &amp;identity);
    <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTLSSetupCerts: SecIdentitySearchCopyNext returned %d&quot;</span>, (<span class="enscript-type">int</span>) err); <span class="enscript-keyword">return</span> err; }
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>

    <span class="enscript-keyword">if</span> (CFGetTypeID(identity) != SecIdentityGetTypeID())
    { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTLSSetupCerts: SecIdentitySearchCopyNext CFTypeID failure&quot;</span>); <span class="enscript-keyword">return</span> mStatus_UnknownErr; }

    <span class="enscript-comment">// Found one. Call CopyCertChain to create the correct certificate chain.
</span>    ServerCerts = CopyCertChain(identity);
    <span class="enscript-keyword">if</span> (ServerCerts == nil) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNSPlatformTLSSetupCerts: CopyCertChain error&quot;</span>); <span class="enscript-keyword">return</span> mStatus_UnknownErr; }

    <span class="enscript-keyword">return</span> mStatus_NoError;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
}

mDNSexport <span class="enscript-type">void</span>  <span class="enscript-function-name">mDNSPlatformTLSTearDownCerts</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    <span class="enscript-keyword">if</span> (ServerCerts) { CFRelease(ServerCerts); ServerCerts = NULL; }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
}


mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSDomainLabelFromCFString</span>(CFStringRef cfs, domainlabel *<span class="enscript-type">const</span> namelabel);

<span class="enscript-comment">// This gets the text of the field currently labelled &quot;Computer Name&quot; in the Sharing Prefs Control Panel
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetUserSpecifiedFriendlyComputerName</span>(domainlabel *<span class="enscript-type">const</span> namelabel)
{
    CFStringEncoding encoding = kCFStringEncodingUTF8;
    CFStringRef cfs = SCDynamicStoreCopyComputerName(NULL, &amp;encoding);

    <span class="enscript-keyword">if</span> (cfs == mDNSNULL) {
        <span class="enscript-keyword">return</span>;
    }

    mDNSDomainLabelFromCFString(cfs, namelabel);

    CFRelease(cfs);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetUserSpecifiedLocalHostName</span>(domainlabel *<span class="enscript-type">const</span> namelabel)
{
    CFStringRef cfs = SCDynamicStoreCopyLocalHostName(NULL);

    <span class="enscript-keyword">if</span> (cfs == mDNSNULL) {
        <span class="enscript-keyword">return</span>;
    }

    mDNSDomainLabelFromCFString(cfs, namelabel);

    CFRelease(cfs);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSDomainLabelFromCFString</span>(CFStringRef cfs, domainlabel *<span class="enscript-type">const</span> namelabel)
{
    CFIndex num_of_bytes_write = 0;
    CFStringGetBytes(cfs, CFRangeMake(0, CFStringGetLength(cfs)), kCFStringEncodingUTF8, 0, FALSE, namelabel-&gt;c + 1, <span class="enscript-keyword">sizeof</span>(*namelabel) - 1, &amp;num_of_bytes_write);
    namelabel-&gt;c[0] = num_of_bytes_write;
}

mDNSexport mDNSBool <span class="enscript-function-name">DictionaryIsEnabled</span>(CFDictionaryRef dict)
{
    mDNSs32 val;
    CFNumberRef state = (CFNumberRef)CFDictionaryGetValue(dict, CFSTR(<span class="enscript-string">&quot;Enabled&quot;</span>));
    <span class="enscript-keyword">if</span> (state == NULL) <span class="enscript-keyword">return</span> mDNSfalse;
    <span class="enscript-keyword">if</span> (!CFNumberGetValue(state, kCFNumberSInt32Type, &amp;val))
    { LogMsg(<span class="enscript-string">&quot;ERROR: DictionaryIsEnabled - CFNumberGetValue&quot;</span>); <span class="enscript-keyword">return</span> mDNSfalse; }
    <span class="enscript-keyword">return</span> val ? mDNStrue : mDNSfalse;
}

mDNSlocal mStatus <span class="enscript-function-name">SetupAddr</span>(mDNSAddr *ip, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *<span class="enscript-type">const</span> sa)
{
    <span class="enscript-keyword">if</span> (!sa) { LogMsg(<span class="enscript-string">&quot;SetupAddr ERROR: NULL sockaddr&quot;</span>); <span class="enscript-keyword">return</span>(mStatus_Invalid); }

    <span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET)
    {
        <span class="enscript-type">struct</span> sockaddr_in *ifa_addr = (<span class="enscript-type">struct</span> sockaddr_in *)sa;
        ip-&gt;type = mDNSAddrType_IPv4;
        ip-&gt;ip.v4.NotAnInteger = ifa_addr-&gt;sin_addr.s_addr;
        <span class="enscript-keyword">return</span>(mStatus_NoError);
    }

    <span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET6)
    {
        <span class="enscript-type">struct</span> sockaddr_in6 *ifa_addr = (<span class="enscript-type">struct</span> sockaddr_in6 *)sa;
        <span class="enscript-comment">// Inside the BSD kernel they use a hack where they stuff the sin6-&gt;sin6_scope_id
</span>        <span class="enscript-comment">// value into the second word of the IPv6 link-local address, so they can just
</span>        <span class="enscript-comment">// pass around IPv6 address structures instead of full sockaddr_in6 structures.
</span>        <span class="enscript-comment">// Those hacked IPv6 addresses aren't supposed to escape the kernel in that form, but they do.
</span>        <span class="enscript-comment">// To work around this we always whack the second word of any IPv6 link-local address back to zero.
</span>        <span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;ifa_addr-&gt;sin6_addr)) ifa_addr-&gt;sin6_addr.__u6_addr.__u6_addr16[1] = 0;
        ip-&gt;type = mDNSAddrType_IPv6;
        ip-&gt;ip.v6 = *(mDNSv6Addr*)&amp;ifa_addr-&gt;sin6_addr;
        <span class="enscript-keyword">return</span>(mStatus_NoError);
    }

    LogMsg(<span class="enscript-string">&quot;SetupAddr invalid sa_family %d&quot;</span>, sa-&gt;sa_family);
    <span class="enscript-keyword">return</span>(mStatus_Invalid);
}

mDNSlocal mDNSEthAddr <span class="enscript-function-name">GetBSSID</span>(<span class="enscript-type">char</span> *ifa_name)
{
    mDNSEthAddr eth = zeroEthAddr;

    CFStringRef entityname = CFStringCreateWithFormat(NULL, NULL, CFSTR(<span class="enscript-string">&quot;State:/Network/Interface/%s/AirPort&quot;</span>), ifa_name);
    <span class="enscript-keyword">if</span> (entityname)
    {
        CFDictionaryRef dict = SCDynamicStoreCopyValue(NULL, entityname);
        <span class="enscript-keyword">if</span> (dict)
        {
            CFRange range = { 0, 6 };       <span class="enscript-comment">// Offset, length
</span>            CFDataRef data = CFDictionaryGetValue(dict, CFSTR(<span class="enscript-string">&quot;BSSID&quot;</span>));
            <span class="enscript-keyword">if</span> (data &amp;&amp; CFDataGetLength(data) == 6)
                CFDataGetBytes(data, range, eth.b);
            CFRelease(dict);
        }
        CFRelease(entityname);
    }

    <span class="enscript-keyword">return</span>(eth);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">GetMAC</span>(mDNSEthAddr *eth, u_short ifindex)
{
    <span class="enscript-type">struct</span> ifaddrs *ifa;
    <span class="enscript-keyword">for</span> (ifa = myGetIfAddrs(0); ifa; ifa = ifa-&gt;ifa_next)
        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_LINK)
        {
            <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *<span class="enscript-type">const</span> sdl = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *)ifa-&gt;ifa_addr;
            <span class="enscript-keyword">if</span> (sdl-&gt;sdl_index == ifindex)
            { mDNSPlatformMemCopy(eth-&gt;b, sdl-&gt;sdl_data + sdl-&gt;sdl_nlen, 6); <span class="enscript-keyword">return</span> 0; }
        }
    *eth = zeroEthAddr;
    <span class="enscript-keyword">return</span> -1;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SIOCGIFWAKEFLAGS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SIOCGIFWAKEFLAGS</span> _IOWR(<span class="enscript-string">'i'</span>, 136, struct ifreq) <span class="enscript-comment">/* get interface wake property flags */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IF_WAKE_ON_MAGIC_PACKET</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WAKE_ON_MAGIC_PACKET</span> 0x01
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ifr_wake_flags</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ifr_wake_flags</span> ifr_ifru.ifru_intval
#<span class="enscript-reference">endif</span>

mDNSlocal
kern_return_t
<span class="enscript-function-name">RegistryEntrySearchCFPropertyAndIOObject</span>( io_registry_entry_t     entry,
                                          <span class="enscript-type">const</span> io_name_t         plane,
                                          CFStringRef             keystr,
                                          CFTypeRef *             outProperty,
                                          io_registry_entry_t *   outEntry)
{
    kern_return_t       kr;

    IOObjectRetain(entry);
    <span class="enscript-keyword">while</span> (entry)
    {
        CFTypeRef ref = IORegistryEntryCreateCFProperty(entry, keystr, kCFAllocatorDefault, mDNSNULL);
        <span class="enscript-keyword">if</span> (ref)
        {
            <span class="enscript-keyword">if</span> (outProperty) *outProperty = ref;
            <span class="enscript-keyword">else</span>             CFRelease(ref);
            <span class="enscript-keyword">break</span>;
        }
        io_registry_entry_t parent;
        kr = IORegistryEntryGetParentEntry(entry, plane, &amp;parent);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) parent = mDNSNULL;
        IOObjectRelease(entry);
        entry = parent;
    }
    <span class="enscript-keyword">if</span> (!entry)          kr = kIOReturnNoDevice;
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (outEntry)   *outEntry = entry;
        <span class="enscript-keyword">else</span>            IOObjectRelease(entry);
        kr = KERN_SUCCESS;
    }
    <span class="enscript-keyword">return</span>(kr);
}

mDNSlocal mDNSBool  <span class="enscript-function-name">CheckInterfaceSupport</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key)
{
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOBSDNameMatching(kIOMasterPortDefault, 0, intf-&gt;ifname));
    <span class="enscript-keyword">if</span> (!service)
    {
        LogSPS(<span class="enscript-string">&quot;CheckInterfaceSupport: No service for interface %s&quot;</span>, intf-&gt;ifname);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    mDNSBool    ret    = mDNSfalse;

    CFStringRef keystr =  CFStringCreateWithCString(NULL, key, kCFStringEncodingUTF8);
    kern_return_t kr = RegistryEntrySearchCFPropertyAndIOObject(service, kIOServicePlane, keystr, mDNSNULL, mDNSNULL);
    CFRelease(keystr);
    <span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) ret = mDNStrue;
    <span class="enscript-keyword">else</span>
    {
        io_name_t n1;
        IOObjectGetClass(service, n1);
        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;CheckInterfaceSupport: No &quot;</span> PUB_S <span class="enscript-string">&quot; for interface &quot;</span> PUB_S <span class="enscript-string">&quot;/&quot;</span> PUB_S <span class="enscript-string">&quot; kr 0x%X&quot;</span>, key, intf-&gt;ifname, n1, kr);
        ret = mDNSfalse;
    }

    IOObjectRelease(service);
    <span class="enscript-keyword">return</span> ret;
}


#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">TARGET_OS_WATCH</span>
mDNSlocal  mDNSBool <span class="enscript-function-name">InterfaceSupportsKeepAlive</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf)
{
    <span class="enscript-keyword">return</span> CheckInterfaceSupport(intf, mDNS_IOREG_KA_KEY);
}
#<span class="enscript-reference">endif</span>

mDNSlocal mDNSBool <span class="enscript-function-name">NetWakeInterface</span>(NetworkInterfaceInfoOSX *i)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_WATCH</span>
    (<span class="enscript-type">void</span>) i;   <span class="enscript-comment">// unused
</span>    <span class="enscript-keyword">return</span>(mDNSfalse);
#<span class="enscript-reference">else</span>
    <span class="enscript-comment">// We only use Sleep Proxy Service on multicast-capable interfaces, except loopback and D2D.
</span>    <span class="enscript-keyword">if</span> (!MulticastInterface(i) || (i-&gt;ifa_flags &amp; IFF_LOOPBACK) || i-&gt;D2DInterface)
    {
        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
            <span class="enscript-string">&quot;NetWakeInterface: returning false for &quot;</span> PUB_S, i-&gt;ifinfo.ifname);
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }

    <span class="enscript-comment">// If the interface supports TCPKeepalive, it is capable of waking up for a magic packet
</span>    <span class="enscript-comment">// This check is needed since the SIOCGIFWAKEFLAGS ioctl returns wrong values for WOMP capability
</span>    <span class="enscript-comment">// when the power source is not AC Power.
</span>    <span class="enscript-keyword">if</span> (InterfaceSupportsKeepAlive(&amp;i-&gt;ifinfo))
    {
        LogSPS(<span class="enscript-string">&quot;NetWakeInterface: %s supports TCP Keepalive returning true&quot;</span>, i-&gt;ifinfo.ifname);
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-type">int</span> s = socket(AF_INET, SOCK_DGRAM, 0);
    <span class="enscript-keyword">if</span> (s &lt; 0) { LogMsg(<span class="enscript-string">&quot;NetWakeInterface socket failed %s error %d errno %d (%s)&quot;</span>, i-&gt;ifinfo.ifname, s, errno, strerror(errno)); <span class="enscript-keyword">return</span>(mDNSfalse); }

    <span class="enscript-type">struct</span> ifreq ifr;
    strlcpy(ifr.ifr_name, i-&gt;ifinfo.ifname, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name));
    <span class="enscript-keyword">if</span> (ioctl(s, SIOCGIFWAKEFLAGS, &amp;ifr) &lt; 0)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> ioctl_errno = errno;
        <span class="enscript-comment">// For some strange reason, in /usr/include/sys/errno.h, EOPNOTSUPP is defined to be
</span>        <span class="enscript-comment">// 102 when compiling kernel code, and 45 when compiling user-level code. Since this
</span>        <span class="enscript-comment">// error code is being returned from the kernel, we need to use the kernel version.
</span>        #define KERNEL_EOPNOTSUPP 102
        <span class="enscript-keyword">if</span> (ioctl_errno != KERNEL_EOPNOTSUPP) <span class="enscript-comment">// &quot;Operation not supported on socket&quot;, the expected result on Leopard and earlier
</span>            LogMsg(<span class="enscript-string">&quot;NetWakeInterface SIOCGIFWAKEFLAGS %s errno %d (%s)&quot;</span>, i-&gt;ifinfo.ifname, ioctl_errno, strerror(ioctl_errno));
        <span class="enscript-comment">// If on Leopard or earlier, we get EOPNOTSUPP, so in that case
</span>        <span class="enscript-comment">// we enable WOL if this interface is not AirPort and &quot;Wake for Network access&quot; is turned on.
</span>        ifr.ifr_wake_flags = (ioctl_errno == KERNEL_EOPNOTSUPP &amp;&amp; !(i)-&gt;BSSID.l[0] &amp;&amp; i-&gt;m-&gt;SystemWakeOnLANEnabled) ? IF_WAKE_ON_MAGIC_PACKET : 0;
    }

    close(s);

    <span class="enscript-comment">// ifr.ifr_wake_flags = IF_WAKE_ON_MAGIC_PACKET;    // For testing with MacBook Air, using a USB dongle that doesn't actually support Wake-On-LAN
</span>
    LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;NetWakeInterface: &quot;</span> PUB_S <span class="enscript-string">&quot; &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot; &quot;</span> PUB_S <span class="enscript-string">&quot; WOMP&quot;</span>,
        i-&gt;ifinfo.ifname, &amp;i-&gt;ifinfo.ip, (ifr.ifr_wake_flags &amp; IF_WAKE_ON_MAGIC_PACKET) ? <span class="enscript-string">&quot;supports&quot;</span> : <span class="enscript-string">&quot;no&quot;</span>);

    <span class="enscript-keyword">return</span>((ifr.ifr_wake_flags &amp; IF_WAKE_ON_MAGIC_PACKET) != 0);
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">TARGET_OS_WATCH</span>
}

mDNSlocal u_int64_t <span class="enscript-function-name">getExtendedFlags</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifa_name)
{
    <span class="enscript-type">int</span> sockFD;
    <span class="enscript-type">struct</span> ifreq ifr;

    sockFD = socket(AF_INET, SOCK_DGRAM, 0);
    <span class="enscript-keyword">if</span> (sockFD &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;getExtendedFlags: socket() call failed, errno = %d (%s)&quot;</span>, errno, strerror(errno));
        <span class="enscript-keyword">return</span> 0;
    }

    ifr.ifr_addr.sa_family = AF_INET;
    strlcpy(ifr.ifr_name, ifa_name, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name));

    <span class="enscript-keyword">if</span> (ioctl(sockFD, SIOCGIFEFLAGS, (caddr_t)&amp;ifr) == -1)
    {
        LogMsg(<span class="enscript-string">&quot;getExtendedFlags: SIOCGIFEFLAGS failed for %s, errno = %d (%s)&quot;</span>, ifa_name, errno, strerror(errno));
        ifr.ifr_eflags = 0;
    }

    close(sockFD);
    <span class="enscript-keyword">return</span> ifr.ifr_eflags;
}

mDNSlocal mDNSBool <span class="enscript-function-name">isExcludedInterface</span>(<span class="enscript-type">int</span> sockFD, <span class="enscript-type">char</span> * ifa_name)
{
    <span class="enscript-type">struct</span> ifreq ifr;

    <span class="enscript-comment">// llw0 interface is excluded from Bonjour discover.
</span>    <span class="enscript-comment">// There currently is no interface attributed based way to identify this interface
</span>    <span class="enscript-comment">// until rdar://problem/47933782 is addressed.
</span>    <span class="enscript-keyword">if</span> (strncmp(ifa_name, <span class="enscript-string">&quot;llw&quot;</span>, 3) == 0)
    {
        LogMsg(<span class="enscript-string">&quot;isExcludedInterface: excluding %s&quot;</span>, ifa_name);
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-comment">// Coprocessor interfaces are also excluded.
</span>    <span class="enscript-keyword">if</span> (sockFD &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;isExcludedInterface: invalid socket FD passed: %d&quot;</span>, sockFD);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    memset(&amp;ifr, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ifreq));
    strlcpy(ifr.ifr_name, ifa_name, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name));

    <span class="enscript-keyword">if</span> (ioctl(sockFD, SIOCGIFFUNCTIONALTYPE, (caddr_t)&amp;ifr) == -1)
    {
        LogMsg(<span class="enscript-string">&quot;isExcludedInterface: SIOCGIFFUNCTIONALTYPE failed, errno = %d (%s)&quot;</span>, errno, strerror(errno));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (ifr.ifr_functional_type == IFRTYPE_FUNCTIONAL_INTCOPROC)
    {
        LogMsg(<span class="enscript-string">&quot;isExcludedInterface: excluding coprocessor interface %s&quot;</span>, ifa_name);
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mDNSfalse;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

<span class="enscript-comment">// Function pointers for the routines we use in the MobileWiFi framework.
</span><span class="enscript-type">static</span> <span class="enscript-function-name">WiFiManagerClientRef</span> (*WiFiManagerClientCreate_p)(CFAllocatorRef allocator, WiFiClientType type) = mDNSNULL;
<span class="enscript-type">static</span> <span class="enscript-function-name">CFArrayRef</span> (*WiFiManagerClientCopyDevices_p)(WiFiManagerClientRef manager) = mDNSNULL;
<span class="enscript-type">static</span> <span class="enscript-function-name">WiFiNetworkRef</span> (*WiFiDeviceClientCopyCurrentNetwork_p)(WiFiDeviceClientRef device) = mDNSNULL;
<span class="enscript-type">static</span> <span class="enscript-function-name">bool</span> (*WiFiNetworkIsCarPlay_p)(WiFiNetworkRef network) = mDNSNULL;

mDNSlocal mDNSBool <span class="enscript-function-name">MobileWiFiLibLoad</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">static</span> mDNSBool isInitialized = mDNSfalse;
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> *MobileWiFiLib_p = mDNSNULL;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> path[] = <span class="enscript-string">&quot;/System/Library/PrivateFrameworks/MobileWiFi.framework/MobileWiFi&quot;</span>;

    <span class="enscript-keyword">if</span> (!isInitialized)
    {
        <span class="enscript-keyword">if</span> (!MobileWiFiLib_p)
        {
            MobileWiFiLib_p = dlopen(path, RTLD_LAZY | RTLD_LOCAL);
            <span class="enscript-keyword">if</span> (!MobileWiFiLib_p)
            {
                LogInfo(<span class="enscript-string">&quot;MobileWiFiLibLoad: dlopen() failed.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }

        <span class="enscript-keyword">if</span> (!WiFiManagerClientCreate_p)
        {
            WiFiManagerClientCreate_p = dlsym(MobileWiFiLib_p, <span class="enscript-string">&quot;WiFiManagerClientCreate&quot;</span>);
            <span class="enscript-keyword">if</span> (!WiFiManagerClientCreate_p)
            {
                LogInfo(<span class="enscript-string">&quot;MobileWiFiLibLoad: load of WiFiManagerClientCreate symbol failed.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }

        <span class="enscript-keyword">if</span> (!WiFiManagerClientCopyDevices_p)
        {
            WiFiManagerClientCopyDevices_p = dlsym(MobileWiFiLib_p, <span class="enscript-string">&quot;WiFiManagerClientCopyDevices&quot;</span>);
            <span class="enscript-keyword">if</span> (!WiFiManagerClientCopyDevices_p)
            {
                LogInfo(<span class="enscript-string">&quot;MobileWiFiLibLoad: load of WiFiManagerClientCopyDevices symbol failed.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }

        <span class="enscript-keyword">if</span> (!WiFiDeviceClientCopyCurrentNetwork_p)
        {
            WiFiDeviceClientCopyCurrentNetwork_p = dlsym(MobileWiFiLib_p, <span class="enscript-string">&quot;WiFiDeviceClientCopyCurrentNetwork&quot;</span>);
            <span class="enscript-keyword">if</span> (!WiFiDeviceClientCopyCurrentNetwork_p)
            {
                LogInfo(<span class="enscript-string">&quot;MobileWiFiLibLoad: load of WiFiDeviceClientCopyCurrentNetwork symbol failed.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }

        <span class="enscript-keyword">if</span> (!WiFiNetworkIsCarPlay_p)
        {
            WiFiNetworkIsCarPlay_p = dlsym(MobileWiFiLib_p, <span class="enscript-string">&quot;WiFiNetworkIsCarPlay&quot;</span>);
            <span class="enscript-keyword">if</span> (!WiFiNetworkIsCarPlay_p)
            {
                LogInfo(<span class="enscript-string">&quot;MobileWiFiLibLoad: load of WiFiNetworkIsCarPlay symbol failed.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }

        isInitialized = mDNStrue;
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span> isInitialized;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CARPLAY_DEBUG</span> 0

<span class="enscript-comment">// Return true if the interface is associate to a CarPlay hosted SSID.
</span><span class="enscript-comment">// If we have associated with a CarPlay hosted SSID, then use the same 
</span><span class="enscript-comment">// optimizations that are used when an interface has the IFEF_DIRECTLINK flag set.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">IsCarPlaySSID</span>(<span class="enscript-type">char</span> *ifa_name)
{
    <span class="enscript-type">static</span> WiFiManagerClientRef manager = NULL;
    CFArrayRef              devices;
    WiFiDeviceClientRef     device;
    WiFiNetworkRef          network;
    mDNSBool                rvalue = mDNSfalse;

    <span class="enscript-keyword">if</span> (!MobileWiFiLibLoad())
    {
        LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: MobileWiFiLibLoad() failed!&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// Cache the WiFiManagerClientRef.
</span>    <span class="enscript-keyword">if</span> (manager == NULL)
        manager = WiFiManagerClientCreate_p(NULL, kWiFiClientTypeNormal);

    <span class="enscript-keyword">if</span> (manager == NULL)
    {
        LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: WiFiManagerClientCreate() failed!&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    devices = WiFiManagerClientCopyDevices_p(manager);

    <span class="enscript-comment">// If the first call fails, update the cached WiFiManagerClientRef pointer and try again.
</span>    <span class="enscript-keyword">if</span> (devices == NULL)
    {
        LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: First call to WiFiManagerClientCopyDevices() returned NULL for %s&quot;</span>, ifa_name);

        <span class="enscript-comment">// Release the previously cached WiFiManagerClientRef which is apparently now stale.
</span>        CFRelease(manager);
        manager = WiFiManagerClientCreate_p(NULL, kWiFiClientTypeNormal);
        <span class="enscript-keyword">if</span> (manager == NULL)
        {
            LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: WiFiManagerClientCreate() failed!&quot;</span>);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        devices = WiFiManagerClientCopyDevices_p(manager);
        <span class="enscript-keyword">if</span> (devices == NULL)
        {
            LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: Second call to WiFiManagerClientCopyDevices() returned NULL for %s&quot;</span>, ifa_name);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
    }

    device = (WiFiDeviceClientRef)CFArrayGetValueAtIndex(devices, 0);
    network = WiFiDeviceClientCopyCurrentNetwork_p(device);
    <span class="enscript-keyword">if</span> (network != NULL)
    {
        <span class="enscript-keyword">if</span> (WiFiNetworkIsCarPlay_p(network))
        {
            LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: %s is CarPlay hosted&quot;</span>, ifa_name);
            rvalue = mDNStrue;
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CARPLAY_DEBUG</span>
        <span class="enscript-keyword">else</span>
            LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: %s is NOT CarPlay hosted&quot;</span>, ifa_name);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CARPLAY_DEBUG</span>

        CFRelease(network);
    }
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;IsCarPlaySSID: WiFiDeviceClientCopyCurrentNetwork() returned NULL for %s&quot;</span>, ifa_name);

    CFRelease(devices);

    <span class="enscript-keyword">return</span> rvalue;
}

#<span class="enscript-reference">else</span>   // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

mDNSlocal mDNSBool <span class="enscript-function-name">IsCarPlaySSID</span>(<span class="enscript-type">char</span> *ifa_name)
{
    (<span class="enscript-type">void</span>)ifa_name;  <span class="enscript-comment">// unused
</span>
    <span class="enscript-comment">// OSX WifiManager currently does not implement WiFiNetworkIsCarPlay()
</span>    <span class="enscript-keyword">return</span> mDNSfalse;;
}

#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

<span class="enscript-comment">// Returns pointer to newly created NetworkInterfaceInfoOSX object, or
</span><span class="enscript-comment">// pointer to already-existing NetworkInterfaceInfoOSX object found in list, or
</span><span class="enscript-comment">// may return NULL if out of memory (unlikely) or parameters are invalid for some reason
</span><span class="enscript-comment">// (e.g. sa_family not AF_INET or AF_INET6)
</span>
mDNSlocal NetworkInterfaceInfoOSX *<span class="enscript-function-name">AddInterfaceToList</span>(<span class="enscript-type">struct</span> ifaddrs *ifa, mDNSs32 utc)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSu32 scope_id  = if_nametoindex(ifa-&gt;ifa_name);
    mDNSEthAddr bssid = GetBSSID(ifa-&gt;ifa_name);
    u_int64_t   eflags = getExtendedFlags(ifa-&gt;ifa_name);

    mDNSAddr ip, mask;
    <span class="enscript-keyword">if</span> (SetupAddr(&amp;ip,   ifa-&gt;ifa_addr   ) != mStatus_NoError) <span class="enscript-keyword">return</span>(NULL);
    <span class="enscript-keyword">if</span> (SetupAddr(&amp;mask, ifa-&gt;ifa_netmask) != mStatus_NoError) <span class="enscript-keyword">return</span>(NULL);

    NetworkInterfaceInfoOSX **p;
    <span class="enscript-keyword">for</span> (p = &amp;m-&gt;p-&gt;InterfaceList; *p; p = &amp;(*p)-&gt;next)
        <span class="enscript-keyword">if</span> (scope_id == (*p)-&gt;scope_id &amp;&amp;
            mDNSSameAddress(&amp;ip, &amp;(*p)-&gt;ifinfo.ip) &amp;&amp;
            mDNSSameEthAddress(&amp;bssid, &amp;(*p)-&gt;BSSID))
        {
            debugf(<span class="enscript-string">&quot;AddInterfaceToList: Found existing interface %lu %.6a with address %#a at %p, ifname before %s, after %s&quot;</span>, scope_id, &amp;bssid, &amp;ip, *p, (*p)-&gt;ifinfo.ifname, ifa-&gt;ifa_name);
            <span class="enscript-comment">// The name should be updated to the new name so that we don't report a wrong name in our SIGINFO output.
</span>            <span class="enscript-comment">// When interfaces are created with same MAC address, kernel resurrects the old interface.
</span>            <span class="enscript-comment">// Even though the interface index is the same (which should be sufficient), when we receive a UDP packet
</span>            <span class="enscript-comment">// we get the corresponding name for the interface index on which the packet was received and check against
</span>            <span class="enscript-comment">// the InterfaceList for a matching name. So, keep the name in sync
</span>            strlcpy((*p)-&gt;ifinfo.ifname, ifa-&gt;ifa_name, <span class="enscript-keyword">sizeof</span>((*p)-&gt;ifinfo.ifname));

            <span class="enscript-comment">// Determine if multicast state has changed.
</span>            <span class="enscript-type">const</span> mDNSBool txrx = MulticastInterface(*p);
            <span class="enscript-keyword">if</span> ((*p)-&gt;ifinfo.McastTxRx != txrx)
            {
                (*p)-&gt;ifinfo.McastTxRx = txrx;
                (*p)-&gt;Exists = MulticastStateChanged; <span class="enscript-comment">// State change; need to deregister and reregister this interface
</span>            }
            <span class="enscript-keyword">else</span>
                 (*p)-&gt;Exists = mDNStrue;

            <span class="enscript-comment">// If interface was not in getifaddrs list last time we looked, but it is now, update 'AppearanceTime' for this record
</span>            <span class="enscript-keyword">if</span> ((*p)-&gt;LastSeen != utc) (*p)-&gt;AppearanceTime = utc;

            <span class="enscript-comment">// If Wake-on-LAN capability of this interface has changed (e.g. because power cable on laptop has been disconnected)
</span>            <span class="enscript-comment">// we may need to start or stop or sleep proxy browse operation
</span>            <span class="enscript-type">const</span> mDNSBool NetWake = NetWakeInterface(*p);
            <span class="enscript-keyword">if</span> ((*p)-&gt;ifinfo.NetWake != NetWake)
            {
                (*p)-&gt;ifinfo.NetWake = NetWake;
                <span class="enscript-comment">// If this interface is already registered with mDNSCore, then we need to start or stop its NetWake browse on-the-fly.
</span>                <span class="enscript-comment">// If this interface is not already registered (i.e. it's a dormant interface we had in our list
</span>                <span class="enscript-comment">// from when we previously saw it) then we mustn't do that, because mDNSCore doesn't know about it yet.
</span>                <span class="enscript-comment">// In this case, the mDNS_RegisterInterface() call will take care of starting the NetWake browse if necessary.
</span>                <span class="enscript-keyword">if</span> ((*p)-&gt;Registered)
                {
                    mDNS_Lock(m);
                    <span class="enscript-keyword">if</span> (NetWake) mDNS_ActivateNetWake_internal  (m, &amp;(*p)-&gt;ifinfo);
                    <span class="enscript-keyword">else</span>         mDNS_DeactivateNetWake_internal(m, &amp;(*p)-&gt;ifinfo);
                    mDNS_Unlock(m);
                }
            }
            <span class="enscript-comment">// Reset the flag if it has changed this time.
</span>            (*p)-&gt;ifinfo.IgnoreIPv4LL = ((eflags &amp; IFEF_ARPLL) != 0) ? mDNSfalse : mDNStrue;

            <span class="enscript-keyword">return</span>(*p);
        }

    NetworkInterfaceInfoOSX *i = (NetworkInterfaceInfoOSX *) callocL(<span class="enscript-string">&quot;NetworkInterfaceInfoOSX&quot;</span>, <span class="enscript-keyword">sizeof</span>(*i));
    debugf(<span class="enscript-string">&quot;AddInterfaceToList: Making   new   interface %lu %.6a with address %#a at %p&quot;</span>, scope_id, &amp;bssid, &amp;ip, i);
    <span class="enscript-keyword">if</span> (!i) <span class="enscript-keyword">return</span>(mDNSNULL);
    i-&gt;ifinfo.InterfaceID = (mDNSInterfaceID)(uintptr_t)scope_id;
    i-&gt;ifinfo.ip          = ip;
    i-&gt;ifinfo.mask        = mask;
    strlcpy(i-&gt;ifinfo.ifname, ifa-&gt;ifa_name, <span class="enscript-keyword">sizeof</span>(i-&gt;ifinfo.ifname));
    i-&gt;ifinfo.ifname[<span class="enscript-keyword">sizeof</span>(i-&gt;ifinfo.ifname)-1] = 0;
    <span class="enscript-comment">// We can be configured to disable multicast advertisement, but we want to to support
</span>    <span class="enscript-comment">// local-only services, which need a loopback address record.
</span>    i-&gt;ifinfo.Advertise   = m-&gt;DivertMulticastAdvertisements ? ((ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) ? mDNStrue : mDNSfalse) : m-&gt;AdvertiseLocalAddresses;
    i-&gt;ifinfo.Loopback    = ((ifa-&gt;ifa_flags &amp; IFF_LOOPBACK) != 0) ? mDNStrue : mDNSfalse;
    i-&gt;ifinfo.IgnoreIPv4LL = ((eflags &amp; IFEF_ARPLL) != 0) ? mDNSfalse : mDNStrue;

    <span class="enscript-comment">// Setting DirectLink indicates we can do the optimization of skipping the probe phase 
</span>    <span class="enscript-comment">// for the interface address records since they should be unique.
</span>    <span class="enscript-comment">// Unfortunately, the legacy p2p* interfaces do not set the IFEF_LOCALNET_PRIVATE 
</span>    <span class="enscript-comment">// or IFEF_DIRECTLINK flags, so we have to match against the name.
</span>    <span class="enscript-keyword">if</span> ((eflags &amp; (IFEF_DIRECTLINK | IFEF_AWDL)) || (strncmp(i-&gt;ifinfo.ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0))
        i-&gt;ifinfo.DirectLink  = mDNStrue;
    <span class="enscript-keyword">else</span>
        i-&gt;ifinfo.DirectLink  = IsCarPlaySSID(ifa-&gt;ifa_name);

    <span class="enscript-keyword">if</span> (i-&gt;ifinfo.DirectLink)
        LogInfo(<span class="enscript-string">&quot;AddInterfaceToList: DirectLink set for %s&quot;</span>, ifa-&gt;ifa_name);

    i-&gt;next            = mDNSNULL;
    i-&gt;m               = m;
    i-&gt;Exists          = mDNStrue;
    i-&gt;Flashing        = mDNSfalse;
    i-&gt;Occulting       = mDNSfalse;

    i-&gt;D2DInterface    = ((eflags &amp; IFEF_LOCALNET_PRIVATE) || (strncmp(i-&gt;ifinfo.ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0)) ? mDNStrue: mDNSfalse;
    <span class="enscript-keyword">if</span> (i-&gt;D2DInterface)
        LogInfo(<span class="enscript-string">&quot;AddInterfaceToList: D2DInterface set for %s&quot;</span>, ifa-&gt;ifa_name);
    i-&gt;isAWDL          = (eflags &amp; IFEF_AWDL)      ? mDNStrue: mDNSfalse;

    <span class="enscript-keyword">if</span> (eflags &amp; IFEF_AWDL)
    {
        <span class="enscript-comment">// Set SupportsUnicastMDNSResponse false for the AWDL interface since unicast reserves
</span>        <span class="enscript-comment">// limited AWDL resources so we don't set the kDNSQClass_UnicastResponse bit in
</span>        <span class="enscript-comment">// Bonjour requests over the AWDL interface.
</span>        i-&gt;ifinfo.SupportsUnicastMDNSResponse = mDNSfalse;
        AWDLInterfaceID = i-&gt;ifinfo.InterfaceID;
        LogInfo(<span class="enscript-string">&quot;AddInterfaceToList: AWDLInterfaceID = %d&quot;</span>, (<span class="enscript-type">int</span>) AWDLInterfaceID);
    }
    <span class="enscript-keyword">else</span>
    {
        i-&gt;ifinfo.SupportsUnicastMDNSResponse = mDNStrue;
    }
    i-&gt;AppearanceTime  = utc;       <span class="enscript-comment">// Brand new interface; AppearanceTime is now
</span>    i-&gt;LastSeen        = utc;
    i-&gt;ifa_flags       = ifa-&gt;ifa_flags;
    i-&gt;scope_id        = scope_id;
    i-&gt;BSSID           = bssid;
    i-&gt;sa_family       = ifa-&gt;ifa_addr-&gt;sa_family;
    i-&gt;BPF_fd          = -1;
    i-&gt;BPF_mcfd        = -1;
    i-&gt;BPF_len         = 0;
    i-&gt;Registered      = mDNSNULL;

    <span class="enscript-comment">// MulticastInterface() depends on the &quot;m&quot; and &quot;ifa_flags&quot; values being initialized above.
</span>    i-&gt;ifinfo.McastTxRx   = MulticastInterface(i);
    <span class="enscript-comment">// Do this AFTER i-&gt;BSSID has been set up
</span>    i-&gt;ifinfo.NetWake  = (eflags &amp; IFEF_EXPENSIVE)? mDNSfalse :  NetWakeInterface(i);
    GetMAC(&amp;i-&gt;ifinfo.MAC, scope_id);
    <span class="enscript-keyword">if</span> (i-&gt;ifinfo.NetWake &amp;&amp; !i-&gt;ifinfo.MAC.l[0])
        LogMsg(<span class="enscript-string">&quot;AddInterfaceToList: Bad MAC address %.6a for %d %s %#a&quot;</span>, &amp;i-&gt;ifinfo.MAC, scope_id, i-&gt;ifinfo.ifname, &amp;ip);

    *p = i;
    <span class="enscript-keyword">return</span>(i);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Power</span> <span class="enscript-variable-name">State</span> &amp; <span class="enscript-variable-name">Configuration</span> <span class="enscript-variable-name">Change</span> <span class="enscript-variable-name">Management</span>
#<span class="enscript-reference">endif</span>

mDNSlocal mStatus <span class="enscript-function-name">ReorderInterfaceList</span>()
{
    <span class="enscript-comment">// Disable Reorder lists till &lt;rdar://problem/30071012&gt; is fixed to prevent spurious name conflicts
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PR_30071012_FIXED</span>
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    nwi_state_t state = nwi_state_copy();

    <span class="enscript-keyword">if</span> (state == mDNSNULL)
    {
        LogMsg(<span class="enscript-string">&quot;NWI State is NULL!&quot;</span>);
        <span class="enscript-keyword">return</span> (mStatus_Invalid);
    }

    <span class="enscript-comment">// Get the count of interfaces
</span>    mDNSu32 count =  nwi_state_get_interface_names(state, mDNSNULL, 0);
    <span class="enscript-keyword">if</span> (count == 0)
    {
        LogMsg(<span class="enscript-string">&quot;Unable to get the ordered list of interface names&quot;</span>);
        nwi_state_release(state);
        <span class="enscript-keyword">return</span> (mStatus_Invalid);
    }

    <span class="enscript-comment">// Get the ordered interface list
</span>    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *names[count];
    count = nwi_state_get_interface_names(state, names, count);

    NetworkInterfaceInfo *newList = mDNSNULL;
    <span class="enscript-keyword">for</span> (i = count-1; i &gt;= 0; i--)
    {   <span class="enscript-comment">// Build a new ordered interface list
</span>        NetworkInterfaceInfo **ptr = &amp;m-&gt;HostInterfaces;
        <span class="enscript-keyword">while</span> (*ptr != mDNSNULL )
        {
            <span class="enscript-keyword">if</span> (strcmp((*ptr)-&gt;ifname, names[i]) == 0)
            {
                NetworkInterfaceInfo *node = *ptr;
                *ptr = (*ptr)-&gt;next;
                node-&gt;next = newList;
                newList = node;
            }
            <span class="enscript-keyword">else</span>
                ptr = &amp;((*ptr)-&gt;next);
        }
    }

    <span class="enscript-comment">// Get to the end of the list
</span>    NetworkInterfaceInfo *newListEnd = newList;
    <span class="enscript-keyword">while</span> (newListEnd != mDNSNULL &amp;&amp; newListEnd-&gt;next != mDNSNULL)
        newListEnd = newListEnd-&gt;next;

    <span class="enscript-comment">// Add any remaing interfaces to the end of the sorted list
</span>    <span class="enscript-keyword">if</span> (newListEnd != mDNSNULL)
        newListEnd-&gt;next  = m-&gt;HostInterfaces;

    <span class="enscript-comment">// If we have a valid new list, point to that now
</span>    <span class="enscript-keyword">if</span> (newList != mDNSNULL)
        m-&gt;HostInterfaces = newList;

    nwi_state_release(state);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">PR_30071012_FIXED</span>
    <span class="enscript-keyword">return</span> (mStatus_NoError);
}

mDNSlocal mStatus <span class="enscript-function-name">UpdateInterfaceList</span>(mDNSs32 utc)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-type">struct</span> ifaddrs *ifa = myGetIfAddrs(0);
    <span class="enscript-type">char</span> defaultname[64];
    <span class="enscript-type">int</span> InfoSocket = socket(AF_INET6, SOCK_DGRAM, 0);
    <span class="enscript-keyword">if</span> (InfoSocket &lt; 3 &amp;&amp; errno != EAFNOSUPPORT) 
        LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: InfoSocket error %d errno %d (%s)&quot;</span>, InfoSocket, errno, strerror(errno));

    <span class="enscript-keyword">if</span> (m-&gt;SleepState == SleepState_Sleeping) ifa = NULL;

    <span class="enscript-keyword">while</span> (ifa)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LIST_ALL_INTERFACES</span>
        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr)
        {
            <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_APPLETALK)
                LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d is AF_APPLETALK&quot;</span>,
                       ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags, ifa-&gt;ifa_addr-&gt;sa_family);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_LINK)
                LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d is AF_LINK&quot;</span>,
                       ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags, ifa-&gt;ifa_addr-&gt;sa_family);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6)
                LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d not AF_INET (2) or AF_INET6 (30)&quot;</span>,
                       ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags, ifa-&gt;ifa_addr-&gt;sa_family);
        }
        <span class="enscript-keyword">else</span>
            LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X ifa_addr is NOT set&quot;</span>,
                   ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags);
        
        <span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_flags &amp; IFF_UP))
            LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d Interface not IFF_UP&quot;</span>,
                   ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags,
                   ifa-&gt;ifa_addr ? ifa-&gt;ifa_addr-&gt;sa_family : 0);
        <span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_flags &amp; IFF_MULTICAST))
            LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d Interface not IFF_MULTICAST&quot;</span>,
                   ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags,
                   ifa-&gt;ifa_addr ? ifa-&gt;ifa_addr-&gt;sa_family : 0);
        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_POINTOPOINT)
            LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d Interface IFF_POINTOPOINT&quot;</span>,
                   ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags,
                   ifa-&gt;ifa_addr ? ifa-&gt;ifa_addr-&gt;sa_family : 0);
        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_LOOPBACK)
            LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: %5s(%d) Flags %04X Family %2d Interface IFF_LOOPBACK&quot;</span>,
                   ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags,
                   ifa-&gt;ifa_addr ? ifa-&gt;ifa_addr-&gt;sa_family : 0);
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_LINK)
        {
            <span class="enscript-type">struct</span> sockaddr_dl *sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)ifa-&gt;ifa_addr;
            <span class="enscript-keyword">if</span> (sdl-&gt;sdl_type == IFT_ETHER &amp;&amp; sdl-&gt;sdl_alen == <span class="enscript-keyword">sizeof</span>(m-&gt;PrimaryMAC) &amp;&amp; mDNSSameEthAddress(&amp;m-&gt;PrimaryMAC, &amp;zeroEthAddr))
                mDNSPlatformMemCopy(m-&gt;PrimaryMAC.b, sdl-&gt;sdl_data + sdl-&gt;sdl_nlen, 6);
        }

        <span class="enscript-keyword">if</span> (ifa-&gt;ifa_flags &amp; IFF_UP &amp;&amp; ifa-&gt;ifa_addr &amp;&amp; !isExcludedInterface(InfoSocket, ifa-&gt;ifa_name))
            <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET || ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6)
            {
                <span class="enscript-keyword">if</span> (!ifa-&gt;ifa_netmask)
                {
                    mDNSAddr ip;
                    SetupAddr(&amp;ip, ifa-&gt;ifa_addr);
                    LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: ifa_netmask is NULL for %5s(%d) Flags %04X Family %2d %#a&quot;</span>,
                           ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags, ifa-&gt;ifa_addr-&gt;sa_family, &amp;ip);
                }
                <span class="enscript-comment">// Apparently it's normal for the sa_family of an ifa_netmask to sometimes be zero, so we don't complain about that
</span>                <span class="enscript-comment">// &lt;rdar://problem/5492035&gt; getifaddrs is returning invalid netmask family for fw0 and vmnet
</span>                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_netmask-&gt;sa_family != ifa-&gt;ifa_addr-&gt;sa_family &amp;&amp; ifa-&gt;ifa_netmask-&gt;sa_family != 0)
                {
                    mDNSAddr ip;
                    SetupAddr(&amp;ip, ifa-&gt;ifa_addr);
                    LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: ifa_netmask for %5s(%d) Flags %04X Family %2d %#a has different family: %d&quot;</span>,
                           ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name), ifa-&gt;ifa_flags, ifa-&gt;ifa_addr-&gt;sa_family, &amp;ip, ifa-&gt;ifa_netmask-&gt;sa_family);
                }
                <span class="enscript-comment">// Currently we use a few internal ones like mDNSInterfaceID_LocalOnly etc. that are negative values (0, -1, -2).
</span>                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)if_nametoindex(ifa-&gt;ifa_name) &lt;= 0)
                {
                    LogMsg(<span class="enscript-string">&quot;UpdateInterfaceList: if_nametoindex returned zero/negative value for %5s(%d)&quot;</span>, ifa-&gt;ifa_name, if_nametoindex(ifa-&gt;ifa_name));
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Make sure ifa_netmask-&gt;sa_family is set correctly
</span>                    <span class="enscript-comment">// &lt;rdar://problem/5492035&gt; getifaddrs is returning invalid netmask family for fw0 and vmnet
</span>                    ifa-&gt;ifa_netmask-&gt;sa_family = ifa-&gt;ifa_addr-&gt;sa_family;
                    <span class="enscript-type">int</span> ifru_flags6 = 0;

                    <span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)ifa-&gt;ifa_addr;
                    <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6 &amp;&amp; InfoSocket &gt;= 0)
                    {
                        <span class="enscript-type">struct</span> in6_ifreq ifr6;
                        mDNSPlatformMemZero((<span class="enscript-type">char</span> *)&amp;ifr6, <span class="enscript-keyword">sizeof</span>(ifr6));
                        strlcpy(ifr6.ifr_name, ifa-&gt;ifa_name, <span class="enscript-keyword">sizeof</span>(ifr6.ifr_name));
                        ifr6.ifr_addr = *sin6;
                        <span class="enscript-keyword">if</span> (ioctl(InfoSocket, SIOCGIFAFLAG_IN6, &amp;ifr6) != -1)
                            ifru_flags6 = ifr6.ifr_ifru.ifru_flags6;
                        verbosedebugf(<span class="enscript-string">&quot;%s %.16a %04X %04X&quot;</span>, ifa-&gt;ifa_name, &amp;sin6-&gt;sin6_addr, ifa-&gt;ifa_flags, ifru_flags6);
                    }

                    <span class="enscript-keyword">if</span> (!(ifru_flags6 &amp; (IN6_IFF_TENTATIVE | IN6_IFF_DETACHED | IN6_IFF_DEPRECATED | IN6_IFF_TEMPORARY)))
                    {
                        AddInterfaceToList(ifa, utc);
                    }
                }
            }
        ifa = ifa-&gt;ifa_next;
    }

    <span class="enscript-keyword">if</span> (InfoSocket &gt;= 0) 
        close(InfoSocket);

    mDNS_snprintf(defaultname, <span class="enscript-keyword">sizeof</span>(defaultname), <span class="enscript-string">&quot;%.*s-%02X%02X%02X%02X%02X%02X&quot;</span>, HINFO_HWstring_prefixlen, HINFO_HWstring,
                  m-&gt;PrimaryMAC.b[0], m-&gt;PrimaryMAC.b[1], m-&gt;PrimaryMAC.b[2], m-&gt;PrimaryMAC.b[3], m-&gt;PrimaryMAC.b[4], m-&gt;PrimaryMAC.b[5]);

    <span class="enscript-comment">// Set up the nice label
</span>    domainlabel nicelabel;
    nicelabel.c[0] = 0;
    GetUserSpecifiedFriendlyComputerName(&amp;nicelabel);
    <span class="enscript-keyword">if</span> (nicelabel.c[0] == 0)
    {
        debugf(<span class="enscript-string">&quot;Couldnt read user-specified Computer Name; using default %s instead&quot;</span>, defaultname);
        MakeDomainLabelFromLiteralString(&amp;nicelabel, defaultname);
    }

    <span class="enscript-comment">// Set up the RFC 1034-compliant label
</span>    domainlabel hostlabel;
    hostlabel.c[0] = 0;
    GetUserSpecifiedLocalHostName(&amp;hostlabel);
    <span class="enscript-keyword">if</span> (hostlabel.c[0] == 0)
    {
        debugf(<span class="enscript-string">&quot;Couldnt read user-specified Local Hostname; using default %s.local instead&quot;</span>, defaultname);
        MakeDomainLabelFromLiteralString(&amp;hostlabel, defaultname);
    }

    <span class="enscript-comment">// We use a case-sensitive comparison here because even though changing the capitalization
</span>    <span class="enscript-comment">// of the name alone is not significant to DNS, it's still a change from the user's point of view
</span>    <span class="enscript-keyword">if</span> (SameDomainLabelCS(m-&gt;p-&gt;usernicelabel.c, nicelabel.c))
        debugf(<span class="enscript-string">&quot;Usernicelabel (%#s) unchanged since last time; not changing m-&gt;nicelabel (%#s)&quot;</span>, m-&gt;p-&gt;usernicelabel.c, m-&gt;nicelabel.c);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (m-&gt;p-&gt;usernicelabel.c[0])   <span class="enscript-comment">// Don't show message first time through, when we first read name from prefs on boot
</span>            LogMsg(<span class="enscript-string">&quot;User updated Computer Name from %#s to %#s&quot;</span>, m-&gt;p-&gt;usernicelabel.c, nicelabel.c);
        m-&gt;p-&gt;usernicelabel = m-&gt;nicelabel = nicelabel;
    }

    <span class="enscript-keyword">if</span> (SameDomainLabelCS(m-&gt;p-&gt;userhostlabel.c, hostlabel.c))
        debugf(<span class="enscript-string">&quot;Userhostlabel (%#s) unchanged since last time; not changing m-&gt;hostlabel (%#s)&quot;</span>, m-&gt;p-&gt;userhostlabel.c, m-&gt;hostlabel.c);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (m-&gt;p-&gt;userhostlabel.c[0])   <span class="enscript-comment">// Don't show message first time through, when we first read name from prefs on boot
</span>            LogMsg(<span class="enscript-string">&quot;User updated Local Hostname from %#s to %#s&quot;</span>, m-&gt;p-&gt;userhostlabel.c, hostlabel.c);
        m-&gt;p-&gt;userhostlabel = m-&gt;hostlabel = hostlabel;
        mDNS_SetFQDN(m);
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// Returns number of leading one-bits in mask: 0-32 for IPv4, 0-128 for IPv6
</span><span class="enscript-comment">// Returns -1 if all the one-bits are not contiguous
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">CountMaskBits</span>(mDNSAddr *mask)
{
    <span class="enscript-type">int</span> i = 0, bits = 0;
    <span class="enscript-type">int</span> bytes = mask-&gt;type == mDNSAddrType_IPv4 ? 4 : mask-&gt;type == mDNSAddrType_IPv6 ? 16 : 0;
    <span class="enscript-keyword">while</span> (i &lt; bytes)
    {
        mDNSu8 b = mask-&gt;ip.v6.b[i++];
        <span class="enscript-keyword">while</span> (b &amp; 0x80) { bits++; b &lt;&lt;= 1; }
        <span class="enscript-keyword">if</span> (b) <span class="enscript-keyword">return</span>(-1);
    }
    <span class="enscript-keyword">while</span> (i &lt; bytes) <span class="enscript-keyword">if</span> (mask-&gt;ip.v6.b[i++]) <span class="enscript-keyword">return</span>(-1);
    <span class="enscript-keyword">return</span>(bits);
}

<span class="enscript-comment">// Returns count of non-link local V4 addresses registered (why? -- SC)
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">SetupActiveInterfaces</span>(mDNSs32 utc)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    NetworkInterfaceInfoOSX *i;
    <span class="enscript-type">int</span> count = 0;

    <span class="enscript-comment">// Recalculate SuppressProbes time based on the current set of active interfaces.
</span>    m-&gt;SuppressProbes = 0;
    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
        <span class="enscript-keyword">if</span> (i-&gt;Exists)
        {
            NetworkInterfaceInfo *<span class="enscript-type">const</span> n = &amp;i-&gt;ifinfo;
            NetworkInterfaceInfoOSX *primary = SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_UNSPEC);

            <span class="enscript-keyword">if</span> (i-&gt;Registered &amp;&amp; i-&gt;Registered != primary)  <span class="enscript-comment">// Sanity check
</span>            {
                LogMsg(<span class="enscript-string">&quot;SetupActiveInterfaces ERROR! n-&gt;Registered %p != primary %p&quot;</span>, i-&gt;Registered, primary);
                i-&gt;Registered = mDNSNULL;
            }

            <span class="enscript-keyword">if</span> (!i-&gt;Registered)
            {
                InterfaceActivationSpeed activationSpeed;

                <span class="enscript-comment">// Note: If i-&gt;Registered is set, that means we've called mDNS_RegisterInterface() for this interface,
</span>                <span class="enscript-comment">// so we need to make sure we call mDNS_DeregisterInterface() before disposing it.
</span>                <span class="enscript-comment">// If i-&gt;Registered is NOT set, then we haven't registered it and we should not try to deregister it.
</span>                i-&gt;Registered = primary;

                <span class="enscript-comment">// If i-&gt;LastSeen == utc, then this is a brand-new interface, just created, or an interface that never went away.
</span>                <span class="enscript-comment">// If i-&gt;LastSeen != utc, then this is an old interface, previously seen, that went away for (utc - i-&gt;LastSeen) seconds.
</span>                <span class="enscript-comment">// If the interface is an old one that went away and came back in less than a minute, then we're in a flapping scenario.
</span>                i-&gt;Occulting = !(i-&gt;ifa_flags &amp; IFF_LOOPBACK) &amp;&amp; (utc - i-&gt;LastSeen &gt; 0 &amp;&amp; utc - i-&gt;LastSeen &lt; 60);

                <span class="enscript-comment">// The &quot;p2p*&quot; interfaces used for legacy AirDrop reuse the scope-id, MAC address and the IP address
</span>                <span class="enscript-comment">// every time a new interface is created. We think it is a duplicate and hence consider it
</span>                <span class="enscript-comment">// as flashing and occulting, that is, flapping. If an interface is marked as flapping,
</span>                <span class="enscript-comment">// mDNS_RegisterInterface() changes the probe delay from 1/2 second to 5 seconds and
</span>                <span class="enscript-comment">// logs a warning message to system.log noting frequent interface transitions.
</span>                <span class="enscript-comment">// The same logic applies when the IFEF_DIRECTLINK flag is set on the interface.
</span>                <span class="enscript-keyword">if</span> ((strncmp(i-&gt;ifinfo.ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0) || i-&gt;ifinfo.DirectLink)
                {
                    activationSpeed = FastActivation;
                    LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %s DirectLink interface registering&quot;</span>, i-&gt;ifinfo.ifname);
                }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i-&gt;Flashing &amp;&amp; i-&gt;Occulting)
                {
                    activationSpeed = SlowActivation;
                }
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">else</span>
                {
                    activationSpeed = NormalActivation;
                }

                mDNS_RegisterInterface(m, n, activationSpeed);

                <span class="enscript-keyword">if</span> (!mDNSAddressIsLinkLocal(&amp;n-&gt;ip)) count++;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                        <span class="enscript-string">&quot;SetupActiveInterfaces: Registered &quot;</span> PUB_S <span class="enscript-string">&quot; (%u) BSSID &quot;</span> PRI_MAC_ADDR <span class="enscript-string">&quot; Struct addr %p, primary %p,&quot;</span>
                        <span class="enscript-string">&quot; &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;/%d&quot;</span> PUB_S PUB_S PUB_S,
                        i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i-&gt;BSSID, i, primary, &amp;n-&gt;ip, CountMaskBits(&amp;n-&gt;mask),
                        i-&gt;Flashing        ? <span class="enscript-string">&quot; (Flashing)&quot;</span>  : <span class="enscript-string">&quot;&quot;</span>,
                        i-&gt;Occulting       ? <span class="enscript-string">&quot; (Occulting)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                        n-&gt;InterfaceActive ? <span class="enscript-string">&quot; (Primary)&quot;</span>   : <span class="enscript-string">&quot;&quot;</span>);

                <span class="enscript-keyword">if</span> (!n-&gt;McastTxRx)
                {
                    debugf(<span class="enscript-string">&quot;SetupActiveInterfaces:   No Tx/Rx on   %5s(%lu) %.6a InterfaceID %p %#a&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i-&gt;BSSID, i-&gt;ifinfo.InterfaceID, &amp;n-&gt;ip);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
                    <span class="enscript-comment">// We join the Bonjour multicast group on Apple embedded platforms ONLY when a client request is active,
</span>                    <span class="enscript-comment">// so we leave the multicast group here to clear any residual group membership.
</span>                    <span class="enscript-keyword">if</span> (i-&gt;sa_family == AF_INET)
                    {
                        <span class="enscript-type">struct</span> ip_mreq imr;
                        primary-&gt;ifa_v4addr.s_addr = n-&gt;ip.ip.v4.NotAnInteger;
                        imr.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
                        imr.imr_interface        = primary-&gt;ifa_v4addr;

                        <span class="enscript-keyword">if</span> (SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_INET) == i)
                        {
                            LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) Doing IP_DROP_MEMBERSHIP for %.4a on %.4a&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;imr.imr_multiaddr, &amp;imr.imr_interface);
                            mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv4, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;imr, <span class="enscript-keyword">sizeof</span>(imr));
                            <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRNOTAVAIL))
                                LogMsg(<span class="enscript-string">&quot;setsockopt - IP_DROP_MEMBERSHIP error %d errno %d (%s)&quot;</span>, err, errno, strerror(errno));
                        }
                    }
                    <span class="enscript-keyword">if</span> (i-&gt;sa_family == AF_INET6)
                    {
                        <span class="enscript-type">struct</span> ipv6_mreq i6mr;
                        i6mr.ipv6mr_interface = primary-&gt;scope_id;
                        i6mr.ipv6mr_multiaddr = *(<span class="enscript-type">struct</span> in6_addr*)&amp;AllDNSLinkGroup_v6.ip.v6;

                        <span class="enscript-keyword">if</span> (SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_INET6) == i)
                        {
                            LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) Doing IPV6_LEAVE_GROUP for %.16a on %u&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                            mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv6, IPPROTO_IPV6, IPV6_LEAVE_GROUP, &amp;i6mr, <span class="enscript-keyword">sizeof</span>(i6mr));
                            <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRNOTAVAIL))
                                LogMsg(<span class="enscript-string">&quot;setsockopt - IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u&quot;</span>, err, errno, strerror(errno), &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                        }
                    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-keyword">if</span> (i-&gt;sa_family == AF_INET)
                    {
                        <span class="enscript-type">struct</span> ip_mreq imr;
                        primary-&gt;ifa_v4addr.s_addr = n-&gt;ip.ip.v4.NotAnInteger;
                        imr.imr_multiaddr.s_addr = AllDNSLinkGroup_v4.ip.v4.NotAnInteger;
                        imr.imr_interface        = primary-&gt;ifa_v4addr;

                        <span class="enscript-comment">// If this is our *first* IPv4 instance for this interface name, we need to do a IP_DROP_MEMBERSHIP first,
</span>                        <span class="enscript-comment">// before trying to join the group, to clear out stale kernel state which may be lingering.
</span>                        <span class="enscript-comment">// In particular, this happens with removable network interfaces like USB Ethernet adapters -- the kernel has stale state
</span>                        <span class="enscript-comment">// from the last time the USB Ethernet adapter was connected, and part of the kernel thinks we've already joined the group
</span>                        <span class="enscript-comment">// on that interface (so we get EADDRINUSE when we try to join again) but a different part of the kernel thinks we haven't
</span>                        <span class="enscript-comment">// joined the group (so we receive no multicasts). Doing an IP_DROP_MEMBERSHIP before joining seems to flush the stale state.
</span>                        <span class="enscript-comment">// Also, trying to make the code leave the group when the adapter is removed doesn't work either,
</span>                        <span class="enscript-comment">// because by the time we get the configuration change notification, the interface is already gone,
</span>                        <span class="enscript-comment">// so attempts to unsubscribe fail with EADDRNOTAVAIL (errno 49 &quot;Can't assign requested address&quot;).
</span>                        <span class="enscript-comment">// &lt;rdar://problem/5585972&gt; IP_ADD_MEMBERSHIP fails for previously-connected removable interfaces
</span>                        <span class="enscript-keyword">if</span> (SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_INET) == i)
                        {
                            LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) Doing precautionary IP_DROP_MEMBERSHIP for %.4a on %.4a&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;imr.imr_multiaddr, &amp;imr.imr_interface);
                            mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv4, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;imr, <span class="enscript-keyword">sizeof</span>(imr));
                            <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRNOTAVAIL))
                                LogMsg(<span class="enscript-string">&quot;setsockopt - IP_DROP_MEMBERSHIP error %d errno %d (%s)&quot;</span>, err, errno, strerror(errno));
                        }

                        LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) joining IPv4 mcast group %.4a on %.4a&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;imr.imr_multiaddr, &amp;imr.imr_interface);
                        mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv4, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;imr, <span class="enscript-keyword">sizeof</span>(imr));
                        <span class="enscript-comment">// Joining same group twice can give &quot;Address already in use&quot; error -- no need to report that
</span>                        <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRINUSE))
                            LogMsg(<span class="enscript-string">&quot;setsockopt - IP_ADD_MEMBERSHIP error %d errno %d (%s) group %.4a on %.4a&quot;</span>, err, errno, strerror(errno), &amp;imr.imr_multiaddr, &amp;imr.imr_interface);
                    }
                    <span class="enscript-keyword">if</span> (i-&gt;sa_family == AF_INET6)
                    {
                        <span class="enscript-type">struct</span> ipv6_mreq i6mr;
                        i6mr.ipv6mr_interface = primary-&gt;scope_id;
                        i6mr.ipv6mr_multiaddr = *(<span class="enscript-type">struct</span> in6_addr*)&amp;AllDNSLinkGroup_v6.ip.v6;

                        <span class="enscript-keyword">if</span> (SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_INET6) == i)
                        {
                            LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) Doing precautionary IPV6_LEAVE_GROUP for %.16a on %u&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                            mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv6, IPPROTO_IPV6, IPV6_LEAVE_GROUP, &amp;i6mr, <span class="enscript-keyword">sizeof</span>(i6mr));
                            <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRNOTAVAIL))
                                LogMsg(<span class="enscript-string">&quot;setsockopt - IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u&quot;</span>, err, errno, strerror(errno), &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                        }

                        LogInfo(<span class="enscript-string">&quot;SetupActiveInterfaces: %5s(%lu) joining IPv6 mcast group %.16a on %u&quot;</span>, i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                        mStatus err = setsockopt(m-&gt;p-&gt;permanentsockets.sktv6, IPPROTO_IPV6, IPV6_JOIN_GROUP, &amp;i6mr, <span class="enscript-keyword">sizeof</span>(i6mr));
                        <span class="enscript-comment">// Joining same group twice can give &quot;Address already in use&quot; error -- no need to report that
</span>                        <span class="enscript-keyword">if</span> (err &lt; 0 &amp;&amp; (errno != EADDRINUSE))
                            LogMsg(<span class="enscript-string">&quot;setsockopt - IPV6_JOIN_GROUP error %d errno %d (%s) group %.16a on %u&quot;</span>, err, errno, strerror(errno), &amp;i6mr.ipv6mr_multiaddr, i6mr.ipv6mr_interface);
                    }
                }
            }
        }

    <span class="enscript-keyword">return</span> count;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">MarkAllInterfacesInactive</span>(mDNSs32 utc)
{
    NetworkInterfaceInfoOSX *i;
    <span class="enscript-keyword">for</span> (i = mDNSStorage.p-&gt;InterfaceList; i; i = i-&gt;next)
    {
        <span class="enscript-keyword">if</span> (i-&gt;Exists) i-&gt;LastSeen = utc;
        i-&gt;Exists = mDNSfalse;
    }
}

<span class="enscript-comment">// Returns count of non-link local V4 addresses deregistered (why? -- SC)
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">ClearInactiveInterfaces</span>(mDNSs32 utc)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-comment">// First pass:
</span>    <span class="enscript-comment">// If an interface is going away, then deregister this from the mDNSCore.
</span>    <span class="enscript-comment">// We also have to deregister it if the primary interface that it's using for its InterfaceID is going away.
</span>    <span class="enscript-comment">// We have to do this because mDNSCore will use that InterfaceID when sending packets, and if the memory
</span>    <span class="enscript-comment">// it refers to has gone away we'll crash.
</span>    NetworkInterfaceInfoOSX *i;
    <span class="enscript-type">int</span> count = 0;
    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
    {
        <span class="enscript-comment">// If this interface is no longer active, or its InterfaceID is changing, deregister it
</span>        NetworkInterfaceInfoOSX *primary = SearchForInterfaceByName(i-&gt;ifinfo.ifname, AF_UNSPEC);
        <span class="enscript-keyword">if</span> (i-&gt;Registered)
            <span class="enscript-keyword">if</span> (i-&gt;Exists == 0 || i-&gt;Exists == MulticastStateChanged || i-&gt;Registered != primary)
            {
                InterfaceActivationSpeed activationSpeed;

                i-&gt;Flashing = !(i-&gt;ifa_flags &amp; IFF_LOOPBACK) &amp;&amp; (utc - i-&gt;AppearanceTime &lt; 60);
                LogInfo(<span class="enscript-string">&quot;ClearInactiveInterfaces: Deregistering %5s(%lu) %.6a InterfaceID %p(%p), primary %p, %#a/%d%s%s%s&quot;</span>,
                        i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i-&gt;BSSID, i-&gt;ifinfo.InterfaceID, i, primary,
                        &amp;i-&gt;ifinfo.ip, CountMaskBits(&amp;i-&gt;ifinfo.mask),
                        i-&gt;Flashing               ? <span class="enscript-string">&quot; (Flashing)&quot;</span>  : <span class="enscript-string">&quot;&quot;</span>,
                        i-&gt;Occulting              ? <span class="enscript-string">&quot; (Occulting)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                        i-&gt;ifinfo.InterfaceActive ? <span class="enscript-string">&quot; (Primary)&quot;</span>   : <span class="enscript-string">&quot;&quot;</span>);

                <span class="enscript-comment">// &quot;p2p*&quot; interfaces used for legacy AirDrop reuse the scope-id, MAC address and the IP address
</span>                <span class="enscript-comment">// every time it creates a new interface. We think it is a duplicate and hence consider it
</span>                <span class="enscript-comment">// as flashing and occulting. The &quot;core&quot; does not flush the cache for this case. This leads to
</span>                <span class="enscript-comment">// stale data returned to the application even after the interface is removed. The application
</span>                <span class="enscript-comment">// then starts to send data but the new interface is not yet created.
</span>                <span class="enscript-comment">// The same logic applies when the IFEF_DIRECTLINK flag is set on the interface.
</span>                <span class="enscript-keyword">if</span> ((strncmp(i-&gt;ifinfo.ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0) || i-&gt;ifinfo.DirectLink)
                {
                    activationSpeed = FastActivation;
                    LogInfo(<span class="enscript-string">&quot;ClearInactiveInterfaces: %s DirectLink interface deregistering&quot;</span>, i-&gt;ifinfo.ifname);
                }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i-&gt;Flashing &amp;&amp; i-&gt;Occulting)
                {
                    activationSpeed = SlowActivation;
                }
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">else</span>
                {
                    activationSpeed = NormalActivation;
                }
                mDNS_DeregisterInterface(m, &amp;i-&gt;ifinfo, activationSpeed);

                <span class="enscript-keyword">if</span> (!mDNSAddressIsLinkLocal(&amp;i-&gt;ifinfo.ip)) count++;
                i-&gt;Registered = mDNSNULL;
                <span class="enscript-comment">// Note: If i-&gt;Registered is set, that means we've called mDNS_RegisterInterface() for this interface,
</span>                <span class="enscript-comment">// so we need to make sure we call mDNS_DeregisterInterface() before disposing it.
</span>                <span class="enscript-comment">// If i-&gt;Registered is NOT set, then it's not registered and we should not call mDNS_DeregisterInterface() on it.
</span>
                <span class="enscript-comment">// Caution: If we ever decide to add code here to leave the multicast group, we need to make sure that this
</span>                <span class="enscript-comment">// is the LAST representative of this physical interface, or we'll unsubscribe from the group prematurely.
</span>            }
    }

    <span class="enscript-comment">// Second pass:
</span>    <span class="enscript-comment">// Now that everything that's going to deregister has done so, we can clean up and free the memory
</span>    NetworkInterfaceInfoOSX **p = &amp;m-&gt;p-&gt;InterfaceList;
    <span class="enscript-keyword">while</span> (*p)
    {
        i = *p;
        <span class="enscript-comment">// If no longer active, delete interface from list and free memory
</span>        <span class="enscript-keyword">if</span> (!i-&gt;Exists)
        {
            <span class="enscript-keyword">if</span> (i-&gt;LastSeen == utc) i-&gt;LastSeen = utc - 1;
            <span class="enscript-type">const</span> mDNSBool delete = ((utc - i-&gt;LastSeen) &gt;= 60) ? mDNStrue : mDNSfalse;
            LogInfo(<span class="enscript-string">&quot;ClearInactiveInterfaces: %-13s %5s(%lu) %.6a InterfaceID %p(%p) %#a/%d Age %d%s&quot;</span>, delete ? <span class="enscript-string">&quot;Deleting&quot;</span> : <span class="enscript-string">&quot;Holding&quot;</span>,
                    i-&gt;ifinfo.ifname, i-&gt;scope_id, &amp;i-&gt;BSSID, i-&gt;ifinfo.InterfaceID, i,
                    &amp;i-&gt;ifinfo.ip, CountMaskBits(&amp;i-&gt;ifinfo.mask), utc - i-&gt;LastSeen,
                    i-&gt;ifinfo.InterfaceActive ? <span class="enscript-string">&quot; (Primary)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-keyword">if</span> (i-&gt;BPF_fd &gt;= 0) CloseBPF(i);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-keyword">if</span> (delete)
            {
                *p = i-&gt;next;
                freeL(<span class="enscript-string">&quot;NetworkInterfaceInfoOSX&quot;</span>, i);
                <span class="enscript-keyword">continue</span>;   <span class="enscript-comment">// After deleting this object, don't want to do the &quot;p = &amp;i-&gt;next;&quot; thing at the end of the loop
</span>            }
        }
        p = &amp;i-&gt;next;
    }
    <span class="enscript-keyword">return</span> count;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AppendDNameListElem</span>(DNameListElem ***List, mDNSu32 uid, domainname *name)
{
    DNameListElem *dnle = (DNameListElem*) callocL(<span class="enscript-string">&quot;DNameListElem/AppendDNameListElem&quot;</span>, <span class="enscript-keyword">sizeof</span>(*dnle));
    <span class="enscript-keyword">if</span> (!dnle) LogMsg(<span class="enscript-string">&quot;ERROR: AppendDNameListElem: memory exhausted&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        dnle-&gt;next = mDNSNULL;
        dnle-&gt;uid  = uid;
        AssignDomainName(&amp;dnle-&gt;name, name);
        **List = dnle;
        *List = &amp;dnle-&gt;next;
    }
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">compare_dns_configs</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *aa, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *bb)
{
    dns_resolver_t *a = *(dns_resolver_t**)aa;
    dns_resolver_t *b = *(dns_resolver_t**)bb;

    <span class="enscript-keyword">return</span> (a-&gt;search_order &lt; b-&gt;search_order) ? -1 : (a-&gt;search_order == b-&gt;search_order) ? 0 : 1;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateSearchDomainHash</span>(MD5_CTX *sdc, <span class="enscript-type">char</span> *domain, mDNSInterfaceID InterfaceID)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-type">char</span> *buf = <span class="enscript-string">&quot;.&quot;</span>;
    mDNSu32 scopeid = 0;
    <span class="enscript-type">char</span> ifid_buf[16];

    <span class="enscript-keyword">if</span> (domain)
        buf = domain;
    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Hash the search domain name followed by the InterfaceID.
</span>    <span class="enscript-comment">// As we have scoped search domains, we also included InterfaceID. If either of them change,
</span>    <span class="enscript-comment">// we will detect it. Even if the order of them change, we will detect it.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: We have to handle a few of these tricky cases.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) Current: com, apple.com Changing to: comapple.com
</span>    <span class="enscript-comment">// 2) Current: a.com,b.com Changing to a.comb.com
</span>    <span class="enscript-comment">// 3) Current: a.com,b.com (ifid 8), Changing to a.com8b.com (ifid 8)
</span>    <span class="enscript-comment">// 4) Current: a.com (ifid 12), Changing to a.com1 (ifid: 2)
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// There are more variants of the above. The key thing is if we include the null in each case
</span>    <span class="enscript-comment">// at the end of name and the InterfaceID, it will prevent a new name (which can't include
</span>    <span class="enscript-comment">// NULL as part of the name) to be mistakenly thought of as a old name.
</span>
    scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, InterfaceID, mDNStrue);
    <span class="enscript-comment">// mDNS_snprintf always null terminates
</span>    <span class="enscript-keyword">if</span> (mDNS_snprintf(ifid_buf, <span class="enscript-keyword">sizeof</span>(ifid_buf), <span class="enscript-string">&quot;%u&quot;</span>, scopeid) &gt;= <span class="enscript-keyword">sizeof</span>(ifid_buf))
        LogMsg(<span class="enscript-string">&quot;UpdateSearchDomainHash: mDNS_snprintf failed for scopeid %u&quot;</span>, scopeid);

    LogInfo(<span class="enscript-string">&quot;UpdateSearchDomainHash: buf %s, ifid_buf %s&quot;</span>, buf, ifid_buf);
    MD5_Update(sdc, buf, strlen(buf) + 1);
    MD5_Update(sdc, ifid_buf, strlen(ifid_buf) + 1);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FinalizeSearchDomainHash</span>(MD5_CTX *sdc)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSu8 md5_hash[MD5_LEN];

    MD5_Final(md5_hash, sdc);

    <span class="enscript-keyword">if</span> (memcmp(md5_hash, m-&gt;SearchDomainsHash, MD5_LEN))
    {
        <span class="enscript-comment">// If the hash is different, either the search domains have changed or
</span>        <span class="enscript-comment">// the ordering between them has changed. Restart the questions that
</span>        <span class="enscript-comment">// would be affected by this.
</span>        LogInfo(<span class="enscript-string">&quot;FinalizeSearchDomains: The hash is different&quot;</span>);
        memcpy(m-&gt;SearchDomainsHash, md5_hash, MD5_LEN);
        RetrySearchDomainQuestions(m);
    }
    <span class="enscript-keyword">else</span> { LogInfo(<span class="enscript-string">&quot;FinalizeSearchDomains: The hash is same&quot;</span>); }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConfigSearchDomains</span>(dns_resolver_t *resolver, mDNSInterfaceID interfaceId, mDNSu32 scope,  MD5_CTX *sdc, uint64_t generation)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *scopeString = DNSScopeToString(scope);
    <span class="enscript-type">int</span> j;
    domainname d;

    <span class="enscript-keyword">if</span> (scope == kScopeNone)
        interfaceId = mDNSInterface_Any;

    <span class="enscript-keyword">if</span> (scope == kScopeNone || scope == kScopeInterfaceID)
    {
        <span class="enscript-keyword">for</span> (j = 0; j &lt; resolver-&gt;n_search; j++)
        {
            <span class="enscript-keyword">if</span> (MakeDomainNameFromDNSNameString(&amp;d, resolver-&gt;search[j]) != NULL)
            {
                <span class="enscript-type">char</span> interface_buf[32];
                mDNS_snprintf(interface_buf, <span class="enscript-keyword">sizeof</span>(interface_buf), <span class="enscript-string">&quot;for interface %s&quot;</span>, InterfaceNameForID(&amp;mDNSStorage,  interfaceId));
                LogInfo(<span class="enscript-string">&quot;ConfigSearchDomains: (%s) configuring search domain %s %s (generation= %llu)&quot;</span>, scopeString,
                        resolver-&gt;search[j], (interfaceId == mDNSInterface_Any) ? <span class="enscript-string">&quot;&quot;</span> : interface_buf, generation);
                UpdateSearchDomainHash(sdc, resolver-&gt;search[j], interfaceId);
                mDNS_AddSearchDomain_CString(resolver-&gt;search[j], interfaceId);
            }
            <span class="enscript-keyword">else</span>
            {
                LogInfo(<span class="enscript-string">&quot;ConfigSearchDomains: An invalid search domain was detected for %s domain %s n_nameserver %d, (generation= %llu)&quot;</span>,
                        DNSScopeToString(scope), resolver-&gt;domain, resolver-&gt;n_nameserver, generation);
            }
        }
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;ConfigSearchDomains: (%s) Ignoring search domain for interface %s&quot;</span>, scopeString, InterfaceNameForID(&amp;mDNSStorage, interfaceId));
    }
}

mDNSlocal mDNSInterfaceID <span class="enscript-function-name">ConfigParseInterfaceID</span>(mDNSu32 ifindex)
{
    NetworkInterfaceInfoOSX *ni;
    mDNSInterfaceID interface;

    <span class="enscript-keyword">for</span> (ni = mDNSStorage.p-&gt;InterfaceList; ni; ni = ni-&gt;next)
    {
        <span class="enscript-keyword">if</span> (ni-&gt;ifinfo.InterfaceID &amp;&amp; ni-&gt;scope_id == ifindex) 
            <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (ni != NULL) 
    {
        interface = ni-&gt;ifinfo.InterfaceID;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// In rare circumstances, we could potentially hit this case where we cannot parse the InterfaceID
</span>        <span class="enscript-comment">// (see &lt;rdar://problem/13214785&gt;). At this point, we still accept the DNS Config from configd 
</span>        <span class="enscript-comment">// Note: We currently ack the whole dns configuration and not individual resolvers or DNS servers. 
</span>        <span class="enscript-comment">// As the caller is going to ack the configuration always, we have to add all the DNS servers 
</span>        <span class="enscript-comment">// in the configuration. Otherwise, we won't have any DNS servers up until the network change.
</span>
        LogMsg(<span class="enscript-string">&quot;ConfigParseInterfaceID: interface specific index %d not found (interface may not be UP)&quot;</span>,ifindex);

        <span class="enscript-comment">// Set the correct interface from configd before passing this to mDNS_AddDNSServer() below
</span>        interface = (mDNSInterfaceID)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)ifindex;
    }
    <span class="enscript-keyword">return</span> interface;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConfigNonUnicastResolver</span>(dns_resolver_t *r)
{
    <span class="enscript-type">char</span> *opt = r-&gt;options;
    domainname d; 

    <span class="enscript-keyword">if</span> (opt &amp;&amp; !strncmp(opt, <span class="enscript-string">&quot;mdns&quot;</span>, strlen(opt)))
    {
        <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;d, r-&gt;domain))
        { 
            LogMsg(<span class="enscript-string">&quot;ConfigNonUnicastResolver: config-&gt;resolver bad domain %s&quot;</span>, r-&gt;domain); 
            <span class="enscript-keyword">return</span>;
        }
        mDNS_AddMcastResolver(&amp;mDNSStorage, &amp;d, mDNSInterface_Any, r-&gt;timeout);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConfigDNSServers</span>(dns_resolver_t *r, mDNSInterfaceID interfaceID, mDNSu32 scope, mDNSu32 resGroupID)
{
    domainname domain;
    <span class="enscript-keyword">if</span> (!r-&gt;domain || (*r-&gt;domain == <span class="enscript-string">'\0'</span>))
    {
        domain.c[0] = 0;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;domain, r-&gt;domain))
    { 
        LogMsg(<span class="enscript-string">&quot;ConfigDNSServers: bad domain %s&quot;</span>, r-&gt;domain); 
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">// Parse the resolver specific attributes that affects all the DNS servers.
</span>    <span class="enscript-type">const</span> int32_t serviceID = (scope == kScopeServiceID) ? r-&gt;service_identifier : 0;

    <span class="enscript-type">const</span> mdns_interface_monitor_t monitor = GetInterfaceMonitorForIndex((uint32_t)((uintptr_t)interfaceID));
    <span class="enscript-type">const</span> mDNSBool isExpensive   = (monitor &amp;&amp; mdns_interface_monitor_is_expensive(monitor))   ? mDNStrue : mDNSfalse;
    <span class="enscript-type">const</span> mDNSBool isConstrained = (monitor &amp;&amp; mdns_interface_monitor_is_constrained(monitor)) ? mDNStrue : mDNSfalse;
    <span class="enscript-type">const</span> mDNSBool isCLAT46      = (monitor &amp;&amp; mdns_interface_monitor_is_clat46(monitor))      ? mDNStrue : mDNSfalse;
    <span class="enscript-type">const</span> mDNSBool usableA       = (r-&gt;flags &amp; DNS_RESOLVER_FLAGS_REQUEST_A_RECORDS)           ? mDNStrue : mDNSfalse;
    <span class="enscript-type">const</span> mDNSBool usableAAAA    = (r-&gt;flags &amp; DNS_RESOLVER_FLAGS_REQUEST_AAAA_RECORDS)        ? mDNStrue : mDNSfalse;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
    <span class="enscript-type">const</span> mDNSBool isCell        = (r-&gt;reach_flags &amp; kSCNetworkReachabilityFlagsIsWWAN)        ? mDNStrue : mDNSfalse;
#<span class="enscript-reference">else</span>
    <span class="enscript-type">const</span> mDNSBool isCell        = mDNSfalse;
#<span class="enscript-reference">endif</span>

    <span class="enscript-type">const</span> mDNSIPPort port = (r-&gt;port != 0) ? mDNSOpaque16fromIntVal(r-&gt;port) : UnicastDNSPort;
    <span class="enscript-keyword">for</span> (int32_t i = 0; i &lt; r-&gt;n_nameserver; i++)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> family = r-&gt;nameserver[i]-&gt;sa_family;
        <span class="enscript-keyword">if</span> ((family != AF_INET) &amp;&amp; (family != AF_INET6)) <span class="enscript-keyword">continue</span>;

        mDNSAddr saddr;
        <span class="enscript-keyword">if</span> (SetupAddr(&amp;saddr, r-&gt;nameserver[i]))
        {
            LogMsg(<span class="enscript-string">&quot;ConfigDNSServers: Bad address&quot;</span>);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// The timeout value is for all the DNS servers in a given resolver, hence we pass
</span>        <span class="enscript-comment">// the timeout value only for the first DNSServer. If we don't have a value in the
</span>        <span class="enscript-comment">// resolver, then use the core's default value
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Note: this assumes that when the core picks a list of DNSServers for a question,
</span>        <span class="enscript-comment">// it takes the sum of all the timeout values for all DNS servers. By doing this, it
</span>        <span class="enscript-comment">// tries all the DNS servers in a specified timeout
</span>        DNSServer *s = mDNS_AddDNSServer(&amp;mDNSStorage, &amp;domain, interfaceID, serviceID, &amp;saddr, port, scope,
            (i == 0) ? (r-&gt;timeout ? r-&gt;timeout : DEFAULT_UDNS_TIMEOUT) : 0, isCell, isExpensive, isConstrained, isCLAT46,
            resGroupID, usableA, usableAAAA, mDNStrue);
        <span class="enscript-keyword">if</span> (s)
        {
            LogInfo(<span class="enscript-string">&quot;ConfigDNSServers(%s): DNS server %#a:%d for domain %##s&quot;</span>,
                DNSScopeToString(scope), &amp;s-&gt;addr, mDNSVal16(s-&gt;port), domain.c);
        }
    }
}

<span class="enscript-comment">// ConfigResolvers is called for different types of resolvers: Unscoped resolver, Interface scope resolver and
</span><span class="enscript-comment">// Service scope resolvers. This is indicated by the scope argument.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;resolver&quot; has entries that should only be used for unscoped questions.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;scoped_resolver&quot; has entries that should only be used for Interface scoped question i.e., questions that specify an
</span><span class="enscript-comment">// interface index (q-&gt;InterfaceID)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;service_specific_resolver&quot; has entries that should be used for Service scoped question i.e., questions that specify
</span><span class="enscript-comment">// a service identifier (q-&gt;ServiceID)
</span><span class="enscript-comment">//
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConfigResolvers</span>(dns_config_t *config, mDNSu32 scope, mDNSBool setsearch, mDNSBool setservers, MD5_CTX *sdc)
{
    <span class="enscript-type">int</span> i;
    dns_resolver_t **resolver;
    <span class="enscript-type">int</span> nresolvers;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *scopeString = DNSScopeToString(scope);
    mDNSInterfaceID interface;

    <span class="enscript-keyword">switch</span> (scope)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeNone</span>:
            resolver = config-&gt;resolver;
            nresolvers = config-&gt;n_resolver;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeInterfaceID</span>:
            resolver = config-&gt;scoped_resolver;
            nresolvers = config-&gt;n_scoped_resolver;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeServiceID</span>:
            resolver = config-&gt;service_specific_resolver;
            nresolvers = config-&gt;n_service_specific_resolver;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span>;
    }
    qsort(resolver, nresolvers, <span class="enscript-keyword">sizeof</span>(dns_resolver_t*), compare_dns_configs);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; nresolvers; i++)
    {
        dns_resolver_t *r = resolver[i];

        LogInfo(<span class="enscript-string">&quot;ConfigResolvers: %s resolver[%d] domain %s n_nameserver %d&quot;</span>, scopeString, i, r-&gt;domain, r-&gt;n_nameserver);

        interface = mDNSInterface_Any;

        <span class="enscript-comment">// Parse the interface index 
</span>        <span class="enscript-keyword">if</span> (r-&gt;if_index != 0)
        {
            interface = ConfigParseInterfaceID(r-&gt;if_index);
        }

        <span class="enscript-keyword">if</span> (setsearch)
        {
            ConfigSearchDomains(resolver[i], interface, scope, sdc, config-&gt;generation);
            
            <span class="enscript-comment">// Parse other scoped resolvers for search lists
</span>            <span class="enscript-keyword">if</span> (!setservers) 
                <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (r-&gt;port == 5353 || r-&gt;n_nameserver == 0)
        {
            ConfigNonUnicastResolver(r);
        }
        <span class="enscript-keyword">else</span>
        {
            ConfigDNSServers(r, interface, scope, mDNS_GetNextResolverGroupID());
        }
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">REACHABILITY_TRIGGER</span>)
mDNSlocal mDNSBool <span class="enscript-function-name">QuestionValidForDNSTrigger</span>(<span class="enscript-type">const</span> DNSQuestion *q)
{
    <span class="enscript-keyword">if</span> (q-&gt;Suppressed)
    {
        debugf(<span class="enscript-string">&quot;QuestionValidForDNSTrigger: Suppressed: %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))
    {
        debugf(<span class="enscript-string">&quot;QuestionValidForDNSTrigger: Multicast: %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-comment">// If we answered using LocalOnly records e.g., /etc/hosts, don't consider that a valid response
</span>    <span class="enscript-comment">// for trigger.
</span>    <span class="enscript-keyword">if</span> (q-&gt;LOAddressAnswers)
    {
        debugf(<span class="enscript-string">&quot;QuestionValidForDNSTrigger: LocalOnly answers: %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// This function is called if we are not delivering unicast answers to &quot;A&quot; or &quot;AAAA&quot; questions.
</span><span class="enscript-comment">// We set our state appropriately so that if we start receiving answers, trigger the
</span><span class="enscript-comment">// upper layer to retry DNS questions.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformUpdateDNSStatus</span>(<span class="enscript-type">const</span> DNSQuestion *q)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-keyword">if</span> (!QuestionValidForDNSTrigger(q))
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// Ignore applications that start and stop queries for no reason before we ever talk
</span>    <span class="enscript-comment">// to any DNS server.
</span>    <span class="enscript-keyword">if</span> (!q-&gt;triedAllServersOnce)
    {
        LogInfo(<span class="enscript-string">&quot;QuestionValidForDNSTrigger: question %##s (%s) stopped too soon&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (q-&gt;qtype == kDNSType_A)
        m-&gt;p-&gt;v4answers = 0;
    <span class="enscript-keyword">if</span> (q-&gt;qtype == kDNSType_AAAA)
        m-&gt;p-&gt;v6answers = 0;
    <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;v4answers || !m-&gt;p-&gt;v6answers)
    {
        LogInfo(<span class="enscript-string">&quot;mDNSPlatformUpdateDNSStatus: Trigger needed v4 %d, v6 %d, question %##s (%s)&quot;</span>, m-&gt;p-&gt;v4answers, m-&gt;p-&gt;v6answers, q-&gt;qname.c,
            DNSTypeName(q-&gt;qtype));
    }
}
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">REACHABILITY_TRIGGER</span>)

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AckConfigd</span>(dns_config_t *config)
{
    mDNS_CheckLock(&amp;mDNSStorage);

    <span class="enscript-comment">// Acking the configuration triggers configd to reissue the reachability queries
</span>    mDNSStorage.p-&gt;DNSTrigger = NonZeroTime(mDNSStorage.timenow);
    _dns_configuration_ack(config, <span class="enscript-string">&quot;com.apple.mDNSResponder&quot;</span>);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">REACHABILITY_TRIGGER</span>)
<span class="enscript-comment">// If v4q is non-NULL, it means we have received some answers for &quot;A&quot; type questions
</span><span class="enscript-comment">// If v6q is non-NULL, it means we have received some answers for &quot;AAAA&quot; type questions
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformTriggerDNSRetry</span>(<span class="enscript-type">const</span> DNSQuestion *v4q, <span class="enscript-type">const</span> DNSQuestion *v6q)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSBool trigger = mDNSfalse;
    mDNSs32 timenow;

    <span class="enscript-comment">// Don't send triggers too often.
</span>    <span class="enscript-comment">// If we have started delivering answers to questions, we should send a trigger
</span>    <span class="enscript-comment">// if the time permits. If we are delivering answers, we should set the state
</span>    <span class="enscript-comment">// of v4answers/v6answers to 1 and avoid sending a trigger.  But, we don't know
</span>    <span class="enscript-comment">// whether the answers that are being delivered currently is for configd or some
</span>    <span class="enscript-comment">// other application. If we set the v4answers/v6answers to 1 and not deliver a trigger,
</span>    <span class="enscript-comment">// then we won't deliver the trigger later when it is okay to send one as the
</span>    <span class="enscript-comment">// &quot;answers&quot; are already set to 1. Hence, don't affect the state of v4answers and
</span>    <span class="enscript-comment">// v6answers if we are not delivering triggers.
</span>    mDNS_Lock(m);
    timenow = m-&gt;timenow;
    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;DNSTrigger &amp;&amp; (timenow - m-&gt;p-&gt;DNSTrigger) &lt; DNS_TRIGGER_INTERVAL)
    {
        <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;v4answers || !m-&gt;p-&gt;v6answers)
        {
            debugf(<span class="enscript-string">&quot;mDNSPlatformTriggerDNSRetry: not triggering, time since last trigger %d ms, v4ans %d, v6ans %d&quot;</span>,
                (timenow - m-&gt;p-&gt;DNSTrigger), m-&gt;p-&gt;v4answers, m-&gt;p-&gt;v6answers);
        }
        mDNS_Unlock(m);
        <span class="enscript-keyword">return</span>;
    }
    mDNS_Unlock(m);
    <span class="enscript-keyword">if</span> (v4q != NULL &amp;&amp; QuestionValidForDNSTrigger(v4q))
    {
        <span class="enscript-type">int</span> old = m-&gt;p-&gt;v4answers;

        m-&gt;p-&gt;v4answers = 1;

        <span class="enscript-comment">// If there are IPv4 answers now and previously we did not have
</span>        <span class="enscript-comment">// any answers, trigger a DNS change so that reachability
</span>        <span class="enscript-comment">// can retry the queries again.
</span>        <span class="enscript-keyword">if</span> (!old)
        {
            LogInfo(<span class="enscript-string">&quot;mDNSPlatformTriggerDNSRetry: Triggering because of IPv4, last trigger %d ms, %##s (%s)&quot;</span>, (timenow - m-&gt;p-&gt;DNSTrigger),
                v4q-&gt;qname.c, DNSTypeName(v4q-&gt;qtype));
            trigger = mDNStrue;
        }
    }
    <span class="enscript-keyword">if</span> (v6q != NULL &amp;&amp; QuestionValidForDNSTrigger(v6q))
    {
        <span class="enscript-type">int</span> old = m-&gt;p-&gt;v6answers;

        m-&gt;p-&gt;v6answers = 1;
        <span class="enscript-comment">// If there are IPv6 answers now and previously we did not have
</span>        <span class="enscript-comment">// any answers, trigger a DNS change so that reachability
</span>        <span class="enscript-comment">// can retry the queries again.
</span>        <span class="enscript-keyword">if</span> (!old)
        {
            LogInfo(<span class="enscript-string">&quot;mDNSPlatformTriggerDNSRetry: Triggering because of IPv6, last trigger %d ms, %##s (%s)&quot;</span>, (timenow - m-&gt;p-&gt;DNSTrigger),
                v6q-&gt;qname.c, DNSTypeName(v6q-&gt;qtype));
            trigger = mDNStrue;
        }
    }
    <span class="enscript-keyword">if</span> (trigger)
    {
        dns_config_t *config = dns_configuration_copy();
        <span class="enscript-keyword">if</span> (config)
        {
            mDNS_Lock(m);
            AckConfigd(config);
            mDNS_Unlock(m);
            dns_configuration_free(config);
        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformTriggerDNSRetry: ERROR!! configd did not return config&quot;</span>);
        }
    }
}
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">REACHABILITY_TRIGGER</span>)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">UNICAST_DOTLOCAL</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetupActiveDirectoryDomain</span>(dns_config_t *config)
{
    <span class="enscript-comment">// Record the so-called &quot;primary&quot; domain, which we use as a hint to tell if the user is on a network set up
</span>    <span class="enscript-comment">// by someone using Microsoft Active Directory using &quot;local&quot; as a private internal top-level domain
</span>    <span class="enscript-keyword">if</span> (config-&gt;n_resolver &amp;&amp; config-&gt;resolver[0]-&gt;domain &amp;&amp; config-&gt;resolver[0]-&gt;n_nameserver &amp;&amp;
        config-&gt;resolver[0]-&gt;nameserver[0])
    {
        MakeDomainNameFromDNSNameString(&amp;ActiveDirectoryPrimaryDomain, config-&gt;resolver[0]-&gt;domain);
    }
    <span class="enscript-keyword">else</span>
    {
         ActiveDirectoryPrimaryDomain.c[0] = 0;
    }

    <span class="enscript-comment">//MakeDomainNameFromDNSNameString(&amp;ActiveDirectoryPrimaryDomain, &quot;test.local&quot;);
</span>    ActiveDirectoryPrimaryDomainLabelCount = CountLabels(&amp;ActiveDirectoryPrimaryDomain);
    <span class="enscript-keyword">if</span> (config-&gt;n_resolver &amp;&amp; config-&gt;resolver[0]-&gt;n_nameserver &amp;&amp;
        SameDomainName(SkipLeadingLabels(&amp;ActiveDirectoryPrimaryDomain, ActiveDirectoryPrimaryDomainLabelCount - 1), &amp;localdomain))
    {
        SetupAddr(&amp;ActiveDirectoryPrimaryDomainServer, config-&gt;resolver[0]-&gt;nameserver[0]);
    }
    <span class="enscript-keyword">else</span>
    {
        AssignConstStringDomainName(&amp;ActiveDirectoryPrimaryDomain, <span class="enscript-string">&quot;&quot;</span>);
        ActiveDirectoryPrimaryDomainLabelCount = 0;
        ActiveDirectoryPrimaryDomainServer = zeroAddr;
    }
}
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetupDDNSDomains</span>(domainname *<span class="enscript-type">const</span> fqdn, DNameListElem **RegDomains, DNameListElem **BrowseDomains)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">char</span> buf[MAX_ESCAPED_DOMAIN_NAME];  <span class="enscript-comment">// Max legal C-string name, including terminating NULL
</span>    domainname d;

    CFDictionaryRef ddnsdict = SCDynamicStoreCopyValue(NULL, NetworkChangedKey_DynamicDNS);
    <span class="enscript-keyword">if</span> (ddnsdict)
    {
        <span class="enscript-keyword">if</span> (fqdn)
        {
            CFArrayRef fqdnArray = CFDictionaryGetValue(ddnsdict, CFSTR(<span class="enscript-string">&quot;HostNames&quot;</span>));
            <span class="enscript-keyword">if</span> (fqdnArray &amp;&amp; CFArrayGetCount(fqdnArray) &gt; 0)
            {
                <span class="enscript-comment">// for now, we only look at the first array element.  if we ever support multiple configurations, we will walk the list
</span>                CFDictionaryRef fqdnDict = CFArrayGetValueAtIndex(fqdnArray, 0);
                <span class="enscript-keyword">if</span> (fqdnDict &amp;&amp; DictionaryIsEnabled(fqdnDict))
                {
                    CFStringRef name = CFDictionaryGetValue(fqdnDict, CFSTR(<span class="enscript-string">&quot;Domain&quot;</span>));
                    <span class="enscript-keyword">if</span> (name)
                    {
                        <span class="enscript-keyword">if</span> (!CFStringGetCString(name, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8) ||
                            !MakeDomainNameFromDNSNameString(fqdn, buf) || !fqdn-&gt;c[0])
                            LogMsg(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS host name: %s&quot;</span>, buf[0] ? buf : <span class="enscript-string">&quot;(unknown)&quot;</span>);
                        <span class="enscript-keyword">else</span> 
                            debugf(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore DDNS host name: %s&quot;</span>, buf);
                    }
                }
            }
        }
        <span class="enscript-keyword">if</span> (RegDomains)
        {
            CFArrayRef regArray = CFDictionaryGetValue(ddnsdict, CFSTR(<span class="enscript-string">&quot;RegistrationDomains&quot;</span>));
            <span class="enscript-keyword">if</span> (regArray &amp;&amp; CFArrayGetCount(regArray) &gt; 0)
            {
                CFDictionaryRef regDict = CFArrayGetValueAtIndex(regArray, 0);
                <span class="enscript-keyword">if</span> (regDict &amp;&amp; DictionaryIsEnabled(regDict))
                {
                    CFStringRef name = CFDictionaryGetValue(regDict, CFSTR(<span class="enscript-string">&quot;Domain&quot;</span>));
                    <span class="enscript-keyword">if</span> (name)
                    {
                        <span class="enscript-keyword">if</span> (!CFStringGetCString(name, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8) ||
                            !MakeDomainNameFromDNSNameString(&amp;d, buf) || !d.c[0])
                            LogMsg(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS registration domain: %s&quot;</span>, buf[0] ? buf : <span class="enscript-string">&quot;(unknown)&quot;</span>);
                        <span class="enscript-keyword">else</span>
                        {
                            debugf(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore DDNS registration domain: %s&quot;</span>, buf);
                            AppendDNameListElem(&amp;RegDomains, 0, &amp;d);
                        }
                    }
                }
            }
        }
        <span class="enscript-keyword">if</span> (BrowseDomains)
        {
            CFArrayRef browseArray = CFDictionaryGetValue(ddnsdict, CFSTR(<span class="enscript-string">&quot;BrowseDomains&quot;</span>));
            <span class="enscript-keyword">if</span> (browseArray)
            {
                <span class="enscript-keyword">for</span> (i = 0; i &lt; CFArrayGetCount(browseArray); i++)
                {
                    CFDictionaryRef browseDict = CFArrayGetValueAtIndex(browseArray, i);
                    <span class="enscript-keyword">if</span> (browseDict &amp;&amp; DictionaryIsEnabled(browseDict))
                    {
                        CFStringRef name = CFDictionaryGetValue(browseDict, CFSTR(<span class="enscript-string">&quot;Domain&quot;</span>));
                        <span class="enscript-keyword">if</span> (name)
                        {
                            <span class="enscript-keyword">if</span> (!CFStringGetCString(name, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8) ||
                                !MakeDomainNameFromDNSNameString(&amp;d, buf) || !d.c[0])
                                LogMsg(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore bad DDNS browsing domain: %s&quot;</span>, buf[0] ? buf : <span class="enscript-string">&quot;(unknown)&quot;</span>);
                            <span class="enscript-keyword">else</span>
                            {
                                debugf(<span class="enscript-string">&quot;GetUserSpecifiedDDNSConfig SCDynamicStore DDNS browsing domain: %s&quot;</span>, buf);
                                AppendDNameListElem(&amp;BrowseDomains, 0, &amp;d);
                            }
                        }
                    }
                }
            }
        }
        CFRelease(ddnsdict);
    }
}

<span class="enscript-comment">// Returns mDNSfalse, if it does not set the configuration i.e., if the DNS configuration did not change
</span>mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformSetDNSConfig</span>(mDNSBool setservers, mDNSBool setsearch, domainname *<span class="enscript-type">const</span> fqdn,
                                             DNameListElem **RegDomains, DNameListElem **BrowseDomains, mDNSBool ackConfig)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    MD5_CTX sdc;    <span class="enscript-comment">// search domain context
</span>
    <span class="enscript-comment">// Need to set these here because we need to do this even if SCDynamicStoreCreate() or SCDynamicStoreCopyValue() below don't succeed
</span>    <span class="enscript-keyword">if</span> (fqdn         ) fqdn-&gt;c[0]      = 0;
    <span class="enscript-keyword">if</span> (RegDomains   ) *RegDomains     = NULL;
    <span class="enscript-keyword">if</span> (BrowseDomains) *BrowseDomains  = NULL;

    LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetDNSConfig:%s%s%s%s%s&quot;</span>,
            setservers    ? <span class="enscript-string">&quot; setservers&quot;</span>    : <span class="enscript-string">&quot;&quot;</span>,
            setsearch     ? <span class="enscript-string">&quot; setsearch&quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
            fqdn          ? <span class="enscript-string">&quot; fqdn&quot;</span>          : <span class="enscript-string">&quot;&quot;</span>,
            RegDomains    ? <span class="enscript-string">&quot; RegDomains&quot;</span>    : <span class="enscript-string">&quot;&quot;</span>,
            BrowseDomains ? <span class="enscript-string">&quot; BrowseDomains&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

    <span class="enscript-keyword">if</span> (setsearch) MD5_Init(&amp;sdc);

    <span class="enscript-comment">// Add the inferred address-based configuration discovery domains
</span>    <span class="enscript-comment">// (should really be in core code I think, not platform-specific)
</span>    <span class="enscript-keyword">if</span> (setsearch)
    {
        <span class="enscript-type">struct</span> ifaddrs *ifa = mDNSNULL;
        <span class="enscript-type">struct</span> sockaddr_in saddr;
        mDNSPlatformMemZero(&amp;saddr, <span class="enscript-keyword">sizeof</span>(saddr));
        saddr.sin_len = <span class="enscript-keyword">sizeof</span>(saddr);
        saddr.sin_family = AF_INET;
        saddr.sin_port = 0;
        saddr.sin_addr.s_addr = *(in_addr_t *)&amp;m-&gt;Router.ip.v4;

        <span class="enscript-comment">// Don't add any reverse-IP search domains if doing the WAB bootstrap queries would cause dial-on-demand connection initiation
</span>        <span class="enscript-keyword">if</span> (!AddrRequiresPPPConnection((<span class="enscript-type">struct</span> sockaddr *)&amp;saddr)) ifa =  myGetIfAddrs(1);

        <span class="enscript-keyword">while</span> (ifa)
        {
            mDNSAddr a, n;
            <span class="enscript-type">char</span> buf[64];

            <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET &amp;&amp;
                ifa-&gt;ifa_netmask                    &amp;&amp;
                !(ifa-&gt;ifa_flags &amp; IFF_LOOPBACK)    &amp;&amp;
                !SetupAddr(&amp;a, ifa-&gt;ifa_addr)       &amp;&amp;
                !mDNSv4AddressIsLinkLocal(&amp;a.ip.v4)  )
            {
                <span class="enscript-comment">// Apparently it's normal for the sa_family of an ifa_netmask to sometimes be incorrect, so we explicitly fix it here before calling SetupAddr
</span>                <span class="enscript-comment">// &lt;rdar://problem/5492035&gt; getifaddrs is returning invalid netmask family for fw0 and vmnet
</span>                ifa-&gt;ifa_netmask-&gt;sa_family = ifa-&gt;ifa_addr-&gt;sa_family;     <span class="enscript-comment">// Make sure ifa_netmask-&gt;sa_family is set correctly
</span>                SetupAddr(&amp;n, ifa-&gt;ifa_netmask);
                <span class="enscript-comment">// Note: This is reverse order compared to a normal dotted-decimal IP address, so we can't use our customary &quot;%.4a&quot; format code
</span>                mDNS_snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;%d.%d.%d.%d.in-addr.arpa.&quot;</span>, a.ip.v4.b[3] &amp; n.ip.v4.b[3],
                              a.ip.v4.b[2] &amp; n.ip.v4.b[2],
                              a.ip.v4.b[1] &amp; n.ip.v4.b[1],
                              a.ip.v4.b[0] &amp; n.ip.v4.b[0]);
                UpdateSearchDomainHash(&amp;sdc, buf, NULL);
                mDNS_AddSearchDomain_CString(buf, mDNSNULL);
            }
            ifa = ifa-&gt;ifa_next;
        }
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MDNS_NO_DNSINFO</span>
    <span class="enscript-keyword">if</span> (setservers || setsearch)
    {
        dns_config_t *config = dns_configuration_copy();
        <span class="enscript-keyword">if</span> (!config)
        {
            <span class="enscript-comment">// On 10.4, calls to dns_configuration_copy() early in the boot process often fail.
</span>            <span class="enscript-comment">// Apparently this is expected behaviour -- &quot;not a bug&quot;.
</span>            <span class="enscript-comment">// Accordingly, we suppress syslog messages for the first three minutes after boot.
</span>            <span class="enscript-comment">// If we are still getting failures after three minutes, then we log them.
</span>            <span class="enscript-keyword">if</span> ((mDNSu32)mDNSPlatformRawTime() &gt; (mDNSu32)(mDNSPlatformOneSecond * 180))
                LogMsg(<span class="enscript-string">&quot;mDNSPlatformSetDNSConfig: Error: dns_configuration_copy returned NULL&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetDNSConfig: config-&gt;n_resolver = %d, generation %llu, last %llu&quot;</span>, config-&gt;n_resolver, config-&gt;generation, m-&gt;p-&gt;LastConfigGeneration);

            <span class="enscript-comment">// For every network change, mDNSPlatformSetDNSConfig is called twice. First,
</span>            <span class="enscript-comment">// to update the search domainlist (in which case, the setsearch bool is set);
</span>            <span class="enscript-comment">// and second, to update the DNS server list (in which case, the setservers bool
</span>            <span class="enscript-comment">// is set). The code assumes only one of these flags, setsearch or setserver,
</span>            <span class="enscript-comment">// will be set when mDNSPlatformSetDNSConfig is called to handle a network change.
</span>            <span class="enscript-comment">// The mDNSPlatformSetDNSConfig function also assumes that ackCfg will be set
</span>            <span class="enscript-comment">// when setservers is set.
</span>
            <span class="enscript-comment">// The search domains update occurs on every network change to avoid sync issues
</span>            <span class="enscript-comment">// that may occur if a network change happens during the processing
</span>            <span class="enscript-comment">// of a network change.  Thedns serversupdate occurs when the DNS config
</span>            <span class="enscript-comment">// changes. The dns servers stay in sync by saving the config's generation number
</span>            <span class="enscript-comment">// on every update; and only updating when the generation number changes.
</span>
            <span class="enscript-comment">// If this is a DNS server update and the configuration hasn't changed, then skip update
</span>            <span class="enscript-keyword">if</span> (setservers &amp;&amp; !m-&gt;p-&gt;if_interface_changed &amp;&amp; m-&gt;p-&gt;LastConfigGeneration == config-&gt;generation)
            {
                LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetDNSConfig(setservers): generation number %llu same, not processing&quot;</span>, config-&gt;generation);
                dns_configuration_free(config);
                SetupDDNSDomains(fqdn, RegDomains, BrowseDomains);
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
            <span class="enscript-keyword">if</span> (setservers) {
                <span class="enscript-comment">// Must check if setservers is true, because mDNSPlatformSetDNSConfig can be called for multiple times
</span>                <span class="enscript-comment">// with setservers equals to false. If setservers is false, we will end up with clearing if_interface_changed
</span>                <span class="enscript-comment">// without really updating the server.
</span>                m-&gt;p-&gt;if_interface_changed = mDNSfalse;
            }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">UNICAST_DOTLOCAL</span>)
            SetupActiveDirectoryDomain(config);
#<span class="enscript-reference">endif</span>
            ConfigResolvers(config, kScopeNone, setsearch, setservers, &amp;sdc);
            ConfigResolvers(config, kScopeInterfaceID, setsearch, setservers, &amp;sdc);
            ConfigResolvers(config, kScopeServiceID, setsearch, setservers, &amp;sdc);

            <span class="enscript-type">const</span> CFIndex n = m-&gt;p-&gt;InterfaceMonitors ? CFArrayGetCount(m-&gt;p-&gt;InterfaceMonitors) : 0;
            <span class="enscript-keyword">for</span> (CFIndex i = n - 1; i &gt;= 0; i--)
            {
                mdns_interface_monitor_t monitor;
                monitor = (mdns_interface_monitor_t) CFArrayGetValueAtIndex(m-&gt;p-&gt;InterfaceMonitors, i);
                <span class="enscript-type">const</span> uint32_t ifIndex = mdns_interface_monitor_get_interface_index(monitor);
                DNSServer *server;
                <span class="enscript-keyword">for</span> (server = m-&gt;DNSServers; server; server = server-&gt;next)
                {
                    <span class="enscript-keyword">if</span> ((((uintptr_t)server-&gt;interface) == ifIndex) &amp;&amp; !(server-&gt;flags &amp; DNSServerFlag_Delete))
                    {
                        <span class="enscript-keyword">break</span>;
                    }
                }
                <span class="enscript-keyword">if</span> (!server)
                {
                    mdns_retain(monitor);
                    CFArrayRemoveValueAtIndex(m-&gt;p-&gt;InterfaceMonitors, i);
                    mdns_interface_monitor_invalidate(monitor);
                    mdns_release(monitor);
                }
            }

            <span class="enscript-comment">// Acking provides a hint to other processes that the current DNS configuration has completed
</span>            <span class="enscript-comment">// its update.  When configd receives the ack, it publishes a notification.
</span>            <span class="enscript-comment">// Applications monitoring the notification then know when to re-issue their DNS queries
</span>            <span class="enscript-comment">// after a network change occurs.
</span>            <span class="enscript-keyword">if</span> (ackConfig)
            {
                <span class="enscript-comment">// Note: We have to set the generation number here when we are acking.
</span>                <span class="enscript-comment">// For every DNS configuration change, we do the following:
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// 1) Copy dns configuration, handle search domains change
</span>                <span class="enscript-comment">// 2) Copy dns configuration, handle dns server change
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// If we update the generation number at step (1), we won't process the
</span>                <span class="enscript-comment">// DNS servers the second time because generation number would be the same.
</span>                <span class="enscript-comment">// As we ack only when we process dns servers, we set the generation number
</span>                <span class="enscript-comment">// during acking.
</span>                m-&gt;p-&gt;LastConfigGeneration = config-&gt;generation;
                LogInfo(<span class="enscript-string">&quot;mDNSPlatformSetDNSConfig: Acking configuration setservers %d, setsearch %d&quot;</span>, setservers, setsearch);
                AckConfigd(config);
            }
            dns_configuration_free(config);
            <span class="enscript-keyword">if</span> (setsearch) FinalizeSearchDomainHash(&amp;sdc);
        }
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNS_NO_DNSINFO</span>
    SetupDDNSDomains(fqdn, RegDomains, BrowseDomains);
    <span class="enscript-keyword">return</span> mDNStrue;
}


mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformGetPrimaryInterface</span>(mDNSAddr *v4, mDNSAddr *v6, mDNSAddr *r)
{
    <span class="enscript-type">char</span> buf[256];

    CFDictionaryRef dict = SCDynamicStoreCopyValue(NULL, NetworkChangedKey_IPv4);
    <span class="enscript-keyword">if</span> (dict)
    {
        r-&gt;type  = mDNSAddrType_IPv4;
        r-&gt;ip.v4 = zerov4Addr;
        CFStringRef string = CFDictionaryGetValue(dict, kSCPropNetIPv4Router);
        <span class="enscript-keyword">if</span> (string)
        {
            <span class="enscript-keyword">if</span> (!CFStringGetCString(string, buf, 256, kCFStringEncodingUTF8))
                LogMsg(<span class="enscript-string">&quot;Could not convert router to CString&quot;</span>);
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-type">struct</span> sockaddr_in saddr;
                saddr.sin_len = <span class="enscript-keyword">sizeof</span>(saddr);
                saddr.sin_family = AF_INET;
                saddr.sin_port = 0;
                inet_aton(buf, &amp;saddr.sin_addr);
                *(in_addr_t *)&amp;r-&gt;ip.v4 = saddr.sin_addr.s_addr;
            }
        }
        string = CFDictionaryGetValue(dict, kSCDynamicStorePropNetPrimaryInterface);
        <span class="enscript-keyword">if</span> (string)
        {
            mDNSBool HavePrimaryGlobalv6 = mDNSfalse;  <span class="enscript-comment">// does the primary interface have a global v6 address?
</span>            <span class="enscript-type">struct</span> ifaddrs *ifa = myGetIfAddrs(1);
            *v4 = *v6 = zeroAddr;

            <span class="enscript-keyword">if</span> (!CFStringGetCString(string, buf, 256, kCFStringEncodingUTF8)) 
            { 
                LogMsg(<span class="enscript-string">&quot;Could not convert router to CString&quot;</span>); 
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; 
            }
            <span class="enscript-comment">// find primary interface in list
</span>            <span class="enscript-keyword">while</span> (ifa &amp;&amp; (mDNSIPv4AddressIsZero(v4-&gt;ip.v4) || mDNSv4AddressIsLinkLocal(&amp;v4-&gt;ip.v4) || !HavePrimaryGlobalv6))
            {
                <span class="enscript-keyword">if</span> (!ifa-&gt;ifa_addr)
                {
                    LogMsg(<span class="enscript-string">&quot;Skip interface, %s, since ifa_addr is not set.&quot;</span>, (ifa-&gt;ifa_name) ? ifa-&gt;ifa_name: <span class="enscript-string">&quot;name not found&quot;</span>);
                    ifa = ifa-&gt;ifa_next;
                    <span class="enscript-keyword">continue</span>;
                }
                mDNSAddr tmp6 = zeroAddr;
                <span class="enscript-keyword">if</span> (!strcmp(buf, ifa-&gt;ifa_name))
                {
                    <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET)
                    {
                        <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(v4-&gt;ip.v4) || mDNSv4AddressIsLinkLocal(&amp;v4-&gt;ip.v4)) 
                            SetupAddr(v4, ifa-&gt;ifa_addr);
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6)
                    {
                        SetupAddr(&amp;tmp6, ifa-&gt;ifa_addr);
                        <span class="enscript-keyword">if</span> (tmp6.ip.v6.b[0] &gt;&gt; 5 == 1)   <span class="enscript-comment">// global prefix: 001
</span>                        { 
                            HavePrimaryGlobalv6 = mDNStrue; 
                            *v6 = tmp6; 
                        }
                    }
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// We'll take a V6 address from the non-primary interface if the primary interface doesn't have a global V6 address
</span>                    <span class="enscript-keyword">if</span> (!HavePrimaryGlobalv6 &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6 &amp;&amp; !v6-&gt;ip.v6.b[0])
                    {
                        SetupAddr(&amp;tmp6, ifa-&gt;ifa_addr);
                        <span class="enscript-keyword">if</span> (tmp6.ip.v6.b[0] &gt;&gt; 5 == 1) 
                            *v6 = tmp6;
                    }
                }
                ifa = ifa-&gt;ifa_next;
            }
            <span class="enscript-comment">// Note that while we advertise v6, we still require v4 (possibly NAT'd, but not link-local) because we must use
</span>            <span class="enscript-comment">// V4 to communicate w/ our DNS server
</span>        }

<span class="enscript-reference">exit</span>:
        CFRelease(dict);
    }
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformDynDNSHostNameStatusChanged</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> dname, <span class="enscript-type">const</span> mStatus status)
{
    LogInfo(<span class="enscript-string">&quot;mDNSPlatformDynDNSHostNameStatusChanged %d %##s&quot;</span>, status, dname-&gt;c);
    <span class="enscript-type">char</span> uname[MAX_ESCAPED_DOMAIN_NAME];    <span class="enscript-comment">// Max legal C-string name, including terminating NUL
</span>    ConvertDomainNameToCString(dname, uname);

    <span class="enscript-type">char</span> *p = uname;
    <span class="enscript-keyword">while</span> (*p)
    {
        *p = tolower(*p);
        <span class="enscript-keyword">if</span> (!(*(p+1)) &amp;&amp; *p == <span class="enscript-string">'.'</span>) *p = 0; <span class="enscript-comment">// if last character, strip trailing dot
</span>        p++;
    }

    <span class="enscript-comment">// We need to make a CFDictionary called &quot;State:/Network/DynamicDNS&quot; containing (at present) a single entity.
</span>    <span class="enscript-comment">// That single entity is a CFDictionary with name &quot;HostNames&quot;.
</span>    <span class="enscript-comment">// The &quot;HostNames&quot; CFDictionary contains a set of name/value pairs, where the each name is the FQDN
</span>    <span class="enscript-comment">// in question, and the corresponding value is a CFDictionary giving the state for that FQDN.
</span>    <span class="enscript-comment">// (At present we only support a single FQDN, so this dictionary holds just a single name/value pair.)
</span>    <span class="enscript-comment">// The CFDictionary for each FQDN holds (at present) a single name/value pair,
</span>    <span class="enscript-comment">// where the name is &quot;Status&quot; and the value is a CFNumber giving an errror code (with zero meaning success).
</span>
    <span class="enscript-type">const</span> CFStringRef StateKeys [1] = { CFSTR(<span class="enscript-string">&quot;HostNames&quot;</span>) };
    <span class="enscript-type">const</span> CFStringRef HostKeys  [1] = { CFStringCreateWithCString(NULL, uname, kCFStringEncodingUTF8) };
    <span class="enscript-type">const</span> CFStringRef StatusKeys[1] = { CFSTR(<span class="enscript-string">&quot;Status&quot;</span>) };
    <span class="enscript-keyword">if</span> (!HostKeys[0]) LogMsg(<span class="enscript-string">&quot;SetDDNSNameStatus: CFStringCreateWithCString(%s) failed&quot;</span>, uname);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">const</span> CFNumberRef StatusVals[1] = { CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;status) };
        <span class="enscript-keyword">if</span> (StatusVals[0] == NULL) LogMsg(<span class="enscript-string">&quot;SetDDNSNameStatus: CFNumberCreate(%d) failed&quot;</span>, status);
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-type">const</span> CFDictionaryRef HostVals[1] = { CFDictionaryCreate(NULL, (<span class="enscript-type">void</span>*)StatusKeys, (<span class="enscript-type">void</span>*)StatusVals, 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks) };
            <span class="enscript-keyword">if</span> (HostVals[0])
            {
                <span class="enscript-type">const</span> CFDictionaryRef StateVals[1] = { CFDictionaryCreate(NULL, (<span class="enscript-type">void</span>*)HostKeys, (<span class="enscript-type">void</span>*)HostVals, 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks) };
                <span class="enscript-keyword">if</span> (StateVals[0])
                {
                    CFDictionaryRef StateDict = CFDictionaryCreate(NULL, (<span class="enscript-type">void</span>*)StateKeys, (<span class="enscript-type">void</span>*)StateVals, 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
                    <span class="enscript-keyword">if</span> (StateDict)
                    {
                        mDNSDynamicStoreSetConfig(kmDNSDynamicConfig, mDNSNULL, StateDict);
                        CFRelease(StateDict);
                    }
                    CFRelease(StateVals[0]);
                }
                CFRelease(HostVals[0]);
            }
            CFRelease(StatusVals[0]);
        }
        CFRelease(HostKeys[0]);
    }
}

<span class="enscript-comment">// MUST be called holding the lock
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetDomainSecrets_internal</span>(mDNS *m)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
        (<span class="enscript-type">void</span>) m;
    LogMsg(<span class="enscript-string">&quot;Note: SetDomainSecrets: no keychain support&quot;</span>);
#<span class="enscript-reference">else</span>

    LogInfo(<span class="enscript-string">&quot;SetDomainSecrets&quot;</span>);

    <span class="enscript-comment">// Rather than immediately deleting all keys now, we mark them for deletion in ten seconds.
</span>    <span class="enscript-comment">// In the case where the user simultaneously removes their DDNS host name and the key
</span>    <span class="enscript-comment">// for it, this gives mDNSResponder ten seconds to gracefully delete the name from the
</span>    <span class="enscript-comment">// server before it loses access to the necessary key. Otherwise, we'd leave orphaned
</span>    <span class="enscript-comment">// address records behind that we no longer have permission to delete.
</span>    DomainAuthInfo *ptr;
    <span class="enscript-keyword">for</span> (ptr = m-&gt;AuthInfoList; ptr; ptr = ptr-&gt;next)
        ptr-&gt;deltime = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond*10);

    <span class="enscript-comment">// String Array used to write list of private domains to Dynamic Store
</span>    CFMutableArrayRef sa = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);
    <span class="enscript-keyword">if</span> (!sa) { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: CFArrayCreateMutable failed&quot;</span>); <span class="enscript-keyword">return</span>; }
    CFIndex i;
    CFDataRef data = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> itemsPerEntry = 4; <span class="enscript-comment">// domain name, key name, key value, Name value
</span>    CFArrayRef secrets = NULL;
    <span class="enscript-type">int</span> err = mDNSKeychainGetSecrets(&amp;secrets);
    <span class="enscript-keyword">if</span> (err || !secrets)
        LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: mDNSKeychainGetSecrets failed error %d CFArrayRef %p&quot;</span>, err, secrets);
    <span class="enscript-keyword">else</span>
    {
        CFIndex ArrayCount = CFArrayGetCount(secrets);
        <span class="enscript-comment">// Iterate through the secrets
</span>        <span class="enscript-keyword">for</span> (i = 0; i &lt; ArrayCount; ++i)
        {
            <span class="enscript-type">int</span> j, offset;
            CFArrayRef entry = CFArrayGetValueAtIndex(secrets, i);
            <span class="enscript-keyword">if</span> (CFArrayGetTypeID() != CFGetTypeID(entry) || itemsPerEntry != CFArrayGetCount(entry))
            { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: malformed entry %d, itemsPerEntry %d&quot;</span>, i, itemsPerEntry); <span class="enscript-keyword">continue</span>; }
            <span class="enscript-keyword">for</span> (j = 0; j &lt; CFArrayGetCount(entry); ++j)
                <span class="enscript-keyword">if</span> (CFDataGetTypeID() != CFGetTypeID(CFArrayGetValueAtIndex(entry, j)))
                { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: malformed entry item %d&quot;</span>, j); <span class="enscript-keyword">continue</span>; }

            <span class="enscript-comment">// The names have already been vetted by the helper, but checking them again here helps humans and automated tools verify correctness
</span>
            <span class="enscript-comment">// Max legal domainname as C-string, including space for dnsprefix and terminating NUL
</span>            <span class="enscript-comment">// Get DNS domain this key is for (kmDNSKcWhere)
</span>            <span class="enscript-type">char</span> stringbuf[MAX_ESCAPED_DOMAIN_NAME + <span class="enscript-keyword">sizeof</span>(dnsprefix)];
            data = CFArrayGetValueAtIndex(entry, kmDNSKcWhere);
            <span class="enscript-keyword">if</span> (CFDataGetLength(data) &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(stringbuf))
            { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: Bad kSecServiceItemAttr length %d&quot;</span>, CFDataGetLength(data)); <span class="enscript-keyword">continue</span>; }
            CFDataGetBytes(data, CFRangeMake(0, CFDataGetLength(data)), (UInt8 *)stringbuf);
            stringbuf[CFDataGetLength(data)] = <span class="enscript-string">'\0'</span>;

            offset = 0;
            <span class="enscript-keyword">if</span> (!strncmp(stringbuf, dnsprefix, strlen(dnsprefix)))
                offset = strlen(dnsprefix);

            domainname domain;
            <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;domain, stringbuf + offset)) { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: bad key domain %s&quot;</span>, stringbuf); <span class="enscript-keyword">continue</span>; }

            <span class="enscript-comment">// Get key name (kmDNSKcAccount)
</span>            data = CFArrayGetValueAtIndex(entry, kmDNSKcAccount);
            <span class="enscript-keyword">if</span> (CFDataGetLength(data) &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(stringbuf))
            { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: Bad kSecAccountItemAttr length %d&quot;</span>, CFDataGetLength(data)); <span class="enscript-keyword">continue</span>; }
            CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8 *)stringbuf);
            stringbuf[CFDataGetLength(data)] = <span class="enscript-string">'\0'</span>;

            domainname keyname;
            <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;keyname, stringbuf)) { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: bad key name %s&quot;</span>, stringbuf); <span class="enscript-keyword">continue</span>; }

            <span class="enscript-comment">// Get key data (kmDNSKcKey)
</span>            data = CFArrayGetValueAtIndex(entry, kmDNSKcKey);
            <span class="enscript-keyword">if</span> (CFDataGetLength(data) &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(stringbuf))
            { 
                LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: Shared secret too long: %d&quot;</span>, CFDataGetLength(data));
                <span class="enscript-keyword">continue</span>;
            }
            CFDataGetBytes(data, CFRangeMake(0, CFDataGetLength(data)), (UInt8 *)stringbuf);
            stringbuf[CFDataGetLength(data)] = <span class="enscript-string">'\0'</span>;    <span class="enscript-comment">// mDNS_SetSecretForDomain requires NULL-terminated C string for key
</span>
            <span class="enscript-comment">// Get the Name of the keychain entry (kmDNSKcName) host or host:port
</span>            <span class="enscript-comment">// The hostname also has the port number and &quot;:&quot;. It should take a maximum of 6 bytes.
</span>            <span class="enscript-type">char</span> hostbuf[MAX_ESCAPED_DOMAIN_NAME + 6];  <span class="enscript-comment">// Max legal domainname as C-string, including terminating NUL
</span>            data = CFArrayGetValueAtIndex(entry, kmDNSKcName);
            <span class="enscript-keyword">if</span> (CFDataGetLength(data) &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(hostbuf))
            { 
                LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: host:port data too long: %d&quot;</span>, CFDataGetLength(data));
                <span class="enscript-keyword">continue</span>;
            }
            CFDataGetBytes(data, CFRangeMake(0,CFDataGetLength(data)), (UInt8 *)hostbuf);
            hostbuf[CFDataGetLength(data)] = <span class="enscript-string">'\0'</span>;

            domainname hostname;
            mDNSIPPort port;
            <span class="enscript-type">char</span> *hptr;
            hptr = strchr(hostbuf, <span class="enscript-string">':'</span>);

            port.NotAnInteger = 0;
            <span class="enscript-keyword">if</span> (hptr)
            {
                mDNSu8 *p;
                mDNSu16 val = 0;

                *hptr++ = <span class="enscript-string">'\0'</span>;
                <span class="enscript-keyword">while</span>(hptr &amp;&amp; *hptr != 0)
                {
                    <span class="enscript-keyword">if</span> (*hptr &lt; <span class="enscript-string">'0'</span> || *hptr &gt; <span class="enscript-string">'9'</span>)
                    { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: Malformed Port number %d, val %d&quot;</span>, *hptr, val); val = 0; <span class="enscript-keyword">break</span>;}
                    val = val * 10 + *hptr - <span class="enscript-string">'0'</span>;
                    hptr++;
                }
                <span class="enscript-keyword">if</span> (!val) <span class="enscript-keyword">continue</span>;
                p = (mDNSu8 *)&amp;val;
                port.NotAnInteger = p[0] &lt;&lt; 8 | p[1];
            }
            <span class="enscript-comment">// The hostbuf is of the format dsid@hostname:port. We don't care about the dsid.
</span>            hptr = strchr(hostbuf, <span class="enscript-string">'@'</span>);
            <span class="enscript-keyword">if</span> (hptr)
                hptr++;
            <span class="enscript-keyword">else</span>
                hptr = hostbuf;
            <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;hostname, hptr)) { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: bad host name %s&quot;</span>, hptr); <span class="enscript-keyword">continue</span>; }

            DomainAuthInfo *FoundInList;
            <span class="enscript-keyword">for</span> (FoundInList = m-&gt;AuthInfoList; FoundInList; FoundInList = FoundInList-&gt;next)
                <span class="enscript-keyword">if</span> (SameDomainName(&amp;FoundInList-&gt;domain, &amp;domain)) <span class="enscript-keyword">break</span>;

            <span class="enscript-comment">// Uncomment the line below to view the keys as they're read out of the system keychain
</span>            <span class="enscript-comment">// DO NOT SHIP CODE THIS WAY OR YOU'LL LEAK SECRET DATA INTO A PUBLICLY READABLE FILE!
</span>            <span class="enscript-comment">//LogInfo(&quot;SetDomainSecrets: domain %##s keyname %##s key %s hostname %##s port %d&quot;, &amp;domain.c, &amp;keyname.c, stringbuf, hostname.c, (port.b[0] &lt;&lt; 8 | port.b[1]));
</span>            LogInfo(<span class="enscript-string">&quot;SetDomainSecrets: domain %##s keyname %##s hostname %##s port %d&quot;</span>, &amp;domain.c, &amp;keyname.c, hostname.c, (port.b[0] &lt;&lt; 8 | port.b[1]));

            <span class="enscript-comment">// If didn't find desired domain in the list, make a new entry
</span>            ptr = FoundInList;
            <span class="enscript-keyword">if</span> (!FoundInList)
            {
                ptr = (DomainAuthInfo*) callocL(<span class="enscript-string">&quot;DomainAuthInfo&quot;</span>, <span class="enscript-keyword">sizeof</span>(*ptr));
                <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;SetDomainSecrets: No memory&quot;</span>); <span class="enscript-keyword">continue</span>; }
            }

            <span class="enscript-keyword">if</span> (mDNS_SetSecretForDomain(m, ptr, &amp;domain, &amp;keyname, stringbuf, &amp;hostname, &amp;port) == mStatus_BadParamErr)
            {
                <span class="enscript-keyword">if</span> (!FoundInList) mDNSPlatformMemFree(ptr);     <span class="enscript-comment">// If we made a new DomainAuthInfo here, and it turned out bad, dispose it immediately
</span>                <span class="enscript-keyword">continue</span>;
            }

            ConvertDomainNameToCString(&amp;domain, stringbuf);
            CFStringRef cfs = CFStringCreateWithCString(NULL, stringbuf, kCFStringEncodingUTF8);
            <span class="enscript-keyword">if</span> (cfs) { CFArrayAppendValue(sa, cfs); CFRelease(cfs); }
        }
        CFRelease(secrets);
    }

    <span class="enscript-keyword">if</span> (!privateDnsArray || !CFEqual(privateDnsArray, sa))
    {
        <span class="enscript-keyword">if</span> (privateDnsArray)
            CFRelease(privateDnsArray);
        
        privateDnsArray = sa;
        CFRetain(privateDnsArray);
        mDNSDynamicStoreSetConfig(kmDNSPrivateConfig, mDNSNULL, privateDnsArray);
    }
    CFRelease(sa);

    CheckSuppressUnusableQuestions(m);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_SECURITYFRAMEWORK */</span>
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SetDomainSecrets</span>(mDNS *m)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-comment">// Don't get secrets for BTMM if running in debug mode
</span>    <span class="enscript-keyword">if</span> (!IsDebugSocketInUse())
#<span class="enscript-reference">endif</span>
    SetDomainSecrets_internal(m);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetLocalDomains</span>(<span class="enscript-type">void</span>)
{
    CFMutableArrayRef sa = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);
    <span class="enscript-keyword">if</span> (!sa) { LogMsg(<span class="enscript-string">&quot;SetLocalDomains: CFArrayCreateMutable failed&quot;</span>); <span class="enscript-keyword">return</span>; }

    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;local&quot;</span>));
    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;254.169.in-addr.arpa&quot;</span>));
    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;8.e.f.ip6.arpa&quot;</span>));
    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;9.e.f.ip6.arpa&quot;</span>));
    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;a.e.f.ip6.arpa&quot;</span>));
    CFArrayAppendValue(sa, CFSTR(<span class="enscript-string">&quot;b.e.f.ip6.arpa&quot;</span>));

    mDNSDynamicStoreSetConfig(kmDNSMulticastConfig, mDNSNULL, sa);
    CFRelease(sa);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">NO_WAKE_FOR_NET_ACCESS</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetCurrentPMSetting</span>(<span class="enscript-type">const</span> CFStringRef name, mDNSs32 *val)
{
    CFDictionaryRef dict = SCDynamicStoreCopyValue(NULL, NetworkChangedKey_PowerSettings);
    <span class="enscript-keyword">if</span> (!dict)
    {
        LogSPS(<span class="enscript-string">&quot;GetCurrentPMSetting: Could not get IOPM CurrentSettings dict&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
    {
        CFNumberRef number = CFDictionaryGetValue(dict, name);
        <span class="enscript-keyword">if</span> ((number == NULL) || CFGetTypeID(number) != CFNumberGetTypeID() || !CFNumberGetValue(number, kCFNumberSInt32Type, val))
            *val = 0;
        CFRelease(dict);
    }
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

<span class="enscript-type">static</span> CFMutableDictionaryRef spsStatusDict = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFStringRef kMetricRef = CFSTR(<span class="enscript-string">&quot;Metric&quot;</span>);

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SPSStatusPutNumber</span>(CFMutableDictionaryRef dict, <span class="enscript-type">const</span> mDNSu8* <span class="enscript-type">const</span> ptr, CFStringRef key)
{
    mDNSu8 tmp = (ptr[0] - <span class="enscript-string">'0'</span>) * 10 + ptr[1] - <span class="enscript-string">'0'</span>;
    CFNumberRef num = CFNumberCreate(NULL, kCFNumberSInt8Type, &amp;tmp);
    <span class="enscript-keyword">if</span> (num == NULL)
        LogMsg(<span class="enscript-string">&quot;SPSStatusPutNumber: Could not create CFNumber&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        CFDictionarySetValue(dict, key, num);
        CFRelease(num);
    }
}

mDNSlocal CFMutableDictionaryRef <span class="enscript-function-name">SPSCreateDict</span>(<span class="enscript-type">const</span> mDNSu8* <span class="enscript-type">const</span> ptr)
{
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
    <span class="enscript-keyword">if</span> (!dict) { LogMsg(<span class="enscript-string">&quot;SPSCreateDict: Could not create CFDictionary dict&quot;</span>); <span class="enscript-keyword">return</span> dict; }

    <span class="enscript-type">char</span> buffer[1024];
    buffer[mDNS_snprintf(buffer, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot;%##s&quot;</span>, ptr) - 1] = 0;
    CFStringRef spsname = CFStringCreateWithCString(NULL, buffer, kCFStringEncodingUTF8);
    <span class="enscript-keyword">if</span> (!spsname) { LogMsg(<span class="enscript-string">&quot;SPSCreateDict: Could not create CFString spsname full&quot;</span>); CFRelease(dict); <span class="enscript-keyword">return</span> NULL; }
    CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;FullName&quot;</span>), spsname);
    CFRelease(spsname);

    <span class="enscript-keyword">if</span> (ptr[0] &gt;=  2) SPSStatusPutNumber(dict, ptr + 1, CFSTR(<span class="enscript-string">&quot;Type&quot;</span>));
    <span class="enscript-keyword">if</span> (ptr[0] &gt;=  5) SPSStatusPutNumber(dict, ptr + 4, CFSTR(<span class="enscript-string">&quot;Portability&quot;</span>));
    <span class="enscript-keyword">if</span> (ptr[0] &gt;=  8) SPSStatusPutNumber(dict, ptr + 7, CFSTR(<span class="enscript-string">&quot;MarginalPower&quot;</span>));
    <span class="enscript-keyword">if</span> (ptr[0] &gt;= 11) SPSStatusPutNumber(dict, ptr +10, CFSTR(<span class="enscript-string">&quot;TotalPower&quot;</span>));

    mDNSu32 tmp = SPSMetric(ptr);
    CFNumberRef num = CFNumberCreate(NULL, kCFNumberSInt32Type, &amp;tmp);
    <span class="enscript-keyword">if</span> (num == NULL)
        LogMsg(<span class="enscript-string">&quot;SPSCreateDict: Could not create CFNumber&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        CFDictionarySetValue(dict, kMetricRef, num);
        CFRelease(num);
    }

    <span class="enscript-keyword">if</span> (ptr[0] &gt;= 12)
    {
        memcpy(buffer, ptr + 13, ptr[0] - 12);
        buffer[ptr[0] - 12] = 0;
        spsname = CFStringCreateWithCString(NULL, buffer, kCFStringEncodingUTF8);
        <span class="enscript-keyword">if</span> (!spsname) { LogMsg(<span class="enscript-string">&quot;SPSCreateDict: Could not create CFString spsname&quot;</span>); CFRelease(dict); <span class="enscript-keyword">return</span> NULL; }
        <span class="enscript-keyword">else</span>
        {
            CFDictionarySetValue(dict, CFSTR(<span class="enscript-string">&quot;PrettyName&quot;</span>), spsname);
            CFRelease(spsname);
        }
    }

    <span class="enscript-keyword">return</span> dict;
}

mDNSlocal CFComparisonResult <span class="enscript-function-name">CompareSPSEntries</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *val1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *val2, <span class="enscript-type">void</span> *context)
{
    (<span class="enscript-type">void</span>)context;
    <span class="enscript-keyword">return</span> CFNumberCompare((CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)val1, kMetricRef),
                           (CFNumberRef)CFDictionaryGetValue((CFDictionaryRef)val2, kMetricRef),
                           NULL);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateSPSStatus</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    NetworkInterfaceInfo* info = (NetworkInterfaceInfo*)question-&gt;QuestionContext;
    debugf(<span class="enscript-string">&quot;UpdateSPSStatus: %s %##s %s %s&quot;</span>, info-&gt;ifname, question-&gt;qname.c, AddRecord ? <span class="enscript-string">&quot;Add&quot;</span> : <span class="enscript-string">&quot;Rmv&quot;</span>, answer ? RRDisplayString(m, answer) : <span class="enscript-string">&quot;&lt;null&gt;&quot;</span>);

    mDNS_Lock(m);
    mDNS_UpdateAllowSleep(m);
    mDNS_Unlock(m);

    <span class="enscript-keyword">if</span> (answer &amp;&amp; SPSMetric(answer-&gt;rdata-&gt;u.name.c) &gt; 999999) <span class="enscript-keyword">return</span>;  <span class="enscript-comment">// Ignore instances with invalid names
</span>
    <span class="enscript-keyword">if</span> (!spsStatusDict)
    {
        spsStatusDict = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
        <span class="enscript-keyword">if</span> (!spsStatusDict) { LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: Could not create CFDictionary spsStatusDict&quot;</span>); <span class="enscript-keyword">return</span>; }
    }

    CFStringRef ifname = CFStringCreateWithCString(NULL, info-&gt;ifname, kCFStringEncodingUTF8);
    <span class="enscript-keyword">if</span> (!ifname) { LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: Could not create CFString ifname&quot;</span>); <span class="enscript-keyword">return</span>; }

    CFMutableArrayRef array = NULL;

    <span class="enscript-keyword">if</span> (!CFDictionaryGetValueIfPresent(spsStatusDict, ifname, (<span class="enscript-type">const</span> <span class="enscript-type">void</span>**) &amp;array))
    {
        array = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);
        <span class="enscript-keyword">if</span> (!array) { LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: Could not create CFMutableArray&quot;</span>); CFRelease(ifname); <span class="enscript-keyword">return</span>; }
        CFDictionarySetValue(spsStatusDict, ifname, array);
        CFRelease(array); <span class="enscript-comment">// let go of our reference, now that the dict has one
</span>    }
    <span class="enscript-keyword">else</span>
    <span class="enscript-keyword">if</span> (!array) { LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: Could not get CFMutableArray for %s&quot;</span>, info-&gt;ifname); CFRelease(ifname); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (!answer) <span class="enscript-comment">// special call that means the question has been stopped (because the interface is going away)
</span>        CFArrayRemoveAllValues(array);
    <span class="enscript-keyword">else</span>
    {
        CFMutableDictionaryRef dict = SPSCreateDict(answer-&gt;rdata-&gt;u.name.c);
        <span class="enscript-keyword">if</span> (!dict) { CFRelease(ifname); <span class="enscript-keyword">return</span>; }

        <span class="enscript-keyword">if</span> (AddRecord)
        {
            <span class="enscript-keyword">if</span> (!CFArrayContainsValue(array, CFRangeMake(0, CFArrayGetCount(array)), dict))
            {
                <span class="enscript-type">int</span> i=0;
                <span class="enscript-keyword">for</span> (i=0; i&lt;CFArrayGetCount(array); i++)
                    <span class="enscript-keyword">if</span> (CompareSPSEntries(CFArrayGetValueAtIndex(array, i), dict, NULL) != kCFCompareLessThan)
                        <span class="enscript-keyword">break</span>;
                CFArrayInsertValueAtIndex(array, i, dict);
            }
            <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: %s array already contains %##s&quot;</span>, info-&gt;ifname, answer-&gt;rdata-&gt;u.name.c);
        }
        <span class="enscript-keyword">else</span>
        {
            CFIndex i = CFArrayGetFirstIndexOfValue(array, CFRangeMake(0, CFArrayGetCount(array)), dict);
            <span class="enscript-keyword">if</span> (i != -1) CFArrayRemoveValueAtIndex(array, i);
            <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;UpdateSPSStatus: %s array does not contain %##s&quot;</span>, info-&gt;ifname, answer-&gt;rdata-&gt;u.name.c);
        }

        CFRelease(dict);
    }

    <span class="enscript-keyword">if</span> (!m-&gt;ShutdownTime) mDNSDynamicStoreSetConfig(kmDNSSleepProxyServersState, info-&gt;ifname, array);

    CFRelease(ifname);
}

mDNSlocal mDNSs32 <span class="enscript-function-name">GetSystemSleepTimerSetting</span>(<span class="enscript-type">void</span>)
{
    mDNSs32 val = -1;
    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:GetSystemSleepTimerSetting&quot;</span>), NULL, NULL);
    <span class="enscript-keyword">if</span> (!store)
        LogMsg(<span class="enscript-string">&quot;GetSystemSleepTimerSetting: SCDynamicStoreCreate failed: %s&quot;</span>, SCErrorString(SCError()));
    <span class="enscript-keyword">else</span>
    {
        CFDictionaryRef dict = SCDynamicStoreCopyValue(store, NetworkChangedKey_PowerSettings);
        <span class="enscript-keyword">if</span> (dict)
        {
            CFNumberRef number = CFDictionaryGetValue(dict, CFSTR(<span class="enscript-string">&quot;System Sleep Timer&quot;</span>));
            <span class="enscript-keyword">if</span> (number != NULL) CFNumberGetValue(number, kCFNumberSInt32Type, &amp;val);
            CFRelease(dict);
        }
        CFRelease(store);
    }
    <span class="enscript-keyword">return</span> val;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetSPS</span>(mDNS *<span class="enscript-type">const</span> m)
{
    
    <span class="enscript-comment">// If we ever want to know InternetSharing status in the future, use DNSXEnableProxy()
</span>    mDNSu8 sps = (OfferSleepProxyService &amp;&amp; GetSystemSleepTimerSetting() == 0) ? mDNSSleepProxyMetric_IncidentalSoftware : 0;

    <span class="enscript-comment">// For devices that are not running NAT, but are set to never sleep, we may choose to act
</span>    <span class="enscript-comment">// as a Sleep Proxy, but only for non-portable Macs (Portability &gt; 35 means nominal weight &lt; 3kg)
</span>    <span class="enscript-comment">//if (sps &gt; mDNSSleepProxyMetric_PrimarySoftware &amp;&amp; SPMetricPortability &gt; 35) sps = 0;
</span>
    <span class="enscript-comment">// If we decide to let laptops act as Sleep Proxy, we should do it only when running on AC power, not on battery
</span>
    <span class="enscript-comment">// For devices that are unable to sleep at all to save power, or save 1W or less by sleeping,
</span>    <span class="enscript-comment">// it makes sense for them to offer low-priority Sleep Proxy service on the network.
</span>    <span class="enscript-comment">// We rate such a device as metric 70 (&quot;Incidentally Available Hardware&quot;)
</span>    <span class="enscript-keyword">if</span> (SPMetricMarginalPower &lt;= 60 &amp;&amp; !sps) sps = mDNSSleepProxyMetric_IncidentalHardware;

    <span class="enscript-comment">// If the launchd plist specifies an explicit value for the Intent Metric, then use that instead of the
</span>    <span class="enscript-comment">// computed value (currently 40 &quot;Primary Network Infrastructure Software&quot; or 80 &quot;Incidentally Available Software&quot;)
</span>    <span class="enscript-keyword">if</span> (sps &amp;&amp; OfferSleepProxyService &amp;&amp; OfferSleepProxyService &lt; 100) sps = OfferSleepProxyService;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_APPLETV_SLEEP_PROXY_ON_WIFI</span>
    <span class="enscript-comment">// AppleTVs are not reliable sleep proxy servers on WiFi. Do not offer to be a BSP if the WiFi interface is active.
</span>    <span class="enscript-keyword">if</span> (IsAppleTV())
    {
        NetworkInterfaceInfo *intf  = mDNSNULL;
        mDNSEthAddr           bssid = zeroEthAddr;
        <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        {
            <span class="enscript-keyword">if</span> (intf-&gt;InterfaceID == AWDLInterfaceID) <span class="enscript-keyword">continue</span>;
            bssid = GetBSSID(intf-&gt;ifname);
            <span class="enscript-keyword">if</span> (!mDNSSameEthAddress(&amp;bssid, &amp;zeroEthAddr))
            {
                LogMsg(<span class="enscript-string">&quot;SetSPS: AppleTV on WiFi - not advertising BSP services&quot;</span>);
                sps = 0;
                <span class="enscript-keyword">break</span>;
            }
        }
    }
#<span class="enscript-reference">endif</span>  //  <span class="enscript-variable-name">NO_APPLETV_SLEEP_PROXY_ON_WIFI</span>

    mDNSCoreBeSleepProxyServer(m, sps, SPMetricPortability, SPMetricMarginalPower, SPMetricTotalPower, SPMetricFeatures);
}

<span class="enscript-comment">// The definitions below should eventually come from some externally-supplied header file.
</span><span class="enscript-comment">// However, since these definitions can't really be changed without breaking binary compatibility,
</span><span class="enscript-comment">// they should never change, so in practice it should not be a big problem to have them defined here.
</span>
<span class="enscript-type">enum</span>
{                               <span class="enscript-comment">// commands from the daemon to the driver
</span>    cmd_mDNSOffloadRR = 21,     <span class="enscript-comment">// give the mdns update buffer to the driver
</span>};

<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> { <span class="enscript-type">void</span> *ptr; mDNSOpaque64 sixtyfourbits; } FatPtr;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{                                       <span class="enscript-comment">// cmd_mDNSOffloadRR structure
</span>    uint32_t command;                 <span class="enscript-comment">// set to OffloadRR
</span>    uint32_t rrBufferSize;            <span class="enscript-comment">// number of bytes of RR records
</span>    uint32_t numUDPPorts;             <span class="enscript-comment">// number of SRV UDP ports
</span>    uint32_t numTCPPorts;             <span class="enscript-comment">// number of SRV TCP ports
</span>    uint32_t numRRRecords;            <span class="enscript-comment">// number of RR records
</span>    uint32_t compression;             <span class="enscript-comment">// rrRecords - compression is base for compressed strings
</span>    FatPtr rrRecords;                 <span class="enscript-comment">// address of array of pointers to the rr records
</span>    FatPtr udpPorts;                  <span class="enscript-comment">// address of udp port list (SRV)
</span>    FatPtr tcpPorts;                  <span class="enscript-comment">// address of tcp port list (SRV)
</span>} mDNSOffloadCmd;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dns_util.h&gt;</span>

mDNSlocal mDNSu32 <span class="enscript-function-name">GetPortArray</span>(<span class="enscript-type">int</span> trans, mDNSIPPort *portarray)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> tp = (trans == mDNSTransport_UDP) ? (<span class="enscript-type">const</span> domainlabel *)<span class="enscript-string">&quot;\x4_udp&quot;</span> : (<span class="enscript-type">const</span> domainlabel *)<span class="enscript-string">&quot;\x4_tcp&quot;</span>;
    mDNSu32 count = 0;

    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; SameDomainLabel(ThirdLabel(rr-&gt;resrec.name)-&gt;c, tp-&gt;c))
        {
            <span class="enscript-keyword">if</span> (!portarray)
                count++;
            <span class="enscript-keyword">else</span>
            {
                mDNSu32 i;
                <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++)
                    <span class="enscript-keyword">if</span> (mDNSSameIPPort(portarray[i], rr-&gt;resrec.rdata-&gt;u.srv.port))
                        <span class="enscript-keyword">break</span>;

                <span class="enscript-comment">// Add it into the port list only if it not already present in the list
</span>                <span class="enscript-keyword">if</span> (i &gt;= count)
                    portarray[count++] = rr-&gt;resrec.rdata-&gt;u.srv.port;
            }
        }
    }
    <span class="enscript-keyword">return</span>(count);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
mDNSlocal mDNSBool <span class="enscript-function-name">SupportsTCPKeepAlive</span>()
{
    IOReturn  ret      = kIOReturnSuccess;
    CFTypeRef obj      = NULL;
    mDNSBool  supports = mDNSfalse;

    ret = IOPlatformCopyFeatureActive(CFSTR(<span class="enscript-string">&quot;TCPKeepAliveDuringSleep&quot;</span>), &amp;obj);
    <span class="enscript-keyword">if</span> ((kIOReturnSuccess == ret) &amp;&amp; (obj != NULL))
    {
        supports = (obj ==  kCFBooleanTrue)? mDNStrue : mDNSfalse;
        CFRelease(obj);
    }
    LogSPS(<span class="enscript-string">&quot;%s: The hardware %s TCP Keep Alive&quot;</span>, __func__, (supports ? <span class="enscript-string">&quot;supports&quot;</span> : <span class="enscript-string">&quot;does not support&quot;</span>));
    <span class="enscript-keyword">return</span> supports;
}

mDNSlocal mDNSBool <span class="enscript-function-name">OnBattery</span>(<span class="enscript-type">void</span>)
{
    CFTypeRef powerInfo = IOPSCopyPowerSourcesInfo();
    CFTypeRef powerSrc  = IOPSGetProvidingPowerSourceType(powerInfo);
    mDNSBool  result    = mDNSfalse;

    <span class="enscript-keyword">if</span> (powerInfo != NULL)
    {
        result = CFEqual(CFSTR(kIOPSBatteryPowerValue), powerSrc);
        CFRelease(powerInfo);
    }
    LogSPS(<span class="enscript-string">&quot;%s: The system is on %s&quot;</span>, __func__, (result)? <span class="enscript-string">&quot;Battery&quot;</span> : <span class="enscript-string">&quot;AC Power&quot;</span>);
    <span class="enscript-keyword">return</span> result;
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TfrRecordToNIC</span>(RR) \
    ((!(RR)-&gt;resrec.InterfaceID &amp;&amp; ((RR)-&gt;ForceMCast || IsLocalDomain((RR)-&gt;resrec.name))))

mDNSlocal mDNSu32 <span class="enscript-function-name">CountProxyRecords</span>(uint32_t *<span class="enscript-type">const</span> numbytes, mDNSBool TCPKAOnly, mDNSBool supportsTCPKA)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    *numbytes = 0;
    uint32_t count = 0;
    mDNSBool isKeepAliveRecord = mDNSfalse;

    AuthRecord *rr;

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!(rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) &amp;&amp; rr-&gt;resrec.RecordType &gt; kDNSRecordTypeDeregistering)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
            isKeepAliveRecord = mDNS_KeepaliveRecord(&amp;rr-&gt;resrec);
            <span class="enscript-comment">// Skip over all other records if we are registering TCP KeepAlive records only
</span>            <span class="enscript-comment">// Skip over TCP KeepAlive records if the policy prohibits it or if the interface does not support TCP Keepalive.
</span>            <span class="enscript-keyword">if</span> ((TCPKAOnly &amp;&amp; !isKeepAliveRecord) || (isKeepAliveRecord &amp;&amp; !supportsTCPKA))
                <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">else</span>
            (<span class="enscript-type">void</span>) TCPKAOnly;     <span class="enscript-comment">// unused
</span>            (<span class="enscript-type">void</span>) supportsTCPKA; <span class="enscript-comment">// unused
</span>#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (TfrRecordToNIC(rr))
            {
                <span class="enscript-comment">// For KeepAlive records, use an estimated length of 256, which is the maximum size.
</span>                <span class="enscript-type">const</span> uint32_t rdataLen   = isKeepAliveRecord ? ((uint32_t)<span class="enscript-keyword">sizeof</span>(UTF8str255)) : rr-&gt;resrec.rdestimate;
                <span class="enscript-type">const</span> uint32_t recordSize = DomainNameLength(rr-&gt;resrec.name) + 10 + rdataLen;
                *numbytes += recordSize;
                LogSPS(<span class="enscript-string">&quot;CountProxyRecords: %3u size %5u total %5u %s&quot;</span>, count, recordSize, *numbytes, ARDisplayString(m,rr));
                count++;
            }
        }
    }
    <span class="enscript-keyword">return</span>(count);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetProxyRecords</span>(DNSMessage *<span class="enscript-type">const</span> msg, uint32_t *<span class="enscript-type">const</span> numbytes, FatPtr *<span class="enscript-type">const</span> records,
    uint32_t *outRecordCount, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSBool TCPKAOnly, mDNSBool supportsTCPKA)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSu8 *p = msg-&gt;data;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = p + *numbytes;
    InitializeDNSMessage(&amp;msg-&gt;h, zeroID, zeroID);

    uint32_t count = 0;
    AuthRecord *rr;

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!(rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) &amp;&amp; rr-&gt;resrec.RecordType &gt; kDNSRecordTypeDeregistering)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
            <span class="enscript-type">const</span> mDNSBool isKeepAliveRecord = mDNS_KeepaliveRecord(&amp;rr-&gt;resrec);

            <span class="enscript-comment">// Skip over all other records if we are registering TCP KeepAlive records only
</span>            <span class="enscript-comment">// Skip over TCP KeepAlive records if the policy prohibits it or if the interface does not support TCP Keepalive
</span>            <span class="enscript-comment">// supportsTCPKA is set to true if both policy and interface allow TCP Keepalive
</span>            <span class="enscript-keyword">if</span> ((TCPKAOnly &amp;&amp; !isKeepAliveRecord) || (isKeepAliveRecord &amp;&amp; !supportsTCPKA))
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">// Update the record before calculating the number of bytes required
</span>            <span class="enscript-comment">// We offload the TCP Keepalive record even if the update fails. When the driver gets the record, it will
</span>            <span class="enscript-comment">// attempt to update the record again.
</span>            <span class="enscript-keyword">if</span> (isKeepAliveRecord)
            {
                <span class="enscript-keyword">if</span> (UpdateKeepaliveRData(m, rr, intf, mDNSfalse, mDNSNULL) != mStatus_NoError)
                {
                    LogSPS(<span class="enscript-string">&quot;GetProxyRecords: Failed to update keepalive record - %s&quot;</span>, ARDisplayString(m, rr));
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-comment">// Offload only Valid Keepalive records
</span>                <span class="enscript-keyword">if</span> (!mDNSValidKeepAliveRecord(rr))
                {
                    <span class="enscript-keyword">continue</span>;
                }
            }
#<span class="enscript-reference">else</span>
            (<span class="enscript-type">void</span>) intf;          <span class="enscript-comment">// unused
</span>            (<span class="enscript-type">void</span>) TCPKAOnly;     <span class="enscript-comment">// unused
</span>            (<span class="enscript-type">void</span>) supportsTCPKA; <span class="enscript-comment">// unused
</span>#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (TfrRecordToNIC(rr))
            {
                records[count].sixtyfourbits = zeroOpaque64;
                records[count].ptr = p;
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                    rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;    <span class="enscript-comment">// Temporarily set the 'unique' bit so PutResourceRecord will set it
</span>                p = PutResourceRecordTTLWithLimit(msg, p, &amp;msg-&gt;h.mDNS_numUpdates, &amp;rr-&gt;resrec, rr-&gt;resrec.rroriginalttl, limit);
                rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;       <span class="enscript-comment">// Make sure to clear 'unique' bit back to normal state
</span>                LogSPS(<span class="enscript-string">&quot;GetProxyRecords: %3d start %p end %p size %5d total %5d %s&quot;</span>,
                       count, records[count].ptr, p, p - (mDNSu8 *)records[count].ptr, p - msg-&gt;data, ARDisplayString(m,rr));
                count++;
            }
        }
    }
    *numbytes = p - msg-&gt;data;
    <span class="enscript-keyword">if</span> (outRecordCount) *outRecordCount = count;
}

mDNSexport mDNSBool <span class="enscript-function-name">SupportsInNICProxy</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf)
{
    <span class="enscript-keyword">if</span>(!UseInternalSleepProxy)
    {
        LogMsg(<span class="enscript-string">&quot;SupportsInNICProxy: Internal Sleep Proxy is disabled&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> CheckInterfaceSupport(intf, mDNS_IOREG_KEY);
}

<span class="enscript-comment">// Called with the lock held
</span>mDNSexport mStatus <span class="enscript-function-name">ActivateLocalProxy</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSBool offloadKeepAlivesOnly, mDNSBool *keepaliveOnly)
{
    mStatus      result        = mStatus_UnknownErr;
    mDNSBool     TCPKAOnly     = mDNSfalse;
    mDNSBool     supportsTCPKA = mDNSfalse;
    io_service_t service       = IOServiceGetMatchingService(kIOMasterPortDefault, IOBSDNameMatching(kIOMasterPortDefault, 0, intf-&gt;ifname));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
    <span class="enscript-comment">// Check if the interface supports TCP Keepalives and the system policy says it is ok to offload TCP Keepalive records
</span>    supportsTCPKA = (InterfaceSupportsKeepAlive(intf) &amp;&amp; SupportsTCPKeepAlive()) ? mDNStrue : mDNSfalse;
    <span class="enscript-keyword">if</span> (!offloadKeepAlivesOnly)
    {
        <span class="enscript-comment">// Only TCP Keepalive records are to be offloaded if
</span>        <span class="enscript-comment">// - The system is on battery
</span>        <span class="enscript-comment">// - OR wake for network access is not set but powernap is enabled
</span>        TCPKAOnly = supportsTCPKA &amp;&amp; ((mDNSStorage.SystemWakeOnLANEnabled == mDNS_WakeOnBattery) || OnBattery());
    }
    <span class="enscript-keyword">else</span>
    {
        TCPKAOnly = mDNStrue;
    }
#<span class="enscript-reference">else</span>
    (<span class="enscript-type">void</span>)offloadKeepAlivesOnly; <span class="enscript-comment">// Unused.
</span>#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!service) { LogMsg(<span class="enscript-string">&quot;ActivateLocalProxy: No service for interface %s&quot;</span>, intf-&gt;ifname); <span class="enscript-keyword">return</span>(mStatus_UnknownErr); }

    io_name_t       n1, n2;
    IOObjectGetClass(service, n1);
    
    CFTypeRef       ref;
    io_object_t     parent;
    kern_return_t   kr = RegistryEntrySearchCFPropertyAndIOObject(service, kIOServicePlane, CFSTR(mDNS_IOREG_KEY), &amp;ref, &amp;parent);
    IOObjectRelease(service);
    <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) LogSPS(<span class="enscript-string">&quot;ActivateLocalProxy: No mDNS_IOREG_KEY for interface %s/%s kr %d&quot;</span>, intf-&gt;ifname, n1, kr);
    <span class="enscript-keyword">else</span>
    {
        IOObjectGetClass(parent, n2);
        LogSPS(<span class="enscript-string">&quot;ActivateLocalProxy: Interface %s service %s parent %s&quot;</span>, intf-&gt;ifname, n1, n2);

        <span class="enscript-keyword">if</span> (CFGetTypeID(ref) != CFStringGetTypeID() || !CFEqual(ref, CFSTR(mDNS_IOREG_VALUE)))
            LogMsg(<span class="enscript-string">&quot;ActivateLocalProxy: mDNS_IOREG_KEY for interface %s/%s/%s value %s != %s&quot;</span>,
                   intf-&gt;ifname, n1, n2, CFStringGetCStringPtr(ref, mDNSNULL), mDNS_IOREG_VALUE);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!UseInternalSleepProxy)
            LogSPS(<span class="enscript-string">&quot;ActivateLocalProxy: Not using internal (NIC) sleep proxy for interface %s&quot;</span>, intf-&gt;ifname);
        <span class="enscript-keyword">else</span>
        {
            io_connect_t conObj;
            kr = IOServiceOpen(parent, mach_task_self(), mDNS_USER_CLIENT_CREATE_TYPE, &amp;conObj);
            <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) LogMsg(<span class="enscript-string">&quot;ActivateLocalProxy: IOServiceOpen for %s/%s/%s failed %d&quot;</span>, intf-&gt;ifname, n1, n2, kr);
            <span class="enscript-keyword">else</span>
            {
                mDNSOffloadCmd cmd;
                mDNSPlatformMemZero(&amp;cmd, <span class="enscript-keyword">sizeof</span>(cmd)); <span class="enscript-comment">// When compiling 32-bit, make sure top 32 bits of 64-bit pointers get initialized to zero
</span>                cmd.command       = cmd_mDNSOffloadRR;
                cmd.numUDPPorts   = TCPKAOnly ? 0 : GetPortArray(mDNSTransport_UDP, mDNSNULL);
                cmd.numTCPPorts   = TCPKAOnly ? 0 : GetPortArray(mDNSTransport_TCP, mDNSNULL);
                cmd.numRRRecords  = CountProxyRecords(&amp;cmd.rrBufferSize, TCPKAOnly, supportsTCPKA);
                cmd.compression   = <span class="enscript-keyword">sizeof</span>(DNSMessageHeader);

                DNSMessage *msg   = (DNSMessage *) callocL(<span class="enscript-string">&quot;mDNSOffloadCmd msg&quot;</span>, <span class="enscript-keyword">sizeof</span>(DNSMessageHeader) + cmd.rrBufferSize);
                cmd.rrRecords.ptr = cmd.numRRRecords ? callocL(<span class="enscript-string">&quot;mDNSOffloadCmd rrRecords&quot;</span>, cmd.numRRRecords * <span class="enscript-keyword">sizeof</span>(FatPtr))     : NULL;
                cmd.udpPorts.ptr  = cmd.numUDPPorts  ? callocL(<span class="enscript-string">&quot;mDNSOffloadCmd udpPorts&quot;</span> , cmd.numUDPPorts  * <span class="enscript-keyword">sizeof</span>(mDNSIPPort)) : NULL;
                cmd.tcpPorts.ptr  = cmd.numTCPPorts  ? callocL(<span class="enscript-string">&quot;mDNSOffloadCmd tcpPorts&quot;</span> , cmd.numTCPPorts  * <span class="enscript-keyword">sizeof</span>(mDNSIPPort)) : NULL;

                LogSPS(<span class="enscript-string">&quot;ActivateLocalProxy: msg %p %u RR %p %u, UDP %p %u, TCP %p %u&quot;</span>,
                       msg, cmd.rrBufferSize,
                       cmd.rrRecords.ptr, cmd.numRRRecords,
                       cmd.udpPorts.ptr, cmd.numUDPPorts,
                       cmd.tcpPorts.ptr, cmd.numTCPPorts);

                <span class="enscript-keyword">if</span> (msg &amp;&amp; cmd.rrRecords.ptr)
                {
                    GetProxyRecords(msg, &amp;cmd.rrBufferSize, cmd.rrRecords.ptr, &amp;cmd.numRRRecords, intf, TCPKAOnly, supportsTCPKA);
                }
                <span class="enscript-keyword">if</span> (cmd.udpPorts.ptr) cmd.numUDPPorts = TCPKAOnly ? 0 : GetPortArray(mDNSTransport_UDP, cmd.udpPorts.ptr);
                <span class="enscript-keyword">if</span> (cmd.tcpPorts.ptr) cmd.numTCPPorts = TCPKAOnly ? 0 : GetPortArray(mDNSTransport_TCP, cmd.tcpPorts.ptr);

                <span class="enscript-type">char</span> outputData[2];
                size_t outputDataSize = <span class="enscript-keyword">sizeof</span>(outputData);
                kr = IOConnectCallStructMethod(conObj, 0, &amp;cmd, <span class="enscript-keyword">sizeof</span>(cmd), outputData, &amp;outputDataSize);
                LogSPS(<span class="enscript-string">&quot;ActivateLocalProxy: IOConnectCallStructMethod for %s/%s/%s %d&quot;</span>, intf-&gt;ifname, n1, n2, kr);
                <span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) result = mStatus_NoError;

                <span class="enscript-keyword">if</span> (cmd.tcpPorts.ptr) freeL(<span class="enscript-string">&quot;mDNSOffloadCmd udpPorts&quot;</span>,  cmd.tcpPorts.ptr);
                <span class="enscript-keyword">if</span> (cmd.udpPorts.ptr) freeL(<span class="enscript-string">&quot;mDNSOffloadCmd tcpPorts&quot;</span>,  cmd.udpPorts.ptr);
                <span class="enscript-keyword">if</span> (cmd.rrRecords.ptr) freeL(<span class="enscript-string">&quot;mDNSOffloadCmd rrRecords&quot;</span>, cmd.rrRecords.ptr);
                <span class="enscript-keyword">if</span> (msg) freeL(<span class="enscript-string">&quot;mDNSOffloadCmd msg&quot;</span>,       msg);
                IOServiceClose(conObj);
            }
        }
        CFRelease(ref);
        IOObjectRelease(parent);
    }
    *keepaliveOnly = (TCPKAOnly &amp;&amp; supportsTCPKA) ? mDNStrue : mDNSfalse;
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSlocal mDNSu8 <span class="enscript-function-name">SystemWakeForNetworkAccess</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">NO_WAKE_FOR_NET_ACCESS</span>)
    LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;SystemWakeForNetworkAccess: compile-time disabled&quot;</span>);
    <span class="enscript-keyword">return</span> ((mDNSu8)mDNS_NoWake);
#<span class="enscript-reference">else</span>
    mDNSs32 val = 0;
    mDNSu8  ret = (mDNSu8)mDNS_NoWake;

    <span class="enscript-keyword">if</span> (DisableSleepProxyClient)
    {
       LogSPS(<span class="enscript-string">&quot;SystemWakeForNetworkAccess: Sleep Proxy Client disabled by command-line option&quot;</span>);
       <span class="enscript-keyword">return</span> ret;
    }

    GetCurrentPMSetting(CFSTR(<span class="enscript-string">&quot;Wake On LAN&quot;</span>), &amp;val);

    ret = (mDNSu8)(val != 0) ? mDNS_WakeOnAC : mDNS_NoWake;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
    <span class="enscript-comment">// If we have TCP Keepalive support, system is capable of registering for TCP Keepalives.
</span>    <span class="enscript-comment">// Further policy decisions on whether to offload the records is handled during sleep processing.
</span>    <span class="enscript-keyword">if</span> ((ret == mDNS_NoWake) &amp;&amp; SupportsTCPKeepAlive())
        ret = (mDNSu8)mDNS_WakeOnBattery;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    LogSPS(<span class="enscript-string">&quot;SystemWakeForNetworkAccess: Wake On LAN: %d&quot;</span>, ret);
    <span class="enscript-keyword">return</span> ret;
#<span class="enscript-reference">endif</span>
}

mDNSlocal mDNSBool <span class="enscript-function-name">SystemSleepOnlyIfWakeOnLAN</span>(<span class="enscript-type">void</span>)
{
    mDNSs32 val = 0;
    <span class="enscript-comment">// PrioritizeNetworkReachabilityOverSleep has been deprecated.
</span>    <span class="enscript-comment">// GetCurrentPMSetting(CFSTR(&quot;PrioritizeNetworkReachabilityOverSleep&quot;), &amp;val);
</span>    <span class="enscript-comment">// Statically set the PrioritizeNetworkReachabilityOverSleep value to 1 for AppleTV
</span>    <span class="enscript-keyword">if</span> (IsAppleTV())
        val = 1;
    <span class="enscript-keyword">return</span> val != 0 ? mDNStrue : mDNSfalse;
}

mDNSlocal mDNSBool <span class="enscript-function-name">IsAppleNetwork</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSServer *s;
    <span class="enscript-comment">// Determine if we're on AppleNW based on DNSServer having 17.x.y.z IPv4 addr
</span>    <span class="enscript-keyword">for</span> (s = m-&gt;DNSServers; s; s = s-&gt;next)
    {
        <span class="enscript-keyword">if</span> (s-&gt;addr.ip.v4.b[0] == 17)
        {     
            LogInfo(<span class="enscript-string">&quot;IsAppleNetwork: Found 17.x.y.z DNSServer concluding that we are on AppleNW: %##s %#a&quot;</span>, s-&gt;domain.c, &amp;s-&gt;addr);
            <span class="enscript-keyword">return</span> mDNStrue;
        }     
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Called with KQueueLock &amp; mDNS lock
</span><span class="enscript-comment">// SetNetworkChanged is allowed to shorten (but not extend) the pause while we wait for configuration changes to settle
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetNetworkChanged</span>(mDNSs32 delay)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNS_CheckLock(m);
    <span class="enscript-keyword">if</span> (!m-&gt;NetworkChanged || m-&gt;NetworkChanged - NonZeroTime(m-&gt;timenow + delay) &gt; 0)
    {
        m-&gt;NetworkChanged = NonZeroTime(m-&gt;timenow + delay);
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;SetNetworkChanged: Scheduling in %d ticks&quot;</span>, delay);
    }
    <span class="enscript-keyword">else</span>
   	{
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;SetNetworkChanged: *NOT* increasing delay from %d to %d&quot;</span>, m-&gt;NetworkChanged - m-&gt;timenow, delay);
    }
}

<span class="enscript-comment">// Called with KQueueLock &amp; mDNS lock
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetKeyChainTimer</span>(mDNSs32 delay)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-comment">// If it's not set or it needs to happen sooner than when it's currently set
</span>    <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;KeyChainTimer || m-&gt;p-&gt;KeyChainTimer - NonZeroTime(m-&gt;timenow + delay) &gt; 0)
    {
        m-&gt;p-&gt;KeyChainTimer = NonZeroTime(m-&gt;timenow + delay);
        LogInfo(<span class="enscript-string">&quot;SetKeyChainTimer: %d&quot;</span>, delay);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXNetworkChanged</span>(<span class="enscript-type">void</span>)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;*** Network Configuration Change ***  %d ticks late&quot;</span> PUB_S,
        m-&gt;NetworkChanged ? mDNS_TimeNow(m) - m-&gt;NetworkChanged : 0,
        m-&gt;NetworkChanged ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot; (no scheduled configuration change)&quot;</span>);
    m-&gt;NetworkChanged = 0;       <span class="enscript-comment">// If we received a network change event and deferred processing, we're now dealing with it
</span>
    <span class="enscript-comment">// If we have *any* TENTATIVE IPv6 addresses, wait until they've finished configuring
</span>    <span class="enscript-type">int</span> InfoSocket = socket(AF_INET6, SOCK_DGRAM, 0);
    <span class="enscript-keyword">if</span> (InfoSocket &gt; 0)
    {
        mDNSBool tentative = mDNSfalse;
        <span class="enscript-type">struct</span> ifaddrs *ifa = myGetIfAddrs(1);
        <span class="enscript-keyword">while</span> (ifa)
        {
            <span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_INET6)
            {
                <span class="enscript-type">struct</span> in6_ifreq ifr6;
                mDNSPlatformMemZero((<span class="enscript-type">char</span> *)&amp;ifr6, <span class="enscript-keyword">sizeof</span>(ifr6));
                strlcpy(ifr6.ifr_name, ifa-&gt;ifa_name, <span class="enscript-keyword">sizeof</span>(ifr6.ifr_name));
                ifr6.ifr_addr = *(<span class="enscript-type">struct</span> sockaddr_in6 *)ifa-&gt;ifa_addr;
                <span class="enscript-comment">// We need to check for IN6_IFF_TENTATIVE here, not IN6_IFF_NOTREADY, because
</span>                <span class="enscript-comment">// IN6_IFF_NOTREADY includes both IN6_IFF_TENTATIVE and IN6_IFF_DUPLICATED addresses.
</span>                <span class="enscript-comment">// We can expect that an IN6_IFF_TENTATIVE address will shortly become ready,
</span>                <span class="enscript-comment">// but an IN6_IFF_DUPLICATED address may not.
</span>                <span class="enscript-keyword">if</span> (ioctl(InfoSocket, SIOCGIFAFLAG_IN6, &amp;ifr6) != -1)
                {
                    <span class="enscript-keyword">if</span> (ifr6.ifr_ifru.ifru_flags6 &amp; IN6_IFF_TENTATIVE)
                    {
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                            <span class="enscript-string">&quot;*** Network Configuration Change ***  IPv6 address &quot;</span> PRI_IPv6_ADDR <span class="enscript-string">&quot; TENTATIVE, will retry&quot;</span>,
                            &amp;ifr6.ifr_addr.sin6_addr);
                        tentative = mDNStrue;
                        <span class="enscript-comment">// no need to check other interfaces if we already found out that one interface is TENTATIVE
</span>                        <span class="enscript-keyword">break</span>;
                    }
                }
            }
            ifa = ifa-&gt;ifa_next;
        }
        close(InfoSocket);
        <span class="enscript-keyword">if</span> (tentative)
        {
            mDNS_Lock(m);
            SetNetworkChanged(mDNSPlatformOneSecond / 2);
            mDNS_Unlock(m);
            <span class="enscript-keyword">return</span>;
        }
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;*** Network Configuration Change ***  No IPv6 address TENTATIVE, will continue&quot;</span>);
    }

    mDNSs32 utc = mDNSPlatformUTC();
    m-&gt;SystemWakeOnLANEnabled = SystemWakeForNetworkAccess();
    m-&gt;SystemSleepOnlyIfWakeOnLAN = SystemSleepOnlyIfWakeOnLAN();
    MarkAllInterfacesInactive(utc);
    UpdateInterfaceList(utc);
    ClearInactiveInterfaces(utc);
    SetupActiveInterfaces(utc);
    ReorderInterfaceList();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    SetSPS(m);

    NetworkInterfaceInfoOSX *i;
    <span class="enscript-keyword">for</span> (i = m-&gt;p-&gt;InterfaceList; i; i = i-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!m-&gt;SPSSocket) <span class="enscript-comment">// Not being Sleep Proxy Server; close any open BPF fds
</span>        {
            <span class="enscript-keyword">if</span> (i-&gt;BPF_fd &gt;= 0 &amp;&amp; CountProxyTargets(i, mDNSNULL, mDNSNULL) == 0)
                CloseBPF(i);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-comment">// else, we're Sleep Proxy Server; open BPF fds
</span>        {
            <span class="enscript-keyword">if</span> (i-&gt;Exists &amp;&amp; (i-&gt;Registered == i) &amp;&amp; SPSInterface(i) &amp;&amp; i-&gt;BPF_fd == -1)
            {
                LogMsg(<span class="enscript-string">&quot;%s mDNSMacOSXNetworkChanged: requesting BPF&quot;</span>, i-&gt;ifinfo.ifname);
                i-&gt;BPF_fd = -2;
                mDNSRequestBPF();
            }
        }
    }

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    uDNS_SetupDNSConfig(m);
    mDNS_ConfigChanged(m);

    <span class="enscript-keyword">if</span> (IsAppleNetwork(m) != mDNS_McastTracingEnabled)
    {
        mDNS_McastTracingEnabled = mDNS_McastTracingEnabled ? mDNSfalse : mDNStrue; 
        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXNetworkChanged: Multicast Tracing %s&quot;</span>, mDNS_McastTracingEnabled ? <span class="enscript-string">&quot;Enabled&quot;</span> : <span class="enscript-string">&quot;Disabled&quot;</span>);
        UpdateDebugState();
    }

}

<span class="enscript-comment">// Copy the fourth slash-delimited element from either:
</span><span class="enscript-comment">//   State:/Network/Interface/&lt;bsdname&gt;/IPv4
</span><span class="enscript-comment">// or
</span><span class="enscript-comment">//   Setup:/Network/Service/&lt;servicename&gt;/Interface
</span>mDNSlocal CFStringRef <span class="enscript-function-name">CopyNameFromKey</span>(CFStringRef key)
{
    CFArrayRef a;
    CFStringRef name = NULL;

    a = CFStringCreateArrayBySeparatingStrings(NULL, key, CFSTR(<span class="enscript-string">&quot;/&quot;</span>));
    <span class="enscript-keyword">if</span> (a &amp;&amp; CFArrayGetCount(a) == 5) name = CFRetain(CFArrayGetValueAtIndex(a, 3));
    <span class="enscript-keyword">if</span> (a != NULL) CFRelease(a);

    <span class="enscript-keyword">return</span> name;
}

<span class="enscript-comment">// Whether a key from a network change notification corresponds to
</span><span class="enscript-comment">// an IP service that is explicitly configured for IPv4 Link Local
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">ChangedKeysHaveIPv4LL</span>(CFArrayRef inkeys)
{
    CFDictionaryRef dict = NULL;
    CFMutableArrayRef a;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> **keys = NULL, **vals = NULL;
    CFStringRef pattern = NULL;
    <span class="enscript-type">int</span> i, ic, j, jc;
    <span class="enscript-type">int</span> found = 0;

    jc = CFArrayGetCount(inkeys);
    <span class="enscript-keyword">if</span> (!jc) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    a = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);
    <span class="enscript-keyword">if</span> (a == NULL) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    <span class="enscript-comment">// Setup:/Network/Service/[^/]+/Interface
</span>    pattern = SCDynamicStoreKeyCreateNetworkServiceEntity(NULL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetInterface);
    <span class="enscript-keyword">if</span> (pattern == NULL) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    CFArrayAppendValue(a, pattern);
    CFRelease(pattern);

    <span class="enscript-comment">// Setup:/Network/Service/[^/]+/IPv4
</span>    pattern = SCDynamicStoreKeyCreateNetworkServiceEntity(NULL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv4);
    <span class="enscript-keyword">if</span> (pattern == NULL) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    CFArrayAppendValue(a, pattern);
    CFRelease(pattern);

    dict = SCDynamicStoreCopyMultiple(NULL, NULL, a);
    CFRelease(a);

    <span class="enscript-keyword">if</span> (!dict)
    {
        LogMsg(<span class="enscript-string">&quot;ChangedKeysHaveIPv4LL: Empty dictionary&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    ic = CFDictionaryGetCount(dict);
    vals = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *) * ic);
    keys = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *) * ic);
    CFDictionaryGetKeysAndValues(dict, keys, vals);

    <span class="enscript-comment">// For each key we were given...
</span>    <span class="enscript-keyword">for</span> (j = 0; j &lt; jc; j++)
    {
        CFStringRef key = CFArrayGetValueAtIndex(inkeys, j);
        CFStringRef ifname = NULL;

        <span class="enscript-type">char</span> buf[256];

        <span class="enscript-comment">// It would be nice to use a regex here
</span>        <span class="enscript-keyword">if</span> (!CFStringHasPrefix(key, CFSTR(<span class="enscript-string">&quot;State:/Network/Interface/&quot;</span>)) || !CFStringHasSuffix(key, kSCEntNetIPv4)) <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> ((ifname = CopyNameFromKey(key)) == NULL) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
        {
            <span class="enscript-keyword">if</span> (!CFStringGetCString(ifname, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)) buf[0] = 0;
            LogInfo(<span class="enscript-string">&quot;ChangedKeysHaveIPv4LL: potential ifname %s&quot;</span>, buf);
        }

        <span class="enscript-comment">// Loop over the interfaces to find matching the ifname, and see if that one has kSCValNetIPv4ConfigMethodLinkLocal
</span>        <span class="enscript-keyword">for</span> (i = 0; i &lt; ic; i++)
        {
            CFDictionaryRef ipv4dict;
            CFStringRef name;
            CFStringRef serviceid;
            CFStringRef configmethod;

            <span class="enscript-keyword">if</span> (!CFStringHasSuffix(keys[i], kSCEntNetInterface)) <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> (CFDictionaryGetTypeID() != CFGetTypeID(vals[i])) <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> ((name = CFDictionaryGetValue(vals[i], kSCPropNetInterfaceDeviceName)) == NULL) <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> (!CFEqual(ifname, name)) <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> ((serviceid = CopyNameFromKey(keys[i])) == NULL) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
            {
                <span class="enscript-keyword">if</span> (!CFStringGetCString(serviceid, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)) buf[0] = 0;
                LogInfo(<span class="enscript-string">&quot;ChangedKeysHaveIPv4LL: found serviceid %s&quot;</span>, buf);
            }

            pattern = SCDynamicStoreKeyCreateNetworkServiceEntity(NULL, kSCDynamicStoreDomainSetup, serviceid, kSCEntNetIPv4);
            CFRelease(serviceid);
            <span class="enscript-keyword">if</span> (pattern == NULL) <span class="enscript-keyword">continue</span>;

            ipv4dict = CFDictionaryGetValue(dict, pattern);
            CFRelease(pattern);
            <span class="enscript-keyword">if</span> (!ipv4dict || CFDictionaryGetTypeID() != CFGetTypeID(ipv4dict)) <span class="enscript-keyword">continue</span>;

            configmethod = CFDictionaryGetValue(ipv4dict, kSCPropNetIPv4ConfigMethod);
            <span class="enscript-keyword">if</span> (!configmethod) <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
            {
                <span class="enscript-keyword">if</span> (!CFStringGetCString(configmethod, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)) buf[0] = 0;
                LogInfo(<span class="enscript-string">&quot;ChangedKeysHaveIPv4LL: configmethod %s&quot;</span>, buf);
            }

            <span class="enscript-keyword">if</span> (CFEqual(configmethod, kSCValNetIPv4ConfigMethodLinkLocal)) { found++; <span class="enscript-keyword">break</span>; }
        }

        CFRelease(ifname);
    }

<span class="enscript-reference">done</span>:
    <span class="enscript-keyword">if</span> (vals != NULL) mDNSPlatformMemFree(vals);
    <span class="enscript-keyword">if</span> (keys != NULL) mDNSPlatformMemFree(keys);
    <span class="enscript-keyword">if</span> (dict != NULL) CFRelease(dict);

    <span class="enscript-keyword">return</span> found;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NetworkChanged</span>(SCDynamicStoreRef store, CFArrayRef changedKeys, <span class="enscript-type">void</span> *context)
{
    (<span class="enscript-type">void</span>)store;        <span class="enscript-comment">// Parameter not used
</span>    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)context;
    KQueueLock();
    mDNS_Lock(m);

    <span class="enscript-comment">//mDNSs32 delay = mDNSPlatformOneSecond * 2;                // Start off assuming a two-second delay
</span>    <span class="enscript-type">const</span> mDNSs32 delay = (mDNSPlatformOneSecond + 39) / 40;    <span class="enscript-comment">// 25 ms delay
</span>
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c = CFArrayGetCount(changedKeys);                   <span class="enscript-comment">// Count changes
</span>    CFRange range = { 0, c };
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c_host = (CFArrayContainsValue(changedKeys, range, NetworkChangedKey_Hostnames   ) != 0);
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c_comp = (CFArrayContainsValue(changedKeys, range, NetworkChangedKey_Computername) != 0);
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c_udns = (CFArrayContainsValue(changedKeys, range, NetworkChangedKey_DNS         ) != 0);
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c_ddns = (CFArrayContainsValue(changedKeys, range, NetworkChangedKey_DynamicDNS  ) != 0);
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> c_v4ll = ChangedKeysHaveIPv4LL(changedKeys);
    <span class="enscript-type">int</span> c_fast = 0;
    
    <span class="enscript-comment">// Do immediate network changed processing for &quot;p2p*&quot; interfaces and
</span>    <span class="enscript-comment">// for interfaces with the IFEF_DIRECTLINK or IFEF_AWDL flag set or association with a CarPlay
</span>    <span class="enscript-comment">// hosted SSID.
</span>    {
        CFArrayRef  labels;
        CFIndex     n;
        <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; c; i++)
        {
            CFStringRef key = CFArrayGetValueAtIndex(changedKeys, i);

            <span class="enscript-comment">// Only look at keys with prefix &quot;State:/Network/Interface/&quot;
</span>            <span class="enscript-keyword">if</span> (!CFStringHasPrefix(key, NetworkChangedKey_StateInterfacePrefix))
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">// And suffix &quot;IPv6&quot; or &quot;IPv4&quot;.
</span>            <span class="enscript-keyword">if</span> (!CFStringHasSuffix(key, kSCEntNetIPv6) &amp;&amp; !CFStringHasSuffix(key, kSCEntNetIPv4))
                <span class="enscript-keyword">continue</span>;

            labels = CFStringCreateArrayBySeparatingStrings(NULL, key, CFSTR(<span class="enscript-string">&quot;/&quot;</span>));
            <span class="enscript-keyword">if</span> (labels == NULL)
                <span class="enscript-keyword">break</span>;
            n = CFArrayGetCount(labels);

            <span class="enscript-comment">// Interface changes will have keys of the form: 
</span>            <span class="enscript-comment">//     State:/Network/Interface/&lt;interfaceName&gt;/IPv6
</span>            <span class="enscript-comment">// Thus five '/' seperated fields, the 4th one being the &lt;interfaceName&gt; string.
</span>            <span class="enscript-keyword">if</span> (n == 5)
            {
                <span class="enscript-type">char</span> buf[256];

                <span class="enscript-comment">// The 4th label (index = 3) should be the interface name.
</span>                <span class="enscript-keyword">if</span> (CFStringGetCString(CFArrayGetValueAtIndex(labels, 3), buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)
                    &amp;&amp; (strstr(buf, <span class="enscript-string">&quot;p2p&quot;</span>) || (getExtendedFlags(buf) &amp; (IFEF_DIRECTLINK | IFEF_AWDL)) || IsCarPlaySSID(buf)))
                {
                    LogInfo(<span class="enscript-string">&quot;NetworkChanged: interface %s qualifies for reduced change handling delay&quot;</span>, buf);
                    c_fast++;
                    CFRelease(labels);
                    <span class="enscript-keyword">break</span>;
                }
            }
            CFRelease(labels);
        }
    }

    <span class="enscript-comment">//if (c &amp;&amp; c - c_host - c_comp - c_udns - c_ddns - c_v4ll - c_fast == 0)
</span>    <span class="enscript-comment">//    delay = mDNSPlatformOneSecond/10;  // If these were the only changes, shorten delay
</span>
    <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
    {
        <span class="enscript-type">int</span> i;
        <span class="enscript-keyword">for</span> (i=0; i&lt;c; i++)
        {
            <span class="enscript-type">char</span> buf[256];
            <span class="enscript-keyword">if</span> (!CFStringGetCString(CFArrayGetValueAtIndex(changedKeys, i), buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)) buf[0] = 0;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;*** Network Configuration Change *** SC key: &quot;</span> PUB_S, buf);
        }
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;*** Network Configuration Change *** %d change&quot;</span> PUB_S <span class="enscript-string">&quot; &quot;</span> PUB_S PUB_S PUB_S PUB_S PUB_S PUB_S <span class="enscript-string">&quot;delay %d&quot;</span> PUB_S,
            c, c&gt;1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
            c_host ? <span class="enscript-string">&quot;(Local Hostname) &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
            c_comp ? <span class="enscript-string">&quot;(Computer Name) &quot;</span>  : <span class="enscript-string">&quot;&quot;</span>,
            c_udns ? <span class="enscript-string">&quot;(DNS) &quot;</span>            : <span class="enscript-string">&quot;&quot;</span>,
            c_ddns ? <span class="enscript-string">&quot;(DynamicDNS) &quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
            c_v4ll ? <span class="enscript-string">&quot;(kSCValNetIPv4ConfigMethodLinkLocal) &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
            c_fast ? <span class="enscript-string">&quot;(P2P/IFEF_DIRECTLINK/IFEF_AWDL/IsCarPlaySSID) &quot;</span>  : <span class="enscript-string">&quot;&quot;</span>,
            delay,
            c_ddns ? <span class="enscript-string">&quot; + SetKeyChainTimer&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
    }

    SetNetworkChanged(delay);

    <span class="enscript-comment">// Other software might pick up these changes to register or browse in WAB or BTMM domains,
</span>    <span class="enscript-comment">// so in order for secure updates to be made to the server, make sure to read the keychain and
</span>    <span class="enscript-comment">// setup the DomainAuthInfo before handing the network change.
</span>    <span class="enscript-comment">// If we don't, then we will first try to register services in the clear, then later setup the
</span>    <span class="enscript-comment">// DomainAuthInfo, which is incorrect.
</span>    <span class="enscript-keyword">if</span> (c_ddns)
        SetKeyChainTimer(delay);

    <span class="enscript-comment">// Don't try to call mDNSMacOSXNetworkChanged() here -- we're running on the wrong thread
</span>
    mDNS_Unlock(m);
    KQueueUnlock(<span class="enscript-string">&quot;NetworkChanged&quot;</span>);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RefreshSPSStatus</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context)
{
    (<span class="enscript-type">void</span>)context;
    <span class="enscript-type">char</span> buf[IFNAMSIZ];

    CFStringRef ifnameStr = (CFStringRef)key;
    CFArrayRef array = (CFArrayRef)value;
    <span class="enscript-keyword">if</span> (!CFStringGetCString(ifnameStr, buf, <span class="enscript-keyword">sizeof</span>(buf), kCFStringEncodingUTF8)) 
        buf[0] = 0;

    LogInfo(<span class="enscript-string">&quot;RefreshSPSStatus: Updating SPS state for key %s, array count %d&quot;</span>, buf, CFArrayGetCount(array));
    mDNSDynamicStoreSetConfig(kmDNSSleepProxyServersState, buf, value);
}
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DynamicStoreReconnected</span>(SCDynamicStoreRef store, <span class="enscript-type">void</span> *info)
{
    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)info;
    (<span class="enscript-type">void</span>)store;

    KQueueLock();   <span class="enscript-comment">// serialize with KQueueLoop()
</span>
    LogInfo(<span class="enscript-string">&quot;DynamicStoreReconnected: Reconnected&quot;</span>);

    <span class="enscript-comment">// State:/Network/MulticastDNS
</span>    SetLocalDomains();

    <span class="enscript-comment">// State:/Network/DynamicDNS
</span>    <span class="enscript-keyword">if</span> (m-&gt;FQDN.c[0])
        mDNSPlatformDynDNSHostNameStatusChanged(&amp;m-&gt;FQDN, 1);

    <span class="enscript-comment">// Note: PrivateDNS and BackToMyMac are automatically populated when configd is restarted
</span>    <span class="enscript-comment">// as we receive network change notifications and thus not necessary. But we leave it here
</span>    <span class="enscript-comment">// so that if things are done differently in the future, this code still works.
</span>
    <span class="enscript-comment">// State:/Network/PrivateDNS
</span>    <span class="enscript-keyword">if</span> (privateDnsArray)
        mDNSDynamicStoreSetConfig(kmDNSPrivateConfig, mDNSNULL, privateDnsArray);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-comment">// State:/Network/Interface/en0/SleepProxyServers
</span>    <span class="enscript-keyword">if</span> (spsStatusDict) 
        CFDictionaryApplyFunction(spsStatusDict, RefreshSPSStatus, NULL);
#<span class="enscript-reference">endif</span>
    KQueueUnlock(<span class="enscript-string">&quot;DynamicStoreReconnected&quot;</span>);
}

mDNSlocal mStatus <span class="enscript-function-name">WatchForNetworkChanges</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mStatus err = -1;
    SCDynamicStoreContext context = { 0, m, NULL, NULL, NULL };
    SCDynamicStoreRef store    = SCDynamicStoreCreate(NULL, CFSTR(<span class="enscript-string">&quot;mDNSResponder:WatchForNetworkChanges&quot;</span>), NetworkChanged, &amp;context);
    CFMutableArrayRef keys     = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);
    CFStringRef pattern1 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(NULL, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4);
    CFStringRef pattern2 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(NULL, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv6);
    CFMutableArrayRef patterns = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);

    <span class="enscript-keyword">if</span> (!store) { LogMsg(<span class="enscript-string">&quot;SCDynamicStoreCreate failed: %s&quot;</span>, SCErrorString(SCError())); <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>; }
    <span class="enscript-keyword">if</span> (!keys || !pattern1 || !pattern2 || !patterns) <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;

    CFArrayAppendValue(keys, NetworkChangedKey_IPv4);
    CFArrayAppendValue(keys, NetworkChangedKey_IPv6);
    CFArrayAppendValue(keys, NetworkChangedKey_Hostnames);
    CFArrayAppendValue(keys, NetworkChangedKey_Computername);
    CFArrayAppendValue(keys, NetworkChangedKey_DNS);
    CFArrayAppendValue(keys, NetworkChangedKey_DynamicDNS);
    CFArrayAppendValue(keys, NetworkChangedKey_PowerSettings);
    CFArrayAppendValue(patterns, pattern1);
    CFArrayAppendValue(patterns, pattern2);
    CFArrayAppendValue(patterns, CFSTR(<span class="enscript-string">&quot;State:/Network/Interface/[^/]+/AirPort&quot;</span>));
    <span class="enscript-keyword">if</span> (!SCDynamicStoreSetNotificationKeys(store, keys, patterns))
    { LogMsg(<span class="enscript-string">&quot;SCDynamicStoreSetNotificationKeys failed: %s&quot;</span>, SCErrorString(SCError())); <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>; }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
    <span class="enscript-keyword">if</span> (!SCDynamicStoreSetDispatchQueue(store, dispatch_get_main_queue()))
    { LogMsg(<span class="enscript-string">&quot;SCDynamicStoreCreateRunLoopSource failed: %s&quot;</span>, SCErrorString(SCError())); <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>; }
#<span class="enscript-reference">else</span>
    m-&gt;p-&gt;StoreRLS = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);
    <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;StoreRLS) { LogMsg(<span class="enscript-string">&quot;SCDynamicStoreCreateRunLoopSource failed: %s&quot;</span>, SCErrorString(SCError())); <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>; }
    CFRunLoopAddSource(CFRunLoopGetMain(), m-&gt;p-&gt;StoreRLS, kCFRunLoopDefaultMode);
#<span class="enscript-reference">endif</span>
    SCDynamicStoreSetDisconnectCallBack(store, DynamicStoreReconnected);
    m-&gt;p-&gt;Store = store;
    err = 0;
    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

<span class="enscript-reference">error</span>:
    <span class="enscript-keyword">if</span> (store) CFRelease(store);

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (patterns) CFRelease(patterns);
    <span class="enscript-keyword">if</span> (pattern2) CFRelease(pattern2);
    <span class="enscript-keyword">if</span> (pattern1) CFRelease(pattern1);
    <span class="enscript-keyword">if</span> (keys) CFRelease(keys);

    <span class="enscript-keyword">return</span>(err);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_OSX</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSSetPacketFilterRules</span>(<span class="enscript-type">char</span> * ifname, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> excludeRecord)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    AuthRecord  *rr;
    pfArray_t portArray;
    pfArray_t protocolArray;
    uint32_t count = 0;

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> ((rr-&gt;resrec.rrtype == kDNSServiceType_SRV) 
            &amp;&amp; ((rr-&gt;ARType == AuthRecordAnyIncludeP2P) || (rr-&gt;ARType == AuthRecordAnyIncludeAWDLandP2P)))
        {
            <span class="enscript-type">const</span> mDNSu8    *p;

            <span class="enscript-keyword">if</span> (count &gt;= PFPortArraySize)
            {
                LogMsg(<span class="enscript-string">&quot;mDNSSetPacketFilterRules: %d service limit, skipping %s&quot;</span>, PFPortArraySize, ARDisplayString(m, rr));
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (excludeRecord &amp;&amp; IdenticalResourceRecord(&amp;rr-&gt;resrec, excludeRecord))
            {
                LogInfo(<span class="enscript-string">&quot;mDNSSetPacketFilterRules: record being removed, skipping %s&quot;</span>, ARDisplayString(m, rr));
                <span class="enscript-keyword">continue</span>;
            }

            LogMsg(<span class="enscript-string">&quot;mDNSSetPacketFilterRules: found %s&quot;</span>, ARDisplayString(m, rr));

            portArray[count] = rr-&gt;resrec.rdata-&gt;u.srv.port.NotAnInteger;

            <span class="enscript-comment">// Assume &lt;Service Instance&gt;.&lt;App Protocol&gt;.&lt;Transport Protocol&gt;.&lt;Name&gt;
</span>            p = rr-&gt;resrec.name-&gt;c;

            <span class="enscript-comment">// Skip to App Protocol
</span>            <span class="enscript-keyword">if</span> (p[0])
                p += 1 + p[0];

            <span class="enscript-comment">// Skip to Transport Protocol
</span>            <span class="enscript-keyword">if</span> (p[0])
                p += 1 + p[0];

            <span class="enscript-keyword">if</span>      (SameDomainLabel(p, (mDNSu8 *)<span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_tcp&quot;</span>))
            {
                protocolArray[count] = IPPROTO_TCP;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SameDomainLabel(p, (mDNSu8 *)<span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_udp&quot;</span>))
            {
                protocolArray[count] = IPPROTO_UDP;
            }
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;mDNSSetPacketFilterRules: could not determine transport protocol of service&quot;</span>);
                LogMsg(<span class="enscript-string">&quot;mDNSSetPacketFilterRules: %s&quot;</span>, ARDisplayString(m, rr));
                <span class="enscript-keyword">return</span>;
            }
            count++;
        }
    }
    mDNSPacketFilterControl(PF_SET_RULES, ifname, count, portArray, protocolArray);
}

<span class="enscript-comment">// If the p2p interface already exists, update the Bonjour packet filter rules for it.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSUpdatePacketFilter</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> excludeRecord)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;

    NetworkInterfaceInfo *intf = GetFirstActiveInterface(m-&gt;HostInterfaces);
    <span class="enscript-keyword">while</span> (intf)
    {
        <span class="enscript-keyword">if</span> (strncmp(intf-&gt;ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0)
        {
            LogInfo(<span class="enscript-string">&quot;mDNSInitPacketFilter: Setting rules for ifname %s&quot;</span>, intf-&gt;ifname);
            mDNSSetPacketFilterRules(intf-&gt;ifname, excludeRecord);
            <span class="enscript-keyword">break</span>;
        }
        intf = GetFirstActiveInterface(intf-&gt;next);
    }
}
#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">TARGET_OS_OSX</span>
<span class="enscript-comment">// Currently no packet filter setup required on embedded platforms.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSUpdatePacketFilter</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> excludeRecord)
{
    (<span class="enscript-type">void</span>) excludeRecord; <span class="enscript-comment">// unused
</span>}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// AWDL should no longer generate KEV_DL_MASTER_ELECTED events, so just log a message if we receive one.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">newMasterElected</span>(<span class="enscript-type">struct</span> net_event_data * ptr)
{
    <span class="enscript-type">char</span>        ifname[IFNAMSIZ];
    mDNSu32     interfaceIndex;

    snprintf(ifname, IFNAMSIZ, <span class="enscript-string">&quot;%s%d&quot;</span>, ptr-&gt;if_name, ptr-&gt;if_unit);
    interfaceIndex  = if_nametoindex(ifname);

    <span class="enscript-keyword">if</span> (!interfaceIndex)
    {
        LogMsg(<span class="enscript-string">&quot;newMasterElected: if_nametoindex(%s) failed&quot;</span>, ifname);
        <span class="enscript-keyword">return</span>;
    }

    LogInfo(<span class="enscript-string">&quot;newMasterElected: KEV_DL_MASTER_ELECTED received on ifname = %s, interfaceIndex = %d&quot;</span>, ifname, interfaceIndex);
}

<span class="enscript-comment">// An ssth array of all zeroes indicates the peer has no services registered.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">allZeroSSTH</span>(<span class="enscript-type">struct</span> opaque_presence_indication *op)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> *intp = (<span class="enscript-type">int</span> *) op-&gt;ssth;

    <span class="enscript-comment">// MAX_SSTH_SIZE should always be a multiple of sizeof(int), if
</span>    <span class="enscript-comment">// it's not, print an error message and return false so that
</span>    <span class="enscript-comment">// corresponding peer records are not flushed when KEV_DL_NODE_PRESENCE event
</span>    <span class="enscript-comment">// is received.
</span>    <span class="enscript-keyword">if</span> (MAX_SSTH_SIZE % <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>))
    {
        LogInfo(<span class="enscript-string">&quot;allZeroSSTH: MAX_SSTH_SIZE = %d not a multiple of sizeof(int)&quot;</span>, MAX_SSTH_SIZE);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(MAX_SSTH_SIZE / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)); i++, intp++)
    {
        <span class="enscript-keyword">if</span> (*intp)
            <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// Mark records from this peer for deletion from the cache.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">removeCachedPeerRecords</span>(mDNSu32 ifindex, mDNSAddr *ap, bool purgeNow)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    mDNSu32     slot;
    CacheGroup  *cg;
    CacheRecord *cr;
    NetworkInterfaceInfoOSX *infoOSX;
    mDNSInterfaceID InterfaceID;

    <span class="enscript-comment">// Using mDNSPlatformInterfaceIDfromInterfaceIndex() would lead to recursive
</span>    <span class="enscript-comment">// locking issues, see: &lt;rdar://problem/21332983&gt;
</span>    infoOSX = IfindexToInterfaceInfoOSX((mDNSInterfaceID)(uintptr_t)ifindex);
    <span class="enscript-keyword">if</span> (!infoOSX)
    {
        LogInfo(<span class="enscript-string">&quot;removeCachedPeerRecords: interface %d not yet active&quot;</span>, ifindex);
        <span class="enscript-keyword">return</span>;
    }
    InterfaceID = infoOSX-&gt;ifinfo.InterfaceID;

    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> ((InterfaceID == cr-&gt;resrec.InterfaceID) &amp;&amp; mDNSSameAddress(ap, &amp; cr-&gt;sourceAddress))
        {
            LogInfo(<span class="enscript-string">&quot;removeCachedPeerRecords: %s %##s marking for deletion&quot;</span>,
                 DNSTypeName(cr-&gt;resrec.rrtype), cr-&gt;resrec.name-&gt;c);

            <span class="enscript-keyword">if</span> (purgeNow)
                mDNS_PurgeCacheResourceRecord(m, cr);
            <span class="enscript-keyword">else</span>
                mDNS_Reconfirm_internal(m, cr, 0);  <span class="enscript-comment">// use default minimum reconfirm time 
</span>        }
    }
}

<span class="enscript-comment">// Handle KEV_DL_NODE_PRESENCE event.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">nodePresence</span>(<span class="enscript-type">struct</span> kev_dl_node_presence * p)
{
    <span class="enscript-type">struct</span> opaque_presence_indication *op = (<span class="enscript-type">struct</span> opaque_presence_indication *) p-&gt;node_service_info;

    LogInfo(<span class="enscript-string">&quot;nodePresence: IPv6 address: %.16a, SUI %d&quot;</span>, p-&gt;sin6_node_address.sin6_addr.s6_addr, op-&gt;SUI);
 
    <span class="enscript-comment">// AWDL will generate a KEV_DL_NODE_PRESENCE event with SSTH field of
</span>    <span class="enscript-comment">// all zeroes when a node is present and has no services registered.
</span>    <span class="enscript-keyword">if</span> (allZeroSSTH(op))
    {
        mDNSAddr    peerAddr;

        peerAddr.type = mDNSAddrType_IPv6;
        peerAddr.ip.v6 = *(mDNSv6Addr*)&amp;p-&gt;sin6_node_address.sin6_addr;

        LogInfo(<span class="enscript-string">&quot;nodePresence: ssth is all zeroes, reconfirm cached records for this peer&quot;</span>);
        removeCachedPeerRecords(p-&gt;sdl_node_address.sdl_index, &amp; peerAddr, false);
    }
}

<span class="enscript-comment">// Handle KEV_DL_NODE_ABSENCE event.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">nodeAbsence</span>(<span class="enscript-type">struct</span> kev_dl_node_absence * p)
{
    mDNSAddr    peerAddr;

    peerAddr.type = mDNSAddrType_IPv6;
    peerAddr.ip.v6 = *(mDNSv6Addr*)&amp;p-&gt;sin6_node_address.sin6_addr;

    LogInfo(<span class="enscript-string">&quot;nodeAbsence: immediately purge cached records from %.16a&quot;</span>, p-&gt;sin6_node_address.sin6_addr.s6_addr);
    removeCachedPeerRecords(p-&gt;sdl_node_address.sdl_index, &amp; peerAddr, true);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SysEventCallBack</span>(<span class="enscript-type">int</span> s1, <span class="enscript-type">short</span> __unused filter, <span class="enscript-type">void</span> *context, __unused mDNSBool encounteredEOF)
{
    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)context;

    mDNS_Lock(m);

    <span class="enscript-type">struct</span> { <span class="enscript-type">struct</span> kern_event_msg k; <span class="enscript-type">char</span> extra[256]; } msg;
    <span class="enscript-type">int</span> bytes = recv(s1, &amp;msg, <span class="enscript-keyword">sizeof</span>(msg), 0);
    <span class="enscript-keyword">if</span> (bytes &lt; 0)
        LogMsg(<span class="enscript-string">&quot;SysEventCallBack: recv error %d errno %d (%s)&quot;</span>, bytes, errno, strerror(errno));
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;SysEventCallBack got %d bytes size %d %X %s %X %s %X %s id %d code %d %s&quot;</span>,
                bytes, msg.k.total_size,
                msg.k.vendor_code, msg.k.vendor_code  == KEV_VENDOR_APPLE  ? <span class="enscript-string">&quot;KEV_VENDOR_APPLE&quot;</span>  : <span class="enscript-string">&quot;?&quot;</span>,
                msg.k.kev_class, msg.k.kev_class    == KEV_NETWORK_CLASS ? <span class="enscript-string">&quot;KEV_NETWORK_CLASS&quot;</span> : <span class="enscript-string">&quot;?&quot;</span>,
                msg.k.kev_subclass, msg.k.kev_subclass == KEV_DL_SUBCLASS   ? <span class="enscript-string">&quot;KEV_DL_SUBCLASS&quot;</span>   : <span class="enscript-string">&quot;?&quot;</span>,
                msg.k.id, msg.k.event_code,
                msg.k.event_code == KEV_DL_SIFFLAGS             ? <span class="enscript-string">&quot;KEV_DL_SIFFLAGS&quot;</span>             :
                msg.k.event_code == KEV_DL_SIFMETRICS           ? <span class="enscript-string">&quot;KEV_DL_SIFMETRICS&quot;</span>           :
                msg.k.event_code == KEV_DL_SIFMTU               ? <span class="enscript-string">&quot;KEV_DL_SIFMTU&quot;</span>               :
                msg.k.event_code == KEV_DL_SIFPHYS              ? <span class="enscript-string">&quot;KEV_DL_SIFPHYS&quot;</span>              :
                msg.k.event_code == KEV_DL_SIFMEDIA             ? <span class="enscript-string">&quot;KEV_DL_SIFMEDIA&quot;</span>             :
                msg.k.event_code == KEV_DL_SIFGENERIC           ? <span class="enscript-string">&quot;KEV_DL_SIFGENERIC&quot;</span>           :
                msg.k.event_code == KEV_DL_ADDMULTI             ? <span class="enscript-string">&quot;KEV_DL_ADDMULTI&quot;</span>             :
                msg.k.event_code == KEV_DL_DELMULTI             ? <span class="enscript-string">&quot;KEV_DL_DELMULTI&quot;</span>             :
                msg.k.event_code == KEV_DL_IF_ATTACHED          ? <span class="enscript-string">&quot;KEV_DL_IF_ATTACHED&quot;</span>          :
                msg.k.event_code == KEV_DL_IF_DETACHING         ? <span class="enscript-string">&quot;KEV_DL_IF_DETACHING&quot;</span>         :
                msg.k.event_code == KEV_DL_IF_DETACHED          ? <span class="enscript-string">&quot;KEV_DL_IF_DETACHED&quot;</span>          :
                msg.k.event_code == KEV_DL_LINK_OFF             ? <span class="enscript-string">&quot;KEV_DL_LINK_OFF&quot;</span>             :
                msg.k.event_code == KEV_DL_LINK_ON              ? <span class="enscript-string">&quot;KEV_DL_LINK_ON&quot;</span>              :
                msg.k.event_code == KEV_DL_PROTO_ATTACHED       ? <span class="enscript-string">&quot;KEV_DL_PROTO_ATTACHED&quot;</span>       :
                msg.k.event_code == KEV_DL_PROTO_DETACHED       ? <span class="enscript-string">&quot;KEV_DL_PROTO_DETACHED&quot;</span>       :
                msg.k.event_code == KEV_DL_LINK_ADDRESS_CHANGED ? <span class="enscript-string">&quot;KEV_DL_LINK_ADDRESS_CHANGED&quot;</span> :
                msg.k.event_code == KEV_DL_WAKEFLAGS_CHANGED    ? <span class="enscript-string">&quot;KEV_DL_WAKEFLAGS_CHANGED&quot;</span>    :
                msg.k.event_code == KEV_DL_IF_IDLE_ROUTE_REFCNT ? <span class="enscript-string">&quot;KEV_DL_IF_IDLE_ROUTE_REFCNT&quot;</span> :
                msg.k.event_code == KEV_DL_IFCAP_CHANGED        ? <span class="enscript-string">&quot;KEV_DL_IFCAP_CHANGED&quot;</span>        :
                msg.k.event_code == KEV_DL_LINK_QUALITY_METRIC_CHANGED    ? <span class="enscript-string">&quot;KEV_DL_LINK_QUALITY_METRIC_CHANGED&quot;</span>    :
                msg.k.event_code == KEV_DL_NODE_PRESENCE        ? <span class="enscript-string">&quot;KEV_DL_NODE_PRESENCE&quot;</span>        :
                msg.k.event_code == KEV_DL_NODE_ABSENCE         ? <span class="enscript-string">&quot;KEV_DL_NODE_ABSENCE&quot;</span>         :
                msg.k.event_code == KEV_DL_MASTER_ELECTED       ? <span class="enscript-string">&quot;KEV_DL_MASTER_ELECTED&quot;</span>       :
                 <span class="enscript-string">&quot;?&quot;</span>);

        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_NODE_PRESENCE)
            nodePresence((<span class="enscript-type">struct</span> kev_dl_node_presence *) &amp;msg.k.event_data);

        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_NODE_ABSENCE)
            nodeAbsence((<span class="enscript-type">struct</span> kev_dl_node_absence *) &amp;msg.k.event_data);

        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_MASTER_ELECTED)
            newMasterElected((<span class="enscript-type">struct</span> net_event_data *) &amp;msg.k.event_data);

        <span class="enscript-comment">// We receive network change notifications both through configd and through SYSPROTO_EVENT socket.
</span>        <span class="enscript-comment">// Configd may not generate network change events for manually configured interfaces (i.e., non-DHCP)
</span>        <span class="enscript-comment">// always during sleep/wakeup due to some race conditions (See radar:8666757). At the same time, if
</span>        <span class="enscript-comment">// &quot;Wake on Network Access&quot; is not turned on, the notification will not have KEV_DL_WAKEFLAGS_CHANGED.
</span>        <span class="enscript-comment">// Hence, during wake up, if we see a KEV_DL_LINK_ON (i.e., link is UP), we trigger a network change.
</span>
        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_WAKEFLAGS_CHANGED || msg.k.event_code == KEV_DL_LINK_ON)
            SetNetworkChanged(mDNSPlatformOneSecond * 2);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_OSX</span>
        <span class="enscript-comment">// For p2p interfaces, need to open the advertised service port in the firewall.
</span>        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_IF_ATTACHED)
        {
            <span class="enscript-type">struct</span> net_event_data   * p;
            p = (<span class="enscript-type">struct</span> net_event_data *) &amp;msg.k.event_data;

            <span class="enscript-keyword">if</span> (strncmp(p-&gt;if_name, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0)
            {
                <span class="enscript-type">char</span> ifname[IFNAMSIZ];
                snprintf(ifname, IFNAMSIZ, <span class="enscript-string">&quot;%s%d&quot;</span>, p-&gt;if_name, p-&gt;if_unit);

                LogInfo(<span class="enscript-string">&quot;SysEventCallBack: KEV_DL_IF_ATTACHED if_family = %d, if_unit = %d, if_name = %s&quot;</span>, p-&gt;if_family, p-&gt;if_unit, p-&gt;if_name);

                mDNSSetPacketFilterRules(ifname, NULL);
            }
        }

        <span class="enscript-comment">// For p2p interfaces, need to clear the firewall rules on interface detach
</span>        <span class="enscript-keyword">if</span> (msg.k.event_code == KEV_DL_IF_DETACHED)
        {
            <span class="enscript-type">struct</span> net_event_data   * p;
            p = (<span class="enscript-type">struct</span> net_event_data *) &amp;msg.k.event_data;

            <span class="enscript-keyword">if</span> (strncmp(p-&gt;if_name, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0)
            {
                pfArray_t portArray, protocolArray; <span class="enscript-comment">// not initialized since count is 0 for PF_CLEAR_RULES
</span>                <span class="enscript-type">char</span> ifname[IFNAMSIZ];
                snprintf(ifname, IFNAMSIZ, <span class="enscript-string">&quot;%s%d&quot;</span>, p-&gt;if_name, p-&gt;if_unit);

                LogInfo(<span class="enscript-string">&quot;SysEventCallBack: KEV_DL_IF_DETACHED if_family = %d, if_unit = %d, if_name = %s&quot;</span>, p-&gt;if_family, p-&gt;if_unit, p-&gt;if_name);

                mDNSPacketFilterControl(PF_CLEAR_RULES, ifname, 0, portArray, protocolArray);
            }
        }
#<span class="enscript-reference">endif</span>
    }

    mDNS_Unlock(m);
}

mDNSlocal mStatus <span class="enscript-function-name">WatchForSysEvents</span>(mDNS *<span class="enscript-type">const</span> m)
{
    m-&gt;p-&gt;SysEventNotifier = socket(PF_SYSTEM, SOCK_RAW, SYSPROTO_EVENT);
    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;SysEventNotifier &lt; 0)
    { LogMsg(<span class="enscript-string">&quot;WatchForSysEvents: socket failed error %d errno %d (%s)&quot;</span>, m-&gt;p-&gt;SysEventNotifier, errno, strerror(errno)); <span class="enscript-keyword">return</span>(mStatus_NoMemoryErr); }

    <span class="enscript-type">struct</span> kev_request kev_req = { KEV_VENDOR_APPLE, KEV_NETWORK_CLASS, KEV_DL_SUBCLASS };
    <span class="enscript-type">int</span> err = ioctl(m-&gt;p-&gt;SysEventNotifier, SIOCSKEVFILT, &amp;kev_req);
    <span class="enscript-keyword">if</span> (err &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;WatchForSysEvents: SIOCSKEVFILT failed error %d errno %d (%s)&quot;</span>, err, errno, strerror(errno));
        close(m-&gt;p-&gt;SysEventNotifier);
        m-&gt;p-&gt;SysEventNotifier = -1;
        <span class="enscript-keyword">return</span>(mStatus_UnknownErr);
    }

    m-&gt;p-&gt;SysEventKQueue.KQcallback = SysEventCallBack;
    m-&gt;p-&gt;SysEventKQueue.KQcontext  = m;
    m-&gt;p-&gt;SysEventKQueue.KQtask     = <span class="enscript-string">&quot;System Event Notifier&quot;</span>;
    KQueueSet(m-&gt;p-&gt;SysEventNotifier, EV_ADD, EVFILT_READ, &amp;m-&gt;p-&gt;SysEventKQueue);

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
mDNSlocal OSStatus <span class="enscript-function-name">KeychainChanged</span>(SecKeychainEvent keychainEvent, SecKeychainCallbackInfo *info, <span class="enscript-type">void</span> *context)
{
    LogInfo(<span class="enscript-string">&quot;***   Keychain Changed   ***&quot;</span>);
    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)context;
    SecKeychainRef skc;
    OSStatus err = SecKeychainCopyDefault(&amp;skc);
    <span class="enscript-keyword">if</span> (!err)
    {
        <span class="enscript-keyword">if</span> (info-&gt;keychain == skc)
        {
            <span class="enscript-comment">// For delete events, attempt to verify what item was deleted fail because the item is already gone, so we just assume they may be relevant
</span>            mDNSBool relevant = (keychainEvent == kSecDeleteEvent);
            <span class="enscript-keyword">if</span> (!relevant)
            {
                UInt32 tags[3] = { kSecTypeItemAttr, kSecServiceItemAttr, kSecAccountItemAttr };
                SecKeychainAttributeInfo attrInfo = { 3, tags, NULL };  <span class="enscript-comment">// Count, array of tags, array of formats
</span>                SecKeychainAttributeList *a = NULL;
                err = SecKeychainItemCopyAttributesAndData(info-&gt;item, &amp;attrInfo, NULL, &amp;a, NULL, NULL);
                <span class="enscript-keyword">if</span> (!err)
                {
                    relevant = ((a-&gt;attr[0].length == 4 &amp;&amp; (!strncasecmp(a-&gt;attr[0].data, <span class="enscript-string">&quot;ddns&quot;</span>, 4) || !strncasecmp(a-&gt;attr[0].data, <span class="enscript-string">&quot;sndd&quot;</span>, 4))) ||
                                (a-&gt;attr[1].length &gt;= mDNSPlatformStrLen(dnsprefix) &amp;&amp; (!strncasecmp(a-&gt;attr[1].data, dnsprefix, mDNSPlatformStrLen(dnsprefix)))));
                    SecKeychainItemFreeAttributesAndData(a, NULL);
                }
            }
            <span class="enscript-keyword">if</span> (relevant)
            {
                LogInfo(<span class="enscript-string">&quot;***   Keychain Changed   *** KeychainEvent=%d %s&quot;</span>,
                        keychainEvent,
                        keychainEvent == kSecAddEvent    ? <span class="enscript-string">&quot;kSecAddEvent&quot;</span>    :
                        keychainEvent == kSecDeleteEvent ? <span class="enscript-string">&quot;kSecDeleteEvent&quot;</span> :
                        keychainEvent == kSecUpdateEvent ? <span class="enscript-string">&quot;kSecUpdateEvent&quot;</span> : <span class="enscript-string">&quot;&lt;Unknown&gt;&quot;</span>);
                <span class="enscript-comment">// We're running on the CFRunLoop (Mach port) thread, not the kqueue thread, so we need to grab the KQueueLock before proceeding
</span>                KQueueLock();
                mDNS_Lock(m);

                <span class="enscript-comment">// To not read the keychain twice: when BTMM is enabled, changes happen to the keychain
</span>                <span class="enscript-comment">// then the BTMM DynStore dictionary, so delay reading the keychain for a second.
</span>                <span class="enscript-comment">// NetworkChanged() will reset the keychain timer to fire immediately when the DynStore changes.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// In the &quot;fixup&quot; case where the BTMM DNS servers aren't accepting the key mDNSResponder has,
</span>                <span class="enscript-comment">// the DynStore dictionary won't change (because the BTMM zone won't change).  In that case,
</span>                <span class="enscript-comment">// a one second delay is ok, as we'll still converge to correctness, and there's no race
</span>                <span class="enscript-comment">// condition between the RegistrationDomain and the DomainAuthInfo.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// Lastly, non-BTMM WAB cases can use the keychain but not the DynStore, so we need to set
</span>                <span class="enscript-comment">// the timer here, as it will not get set by NetworkChanged().
</span>                SetKeyChainTimer(mDNSPlatformOneSecond);

                mDNS_Unlock(m);
                KQueueUnlock(<span class="enscript-string">&quot;KeychainChanged&quot;</span>);
            }
        }
        CFRelease(skc);
    }

    <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PowerOn</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSCoreMachineSleep(m, false);     <span class="enscript-comment">// Will set m-&gt;SleepState = SleepState_Awake;
</span>
    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;WakeAtUTC)
    {
        <span class="enscript-type">long</span> utc = mDNSPlatformUTC();
        mDNSPowerRequest(-1,-1);        <span class="enscript-comment">// Need to explicitly clear any previous power requests -- they're not cleared automatically on wake
</span>        <span class="enscript-keyword">if</span> (m-&gt;p-&gt;WakeAtUTC - utc &gt; 30)
        {
            LogSPS(<span class="enscript-string">&quot;PowerChanged PowerOn %d seconds early, assuming not maintenance wake&quot;</span>, m-&gt;p-&gt;WakeAtUTC - utc);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (utc - m-&gt;p-&gt;WakeAtUTC &gt; 30)
        {
            LogSPS(<span class="enscript-string">&quot;PowerChanged PowerOn %d seconds late, assuming not maintenance wake&quot;</span>, utc - m-&gt;p-&gt;WakeAtUTC);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IsAppleTV())
        {
            LogSPS(<span class="enscript-string">&quot;PowerChanged PowerOn %d seconds late, device is an AppleTV running iOS so not re-sleeping&quot;</span>, utc - m-&gt;p-&gt;WakeAtUTC);
        }
        <span class="enscript-keyword">else</span>
        {
            LogSPS(<span class="enscript-string">&quot;PowerChanged: Waking for network maintenance operations %d seconds early; re-sleeping in 20 seconds&quot;</span>, m-&gt;p-&gt;WakeAtUTC - utc);
            m-&gt;p-&gt;RequestReSleep = mDNS_TimeNow(m) + 20 * mDNSPlatformOneSecond;
        }
    }

    <span class="enscript-comment">// Hold on to a sleep assertion to allow mDNSResponder to perform its maintenance activities.
</span>    <span class="enscript-comment">// This allows for the network link to come up, DHCP to get an address, mDNS to issue queries etc.
</span>    <span class="enscript-comment">// We will clear this assertion as soon as we think the mainenance activities are done.
</span>    mDNSPlatformPreventSleep(DARK_WAKE_TIME, <span class="enscript-string">&quot;mDNSResponder:maintenance&quot;</span>);

}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PowerChanged</span>(<span class="enscript-type">void</span> *refcon, io_service_t service, natural_t messageType, <span class="enscript-type">void</span> *messageArgument)
{
    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)refcon;
    KQueueLock();
    (<span class="enscript-type">void</span>)service;    <span class="enscript-comment">// Parameter not used
</span>    debugf(<span class="enscript-string">&quot;PowerChanged %X %lX&quot;</span>, messageType, messageArgument);

    <span class="enscript-comment">// Make sure our m-&gt;SystemWakeOnLANEnabled value correctly reflects the current system setting
</span>    m-&gt;SystemWakeOnLANEnabled = SystemWakeForNetworkAccess();

    <span class="enscript-keyword">switch</span>(messageType)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageCanSystemPowerOff</span>:       LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageCanSystemPowerOff     (no action)&quot;</span>); <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// E0000240
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillPowerOff</span>:      LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillPowerOff&quot;</span>);                                <span class="enscript-comment">// E0000250
</span>        mDNSCoreMachineSleep(m, true);
        <span class="enscript-keyword">if</span> (m-&gt;SleepState == SleepState_Sleeping) mDNSMacOSXNetworkChanged();
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillNotPowerOff</span>:   LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillNotPowerOff (no action)&quot;</span>); <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// E0000260
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageCanSystemSleep</span>:          LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageCanSystemSleep&quot;</span>);                    <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// E0000270
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillSleep</span>:         LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillSleep&quot;</span>);                                   <span class="enscript-comment">// E0000280
</span>        mDNSCoreMachineSleep(m, true);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillNotSleep</span>:      LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillNotSleep    (no action)&quot;</span>); <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// E0000290
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemHasPoweredOn</span>:      LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemHasPoweredOn&quot;</span>);                                <span class="enscript-comment">// E0000300
</span>        <span class="enscript-comment">// If still sleeping (didn't get 'WillPowerOn' message for some reason?) wake now
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepState)
        {
            LogMsg(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemHasPoweredOn: ERROR m-&gt;SleepState %d&quot;</span>, m-&gt;SleepState);
            PowerOn(m);
        }
        <span class="enscript-comment">// Just to be safe, schedule a mDNSMacOSXNetworkChanged(), in case we never received
</span>        <span class="enscript-comment">// the System Configuration Framework &quot;network changed&quot; event that we expect
</span>        <span class="enscript-comment">// to receive some time shortly after the kIOMessageSystemWillPowerOn message
</span>        mDNS_Lock(m);
        SetNetworkChanged(mDNSPlatformOneSecond * 2);
        mDNS_Unlock(m);

        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillRestart</span>:       LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillRestart     (no action)&quot;</span>); <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// E0000310
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageSystemWillPowerOn</span>:       LogSPS(<span class="enscript-string">&quot;PowerChanged kIOMessageSystemWillPowerOn&quot;</span>);                                 <span class="enscript-comment">// E0000320
</span>
        <span class="enscript-comment">// Make sure our interface list is cleared to the empty state, then tell mDNSCore to wake
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepState != SleepState_Sleeping)
        {
            LogMsg(<span class="enscript-string">&quot;kIOMessageSystemWillPowerOn: ERROR m-&gt;SleepState %d&quot;</span>, m-&gt;SleepState);
            m-&gt;SleepState = SleepState_Sleeping;
            mDNSMacOSXNetworkChanged();
        }
        PowerOn(m);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:                                LogSPS(<span class="enscript-string">&quot;PowerChanged unknown message %X&quot;</span>, messageType); <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (messageType == kIOMessageSystemWillSleep)
        m-&gt;p-&gt;SleepCookie = (<span class="enscript-type">long</span>)messageArgument;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (messageType == kIOMessageCanSystemSleep)
        IOAllowPowerChange(m-&gt;p-&gt;PowerConnection, (<span class="enscript-type">long</span>)messageArgument);

    KQueueUnlock(<span class="enscript-string">&quot;PowerChanged Sleep/Wake&quot;</span>);
}

<span class="enscript-comment">// iPhone OS doesn't currently have SnowLeopard's IO Power Management
</span><span class="enscript-comment">// but it does define kIOPMAcknowledgmentOptionSystemCapabilityRequirements
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">kIOPMAcknowledgmentOptionSystemCapabilityRequirements</span>) &amp;&amp; <span class="enscript-variable-name">TARGET_OS_OSX</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SnowLeopardPowerChanged</span>(<span class="enscript-type">void</span> *refcon, IOPMConnection connection, IOPMConnectionMessageToken token, IOPMSystemPowerStateCapabilities eventDescriptor)
{
    mDNS *<span class="enscript-type">const</span> m = (mDNS *<span class="enscript-type">const</span>)refcon;
    KQueueLock();
    LogSPS(<span class="enscript-string">&quot;SnowLeopardPowerChanged %X %X %X%s%s%s%s%s&quot;</span>,
           connection, token, eventDescriptor,
           eventDescriptor &amp; kIOPMSystemPowerStateCapabilityCPU     ? <span class="enscript-string">&quot; CPU&quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
           eventDescriptor &amp; kIOPMSystemPowerStateCapabilityVideo   ? <span class="enscript-string">&quot; Video&quot;</span>   : <span class="enscript-string">&quot;&quot;</span>,
           eventDescriptor &amp; kIOPMSystemPowerStateCapabilityAudio   ? <span class="enscript-string">&quot; Audio&quot;</span>   : <span class="enscript-string">&quot;&quot;</span>,
           eventDescriptor &amp; kIOPMSystemPowerStateCapabilityNetwork ? <span class="enscript-string">&quot; Network&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
           eventDescriptor &amp; kIOPMSystemPowerStateCapabilityDisk    ? <span class="enscript-string">&quot; Disk&quot;</span>    : <span class="enscript-string">&quot;&quot;</span>);

    <span class="enscript-comment">// Make sure our m-&gt;SystemWakeOnLANEnabled value correctly reflects the current system setting
</span>    m-&gt;SystemWakeOnLANEnabled = SystemWakeForNetworkAccess();

    <span class="enscript-keyword">if</span> (eventDescriptor &amp; kIOPMSystemPowerStateCapabilityCPU)
    {
        <span class="enscript-comment">// We might be in Sleeping or Transferring state. When we go from &quot;wakeup&quot; to &quot;sleep&quot; state, we don't
</span>        <span class="enscript-comment">// go directly to sleep state, but transfer in to the sleep state during which SleepState is set to
</span>        <span class="enscript-comment">// SleepState_Transferring. During that time, we might get another wakeup before we transition to Sleeping
</span>        <span class="enscript-comment">// state. In that case, we need to acknowledge the previous &quot;sleep&quot; before we acknowledge the wakeup.
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepLimit)
        {
            LogSPS(<span class="enscript-string">&quot;SnowLeopardPowerChanged: Waking up, Acking old Sleep, SleepLimit %d SleepState %d&quot;</span>, m-&gt;SleepLimit, m-&gt;SleepState);
            IOPMConnectionAcknowledgeEvent(connection, m-&gt;p-&gt;SleepCookie);
            m-&gt;SleepLimit = 0;
        }
        LogSPS(<span class="enscript-string">&quot;SnowLeopardPowerChanged: Waking up, Acking Wakeup, SleepLimit %d SleepState %d&quot;</span>, m-&gt;SleepLimit, m-&gt;SleepState);
        <span class="enscript-comment">// CPU Waking. Note: Can get this message repeatedly, as other subsystems power up or down.
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepState != SleepState_Awake)
        {
            PowerOn(m);
            <span class="enscript-comment">// If the network notifications have already come before we got the wakeup, we ignored them and
</span>            <span class="enscript-comment">// in case we get no more, we need to trigger one.
</span>            mDNS_Lock(m);
            SetNetworkChanged(mDNSPlatformOneSecond * 2);
            mDNS_Unlock(m);
        }
        IOPMConnectionAcknowledgeEvent(connection, token);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// CPU sleeping. Should not get this repeatedly -- once we're told that the CPU is halting
</span>        <span class="enscript-comment">// we should hear nothing more until we're told that the CPU has started executing again.
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepState) LogMsg(<span class="enscript-string">&quot;SnowLeopardPowerChanged: Sleep Error %X m-&gt;SleepState %d&quot;</span>, eventDescriptor, m-&gt;SleepState);
        <span class="enscript-comment">//sleep(5);
</span>        <span class="enscript-comment">//mDNSMacOSXNetworkChanged(m);
</span>        mDNSCoreMachineSleep(m, true);
        <span class="enscript-comment">//if (m-&gt;SleepState == SleepState_Sleeping) mDNSMacOSXNetworkChanged(m);
</span>        m-&gt;p-&gt;SleepCookie = token;
    }

    KQueueUnlock(<span class="enscript-string">&quot;SnowLeopardPowerChanged Sleep/Wake&quot;</span>);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - /<span class="enscript-variable-name">etc</span>/<span class="enscript-variable-name">hosts</span> <span class="enscript-variable-name">support</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Implementation Notes
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// As /etc/hosts file can be huge (1000s of entries - when this comment was written, the test file had about
</span><span class="enscript-comment">// 23000 entries with about 4000 duplicates), we can't use a linked list to store these entries. So, we parse
</span><span class="enscript-comment">// them into a hash table. The implementation need to be able to do the following things efficiently
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 1. Detect duplicates e.g., two entries with &quot;1.2.3.4 foo&quot;
</span><span class="enscript-comment">// 2. Detect whether /etc/hosts has changed and what has changed since the last read from the disk
</span><span class="enscript-comment">// 3. Ability to support multiple addresses per name e.g., &quot;1.2.3.4 foo, 2.3.4.5 foo&quot;. To support this, we
</span><span class="enscript-comment">//    need to be able set the RRSet of a resource record to the first one in the list and also update when
</span><span class="enscript-comment">//    one of them go away. This is needed so that the core thinks that they are all part of the same RRSet and
</span><span class="enscript-comment">//    not a duplicate
</span><span class="enscript-comment">// 4. Don't maintain any local state about any records registered with the core to detect changes to /etc/hosts
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// CFDictionary is not a suitable candidate because it does not support duplicates and even if we use a custom
</span><span class="enscript-comment">// &quot;hash&quot; function to solve this, the others are hard to solve. Hence, we share the hash (AuthHash) implementation
</span><span class="enscript-comment">// of the core layer which does all of the above very efficiently
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ETCHOSTS_BUFSIZE</span>    1024    // Buffer size to parse a single line in /etc/hosts

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">FreeEtcHosts</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m;  <span class="enscript-comment">// unused
</span>    (<span class="enscript-type">void</span>)rr;
    (<span class="enscript-type">void</span>)result;
    <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        LogInfo(<span class="enscript-string">&quot;FreeEtcHosts: %s&quot;</span>, ARDisplayString(m, rr));
        freeL(<span class="enscript-string">&quot;etchosts&quot;</span>, rr);
    }
}

<span class="enscript-comment">// Returns true on success and false on failure
</span>mDNSlocal mDNSBool <span class="enscript-function-name">mDNSMacOSXCreateEtcHostsEntry</span>(<span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">const</span> domainname *cname, <span class="enscript-type">char</span> *ifname, AuthHash *auth)
{
    AuthRecord *rr;
    mDNSu32 namehash;
    AuthGroup *ag;
    mDNSInterfaceID InterfaceID = mDNSInterface_LocalOnly;
    mDNSu16 rrtype;

    <span class="enscript-keyword">if</span> (!domain)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: ERROR!! name NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (!sa &amp;&amp; !cname)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa and cname both NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (sa &amp;&amp; sa-&gt;sa_family != AF_INET &amp;&amp; sa-&gt;sa_family != AF_INET6)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa with bad family %d&quot;</span>, sa-&gt;sa_family);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }


    <span class="enscript-keyword">if</span> (ifname)
    {
        mDNSu32 ifindex = if_nametoindex(ifname);
        <span class="enscript-keyword">if</span> (!ifindex)
        {
            LogMsg(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: hosts entry %##s with invalid ifname %s&quot;</span>, domain-&gt;c, ifname);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        InterfaceID = (mDNSInterfaceID)(uintptr_t)ifindex;
    }

    <span class="enscript-keyword">if</span> (sa)
        rrtype = (sa-&gt;sa_family == AF_INET ? kDNSType_A : kDNSType_AAAA);
    <span class="enscript-keyword">else</span>
        rrtype = kDNSType_CNAME;

    <span class="enscript-comment">// Check for duplicates. See whether we parsed an entry before like this ?
</span>    namehash = DomainNameHashValue(domain);
    ag = AuthGroupForName(auth, namehash, domain);
    <span class="enscript-keyword">if</span> (ag)
    {
        rr = ag-&gt;members;
        <span class="enscript-keyword">while</span> (rr)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == rrtype)
            {
                <span class="enscript-keyword">if</span> (rrtype == kDNSType_A)
                {
                    mDNSv4Addr ip;
                    ip.NotAnInteger = ((<span class="enscript-type">struct</span> sockaddr_in*)sa)-&gt;sin_addr.s_addr;
                    <span class="enscript-keyword">if</span> (mDNSSameIPv4Address(rr-&gt;resrec.rdata-&gt;u.ipv4, ip) &amp;&amp; InterfaceID == rr-&gt;resrec.InterfaceID)
                    {
                        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: Same IPv4 address and InterfaceID for name %##s ID %d&quot;</span>, domain-&gt;c, IIDPrintable(InterfaceID));
                        <span class="enscript-keyword">return</span> mDNSfalse;
                    }
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rrtype == kDNSType_AAAA)
                {
                    mDNSv6Addr ip6;
                    ip6.l[0] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[0];
                    ip6.l[1] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[1];
                    ip6.l[2] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[2];
                    ip6.l[3] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[3];
                    <span class="enscript-keyword">if</span> (mDNSSameIPv6Address(rr-&gt;resrec.rdata-&gt;u.ipv6, ip6) &amp;&amp; InterfaceID == rr-&gt;resrec.InterfaceID)
                    {
                        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: Same IPv6 address and InterfaceID for name %##s ID %d&quot;</span>, domain-&gt;c, IIDPrintable(InterfaceID));
                        <span class="enscript-keyword">return</span> mDNSfalse;
                    }
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rrtype == kDNSType_CNAME)
                {
                    <span class="enscript-keyword">if</span> (SameDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.name, cname))
                    {
                        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: Same cname %##s for name %##s&quot;</span>, cname-&gt;c, domain-&gt;c);
                        <span class="enscript-keyword">return</span> mDNSfalse;
                    }
                }
            }
            rr = rr-&gt;next;
        }
    }
    rr = (AuthRecord *) callocL(<span class="enscript-string">&quot;etchosts&quot;</span>, <span class="enscript-keyword">sizeof</span>(*rr));
    <span class="enscript-keyword">if</span> (rr == NULL) <span class="enscript-keyword">return</span> mDNSfalse;
    mDNS_SetupResourceRecord(rr, NULL, InterfaceID, rrtype, 1, kDNSRecordTypeKnownUnique, AuthRecordLocalOnly, FreeEtcHosts, NULL);
    AssignDomainName(&amp;rr-&gt;namestorage, domain);

    <span class="enscript-keyword">if</span> (sa)
    {
        rr-&gt;resrec.rdlength = sa-&gt;sa_family == AF_INET ? <span class="enscript-keyword">sizeof</span>(mDNSv4Addr) : <span class="enscript-keyword">sizeof</span>(mDNSv6Addr);
        <span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET)
            rr-&gt;resrec.rdata-&gt;u.ipv4.NotAnInteger = ((<span class="enscript-type">struct</span> sockaddr_in*)sa)-&gt;sin_addr.s_addr;
        <span class="enscript-keyword">else</span>
        {
            rr-&gt;resrec.rdata-&gt;u.ipv6.l[0] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[0];
            rr-&gt;resrec.rdata-&gt;u.ipv6.l[1] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[1];
            rr-&gt;resrec.rdata-&gt;u.ipv6.l[2] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[2];
            rr-&gt;resrec.rdata-&gt;u.ipv6.l[3] = ((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr.__u6_addr.__u6_addr32[3];
        }
    }
    <span class="enscript-keyword">else</span>
    {
        rr-&gt;resrec.rdlength = DomainNameLength(cname);
        rr-&gt;resrec.rdata-&gt;u.name.c[0] = 0;
        AssignDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.name, cname);
    }
    rr-&gt;resrec.namehash = DomainNameHashValue(rr-&gt;resrec.name);
    SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);  <span class="enscript-comment">// Sets rr-&gt;rdatahash for us
</span>    LogInfo(<span class="enscript-string">&quot;mDNSMacOSXCreateEtcHostsEntry: Adding resource record %s ID %d&quot;</span>, ARDisplayString(&amp;mDNSStorage, rr), IIDPrintable(rr-&gt;resrec.InterfaceID));
    InsertAuthRecord(&amp;mDNSStorage, auth, rr);
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">EtcHostsParseOneName</span>(<span class="enscript-type">int</span> start, <span class="enscript-type">int</span> length, <span class="enscript-type">char</span> *buffer, <span class="enscript-type">char</span> **name)
{
    <span class="enscript-type">int</span> i;

    *name = NULL;
    <span class="enscript-keyword">for</span> (i = start; i &lt; length; i++)
    {
        <span class="enscript-keyword">if</span> (buffer[i] == <span class="enscript-string">'#'</span>)
            <span class="enscript-keyword">return</span> -1;
        <span class="enscript-keyword">if</span> (buffer[i] != <span class="enscript-string">' '</span> &amp;&amp; buffer[i] != <span class="enscript-string">','</span> &amp;&amp; buffer[i] != <span class="enscript-string">'\t'</span>)
        {
            *name = &amp;buffer[i];

            <span class="enscript-comment">// Found the start of a name, find the end and null terminate
</span>            <span class="enscript-keyword">for</span> (i++; i &lt; length; i++)
            {
                <span class="enscript-keyword">if</span> (buffer[i] == <span class="enscript-string">' '</span> || buffer[i] == <span class="enscript-string">','</span> || buffer[i] == <span class="enscript-string">'\t'</span>)
                {
                    buffer[i] = 0;
                    <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">return</span> i;
        }
    }
    <span class="enscript-keyword">return</span> -1;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXParseEtcHostsLine</span>(<span class="enscript-type">char</span> *buffer, ssize_t length, AuthHash *auth)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> ifStart = 0;
    <span class="enscript-type">char</span> *ifname = NULL;
    domainname name1d;
    domainname name2d;
    <span class="enscript-type">char</span> *name1;
    <span class="enscript-type">char</span> *name2;
    <span class="enscript-type">int</span> aliasIndex;

    <span class="enscript-comment">//Ignore leading whitespaces and tabs
</span>    <span class="enscript-keyword">while</span> (*buffer == <span class="enscript-string">' '</span> || *buffer == <span class="enscript-string">'\t'</span>)
    {
        buffer++;
        length--;
    }

    <span class="enscript-comment">// Find the end of the address string
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; length; i++)
    {
        <span class="enscript-keyword">if</span> (buffer[i] == <span class="enscript-string">' '</span> || buffer[i] == <span class="enscript-string">','</span> || buffer[i] == <span class="enscript-string">'\t'</span> || buffer[i] == <span class="enscript-string">'%'</span>)
        {
            <span class="enscript-keyword">if</span> (buffer[i] == <span class="enscript-string">'%'</span>)
                ifStart = i + 1;
            buffer[i] = 0;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-comment">// Convert the address string to an address
</span>    <span class="enscript-type">struct</span> addrinfo hints;
    bzero(&amp;hints, <span class="enscript-keyword">sizeof</span>(hints));
    hints.ai_flags = AI_NUMERICHOST;
    <span class="enscript-type">struct</span> addrinfo *gairesults = NULL;
    <span class="enscript-keyword">if</span> (getaddrinfo(buffer, NULL, &amp;hints, &amp;gairesults) != 0)
    {
        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: getaddrinfo returning null&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (ifStart)
    {
        <span class="enscript-comment">// Parse the interface
</span>        ifname = &amp;buffer[ifStart];
        <span class="enscript-keyword">for</span> (i = ifStart + 1; i &lt; length; i++)
        {
            <span class="enscript-keyword">if</span> (buffer[i] == <span class="enscript-string">' '</span> || buffer[i] == <span class="enscript-string">','</span> || buffer[i] == <span class="enscript-string">'\t'</span>)
            {
                buffer[i] = 0;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    i = EtcHostsParseOneName(i + 1, length, buffer, &amp;name1);
    <span class="enscript-keyword">if</span> (i == length)
    {
        <span class="enscript-comment">// Common case (no aliases) : The entry is of the form &quot;1.2.3.4 somehost&quot; with no trailing white spaces/tabs etc.
</span>        <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;name1d, name1))
        {
            LogMsg(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s&quot;</span>, name1);
            freeaddrinfo(gairesults);
            <span class="enscript-keyword">return</span>;
        }
        mDNSMacOSXCreateEtcHostsEntry(&amp;name1d, gairesults-&gt;ai_addr, mDNSNULL, ifname, auth);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i != -1)
    {
        domainname first;
        <span class="enscript-comment">// We might have some extra white spaces at the end for the common case of &quot;1.2.3.4 somehost&quot;.
</span>        <span class="enscript-comment">// When we parse again below, EtchHostsParseOneName would return -1 and we will end up
</span>        <span class="enscript-comment">// doing the right thing.
</span>        
        <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;first, name1))
        {
            LogMsg(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s&quot;</span>, name1);
            freeaddrinfo(gairesults);
            <span class="enscript-keyword">return</span>;
        }
        mDNSMacOSXCreateEtcHostsEntry(&amp;first, gairesults-&gt;ai_addr, mDNSNULL, ifname, auth);
        
        <span class="enscript-comment">// /etc/hosts alias discussion:
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// If the /etc/hosts has an entry like this
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">//  ip_address cname [aliases...]
</span>        <span class="enscript-comment">//  1.2.3.4    sun    star    bright
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// star and bright are aliases (gethostbyname h_alias should point to these) and sun is the canonical
</span>        <span class="enscript-comment">// name (getaddrinfo ai_cannonname and gethostbyname h_name points to &quot;sun&quot;)
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// To achieve this, we need to add the entry like this:
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// sun A 1.2.3.4
</span>        <span class="enscript-comment">// star CNAME sun
</span>        <span class="enscript-comment">// bright CNAME sun
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// We store the first name we parsed in &quot;first&quot; and add the address (A/AAAA) record.
</span>        <span class="enscript-comment">// Then we parse additional names adding CNAME records till we reach the end.
</span>        
        aliasIndex = 0;
        <span class="enscript-keyword">while</span> (i &lt; length)
        {
            <span class="enscript-comment">// Continue to parse additional aliases until we reach end of the line and
</span>            <span class="enscript-comment">// for each &quot;alias&quot; parsed, add a CNAME record where &quot;alias&quot; points to the first &quot;name&quot;.
</span>            <span class="enscript-comment">// See also /etc/hosts alias discussion above
</span>            
            i = EtcHostsParseOneName(i + 1, length, buffer, &amp;name2);
            
            <span class="enscript-keyword">if</span> (name2)
            {
                <span class="enscript-keyword">if</span> ((aliasIndex) &amp;&amp; (*buffer == *name2))
                    <span class="enscript-keyword">break</span>; <span class="enscript-comment">// break out of the loop if we wrap around
</span>                
                <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;name2d, name2))
                {
                    LogMsg(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s&quot;</span>, name2);
                    freeaddrinfo(gairesults);
                    <span class="enscript-keyword">return</span>;
                }
                <span class="enscript-comment">// Ignore if it points to itself
</span>                <span class="enscript-keyword">if</span> (!SameDomainName(&amp;first, &amp;name2d))
                {
                    <span class="enscript-keyword">if</span> (!mDNSMacOSXCreateEtcHostsEntry(&amp;name2d, mDNSNULL, &amp;first, ifname, auth))
                    {
                        freeaddrinfo(gairesults);
                        <span class="enscript-keyword">return</span>;
                    }
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: Ignoring entry with same names first %##s, name2 %##s&quot;</span>, first.c, name2d.c);
                }
                aliasIndex++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!aliasIndex)
            {
                <span class="enscript-comment">// We have never parsed any aliases. This case happens if there
</span>                <span class="enscript-comment">// is just one name and some extra white spaces at the end.
</span>                LogInfo(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHostsLine: White space at the end of %##s&quot;</span>, first.c);
                <span class="enscript-keyword">break</span>;
            }
        }
    }
    freeaddrinfo(gairesults);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXParseEtcHosts</span>(<span class="enscript-type">int</span> fd, AuthHash *auth)
{
    mDNSBool good;
    <span class="enscript-type">char</span> buf[ETCHOSTS_BUFSIZE];
    ssize_t len;
    FILE *fp;

    <span class="enscript-keyword">if</span> (fd == -1) { LogInfo(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHosts: fd is -1&quot;</span>); <span class="enscript-keyword">return</span>; }

    fp = fopen(<span class="enscript-string">&quot;/etc/hosts&quot;</span>, <span class="enscript-string">&quot;r&quot;</span>);
    <span class="enscript-keyword">if</span> (!fp) { LogInfo(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHosts: fp is NULL&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">while</span> (1)
    {
        good = (fgets(buf, ETCHOSTS_BUFSIZE, fp) != NULL);
        <span class="enscript-keyword">if</span> (!good) <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// skip comment and empty lines
</span>        <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">'#'</span> || buf[0] == <span class="enscript-string">'\r'</span> || buf[0] == <span class="enscript-string">'\n'</span>)
            <span class="enscript-keyword">continue</span>;

        len = strlen(buf);
        <span class="enscript-keyword">if</span> (!len) <span class="enscript-keyword">break</span>;    <span class="enscript-comment">// sanity check
</span>        <span class="enscript-comment">//Check for end of line code(mostly only \n but pre-OS X Macs could have only \r)
</span>        <span class="enscript-keyword">if</span> (buf[len - 1] == <span class="enscript-string">'\r'</span> || buf[len - 1] == <span class="enscript-string">'\n'</span>)
        {
            buf[len - 1] = <span class="enscript-string">'\0'</span>;
            len = len - 1;
        }
        <span class="enscript-comment">// fgets always null terminates and hence even if we have no
</span>        <span class="enscript-comment">// newline at the end, it is null terminated. The callee
</span>        <span class="enscript-comment">// (mDNSMacOSXParseEtcHostsLine) expects the length to be such that
</span>        <span class="enscript-comment">// buf[length] is zero and hence we decrement len to reflect that.
</span>        <span class="enscript-keyword">if</span> (len)
        {
            <span class="enscript-comment">//Additional check when end of line code is 2 chars ie\r\n(DOS, other old OSes)
</span>            <span class="enscript-comment">//here we need to check for just \r but taking extra caution.
</span>            <span class="enscript-keyword">if</span> (buf[len - 1] == <span class="enscript-string">'\r'</span> || buf[len - 1] == <span class="enscript-string">'\n'</span>)
            {
                buf[len - 1] = <span class="enscript-string">'\0'</span>;
                len = len - 1;
            }
        }
        <span class="enscript-keyword">if</span> (!len) <span class="enscript-comment">//Sanity Check: len should never be zero
</span>        {
            LogMsg(<span class="enscript-string">&quot;mDNSMacOSXParseEtcHosts: Length is zero!&quot;</span>);
            <span class="enscript-keyword">continue</span>;
        }
        mDNSMacOSXParseEtcHostsLine(buf, len, auth);
    }
    fclose(fp);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXUpdateEtcHosts</span>(mDNS *<span class="enscript-type">const</span> m);

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">mDNSMacOSXGetEtcHostsFD</span>(<span class="enscript-type">void</span>)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__DISPATCH_GROUP__</span>
    <span class="enscript-comment">// Can't do this stuff to be notified of changes in /etc/hosts if we don't have libdispatch
</span>    <span class="enscript-type">static</span> dispatch_queue_t etcq     = 0;
    <span class="enscript-type">static</span> dispatch_source_t etcsrc   = 0;
    <span class="enscript-type">static</span> dispatch_source_t hostssrc = 0;

    <span class="enscript-comment">// First time through? just schedule ourselves on the main queue and we'll do the work later
</span>    <span class="enscript-keyword">if</span> (!etcq)
    {
        etcq = dispatch_get_main_queue();
        <span class="enscript-keyword">if</span> (etcq)
        {
            <span class="enscript-comment">// Do this work on the queue, not here - solves potential synchronization issues
</span>            dispatch_async(etcq, ^{mDNSMacOSXUpdateEtcHosts(m);});
        }
        <span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">if</span> (hostssrc) <span class="enscript-keyword">return</span> dispatch_source_get_handle(hostssrc);
#<span class="enscript-reference">endif</span>

    <span class="enscript-type">int</span> fd = open(<span class="enscript-string">&quot;/etc/hosts&quot;</span>, O_RDONLY);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__DISPATCH_GROUP__</span>
    <span class="enscript-comment">// Can't do this stuff to be notified of changes in /etc/hosts if we don't have libdispatch
</span>    <span class="enscript-keyword">if</span> (fd == -1)
    {
        <span class="enscript-comment">// If the open failed and we're already watching /etc, we're done
</span>        <span class="enscript-keyword">if</span> (etcsrc) { LogInfo(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: Returning etcfd because no etchosts&quot;</span>); <span class="enscript-keyword">return</span> fd; }

        <span class="enscript-comment">// we aren't watching /etc, we should be
</span>        fd = open(<span class="enscript-string">&quot;/etc&quot;</span>, O_RDONLY);
        <span class="enscript-keyword">if</span> (fd == -1) { LogInfo(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: etc does not exist&quot;</span>); <span class="enscript-keyword">return</span> -1; }
        etcsrc = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE | DISPATCH_VNODE_RENAME, etcq);
        <span class="enscript-keyword">if</span> (etcsrc == NULL)
        {
            close(fd);
            <span class="enscript-keyword">return</span> -1;
        }
        dispatch_source_set_event_handler(etcsrc,
                                          ^{
                                              u_int32_t flags = dispatch_source_get_data(etcsrc);
                                              LogMsg(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: /etc changed 0x%x&quot;</span>, flags);
                                              <span class="enscript-keyword">if</span> ((flags &amp; (DISPATCH_VNODE_DELETE | DISPATCH_VNODE_RENAME)) != 0)
                                              {
                                                  dispatch_source_cancel(etcsrc);
                                                  dispatch_release(etcsrc);
                                                  etcsrc = NULL;
                                                  dispatch_async(etcq, ^{mDNSMacOSXUpdateEtcHosts(m);});
                                                  <span class="enscript-keyword">return</span>;
                                              }
                                              <span class="enscript-keyword">if</span> ((flags &amp; DISPATCH_VNODE_WRITE) != 0 &amp;&amp; hostssrc == NULL)
                                              {
                                                  mDNSMacOSXUpdateEtcHosts(m);
                                              }
                                          });
        dispatch_source_set_cancel_handler(etcsrc, ^{close(fd);});
        dispatch_resume(etcsrc);

        <span class="enscript-comment">// Try and open /etc/hosts once more now that we're watching /etc, in case we missed the creation
</span>        fd = open(<span class="enscript-string">&quot;/etc/hosts&quot;</span>, O_RDONLY | O_EVTONLY);
        <span class="enscript-keyword">if</span> (fd == -1) { LogMsg(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD etc hosts does not exist, watching etc&quot;</span>); <span class="enscript-keyword">return</span> -1; }
    }

    <span class="enscript-comment">// create a dispatch source to watch for changes to hosts file
</span>    hostssrc = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,
                                      (DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE | DISPATCH_VNODE_RENAME |
                                       DISPATCH_VNODE_ATTRIB | DISPATCH_VNODE_EXTEND | DISPATCH_VNODE_LINK | DISPATCH_VNODE_REVOKE), etcq);
    <span class="enscript-keyword">if</span> (hostssrc == NULL)
    {
        close(fd);
        <span class="enscript-keyword">return</span> -1;
    }
    dispatch_source_set_event_handler(hostssrc,
                                      ^{
                                          u_int32_t flags = dispatch_source_get_data(hostssrc);
                                          LogInfo(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: /etc/hosts changed 0x%x&quot;</span>, flags);
                                          <span class="enscript-keyword">if</span> ((flags &amp; (DISPATCH_VNODE_DELETE | DISPATCH_VNODE_RENAME)) != 0)
                                          {
                                              dispatch_source_cancel(hostssrc);
                                              dispatch_release(hostssrc);
                                              hostssrc = NULL;
                                              <span class="enscript-comment">// Bug in LibDispatch: wait a second before scheduling the block. If we schedule
</span>                                              <span class="enscript-comment">// the block immediately, we try to open the file and the file may not exist and may
</span>                                              <span class="enscript-comment">// fail to get a notification in the future. When the file does not exist and
</span>                                              <span class="enscript-comment">// we start to monitor the directory, on &quot;dispatch_resume&quot; of that source, there
</span>                                              <span class="enscript-comment">// is no guarantee that the file creation will be notified always because when
</span>                                              <span class="enscript-comment">// the dispatch_resume returns, the kevent manager may not have registered the
</span>                                              <span class="enscript-comment">// kevent yet but the file may have been created
</span>                                              usleep(1000000);
                                              dispatch_async(etcq, ^{mDNSMacOSXUpdateEtcHosts(m);});
                                              <span class="enscript-keyword">return</span>;
                                          }
                                          <span class="enscript-keyword">if</span> ((flags &amp; DISPATCH_VNODE_WRITE) != 0)
                                          {
                                              mDNSMacOSXUpdateEtcHosts(m);
                                          }
                                      });
    dispatch_source_set_cancel_handler(hostssrc, ^{LogInfo(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: Closing etchosts fd %d&quot;</span>, fd); close(fd);});
    dispatch_resume(hostssrc);

    <span class="enscript-comment">// Cleanup /etc source, no need to watch it if we already have /etc/hosts
</span>    <span class="enscript-keyword">if</span> (etcsrc)
    {
        dispatch_source_cancel(etcsrc);
        dispatch_release(etcsrc);
        etcsrc = NULL;
    }

    LogInfo(<span class="enscript-string">&quot;mDNSMacOSXGetEtcHostsFD: /etc/hosts being monitored, and not etc&quot;</span>);
    <span class="enscript-keyword">return</span> hostssrc ? (<span class="enscript-type">int</span>)dispatch_source_get_handle(hostssrc) : -1;
#<span class="enscript-reference">else</span>
    (<span class="enscript-type">void</span>)m;
    <span class="enscript-keyword">return</span> fd;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">// When /etc/hosts is modified, flush all the cache records as there may be local
</span><span class="enscript-comment">// authoritative answers now
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FlushAllCacheRecords</span>(mDNS *<span class="enscript-type">const</span> m)
{
    CacheRecord *cr;
    mDNSu32 slot;
    CacheGroup *cg;

    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-comment">// Skip multicast.
</span>        <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID) <span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">// If a resource record can answer A or AAAA, they need to be flushed so that we will
</span>        <span class="enscript-comment">// never used to deliver an ADD or RMV
</span>        <span class="enscript-keyword">if</span> (RRTypeAnswersQuestionType(&amp;cr-&gt;resrec, kDNSType_A) ||
            RRTypeAnswersQuestionType(&amp;cr-&gt;resrec, kDNSType_AAAA))
        {
            LogInfo(<span class="enscript-string">&quot;FlushAllCacheRecords: Purging Resourcerecord %s&quot;</span>, CRDisplayString(m, cr));
            mDNS_PurgeCacheResourceRecord(m, cr);
        }
    }
}

<span class="enscript-comment">// Add new entries to the core. If justCheck is set, this function does not add, just returns true
</span>mDNSlocal mDNSBool <span class="enscript-function-name">EtcHostsAddNewEntries</span>(AuthHash *newhosts, mDNSBool justCheck)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    AuthGroup *ag;
    mDNSu32 slot;
    AuthRecord *rr, *primary, *rrnext;
    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
        <span class="enscript-keyword">for</span> (ag = newhosts-&gt;rrauth_hash[slot]; ag; ag = ag-&gt;next)
        {
            primary = NULL;
            <span class="enscript-keyword">for</span> (rr = ag-&gt;members; rr; rr = rrnext)
            {
                rrnext = rr-&gt;next;
                AuthGroup *ag1;
                AuthRecord *rr1;
                mDNSBool found = mDNSfalse;
                ag1 = AuthGroupForRecord(&amp;m-&gt;rrauth, &amp;rr-&gt;resrec);
                <span class="enscript-keyword">if</span> (ag1 &amp;&amp; ag1-&gt;members)
                {
                    <span class="enscript-keyword">if</span> (!primary) primary = ag1-&gt;members;
                    rr1 = ag1-&gt;members;
                    <span class="enscript-keyword">while</span> (rr1)
                    {
                        <span class="enscript-comment">// We are not using InterfaceID in checking for duplicates. This means,
</span>                        <span class="enscript-comment">// if there are two addresses for a given name e.g., fe80::1%en0 and
</span>                        <span class="enscript-comment">// fe80::1%en1, we only add the first one. It is not clear whether
</span>                        <span class="enscript-comment">// this is a common case. To fix this, we also need to modify
</span>                        <span class="enscript-comment">// mDNS_Register_internal in how it handles duplicates. If it becomes a
</span>                        <span class="enscript-comment">// common case, we will fix it then.
</span>                        <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rr1-&gt;resrec, &amp;rr-&gt;resrec) &amp;&amp; rr1-&gt;resrec.InterfaceID == rr-&gt;resrec.InterfaceID)
                        {
                            LogInfo(<span class="enscript-string">&quot;EtcHostsAddNewEntries: Skipping, not adding %s&quot;</span>, ARDisplayString(m, rr1));
                            found = mDNStrue;
                            <span class="enscript-keyword">break</span>;
                        }
                        rr1 = rr1-&gt;next;
                    }
                }
                <span class="enscript-keyword">if</span> (!found)
                {
                    <span class="enscript-keyword">if</span> (justCheck)
                    {
                        LogInfo(<span class="enscript-string">&quot;EtcHostsAddNewEntries: Entry %s not registered with core yet&quot;</span>, ARDisplayString(m, rr));
                        <span class="enscript-keyword">return</span> mDNStrue;
                    }
                    RemoveAuthRecord(m, newhosts, rr);
                    <span class="enscript-comment">// if there is no primary, point to self
</span>                    rr-&gt;RRSet = (primary ? primary : rr);
                    rr-&gt;next = NULL;
                    LogInfo(<span class="enscript-string">&quot;EtcHostsAddNewEntries: Adding %s ID %d&quot;</span>, ARDisplayString(m, rr), IIDPrintable(rr-&gt;resrec.InterfaceID));
                    <span class="enscript-keyword">if</span> (mDNS_Register_internal(m, rr) != mStatus_NoError)
                        LogMsg(<span class="enscript-string">&quot;EtcHostsAddNewEntries: mDNS_Register failed for %s&quot;</span>, ARDisplayString(m, rr));
                }
            }
        }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Delete entries from the core that are no longer needed. If justCheck is set, this function
</span><span class="enscript-comment">// does not delete, just returns true
</span>mDNSlocal mDNSBool <span class="enscript-function-name">EtcHostsDeleteOldEntries</span>(AuthHash *newhosts, mDNSBool justCheck)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    AuthGroup *ag;
    mDNSu32 slot;
    AuthRecord *rr, *rrnext;
    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
        <span class="enscript-keyword">for</span> (ag = m-&gt;rrauth.rrauth_hash[slot]; ag; ag = ag-&gt;next)
            <span class="enscript-keyword">for</span> (rr = ag-&gt;members; rr; rr = rrnext)
            {
                mDNSBool found = mDNSfalse;
                AuthGroup *ag1;
                AuthRecord *rr1;
                rrnext = rr-&gt;next;
                <span class="enscript-keyword">if</span> (rr-&gt;RecordCallback != FreeEtcHosts) <span class="enscript-keyword">continue</span>;
                ag1 = AuthGroupForRecord(newhosts, &amp;rr-&gt;resrec);
                <span class="enscript-keyword">if</span> (ag1)
                {
                    rr1 = ag1-&gt;members;
                    <span class="enscript-keyword">while</span> (rr1)
                    {
                        <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rr1-&gt;resrec, &amp;rr-&gt;resrec))
                        {
                            LogInfo(<span class="enscript-string">&quot;EtcHostsDeleteOldEntries: Old record %s found in new, skipping&quot;</span>, ARDisplayString(m, rr));
                            found = mDNStrue;
                            <span class="enscript-keyword">break</span>;
                        }
                        rr1 = rr1-&gt;next;
                    }
                }
                <span class="enscript-comment">// there is no corresponding record in newhosts for the same name. This means
</span>                <span class="enscript-comment">// we should delete this from the core.
</span>                <span class="enscript-keyword">if</span> (!found)
                {
                    <span class="enscript-keyword">if</span> (justCheck)
                    {
                        LogInfo(<span class="enscript-string">&quot;EtcHostsDeleteOldEntries: Record %s not found in new, deleting&quot;</span>, ARDisplayString(m, rr));
                        <span class="enscript-keyword">return</span> mDNStrue;
                    }
                    <span class="enscript-comment">// if primary is going away, make sure that the rest of the records
</span>                    <span class="enscript-comment">// point to the new primary
</span>                    <span class="enscript-keyword">if</span> (rr == ag-&gt;members)
                    {
                        AuthRecord *new_primary = rr-&gt;next;
                        AuthRecord *r = new_primary;
                        <span class="enscript-keyword">while</span> (r)
                        {
                            <span class="enscript-keyword">if</span> (r-&gt;RRSet == rr)
                            {
                                LogInfo(<span class="enscript-string">&quot;EtcHostsDeleteOldEntries: Updating Resource Record %s to primary&quot;</span>, ARDisplayString(m, r));
                                r-&gt;RRSet = new_primary;
                            }
                            <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;EtcHostsDeleteOldEntries: ERROR!! Resource Record %s not pointing to primary %##s&quot;</span>, ARDisplayString(m, r), r-&gt;resrec.name);
                            r = r-&gt;next;
                        }
                    }
                    LogInfo(<span class="enscript-string">&quot;EtcHostsDeleteOldEntries: Deleting %s&quot;</span>, ARDisplayString(m, rr));
                    mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
                }
            }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateEtcHosts</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context)
{
    AuthHash *newhosts = (AuthHash *)context;

    mDNS_CheckLock(m);

    <span class="enscript-comment">//Delete old entries from the core if they are not present in the newhosts
</span>    EtcHostsDeleteOldEntries(newhosts, mDNSfalse);
    <span class="enscript-comment">// Add the new entries to the core if not already present in the core
</span>    EtcHostsAddNewEntries(newhosts, mDNSfalse);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeNewHosts</span>(AuthHash *newhosts)
{
    mDNSu32 slot;
    AuthGroup *ag, *agnext;
    AuthRecord *rr, *rrnext;

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
        <span class="enscript-keyword">for</span> (ag = newhosts-&gt;rrauth_hash[slot]; ag; ag = agnext)
        {
            agnext = ag-&gt;next;
            <span class="enscript-keyword">for</span> (rr = ag-&gt;members; rr; rr = rrnext)
            {
                rrnext = rr-&gt;next;
                freeL(<span class="enscript-string">&quot;etchosts&quot;</span>, rr);
            }
            freeL(<span class="enscript-string">&quot;AuthGroups&quot;</span>, ag);
        }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXUpdateEtcHosts</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthHash newhosts;

    <span class="enscript-comment">// As we will be modifying the core, we can only have one thread running at
</span>    <span class="enscript-comment">// any point in time.
</span>    KQueueLock();

    mDNSPlatformMemZero(&amp;newhosts, <span class="enscript-keyword">sizeof</span>(AuthHash));

    <span class="enscript-comment">// Get the file desecriptor (will trigger us to start watching for changes)
</span>    <span class="enscript-type">int</span> fd = mDNSMacOSXGetEtcHostsFD();
    <span class="enscript-keyword">if</span> (fd != -1)
    {
        LogInfo(<span class="enscript-string">&quot;mDNSMacOSXUpdateEtcHosts: Parsing /etc/hosts fd %d&quot;</span>, fd);
        mDNSMacOSXParseEtcHosts(fd, &amp;newhosts);
    }
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;mDNSMacOSXUpdateEtcHosts: /etc/hosts is not present&quot;</span>);

    <span class="enscript-comment">// Optimization: Detect whether /etc/hosts changed or not.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. Check to see if there are any new entries. We do this by seeing whether any entries in
</span>    <span class="enscript-comment">//    newhosts is already registered with core.  If we find at least one entry that is not
</span>    <span class="enscript-comment">//    registered with core, then it means we have work to do.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. Next, we check to see if any of the entries that are registered with core is not present
</span>    <span class="enscript-comment">//   in newhosts. If we find at least one entry that is not present, it means we have work to
</span>    <span class="enscript-comment">//   do.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: We may not have to hold the lock right here as KQueueLock is held which prevents any
</span>    <span class="enscript-comment">// other thread from running. But mDNS_Lock is needed here as we will be traversing the core
</span>    <span class="enscript-comment">// data structure in EtcHostsDeleteOldEntries/NewEntries which might expect the lock to be held
</span>    <span class="enscript-comment">// in the future and this code does not have to change.
</span>    mDNS_Lock(m);
    <span class="enscript-comment">// Add the new entries to the core if not already present in the core
</span>    <span class="enscript-keyword">if</span> (!EtcHostsAddNewEntries(&amp;newhosts, mDNStrue))
    {
        <span class="enscript-comment">// No new entries to add, check to see if we need to delete any old entries from the
</span>        <span class="enscript-comment">// core if they are not present in the newhosts
</span>        <span class="enscript-keyword">if</span> (!EtcHostsDeleteOldEntries(&amp;newhosts, mDNStrue))
        {
            LogInfo(<span class="enscript-string">&quot;mDNSMacOSXUpdateEtcHosts: No work&quot;</span>);
            FreeNewHosts(&amp;newhosts);
            mDNS_Unlock(m);
            KQueueUnlock(<span class="enscript-string">&quot;/etc/hosts changed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
    }

    <span class="enscript-comment">// This will flush the cache, stop and start the query so that the queries
</span>    <span class="enscript-comment">// can look at the /etc/hosts again
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Notes:
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We can't delete and free the records here. We wait for the mDNSCoreRestartAddressQueries to
</span>    <span class="enscript-comment">// deliver RMV events. It has to be done in a deferred way because we can't deliver RMV
</span>    <span class="enscript-comment">// events for local records *before* the RMV events for cache records. mDNSCoreRestartAddressQueries
</span>    <span class="enscript-comment">// delivers these events in the right order and then calls us back to delete them.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Similarly, we do a deferred Registration of the record because mDNSCoreRestartAddressQueries
</span>    <span class="enscript-comment">// is a common function that looks at all local auth records and delivers a RMV including
</span>    <span class="enscript-comment">// the records that we might add here. If we deliver a ADD here, it will get a RMV and then when
</span>    <span class="enscript-comment">// the query is restarted, it will get another ADD. To avoid this (ADD-RMV-ADD), we defer registering
</span>    <span class="enscript-comment">// the record until the RMVs are delivered in mDNSCoreRestartAddressQueries after which UpdateEtcHosts
</span>    <span class="enscript-comment">// is called back where we do the Registration of the record. This results in RMV followed by ADD which
</span>    <span class="enscript-comment">// looks normal.
</span>    mDNSCoreRestartAddressQueries(m, mDNSfalse, FlushAllCacheRecords, UpdateEtcHosts, &amp;newhosts);
    FreeNewHosts(&amp;newhosts);
    mDNS_Unlock(m);
    KQueueUnlock(<span class="enscript-string">&quot;/etc/hosts changed&quot;</span>);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Initialization</span> &amp; <span class="enscript-variable-name">Teardown</span>
#<span class="enscript-reference">endif</span>

CF_EXPORT CFDictionaryRef <span class="enscript-function-name">_CFCopySystemVersionDictionary</span>(<span class="enscript-type">void</span>);
CF_EXPORT <span class="enscript-type">const</span> CFStringRef _kCFSystemVersionProductNameKey;
CF_EXPORT <span class="enscript-type">const</span> CFStringRef _kCFSystemVersionProductVersionKey;
CF_EXPORT <span class="enscript-type">const</span> CFStringRef _kCFSystemVersionBuildVersionKey;

<span class="enscript-comment">// Major version 13 is 10.9.x 
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSMacOSXSystemBuildNumber</span>(<span class="enscript-type">char</span> *HINFO_SWstring)
{
    <span class="enscript-type">int</span> major = 0, minor = 0;
    <span class="enscript-type">char</span> letter = 0, prodname[256]=<span class="enscript-string">&quot;&lt;Unknown&gt;&quot;</span>, prodvers[256]=<span class="enscript-string">&quot;&lt;Unknown&gt;&quot;</span>, buildver[256]=<span class="enscript-string">&quot;&lt;Unknown&gt;&quot;</span>;
    CFDictionaryRef vers = _CFCopySystemVersionDictionary();
    <span class="enscript-keyword">if</span> (vers)
    {
        CFStringRef cfprodname = CFDictionaryGetValue(vers, _kCFSystemVersionProductNameKey);
        CFStringRef cfprodvers = CFDictionaryGetValue(vers, _kCFSystemVersionProductVersionKey);
        CFStringRef cfbuildver = CFDictionaryGetValue(vers, _kCFSystemVersionBuildVersionKey);
        <span class="enscript-keyword">if</span> (cfprodname) 
            CFStringGetCString(cfprodname, prodname, <span class="enscript-keyword">sizeof</span>(prodname), kCFStringEncodingUTF8);
        <span class="enscript-keyword">if</span> (cfprodvers) 
            CFStringGetCString(cfprodvers, prodvers, <span class="enscript-keyword">sizeof</span>(prodvers), kCFStringEncodingUTF8);
        <span class="enscript-keyword">if</span> (cfbuildver &amp;&amp; CFStringGetCString(cfbuildver, buildver, <span class="enscript-keyword">sizeof</span>(buildver), kCFStringEncodingUTF8))
            sscanf(buildver, <span class="enscript-string">&quot;%d%c%d&quot;</span>, &amp;major, &amp;letter, &amp;minor);
        CFRelease(vers);
    }
    <span class="enscript-keyword">if</span> (!major) 
    { 
        major = 13; 
        LogMsg(<span class="enscript-string">&quot;Note: No Major Build Version number found; assuming 13&quot;</span>); 
    }
    <span class="enscript-keyword">if</span> (HINFO_SWstring) 
        mDNS_snprintf(HINFO_SWstring, 256, <span class="enscript-string">&quot;%s %s (%s), %s&quot;</span>, prodname, prodvers, buildver, STRINGIFY(mDNSResponderVersion));
    <span class="enscript-comment">//LogMsg(&quot;%s %s (%s), %d %c %d&quot;, prodname, prodvers, buildver, major, letter, minor);
</span>
    <span class="enscript-comment">// If product name is &quot;Mac OS X&quot; (or similar) we set OSXVers, else we set iOSVers;
</span>    <span class="enscript-keyword">if</span> ((prodname[0] &amp; 0xDF) == <span class="enscript-string">'M'</span>) 
        OSXVers = major;
    <span class="enscript-keyword">else</span> 
        iOSVers = major;
}

<span class="enscript-comment">// Test to see if we're the first client running on UDP port 5353, by trying to bind to 5353 without using SO_REUSEPORT.
</span><span class="enscript-comment">// If we fail, someone else got here first. That's not a big problem; we can share the port for multicast responses --
</span><span class="enscript-comment">// we just need to be aware that we shouldn't expect to successfully receive unicast UDP responses.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">mDNSPlatformInit_CanReceiveUnicast</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> err = -1;
    <span class="enscript-type">int</span> s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    <span class="enscript-keyword">if</span> (s &lt; 3)
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_CanReceiveUnicast: socket error %d errno %d (%s)&quot;</span>, s, errno, strerror(errno));
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">struct</span> sockaddr_in s5353;
        s5353.sin_family      = AF_INET;
        s5353.sin_port        = MulticastDNSPort.NotAnInteger;
        s5353.sin_addr.s_addr = 0;
        err = bind(s, (<span class="enscript-type">struct</span> sockaddr *)&amp;s5353, <span class="enscript-keyword">sizeof</span>(s5353));
        close(s);
    }

    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;No unicast UDP responses&quot;</span>);
    <span class="enscript-keyword">else</span> debugf(<span class="enscript-string">&quot;Unicast UDP responses okay&quot;</span>);
    <span class="enscript-keyword">return</span>(err == 0);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CreatePTRRecord</span>(<span class="enscript-type">const</span> domainname *domain)
{
    AuthRecord *rr;
    <span class="enscript-type">const</span> domainname *pname = (domainname *)<span class="enscript-string">&quot;\x9&quot;</span> <span class="enscript-string">&quot;localhost&quot;</span>;

    rr = (AuthRecord *) callocL(<span class="enscript-string">&quot;localhosts&quot;</span>, <span class="enscript-keyword">sizeof</span>(*rr));
    <span class="enscript-keyword">if</span> (rr == NULL) <span class="enscript-keyword">return</span>;

    mDNS_SetupResourceRecord(rr, mDNSNULL, mDNSInterface_LocalOnly, kDNSType_PTR, kHostNameTTL, kDNSRecordTypeKnownUnique, AuthRecordLocalOnly, mDNSNULL, mDNSNULL);
    AssignDomainName(&amp;rr-&gt;namestorage, domain);

    rr-&gt;resrec.rdlength = DomainNameLength(pname);
    rr-&gt;resrec.rdata-&gt;u.name.c[0] = 0;
    AssignDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.name, pname);

    rr-&gt;resrec.namehash = DomainNameHashValue(rr-&gt;resrec.name);
    SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);  <span class="enscript-comment">// Sets rr-&gt;rdatahash for us
</span>    mDNS_Register(&amp;mDNSStorage, rr);
}

<span class="enscript-comment">// Setup PTR records for 127.0.0.1 and ::1. This helps answering them locally rather than relying
</span><span class="enscript-comment">// on the external DNS server to answer this. Sometimes, the DNS servers don't respond in a timely
</span><span class="enscript-comment">// fashion and applications depending on this e.g., telnetd, times out after 30 seconds creating
</span><span class="enscript-comment">// a bad user experience. For now, we specifically create only localhosts to handle radar://9354225
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Note: We could have set this up while parsing the entries in /etc/hosts. But this is kept separate
</span><span class="enscript-comment">// intentionally to avoid adding to the complexity of code handling /etc/hosts.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetupLocalHostRecords</span>(<span class="enscript-type">void</span>)
{
    domainname name;

    MakeDomainNameFromDNSNameString(&amp;name, <span class="enscript-string">&quot;1.0.0.127.in-addr.arpa.&quot;</span>);
    CreatePTRRecord(&amp;name);

    MakeDomainNameFromDNSNameString(&amp;name, <span class="enscript-string">&quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa.&quot;</span>);
    CreatePTRRecord(&amp;name);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> // <span class="enscript-variable-name">Don</span>'<span class="enscript-variable-name">t</span> <span class="enscript-variable-name">compile</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">dnsextd</span> <span class="enscript-variable-name">target</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">setSameDomainLabelPointer</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Construction of Default Browse domain list (i.e. when clients pass NULL) is as follows:
</span><span class="enscript-comment">// 1) query for b._dns-sd._udp.local on LocalOnly interface
</span><span class="enscript-comment">//    (.local manually generated via explicit callback)
</span><span class="enscript-comment">// 2) for each search domain (from prefs pane), query for b._dns-sd._udp.&lt;searchdomain&gt;.
</span><span class="enscript-comment">// 3) for each result from (2), register LocalOnly PTR record b._dns-sd._udp.local. -&gt; &lt;result&gt;
</span><span class="enscript-comment">// 4) result above should generate a callback from question in (1).  result added to global list
</span><span class="enscript-comment">// 5) global list delivered to client via GetSearchDomainList()
</span><span class="enscript-comment">// 6) client calls to enumerate domains now go over LocalOnly interface
</span><span class="enscript-comment">//    (!!!KRS may add outgoing interface in addition)
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">IGNORE_HOSTS_FILE</span>)
mDNSlocal mStatus <span class="enscript-function-name">RegisterLocalOnlyAddressRecord</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 type, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *rdata, mDNSu16 rdlength)
{
    <span class="enscript-keyword">switch</span>(type)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:
        <span class="enscript-keyword">if</span> (rdlength != 4) <span class="enscript-keyword">return</span> (mStatus_BadParamErr);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>:
        <span class="enscript-keyword">if</span> (rdlength != 16) <span class="enscript-keyword">return</span> (mStatus_BadParamErr);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> (mStatus_BadParamErr);
    }

    AuthRecord *rr = (AuthRecord *) callocL(<span class="enscript-string">&quot;etchosts&quot;</span>, <span class="enscript-keyword">sizeof</span>(*rr));
    <span class="enscript-keyword">if</span> (!rr) <span class="enscript-keyword">return</span> (mStatus_NoMemoryErr);

    mDNS_SetupResourceRecord(rr, NULL, mDNSInterface_LocalOnly, type, 1, kDNSRecordTypeKnownUnique, AuthRecordLocalOnly, FreeEtcHosts, NULL);
    AssignDomainName(&amp;rr-&gt;namestorage, name);
    mDNSPlatformMemCopy(rr-&gt;resrec.rdata-&gt;u.data, rdata, rdlength);

    <span class="enscript-type">const</span> mStatus err = mDNS_Register_internal(&amp;mDNSStorage, rr);
    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;RegisterLocalOnlyAddressRecord: mDNS_Register error %d registering %s&quot;</span>, err, ARDisplayString(&amp;mDNSStorage, rr));
        freeL(<span class="enscript-string">&quot;etchosts&quot;</span>, rr);
    }
    <span class="enscript-keyword">return</span> (err);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RegisterLocalOnlyARecord</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSv4Addr *<span class="enscript-type">const</span> addr)
{
    RegisterLocalOnlyAddressRecord(name, kDNSType_A, addr-&gt;b, (mDNSu16)<span class="enscript-keyword">sizeof</span>(mDNSv4Addr));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RegisterLocalOnlyAAAARecord</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> addr)
{
    RegisterLocalOnlyAddressRecord(name, kDNSType_AAAA, addr-&gt;b, (mDNSu16)<span class="enscript-keyword">sizeof</span>(mDNSv6Addr));
}
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">IGNORE_HOSTS_FILE</span>)

mDNSlocal mStatus <span class="enscript-function-name">mDNSPlatformInit_setup</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mStatus err;

    <span class="enscript-type">char</span> HINFO_SWstring[256] = <span class="enscript-string">&quot;&quot;</span>;
    mDNSMacOSXSystemBuildNumber(HINFO_SWstring);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    setSameDomainLabelPointer();
#<span class="enscript-reference">endif</span>

    err = mDNSHelperInit();
    <span class="enscript-keyword">if</span> (err)
        <span class="enscript-keyword">return</span> err;
    
    <span class="enscript-comment">// Store mDNSResponder Platform 
</span>    <span class="enscript-keyword">if</span> (OSXVers)
    {
        m-&gt;mDNS_plat = platform_OSX;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iOSVers)
    {
        <span class="enscript-keyword">if</span> (IsAppleTV())
            m-&gt;mDNS_plat = platform_Atv;
        <span class="enscript-keyword">else</span>
            m-&gt;mDNS_plat = platform_iOS;
    }
    <span class="enscript-keyword">else</span>
    {
        m-&gt;mDNS_plat = platform_NonApple; 
    }   
        
    <span class="enscript-comment">// In 10.4, mDNSResponder is launched very early in the boot process, while other subsystems are still in the process of starting up.
</span>    <span class="enscript-comment">// If we can't read the user's preferences, then we sleep a bit and try again, for up to five seconds before we give up.
</span>    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=0; i&lt;100; i++)
    {
        domainlabel testlabel;
        testlabel.c[0] = 0;
        GetUserSpecifiedLocalHostName(&amp;testlabel);
        <span class="enscript-keyword">if</span> (testlabel.c[0]) <span class="enscript-keyword">break</span>;
        usleep(50000);
    }

    m-&gt;hostlabel.c[0]        = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    GetRandomUUIDLocalHostname(&amp;m-&gt;RandomizedHostname);
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">int</span> get_model[2] = { CTL_HW, HW_MODEL };
    size_t len_model = <span class="enscript-keyword">sizeof</span>(HINFO_HWstring_buffer);

    <span class="enscript-comment">// Normal Apple model names are of the form &quot;iPhone2,1&quot;, and
</span>    <span class="enscript-comment">// internal code names are strings containing no commas, e.g. &quot;N88AP&quot;.
</span>    <span class="enscript-comment">// We used to ignore internal code names, but Apple now uses these internal code names
</span>    <span class="enscript-comment">// even in released shipping products, so we no longer ignore strings containing no commas.
</span><span class="enscript-comment">//  if (sysctl(get_model, 2, HINFO_HWstring_buffer, &amp;len_model, NULL, 0) == 0 &amp;&amp; strchr(HINFO_HWstring_buffer, ','))
</span>    <span class="enscript-keyword">if</span> (sysctl(get_model, 2, HINFO_HWstring_buffer, &amp;len_model, NULL, 0) == 0)
        HINFO_HWstring = HINFO_HWstring_buffer;

    <span class="enscript-comment">// For names of the form &quot;iPhone2,1&quot; we use &quot;iPhone&quot; as the prefix for automatic name generation.
</span>    <span class="enscript-comment">// For names of the form &quot;N88AP&quot; containg no comma, we use the entire string.
</span>    HINFO_HWstring_prefixlen = strchr(HINFO_HWstring_buffer, <span class="enscript-string">','</span>) ? strcspn(HINFO_HWstring, <span class="enscript-string">&quot;0123456789&quot;</span>) : strlen(HINFO_HWstring);

    <span class="enscript-keyword">if</span> (mDNSPlatformInit_CanReceiveUnicast()) 
        m-&gt;CanReceiveUnicastOn5353 = mDNStrue;

    mDNSu32 hlen = mDNSPlatformStrLen(HINFO_HWstring);
    mDNSu32 slen = mDNSPlatformStrLen(HINFO_SWstring);
    <span class="enscript-keyword">if</span> (hlen + slen &lt; 254)
    {
        m-&gt;HIHardware.c[0] = hlen;
        m-&gt;HISoftware.c[0] = slen;
        mDNSPlatformMemCopy(&amp;m-&gt;HIHardware.c[1], HINFO_HWstring, hlen);
        mDNSPlatformMemCopy(&amp;m-&gt;HISoftware.c[1], HINFO_SWstring, slen);
    }

    m-&gt;p-&gt;permanentsockets.port  = MulticastDNSPort;
    m-&gt;p-&gt;permanentsockets.m     = m;
    m-&gt;p-&gt;permanentsockets.sktv4 = -1;
    m-&gt;p-&gt;permanentsockets.kqsv4.KQcallback = myKQSocketCallBack;
    m-&gt;p-&gt;permanentsockets.kqsv4.KQcontext  = &amp;m-&gt;p-&gt;permanentsockets;
    m-&gt;p-&gt;permanentsockets.kqsv4.KQtask     = <span class="enscript-string">&quot;IPv4 UDP packet reception&quot;</span>;
    m-&gt;p-&gt;permanentsockets.sktv6 = -1;
    m-&gt;p-&gt;permanentsockets.kqsv6.KQcallback = myKQSocketCallBack;
    m-&gt;p-&gt;permanentsockets.kqsv6.KQcontext  = &amp;m-&gt;p-&gt;permanentsockets;
    m-&gt;p-&gt;permanentsockets.kqsv6.KQtask     = <span class="enscript-string">&quot;IPv6 UDP packet reception&quot;</span>;

    err = SetupSocket(&amp;m-&gt;p-&gt;permanentsockets, MulticastDNSPort, AF_INET, mDNSNULL);
    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: SetupSocket(AF_INET) failed error %d errno %d (%s)&quot;</span>, err, errno, strerror(errno));
    err = SetupSocket(&amp;m-&gt;p-&gt;permanentsockets, MulticastDNSPort, AF_INET6, mDNSNULL);
    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: SetupSocket(AF_INET6) failed error %d errno %d (%s)&quot;</span>, err, errno, strerror(errno));

    <span class="enscript-type">struct</span> sockaddr_in s4;
    socklen_t n4 = <span class="enscript-keyword">sizeof</span>(s4);
    <span class="enscript-keyword">if</span> (getsockname(m-&gt;p-&gt;permanentsockets.sktv4, (<span class="enscript-type">struct</span> sockaddr *)&amp;s4, &amp;n4) &lt; 0) 
        LogMsg(<span class="enscript-string">&quot;getsockname v4 error %d (%s)&quot;</span>, errno, strerror(errno));
    <span class="enscript-keyword">else</span> 
        m-&gt;UnicastPort4.NotAnInteger = s4.sin_port;

    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;permanentsockets.sktv6 &gt;= 0)
    {
        <span class="enscript-type">struct</span> sockaddr_in6 s6;
        socklen_t n6 = <span class="enscript-keyword">sizeof</span>(s6);
        <span class="enscript-keyword">if</span> (getsockname(m-&gt;p-&gt;permanentsockets.sktv6, (<span class="enscript-type">struct</span> sockaddr *)&amp;s6, &amp;n6) &lt; 0) LogMsg(<span class="enscript-string">&quot;getsockname v6 error %d (%s)&quot;</span>, errno, strerror(errno));
        <span class="enscript-keyword">else</span> m-&gt;UnicastPort6.NotAnInteger = s6.sin6_port;
    }

    m-&gt;p-&gt;InterfaceList         = mDNSNULL;
    m-&gt;p-&gt;InterfaceMonitors     = NULL;
    m-&gt;p-&gt;userhostlabel.c[0]    = 0;
    m-&gt;p-&gt;usernicelabel.c[0]    = 0;
    m-&gt;p-&gt;prevoldnicelabel.c[0] = 0;
    m-&gt;p-&gt;prevnewnicelabel.c[0] = 0;
    m-&gt;p-&gt;prevoldhostlabel.c[0] = 0;
    m-&gt;p-&gt;prevnewhostlabel.c[0] = 0;
    m-&gt;p-&gt;NotifyUser         = 0;
    m-&gt;p-&gt;KeyChainTimer      = 0;
    m-&gt;p-&gt;WakeAtUTC          = 0;
    m-&gt;p-&gt;RequestReSleep     = 0;
    <span class="enscript-comment">// Assume that everything is good to begin with. If something is not working,
</span>    <span class="enscript-comment">// we will detect that when we start sending questions.
</span>    m-&gt;p-&gt;v4answers          = 1;
    m-&gt;p-&gt;v6answers          = 1;
    m-&gt;p-&gt;DNSTrigger         = 0;
    m-&gt;p-&gt;LastConfigGeneration = 0;
    m-&gt;p-&gt;if_interface_changed = mDNSfalse;

    NetworkChangedKey_IPv4         = SCDynamicStoreKeyCreateNetworkGlobalEntity(NULL, kSCDynamicStoreDomainState, kSCEntNetIPv4);
    NetworkChangedKey_IPv6         = SCDynamicStoreKeyCreateNetworkGlobalEntity(NULL, kSCDynamicStoreDomainState, kSCEntNetIPv6);
    NetworkChangedKey_Hostnames    = SCDynamicStoreKeyCreateHostNames(NULL);
    NetworkChangedKey_Computername = SCDynamicStoreKeyCreateComputerName(NULL);
    NetworkChangedKey_DNS          = SCDynamicStoreKeyCreateNetworkGlobalEntity(NULL, kSCDynamicStoreDomainState, kSCEntNetDNS);
    NetworkChangedKey_StateInterfacePrefix = SCDynamicStoreKeyCreateNetworkInterfaceEntity(NULL, kSCDynamicStoreDomainState, CFSTR(<span class="enscript-string">&quot;&quot;</span>), NULL);
    <span class="enscript-keyword">if</span> (!NetworkChangedKey_IPv4 || !NetworkChangedKey_IPv6 || !NetworkChangedKey_Hostnames || !NetworkChangedKey_Computername || !NetworkChangedKey_DNS || !NetworkChangedKey_StateInterfacePrefix)
    { LogMsg(<span class="enscript-string">&quot;SCDynamicStore string setup failed&quot;</span>); <span class="enscript-keyword">return</span>(mStatus_NoMemoryErr); }

    err = WatchForNetworkChanges(m);
    <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: WatchForNetworkChanges failed %d&quot;</span>, err); <span class="enscript-keyword">return</span>(err); }

    err = WatchForSysEvents(m);
    <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: WatchForSysEvents failed %d&quot;</span>, err); <span class="enscript-keyword">return</span>(err); }

    mDNSs32 utc = mDNSPlatformUTC();
    m-&gt;SystemWakeOnLANEnabled = SystemWakeForNetworkAccess();
    myGetIfAddrs(1);
    UpdateInterfaceList(utc);
    SetupActiveInterfaces(utc);
    ReorderInterfaceList();

    <span class="enscript-comment">// Explicitly ensure that our Keychain operations utilize the system domain.
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    SecKeychainSetPreferenceDomain(kSecPreferencesDomainSystem);
#<span class="enscript-reference">endif</span>

    mDNS_Lock(m);
    SetDomainSecrets(m);
    SetLocalDomains();
    mDNS_Unlock(m);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    err = SecKeychainAddCallback(KeychainChanged, kSecAddEventMask|kSecDeleteEventMask|kSecUpdateEventMask, m);
    <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: SecKeychainAddCallback failed %d&quot;</span>, err); <span class="enscript-keyword">return</span>(err); }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">kIOPMAcknowledgmentOptionSystemCapabilityRequirements</span>) || <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
    LogMsg(<span class="enscript-string">&quot;Note: Compiled without SnowLeopard Fine-Grained Power Management support&quot;</span>);
#<span class="enscript-reference">else</span>
    IOPMConnection c;
    IOReturn iopmerr = IOPMConnectionCreate(CFSTR(<span class="enscript-string">&quot;mDNSResponder&quot;</span>), kIOPMSystemPowerStateCapabilityCPU, &amp;c);
    <span class="enscript-keyword">if</span> (iopmerr) LogMsg(<span class="enscript-string">&quot;IOPMConnectionCreate failed %d&quot;</span>, iopmerr);
    <span class="enscript-keyword">else</span>
    {
        iopmerr = IOPMConnectionSetNotification(c, m, SnowLeopardPowerChanged);
        <span class="enscript-keyword">if</span> (iopmerr) LogMsg(<span class="enscript-string">&quot;IOPMConnectionSetNotification failed %d&quot;</span>, iopmerr);
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
            IOPMConnectionSetDispatchQueue(c, dispatch_get_main_queue());
            LogInfo(<span class="enscript-string">&quot;IOPMConnectionSetDispatchQueue is now running&quot;</span>);
#<span class="enscript-reference">else</span>
            iopmerr = IOPMConnectionScheduleWithRunLoop(c, CFRunLoopGetMain(), kCFRunLoopDefaultMode);
            <span class="enscript-keyword">if</span> (iopmerr) LogMsg(<span class="enscript-string">&quot;IOPMConnectionScheduleWithRunLoop failed %d&quot;</span>, iopmerr);
            LogInfo(<span class="enscript-string">&quot;IOPMConnectionScheduleWithRunLoop is now running&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM */</span>
        }
    }
    m-&gt;p-&gt;IOPMConnection = iopmerr ? mDNSNULL : c;
    <span class="enscript-keyword">if</span> (iopmerr) <span class="enscript-comment">// If IOPMConnectionCreate unavailable or failed, proceed with old-style power notification code below
</span>#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">kIOPMAcknowledgmentOptionSystemCapabilityRequirements</span>
    {
        m-&gt;p-&gt;PowerConnection = IORegisterForSystemPower(m, &amp;m-&gt;p-&gt;PowerPortRef, PowerChanged, &amp;m-&gt;p-&gt;PowerNotifier);
        <span class="enscript-keyword">if</span> (!m-&gt;p-&gt;PowerConnection) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformInit_setup: IORegisterForSystemPower failed&quot;</span>); <span class="enscript-keyword">return</span>(-1); }
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
            IONotificationPortSetDispatchQueue(m-&gt;p-&gt;PowerPortRef, dispatch_get_main_queue());
#<span class="enscript-reference">else</span>
            CFRunLoopAddSource(CFRunLoopGetMain(), IONotificationPortGetRunLoopSource(m-&gt;p-&gt;PowerPortRef), kCFRunLoopDefaultMode);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM */</span>
        }
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-comment">// Note: We use SPMetricPortability &gt; 35 to indicate a laptop of some kind
</span>    <span class="enscript-comment">// SPMetricPortability &lt;= 35 means nominally a non-portable machine (i.e. Mac mini or better)
</span>    <span class="enscript-comment">// Apple TVs, AirPort base stations, and Time Capsules do not actually weigh 3kg, but we assign them
</span>    <span class="enscript-comment">// higher 'nominal' masses to indicate they should be treated as being relatively less portable than a laptop
</span>    <span class="enscript-keyword">if</span>      (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;Xserve&quot;</span>,       6)) { SPMetricPortability = 25 <span class="enscript-comment">/* 30kg */</span>; SPMetricMarginalPower = 84 <span class="enscript-comment">/* 250W */</span>; SPMetricTotalPower = 85 <span class="enscript-comment">/* 300W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;RackMac&quot;</span>,      7)) { SPMetricPortability = 25 <span class="enscript-comment">/* 30kg */</span>; SPMetricMarginalPower = 84 <span class="enscript-comment">/* 250W */</span>; SPMetricTotalPower = 85 <span class="enscript-comment">/* 300W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;MacPro&quot;</span>,       6)) { SPMetricPortability = 27 <span class="enscript-comment">/* 20kg */</span>; SPMetricMarginalPower = 84 <span class="enscript-comment">/* 250W */</span>; SPMetricTotalPower = 85 <span class="enscript-comment">/* 300W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;PowerMac&quot;</span>,     8)) { SPMetricPortability = 27 <span class="enscript-comment">/* 20kg */</span>; SPMetricMarginalPower = 82 <span class="enscript-comment">/* 160W */</span>; SPMetricTotalPower = 83 <span class="enscript-comment">/* 200W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;iMac&quot;</span>,         4)) { SPMetricPortability = 30 <span class="enscript-comment">/* 10kg */</span>; SPMetricMarginalPower = 77 <span class="enscript-comment">/*  50W */</span>; SPMetricTotalPower = 78 <span class="enscript-comment">/*  60W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;Macmini&quot;</span>,      7)) { SPMetricPortability = 33 <span class="enscript-comment">/*  5kg */</span>; SPMetricMarginalPower = 73 <span class="enscript-comment">/*  20W */</span>; SPMetricTotalPower = 74 <span class="enscript-comment">/*  25W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;TimeCapsule&quot;</span>, 11)) { SPMetricPortability = 34 <span class="enscript-comment">/*  4kg */</span>; SPMetricMarginalPower = 10 <span class="enscript-comment">/*  ~0W */</span>; SPMetricTotalPower = 70 <span class="enscript-comment">/*  13W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;AirPort&quot;</span>,      7)) { SPMetricPortability = 35 <span class="enscript-comment">/*  3kg */</span>; SPMetricMarginalPower = 10 <span class="enscript-comment">/*  ~0W */</span>; SPMetricTotalPower = 70 <span class="enscript-comment">/*  12W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (  IsAppleTV()  )                                 { SPMetricPortability = 35 <span class="enscript-comment">/*  3kg */</span>; SPMetricMarginalPower = 60 <span class="enscript-comment">/*   1W */</span>; SPMetricTotalPower = 63 <span class="enscript-comment">/*   2W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;MacBook&quot;</span>,      7)) { SPMetricPortability = 37 <span class="enscript-comment">/*  2kg */</span>; SPMetricMarginalPower = 71 <span class="enscript-comment">/*  13W */</span>; SPMetricTotalPower = 72 <span class="enscript-comment">/*  15W */</span>; }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncasecmp(HINFO_HWstring, <span class="enscript-string">&quot;PowerBook&quot;</span>,    9)) { SPMetricPortability = 37 <span class="enscript-comment">/*  2kg */</span>; SPMetricMarginalPower = 71 <span class="enscript-comment">/*  13W */</span>; SPMetricTotalPower = 72 <span class="enscript-comment">/*  15W */</span>; }
    LogSPS(<span class="enscript-string">&quot;HW_MODEL: %.*s (%s) Portability %d Marginal Power %d Total Power %d Features %d&quot;</span>,
           HINFO_HWstring_prefixlen, HINFO_HWstring, HINFO_HWstring, SPMetricPortability, SPMetricMarginalPower, SPMetricTotalPower, SPMetricFeatures);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    <span class="enscript-comment">// Currently this is not defined. SSL code will eventually fix this. If it becomes
</span>    <span class="enscript-comment">// critical, we will define this to workaround the bug in SSL.
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__SSL_NEEDS_SERIALIZATION__</span>
    SSLqueue = dispatch_queue_create(<span class="enscript-string">&quot;com.apple.mDNSResponder.SSLQueue&quot;</span>, NULL);
#<span class="enscript-reference">else</span>
    SSLqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (SSLqueue == mDNSNULL) LogMsg(<span class="enscript-string">&quot;dispatch_queue_create: SSL queue NULL&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">IGNORE_HOSTS_FILE</span>)
    <span class="enscript-comment">// On device OSes (iOS, tvOS, watchOS, etc.), ignore /etc/hosts unless the OS is an internal build. When the /etc/hosts
</span>    <span class="enscript-comment">// file is ignored, LocalOnly auth records will be registered for localhost and broadcasthost addresses contained in the
</span>    <span class="enscript-comment">// standard /etc/hosts file:
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">//  127.0.0.1       localhost
</span>    <span class="enscript-comment">//  255.255.255.255 broadcasthost
</span>    <span class="enscript-comment">//  ::1             localhost
</span>
    <span class="enscript-keyword">if</span> (!IsAppleInternalBuild())
    {
        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> localHostName     = (<span class="enscript-type">const</span> domainname *) <span class="enscript-string">&quot;\x9&quot;</span> <span class="enscript-string">&quot;localhost&quot;</span>;
        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> broadcastHostName = (<span class="enscript-type">const</span> domainname *) <span class="enscript-string">&quot;\xd&quot;</span> <span class="enscript-string">&quot;broadcasthost&quot;</span>;
        <span class="enscript-type">const</span> mDNSv4Addr        localHostV4       = { { 127, 0, 0, 1 } };
        mDNSv6Addr              localHostV6;

        <span class="enscript-comment">// Register localhost 127.0.0.1 A record.
</span>
        RegisterLocalOnlyARecord(localHostName, &amp;localHostV4);

        <span class="enscript-comment">// Register broadcasthost 255.255.255.255 A record.
</span>
        RegisterLocalOnlyARecord(broadcastHostName, &amp;onesIPv4Addr);

        <span class="enscript-comment">// Register localhost ::1 AAAA record.
</span>
        mDNSPlatformMemZero(&amp;localHostV6, <span class="enscript-keyword">sizeof</span>(localHostV6));
        localHostV6.b[15] = 1;
        RegisterLocalOnlyAAAARecord(localHostName, &amp;localHostV6);
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
        mDNSMacOSXUpdateEtcHosts(m);
    }
    SetupLocalHostRecords();
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
    dso_transport_init();
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformInit</span>(mDNS *<span class="enscript-type">const</span> m)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_NO_DNSINFO</span>
    LogMsg(<span class="enscript-string">&quot;Note: Compiled without Apple-specific Split-DNS support&quot;</span>);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Adding interfaces will use this flag, so set it now.
</span>    m-&gt;DivertMulticastAdvertisements = !m-&gt;AdvertiseLocalAddresses;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    m-&gt;SPSBrowseCallback = UpdateSPSStatus;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    mStatus result = mDNSPlatformInit_setup(m);

    <span class="enscript-comment">// We don't do asynchronous initialization on OS X, so by the time we get here the setup will already
</span>    <span class="enscript-comment">// have succeeded or failed -- so if it succeeded, we should just call mDNSCoreInitComplete() immediately
</span>    <span class="enscript-keyword">if</span> (result == mStatus_NoError)
    {
        mDNSCoreInitComplete(m, mStatus_NoError);
        initializeD2DPlugins(m);
    }
    result = DNSSECCryptoInit(m);
    <span class="enscript-keyword">return</span>(result);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformClose</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;PowerConnection)
    {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
        IONotificationPortSetDispatchQueue(m-&gt;p-&gt;PowerPortRef, NULL);
#<span class="enscript-reference">else</span>
        CFRunLoopRemoveSource(CFRunLoopGetMain(), IONotificationPortGetRunLoopSource(m-&gt;p-&gt;PowerPortRef), kCFRunLoopDefaultMode);
#<span class="enscript-reference">endif</span>
        <span class="enscript-comment">// According to &lt;<a href="http://developer.apple.com/qa/qa2004/qa1340.html">http://developer.apple.com/qa/qa2004/qa1340.html</a>&gt;, a single call
</span>        <span class="enscript-comment">// to IORegisterForSystemPower creates *three* objects that need to be disposed individually:
</span>        IODeregisterForSystemPower(&amp;m-&gt;p-&gt;PowerNotifier);
        IOServiceClose            ( m-&gt;p-&gt;PowerConnection);
        IONotificationPortDestroy ( m-&gt;p-&gt;PowerPortRef);
        m-&gt;p-&gt;PowerConnection = 0;
    }

    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;Store)
    {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
        <span class="enscript-keyword">if</span> (!SCDynamicStoreSetDispatchQueue(m-&gt;p-&gt;Store, NULL))
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformClose: SCDynamicStoreSetDispatchQueue failed&quot;</span>);
#<span class="enscript-reference">else</span>
        CFRunLoopRemoveSource(CFRunLoopGetMain(), m-&gt;p-&gt;StoreRLS, kCFRunLoopDefaultMode);
        CFRunLoopSourceInvalidate(m-&gt;p-&gt;StoreRLS);
        CFRelease(m-&gt;p-&gt;StoreRLS);
        m-&gt;p-&gt;StoreRLS = NULL;
#<span class="enscript-reference">endif</span>
        CFRelease(m-&gt;p-&gt;Store);
        m-&gt;p-&gt;Store    = NULL;
    }

    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;PMRLS)
    {
        CFRunLoopRemoveSource(CFRunLoopGetMain(), m-&gt;p-&gt;PMRLS, kCFRunLoopDefaultMode);
        CFRunLoopSourceInvalidate(m-&gt;p-&gt;PMRLS);
        CFRelease(m-&gt;p-&gt;PMRLS);
        m-&gt;p-&gt;PMRLS = NULL;
    }

    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;SysEventNotifier &gt;= 0) { close(m-&gt;p-&gt;SysEventNotifier); m-&gt;p-&gt;SysEventNotifier = -1; }
    terminateD2DPlugins();

    mDNSs32 utc = mDNSPlatformUTC();
    MarkAllInterfacesInactive(utc);
    ClearInactiveInterfaces(utc);
    CloseSocketSet(&amp;m-&gt;p-&gt;permanentsockets);

    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;InterfaceMonitors)
    {
        CFArrayRef monitors = m-&gt;p-&gt;InterfaceMonitors;
        m-&gt;p-&gt;InterfaceMonitors = NULL;
        <span class="enscript-type">const</span> CFIndex n = CFArrayGetCount(monitors);
        <span class="enscript-keyword">for</span> (CFIndex i = 0; i &lt; n; i++)
        {
            mdns_interface_monitor_invalidate((mdns_interface_monitor_t) CFArrayGetValueAtIndex(monitors, i));
        }
        CFRelease(monitors);
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">Platform</span> <span class="enscript-variable-name">Support</span> <span class="enscript-variable-name">Layer</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

mDNSexport mDNSu32 <span class="enscript-function-name">mDNSPlatformRandomNumber</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span>(arc4random());
}

mDNSexport mDNSs32 mDNSPlatformOneSecond = 1000;
mDNSexport mDNSu32 mDNSPlatformClockDivisor = 0;

mDNSexport mStatus <span class="enscript-function-name">mDNSPlatformTimeInit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-comment">// Notes: Typical values for mach_timebase_info:
</span>    <span class="enscript-comment">// tbi.numer = 1000 million
</span>    <span class="enscript-comment">// tbi.denom =   33 million
</span>    <span class="enscript-comment">// These are set such that (mach_absolute_time() * numer/denom) gives us nanoseconds;
</span>    <span class="enscript-comment">//          numer  / denom = nanoseconds per hardware clock tick (e.g. 30);
</span>    <span class="enscript-comment">//          denom  / numer = hardware clock ticks per nanosecond (e.g. 0.033)
</span>    <span class="enscript-comment">// (denom*1000000) / numer = hardware clock ticks per millisecond (e.g. 33333)
</span>    <span class="enscript-comment">// So: mach_absolute_time() / ((denom*1000000)/numer) = milliseconds
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Arithmetic notes:
</span>    <span class="enscript-comment">// tbi.denom is at least 1, and not more than 2^32-1.
</span>    <span class="enscript-comment">// Therefore (tbi.denom * 1000000) is at least one million, but cannot overflow a uint64_t.
</span>    <span class="enscript-comment">// tbi.denom is at least 1, and not more than 2^32-1.
</span>    <span class="enscript-comment">// Therefore clockdivisor should end up being a number roughly in the range 10^3 - 10^9.
</span>    <span class="enscript-comment">// If clockdivisor is less than 10^3 then that means that the native clock frequency is less than 1MHz,
</span>    <span class="enscript-comment">// which is unlikely on any current or future Macintosh.
</span>    <span class="enscript-comment">// If clockdivisor is greater than 10^9 then that means the native clock frequency is greater than 1000GHz.
</span>    <span class="enscript-comment">// When we ship Macs with clock frequencies above 1000GHz, we may have to update this code.
</span>    <span class="enscript-type">struct</span> mach_timebase_info tbi;
    kern_return_t result = mach_timebase_info(&amp;tbi);
    <span class="enscript-keyword">if</span> (result == KERN_SUCCESS) mDNSPlatformClockDivisor = ((uint64_t)tbi.denom * 1000000) / tbi.numer;
    <span class="enscript-keyword">return</span>(result);
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNSPlatformRawTime</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (mDNSPlatformClockDivisor == 0) { LogMsg(<span class="enscript-string">&quot;mDNSPlatformRawTime called before mDNSPlatformTimeInit&quot;</span>); <span class="enscript-keyword">return</span>(0); }

    <span class="enscript-type">static</span> uint64_t last_mach_absolute_time = 0;
    <span class="enscript-comment">//static uint64_t last_mach_absolute_time = 0x8000000000000000LL;   // Use this value for testing the alert display
</span>    uint64_t this_mach_absolute_time = mach_absolute_time();
    <span class="enscript-keyword">if</span> ((int64_t)this_mach_absolute_time - (int64_t)last_mach_absolute_time &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformRawTime: last_mach_absolute_time %08X%08X&quot;</span>, last_mach_absolute_time);
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformRawTime: this_mach_absolute_time %08X%08X&quot;</span>, this_mach_absolute_time);
        <span class="enscript-comment">// Update last_mach_absolute_time *before* calling NotifyOfElusiveBug()
</span>        last_mach_absolute_time = this_mach_absolute_time;
        <span class="enscript-comment">// Note: This bug happens all the time on 10.3
</span>        NotifyOfElusiveBug(<span class="enscript-string">&quot;mach_absolute_time went backwards!&quot;</span>,
                           <span class="enscript-string">&quot;This error occurs from time to time, often on newly released hardware, &quot;</span>
                           <span class="enscript-string">&quot;and usually the exact cause is different in each instance.\r\r&quot;</span>
                           <span class="enscript-string">&quot;Please file a new Radar bug report with the title mach_absolute_time went backwards &quot;</span>
                           <span class="enscript-string">&quot;and assign it to Radar Component Kernel Version X.&quot;</span>);
    }
    last_mach_absolute_time = this_mach_absolute_time;

    <span class="enscript-keyword">return</span>((mDNSs32)(this_mach_absolute_time / mDNSPlatformClockDivisor));
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNSPlatformUTC</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> time(NULL);
}

<span class="enscript-comment">// Locking is a no-op here, because we're single-threaded with a CFRunLoop, so we can never interrupt ourselves
</span>mDNSexport <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformLock</span>   (<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m) { (<span class="enscript-type">void</span>)m; }
mDNSexport <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformUnlock</span> (<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m) { (<span class="enscript-type">void</span>)m; }
mDNSexport mDNSu32  <span class="enscript-function-name">mDNSPlatformStrLCopy</span>(     <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 dstlen) { <span class="enscript-keyword">return</span> (strlcpy((<span class="enscript-type">char</span> *)dst, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)src, dstlen)); }
mDNSexport mDNSu32  <span class="enscript-function-name">mDNSPlatformStrLen</span> (                 <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src)              { <span class="enscript-keyword">return</span>(strlen((<span class="enscript-type">const</span> <span class="enscript-type">char</span>*)src)); }
mDNSexport <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformMemCopy</span>(      <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len) { memcpy(dst, src, len); }
mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformMemSame</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len) { <span class="enscript-keyword">return</span>(memcmp(dst, src, len) == 0); }
mDNSexport <span class="enscript-type">int</span>      <span class="enscript-function-name">mDNSPlatformMemCmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len) { <span class="enscript-keyword">return</span>(memcmp(dst, src, len)); }
mDNSexport <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformMemZero</span>(      <span class="enscript-type">void</span> *dst,                  mDNSu32 len) { memset(dst, 0, len); }
mDNSexport <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformQsort</span>  (      <span class="enscript-type">void</span> *base, <span class="enscript-type">int</span> nel, <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> (*compar)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *))
{
    <span class="enscript-keyword">return</span> (qsort(base, nel, width, compar));
}
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
mDNSexport <span class="enscript-type">void</span> *<span class="enscript-function-name">mDNSPlatformMemAllocate</span>(mDNSu32 len)      { <span class="enscript-keyword">return</span>(mallocL(<span class="enscript-string">&quot;mDNSPlatformMemAllocate&quot;</span>, len)); }
mDNSexport <span class="enscript-type">void</span> *<span class="enscript-function-name">mDNSPlatformMemAllocateClear</span>(mDNSu32 len) { <span class="enscript-keyword">return</span>(callocL(<span class="enscript-string">&quot;mDNSPlatformMemAllocateClear&quot;</span>, len)); }
mDNSexport <span class="enscript-type">void</span>  <span class="enscript-function-name">mDNSPlatformMemFree</span>    (<span class="enscript-type">void</span> *mem)                 { freeL(<span class="enscript-string">&quot;mDNSPlatformMemFree&quot;</span>, mem); }
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSetAllowSleep</span>(mDNSBool allowSleep, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-keyword">if</span> (allowSleep &amp;&amp; m-&gt;p-&gt;IOPMAssertion)
    {
        LogInfo(<span class="enscript-string">&quot;%s Destroying NoIdleSleep power assertion&quot;</span>, __FUNCTION__);
        IOPMAssertionRelease(m-&gt;p-&gt;IOPMAssertion);
        m-&gt;p-&gt;IOPMAssertion = 0;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!allowSleep)
    {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">kIOPMAssertionTypeNoIdleSleep</span>
        <span class="enscript-keyword">if</span> (m-&gt;p-&gt;IOPMAssertion)
        {
            IOPMAssertionRelease(m-&gt;p-&gt;IOPMAssertion);
            m-&gt;p-&gt;IOPMAssertion = 0;
        }

        CFStringRef assertionName = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR(<span class="enscript-string">&quot;%s.%d %s&quot;</span>), getprogname(), getpid(), reason ? reason : <span class="enscript-string">&quot;&quot;</span>);
        IOPMAssertionCreateWithName(kIOPMAssertionTypeNoIdleSleep, kIOPMAssertionLevelOn, assertionName ? assertionName : CFSTR(<span class="enscript-string">&quot;mDNSResponder&quot;</span>), &amp;m-&gt;p-&gt;IOPMAssertion);
        <span class="enscript-keyword">if</span> (assertionName) CFRelease(assertionName);
        LogInfo(<span class="enscript-string">&quot;%s Creating NoIdleSleep power assertion&quot;</span>, __FUNCTION__);
#<span class="enscript-reference">endif</span>
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformPreventSleep</span>(mDNSu32 timeout, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
    <span class="enscript-keyword">if</span> (m-&gt;p-&gt;IOPMAssertion)
    {
        LogSPS(<span class="enscript-string">&quot;Sleep Assertion is already being held. Will not attempt to get it again for %d seconds for %s&quot;</span>, timeout, reason);
        <span class="enscript-keyword">return</span>;
    }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">kIOPMAssertionTypeNoIdleSleep</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
    <span class="enscript-keyword">if</span> (!IsAppleTV())
        <span class="enscript-keyword">return</span>; <span class="enscript-comment">// No need for maintenance wakes on non-AppleTV embedded devices.
</span>#<span class="enscript-reference">endif</span>

    <span class="enscript-type">double</span> timeoutVal = (<span class="enscript-type">double</span>)timeout;
    CFStringRef str = CFStringCreateWithCString(NULL, reason, kCFStringEncodingUTF8);
    CFNumberRef Timeout_num = CFNumberCreate(NULL, kCFNumberDoubleType, &amp;timeoutVal);
    CFMutableDictionaryRef assertionProperties = CFDictionaryCreateMutable(NULL, 0,
                                                                           &amp;kCFTypeDictionaryKeyCallBacks,
                                                                           &amp;kCFTypeDictionaryValueCallBacks);
    <span class="enscript-keyword">if</span> (IsAppleTV())
        CFDictionarySetValue(assertionProperties, kIOPMAssertionTypeKey, kIOPMAssertPreventUserIdleSystemSleep);
    <span class="enscript-keyword">else</span>
        CFDictionarySetValue(assertionProperties, kIOPMAssertionTypeKey, kIOPMAssertMaintenanceActivity);

    CFDictionarySetValue(assertionProperties, kIOPMAssertionTimeoutKey, Timeout_num);
    CFDictionarySetValue(assertionProperties, kIOPMAssertionNameKey,    str);

    IOPMAssertionCreateWithProperties(assertionProperties, (IOPMAssertionID *)&amp;m-&gt;p-&gt;IOPMAssertion);
    CFRelease(str);
    CFRelease(Timeout_num);
    CFRelease(assertionProperties);
    LogSPS(<span class="enscript-string">&quot;Got an idle sleep assertion for %d seconds for %s&quot;</span>, timeout, reason);
#<span class="enscript-reference">endif</span>
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSendWakeupPacket</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">char</span> *EthAddr, <span class="enscript-type">char</span> *IPAddr, <span class="enscript-type">int</span> iteration)
{
    mDNSu32 ifindex;

    <span class="enscript-comment">// Sanity check
</span>    ifindex = mDNSPlatformInterfaceIndexfromInterfaceID(&amp;mDNSStorage, InterfaceID, mDNStrue);
    <span class="enscript-keyword">if</span> (ifindex &lt;= 0)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSPlatformSendWakeupPacket: ERROR!! Invalid InterfaceID %u&quot;</span>, ifindex);
        <span class="enscript-keyword">return</span>;
    }
    mDNSSendWakeupPacket(ifindex, EthAddr, IPAddr, iteration);
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformInterfaceIsD2D</span>(mDNSInterfaceID InterfaceID)
{
    NetworkInterfaceInfoOSX *info;

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// mDNSInterface_BLE not considered a D2D interface for the purpose of this
</span>    <span class="enscript-comment">// routine, since it's not implemented via a D2D plugin.
</span>    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_BLE)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (   (InterfaceID == mDNSInterface_Any) 
        || (InterfaceID == mDNSInterfaceMark)
        || (InterfaceID == mDNSInterface_LocalOnly))
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// Compare to cached AWDL interface ID.
</span>    <span class="enscript-keyword">if</span> (AWDLInterfaceID &amp;&amp; (InterfaceID == AWDLInterfaceID))
        <span class="enscript-keyword">return</span> mDNStrue;

    info = IfindexToInterfaceInfoOSX(InterfaceID);
    <span class="enscript-keyword">if</span> (info == NULL)
    {
        <span class="enscript-comment">// this log message can print when operations are stopped on an interface that has gone away
</span>        LogInfo(<span class="enscript-string">&quot;mDNSPlatformInterfaceIsD2D: Invalid interface index %d&quot;</span>, InterfaceID);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">return</span> (mDNSBool) info-&gt;D2DInterface;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformInterfaceIsAWDL</span>(<span class="enscript-type">const</span> mDNSInterfaceID interfaceID)
{
    <span class="enscript-keyword">return</span> ((AWDLInterfaceID &amp;&amp; (interfaceID == AWDLInterfaceID)) ? mDNStrue : mDNSfalse);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Filter records send over P2P (D2D) type interfaces
</span><span class="enscript-comment">// Note that the terms P2P and D2D are used synonymously in the current code and comments.
</span>mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformValidRecordForInterface</span>(<span class="enscript-type">const</span> AuthRecord *rr, mDNSInterfaceID InterfaceID)
{
    <span class="enscript-comment">// For an explicit match to a valid interface ID, return true. 
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// Only filtering records for D2D type interfaces, return true for all other interface types.
</span>    <span class="enscript-keyword">if</span> (!mDNSPlatformInterfaceIsD2D(InterfaceID))
        <span class="enscript-keyword">return</span> mDNStrue;
    
    <span class="enscript-comment">// If it's an AWDL interface the record must be explicitly marked to include AWDL.
</span>    <span class="enscript-keyword">if</span> (InterfaceID == AWDLInterfaceID)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;ARType == AuthRecordAnyIncludeAWDL || rr-&gt;ARType == AuthRecordAnyIncludeAWDLandP2P)
            <span class="enscript-keyword">return</span> mDNStrue;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">return</span> mDNSfalse;
    }
    
    <span class="enscript-comment">// Send record if it is explicitly marked to include all other P2P type interfaces.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;ARType == AuthRecordAnyIncludeP2P || rr-&gt;ARType == AuthRecordAnyIncludeAWDLandP2P)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// Don't send the record over this interface.
</span>    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Filter questions send over P2P (D2D) type interfaces.
</span>mDNSexport mDNSBool <span class="enscript-function-name">mDNSPlatformValidQuestionForInterface</span>(DNSQuestion *q, <span class="enscript-type">const</span> NetworkInterfaceInfo *intf)
{
    <span class="enscript-comment">// For an explicit match to a valid interface ID, return true. 
</span>    <span class="enscript-keyword">if</span> (q-&gt;InterfaceID == intf-&gt;InterfaceID)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// Only filtering questions for D2D type interfaces
</span>    <span class="enscript-keyword">if</span> (!mDNSPlatformInterfaceIsD2D(intf-&gt;InterfaceID))
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// If it's an AWDL interface the question must be explicitly marked to include AWDL.
</span>    <span class="enscript-keyword">if</span> (intf-&gt;InterfaceID == AWDLInterfaceID)
    {
        <span class="enscript-keyword">if</span> (q-&gt;flags &amp; kDNSServiceFlagsIncludeAWDL)
            <span class="enscript-keyword">return</span> mDNStrue;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">return</span> mDNSfalse;
    }
    
    <span class="enscript-comment">// Sent question if it is explicitly marked to include all other P2P type interfaces.
</span>    <span class="enscript-keyword">if</span> (q-&gt;flags &amp; kDNSServiceFlagsIncludeP2P)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// Don't send the question over this interface.
</span>    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Returns true unless record was received over the AWDL interface and
</span><span class="enscript-comment">// the question was not specific to the AWDL interface or did not specify kDNSServiceInterfaceIndexAny
</span><span class="enscript-comment">// with the kDNSServiceFlagsIncludeAWDL flag set.
</span>mDNSexport mDNSBool   <span class="enscript-function-name">mDNSPlatformValidRecordForQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">if</span> (!rr-&gt;InterfaceID || (rr-&gt;InterfaceID == q-&gt;InterfaceID))
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-keyword">if</span> ((rr-&gt;InterfaceID == AWDLInterfaceID) &amp;&amp; !(q-&gt;flags &amp; kDNSServiceFlagsIncludeAWDL))
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// formating time to RFC 4034 format
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformFormatTime</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> te, mDNSu8 *buf, <span class="enscript-type">int</span> bufsize)
{
    <span class="enscript-type">struct</span> tm tmTime;
    time_t t = (time_t)te;
    <span class="enscript-comment">// Time since epoch : strftime takes &quot;tm&quot;. Convert seconds to &quot;tm&quot; using
</span>    <span class="enscript-comment">// gmtime_r first and then use strftime
</span>    gmtime_r(&amp;t, &amp;tmTime);
    strftime((<span class="enscript-type">char</span> *)buf, bufsize, <span class="enscript-string">&quot;%Y%m%d%H%M%S&quot;</span>, &amp;tmTime);
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNSPlatformGetPID</span>()
{
    <span class="enscript-keyword">return</span> getpid();
}

<span class="enscript-comment">// Schedule a function asynchronously on the main queue
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformDispatchAsync</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context, AsyncDispatchFunc func)
{
    <span class="enscript-comment">// KQueueLock/Unlock is used for two purposes
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. We can't be running along with the KQueue thread and hence acquiring the lock
</span>    <span class="enscript-comment">//    serializes the access to the &quot;core&quot;
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. KQueueUnlock also sends a message wake up the KQueue thread which in turn wakes
</span>    <span class="enscript-comment">//    up and calls udsserver_idle which schedules the messages across the uds socket.
</span>    <span class="enscript-comment">//    If &quot;func&quot; delivers something to the uds socket from the dispatch thread, it will
</span>    <span class="enscript-comment">//    not be delivered immediately if not for the Unlock.
</span>    dispatch_async(dispatch_get_main_queue(), ^{
        KQueueLock();
        func(m, context);
        KQueueUnlock(<span class="enscript-string">&quot;mDNSPlatformDispatchAsync&quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNSRESPONDER_USES_LIB_DISPATCH_AS_PRIMARY_EVENT_LOOP_MECHANISM</span>
        <span class="enscript-comment">// KQueueUnlock is a noop. Hence, we need to run kick off the idle loop
</span>        <span class="enscript-comment">// to handle any message that &quot;func&quot; might deliver.
</span>        TriggerEventCompletion();
#<span class="enscript-reference">endif</span>
    });
}

<span class="enscript-comment">// definitions for device-info record construction
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEVINFO_MODEL</span>       <span class="enscript-string">&quot;model=&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEVINFO_MODEL_LEN</span>   sizeof_string(DEVINFO_MODEL)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OSX_VER</span>         <span class="enscript-string">&quot;osxvers=&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OSX_VER_LEN</span>     sizeof_string(OSX_VER) 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VER_NUM_LEN</span>     2  // 2 digits of version number added to base string

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MODEL_COLOR</span>           <span class="enscript-string">&quot;ecolor=&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MODEL_COLOR_LEN</span>       sizeof_string(MODEL_COLOR)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MODEL_RGB_VALUE_LEN</span>   sizeof_string(<span class="enscript-string">&quot;255,255,255&quot;</span>) // 'r,g,b'

<span class="enscript-comment">// Bytes available in TXT record for model name after subtracting space for other
</span><span class="enscript-comment">// fixed size strings and their length bytes.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_MODEL_NAME_LEN</span>   (256 - (DEVINFO_MODEL_LEN + 1) - (OSX_VER_LEN + VER_NUM_LEN + 1) - (MODEL_COLOR_LEN + MODEL_RGB_VALUE_LEN + 1))

mDNSlocal mDNSu8 <span class="enscript-function-name">getModelIconColors</span>(<span class="enscript-type">char</span> *color)
{
    mDNSPlatformMemZero(color, MODEL_RGB_VALUE_LEN + 1);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_OSX</span> &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">kIOPlatformDeviceEnclosureColorKey</span>)
    mDNSu8   red      = 0;
    mDNSu8   green    = 0;
    mDNSu8   blue     = 0;

    IOReturn rGetDeviceColor = IOPlatformGetDeviceColor(kIOPlatformDeviceEnclosureColorKey,
                                                        &amp;red, &amp;green, &amp;blue);
    <span class="enscript-keyword">if</span> (kIOReturnSuccess == rGetDeviceColor)
    {
        <span class="enscript-comment">// IOKit was able to get enclosure color for the current device.
</span>        <span class="enscript-keyword">return</span> snprintf(color, MODEL_RGB_VALUE_LEN + 1, <span class="enscript-string">&quot;%d,%d,%d&quot;</span>, red, green, blue);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">// Initialize device-info TXT record contents and return total length of record data.
</span>mDNSexport mDNSu32 <span class="enscript-function-name">initializeDeviceInfoTXT</span>(mDNS *m, mDNSu8 *ptr)
{
    mDNSu8 *bufferStart = ptr;
    mDNSu8 len = m-&gt;HIHardware.c[0] &lt; MAX_MODEL_NAME_LEN ? m-&gt;HIHardware.c[0] : MAX_MODEL_NAME_LEN;

    *ptr = DEVINFO_MODEL_LEN + len; <span class="enscript-comment">// total length of DEVINFO_MODEL string plus the hardware name string
</span>    ptr++;
    mDNSPlatformMemCopy(ptr, DEVINFO_MODEL, DEVINFO_MODEL_LEN);
    ptr += DEVINFO_MODEL_LEN;
    mDNSPlatformMemCopy(ptr, m-&gt;HIHardware.c + 1, len);
    ptr += len;

    <span class="enscript-comment">// only include this string for OSX
</span>    <span class="enscript-keyword">if</span> (OSXVers)
    {
        <span class="enscript-type">char</span>    ver_num[VER_NUM_LEN + 1]; <span class="enscript-comment">// version digits + null written by snprintf
</span>        *ptr = OSX_VER_LEN + VER_NUM_LEN; <span class="enscript-comment">// length byte
</span>        ptr++;
        mDNSPlatformMemCopy(ptr, OSX_VER, OSX_VER_LEN);
        ptr += OSX_VER_LEN;
        <span class="enscript-comment">// convert version number to ASCII, add 1 for terminating null byte written by snprintf()
</span>        <span class="enscript-comment">// WARNING: This code assumes that OSXVers is always exactly two digits
</span>        snprintf(ver_num, VER_NUM_LEN + 1, <span class="enscript-string">&quot;%d&quot;</span>, OSXVers);
        mDNSPlatformMemCopy(ptr, ver_num, VER_NUM_LEN);
        ptr += VER_NUM_LEN;

        <span class="enscript-type">char</span> rgb[MODEL_RGB_VALUE_LEN + 1]; <span class="enscript-comment">// RGB value + null written by snprintf
</span>        len = getModelIconColors(rgb);
        <span class="enscript-keyword">if</span> (len)
        {
            *ptr = MODEL_COLOR_LEN + len; <span class="enscript-comment">// length byte
</span>            ptr++;

            mDNSPlatformMemCopy(ptr, MODEL_COLOR, MODEL_COLOR_LEN);
            ptr += MODEL_COLOR_LEN;

            mDNSPlatformMemCopy(ptr, rgb, len);
            ptr += len;
        }
    }

    <span class="enscript-keyword">return</span> (ptr - bufferStart);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> // <span class="enscript-variable-name">Don</span>'<span class="enscript-variable-name">t</span> <span class="enscript-variable-name">compile</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">dnsextd</span> <span class="enscript-variable-name">target</span>

<span class="enscript-comment">// Use the scalar version of SameDomainLabel() by default
</span>mDNSlocal mDNSBool <span class="enscript-function-name">scalarSameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b);
mDNSlocal mDNSBool <span class="enscript-function-name">vectorSameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b);
mDNSlocal <span class="enscript-function-name">mDNSBool</span> (*SameDomainLabelPointer)(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b) = scalarSameDomainLabel;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;System/machine/cpu_capabilities.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_cpu_capabilities</span>   ((uint32_t*) _COMM_PAGE_CPU_CAPABILITIES)[0]

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arm_neon.h&gt;</span>

<span class="enscript-comment">// Cache line aligned table that returns 32 for the upper case letters.
</span><span class="enscript-comment">// This will take up 4 cache lines.
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-function-name">__attribute__</span> ((aligned(64))) uint8_t upper_to_lower_case_table[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

<span class="enscript-comment">// Neon version
</span>mDNSlocal mDNSBool <span class="enscript-function-name">vectorSameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b)
{
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = *a++;
    
    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL)
    {
        fprintf(stderr, <span class="enscript-string">&quot;v: Malformed label (too long)\n&quot;</span>);
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    
    <span class="enscript-keyword">if</span> (len != *b++)
    {
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    
    uint32_t len_count = len;
    
    uint8x16_t vA, vB, vARotated, vBRotated, vMaskA, vMaskB;
    
    uint8x16_t v32 = vdupq_n_u8(32);
    uint8x16_t v37 = vdupq_n_u8(37);
    uint8x16_t v101 = vdupq_n_u8(101);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__arm64__</span>
    uint32x4_t vtemp32;
    uint32x2_t vtemp32d;
    uint32_t sum;
#<span class="enscript-reference">endif</span>
    
    <span class="enscript-keyword">while</span>(len_count &gt; 15)
    {
        vA = vld1q_u8(a);
        vB = vld1q_u8(b);
        a += 16;
        b += 16;
        
        <span class="enscript-comment">//Make vA to lowercase if there is any uppercase.
</span>        vARotated = vaddq_u8(vA, v37);            <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskA    = vcgtq_s8(vARotated, v101);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskA    = vandq_u8(vMaskA, v32);        <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vA        = vaddq_u8(vA, vMaskA);         <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Make vB to lowercase if there is any uppercase.
</span>        vBRotated = vaddq_u8(vB, v37);            <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskB    = vcgtq_s8(vBRotated, v101);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskB    = vandq_u8(vMaskB, v32);        <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vB        = vaddq_u8(vB, vMaskB);         <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Compare vA &amp; vB
</span>        vA = vceqq_u8(vA, vB);
        
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__arm64__</span>
        <span class="enscript-comment">//View 8-bit element as 32-bit =&gt; a3 a2 a1 a0
</span>        <span class="enscript-comment">//If min of 4 32-bit values in vA is 0xffffffff, then it means we have 0xff for all 16.
</span>        <span class="enscript-keyword">if</span>(vminvq_u32(vA) != 0xffffffffU)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
            
        }
#<span class="enscript-reference">else</span>
        <span class="enscript-comment">//See if any element was not same.
</span>        <span class="enscript-comment">//View 8-bit element as 16-bit =&gt; a7 a6 a5 a4  a3 a2 a1 a0
</span>        <span class="enscript-comment">//(a7+a6) (a5+a4) (a3+a2) (a1+a0) =&gt; Each will be 0xffff + 0xffff = 0x0001fffe when all same.
</span>        vtemp32  = vpaddlq_u16(vA);
        vtemp32d = vpadd_u32(vget_low_u32(vtemp32), vget_high_u32(vtemp32));
        vtemp32d = vpadd_u32(vtemp32d, vtemp32d);
        sum      = vget_lane_u32(vtemp32d, 0);
        
        <span class="enscript-comment">//0x0001fffe + 0x0001fffe + 0x0001fffe + 0x0001fffe = 0x0007fff8U when all same.
</span>        <span class="enscript-keyword">if</span>(sum != 0x0007fff8U)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
        }
#<span class="enscript-reference">endif</span>
        
        len_count -= 16;
    }
    
    uint8x8_t vAd, vBd, vARotatedd, vBRotatedd, vMaskAd, vMaskBd;
    
    uint8x8_t v32d = vdup_n_u8(32);
    uint8x8_t v37d = vdup_n_u8(37);
    uint8x8_t v101d = vdup_n_u8(101);
    
    <span class="enscript-keyword">while</span>(len_count &gt; 7)
    {
        vAd = vld1_u8(a);
        vBd = vld1_u8(b);
        a += 8;
        b += 8;
        
        <span class="enscript-comment">//Make vA to lowercase if there is any uppercase.
</span>        vARotatedd = vadd_u8(vAd, v37d);            <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskAd    = vcgt_s8(vARotatedd, v101d);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskAd    = vand_u8(vMaskAd, v32d);        <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vAd        = vadd_u8(vAd, vMaskAd);         <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Make vB to lowercase if there is any uppercase.
</span>        vBRotatedd = vadd_u8(vBd, v37d);            <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskBd    = vcgt_s8(vBRotatedd, v101d);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskBd    = vand_u8(vMaskBd, v32d);        <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vBd        = vadd_u8(vBd, vMaskBd);         <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Compare vA &amp; vB
</span>        vAd = vceq_u8(vAd, vBd);
        
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__arm64__</span>
        <span class="enscript-comment">//View 8-bit element as 32-bit =&gt; a1 a0
</span>        <span class="enscript-comment">//If min of 2 32-bit values in vAd is 0xffffffff, then it means we have 0xff for all 16.
</span>        <span class="enscript-keyword">if</span>(vminv_u32(vAd) != 0xffffffffU)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
            
        }
#<span class="enscript-reference">else</span>
        <span class="enscript-comment">//See if any element was not same.
</span>        <span class="enscript-comment">//View 8-bit element as 16-bit =&gt; a3 a2 a1 a0
</span>        <span class="enscript-comment">//(a3+a2) (a1+a0) =&gt; Each will be 0xffff + 0xffff = 0x0001fffe when all same.
</span>        vtemp32d = vpaddl_u16(vAd);
        vtemp32d = vpadd_u32(vtemp32d, vtemp32d);
        sum      = vget_lane_u32(vtemp32d, 0);
        
        <span class="enscript-comment">//0x0001fffe + 0x0001fffe = 0x0003fffc when all same.
</span>        <span class="enscript-keyword">if</span>(sum != 0x0003fffcU)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
        }
#<span class="enscript-reference">endif</span>
        
        len_count -= 8;
    }
    
    <span class="enscript-keyword">while</span>(len_count &gt; 0)
    {
        mDNSu8 ac = *a++;
        mDNSu8 bc = *b++;
        
        ac += upper_to_lower_case_table[ac];
        bc += upper_to_lower_case_table[bc];
        
        <span class="enscript-keyword">if</span> (ac != bc)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
        }
        
        len_count -= 1;
    }
    <span class="enscript-keyword">return</span>(mDNStrue);
}

<span class="enscript-comment">// Use vectorized implementation if it is supported on this platform.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">setSameDomainLabelPointer</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span>(_cpu_capabilities &amp; kHasNeon)
    {
        <span class="enscript-comment">// Use Neon Code
</span>        SameDomainLabelPointer = vectorSameDomainLabel;
        LogMsg(<span class="enscript-string">&quot;setSameDomainLabelPointer: using vector code&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;setSameDomainLabelPointer: using scalar code&quot;</span>);
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_OSX</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;smmintrin.h&gt;</span>

<span class="enscript-comment">// Cache line aligned table that returns 32 for the upper case letters.
</span><span class="enscript-comment">// This will take up 4 cache lines.
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-function-name">__attribute__</span> ((aligned(64))) uint8_t upper_to_lower_case_table[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

<span class="enscript-comment">// SSE2 version
</span>mDNSlocal mDNSBool <span class="enscript-function-name">vectorSameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b)
{
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = *a++;
    
    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL)
    {
        fprintf(stderr, <span class="enscript-string">&quot;v: Malformed label (too long)\n&quot;</span>);
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    
    <span class="enscript-keyword">if</span> (len != *b++)
    {
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    
    uint32_t len_count = len;
    
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> __attribute__ ((aligned(16))) <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c_32[16] = { 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32 };
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> __attribute__ ((aligned(16))) <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c_37[16] = { 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37 };
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> __attribute__ ((aligned(16))) <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c_101[16] = { 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101 };
    __m128i v37  = _mm_load_si128((__m128i*)c_37);
    __m128i v101 = _mm_load_si128((__m128i*)c_101);
    __m128i v32  = _mm_load_si128((__m128i*)c_32);
    
    uint32_t is_equal;
    __m128i vA, vB, vARotated, vBRotated, vMaskA, vMaskB;
    
    <span class="enscript-comment">//AVX code that uses higher bandwidth (more elements per vector) was removed
</span>    <span class="enscript-comment">//to speed up the processing on the small sizes.
</span>    <span class="enscript-comment">//When I had them, the performance of 1 ~ 8 characters were slower by about 10% ~ 30%.
</span>    <span class="enscript-keyword">while</span>(len_count &gt; 15)
    {
        vA = _mm_loadu_si128((__m128i*)a);
        vB = _mm_loadu_si128((__m128i*)b);
        a += 16;
        b += 16;
        
        <span class="enscript-comment">//Make vA to lowercase if there is any uppercase.
</span>        vARotated = _mm_add_epi8(vA, v37);              <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskA    = _mm_cmpgt_epi8(vARotated, v101);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskA    = _mm_and_si128(vMaskA, v32);         <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vA        = _mm_add_epi8(vA, vMaskA);           <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Make vB to lowercase if there is any uppercase.
</span>        vBRotated = _mm_add_epi8(vB, v37);              <span class="enscript-comment">//Map 'A' ~ 'Z' from '65' ~ '90' to '102' ~ '127'.
</span>        vMaskB    = _mm_cmpgt_epi8(vBRotated, v101);    <span class="enscript-comment">//Check if anything is greater than '101' which means we have uppercase letters.
</span>        vMaskB    = _mm_and_si128(vMaskB, v32);         <span class="enscript-comment">//Prepare 32 for the elements with uppercase letters.
</span>        vB        = _mm_add_epi8(vB, vMaskB);           <span class="enscript-comment">//Add 32 only to the uppercase letters to make them lowercase letters.
</span>        
        <span class="enscript-comment">//Compare vA &amp; vB
</span>        vA = _mm_cmpeq_epi8(vA, vB);
        
        <span class="enscript-comment">//Return if any different.
</span>        is_equal = _mm_movemask_epi8(vA);
        is_equal = is_equal &amp; 0xffff;                 
        <span class="enscript-keyword">if</span>(is_equal != 0xffff)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
        }
        
        len_count -= 16;
    }
    
    <span class="enscript-keyword">while</span>(len_count &gt; 0)
    {
        mDNSu8 ac = *a++;
        mDNSu8 bc = *b++;
        
        <span class="enscript-comment">//Table will return 32 for upper case letters only.
</span>        <span class="enscript-comment">//0 will be returned for all others.
</span>        ac += upper_to_lower_case_table[ac];
        bc += upper_to_lower_case_table[bc];
        
        <span class="enscript-comment">//Return if a &amp; b are different.
</span>        <span class="enscript-keyword">if</span> (ac != bc)
        {
            <span class="enscript-keyword">return</span>(mDNSfalse);
        }
        
        len_count -= 1;
    }
    <span class="enscript-keyword">return</span>(mDNStrue);
}

<span class="enscript-comment">// Use vectorized implementation if it is supported on this platform.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">setSameDomainLabelPointer</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span>(_cpu_capabilities &amp; kHasSSE4_1)
    {
        <span class="enscript-comment">// Use SSE Code
</span>        SameDomainLabelPointer = vectorSameDomainLabel;
        LogMsg(<span class="enscript-string">&quot;setSameDomainLabelPointer: using vector code&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;setSameDomainLabelPointer: using scalar code&quot;</span>);
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">TARGET_OS_OSX</span>

<span class="enscript-comment">// Original SameDomainLabel() implementation.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">scalarSameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = *a++;

    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL)
    { debugf(<span class="enscript-string">&quot;Malformed label (too long)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }

    <span class="enscript-keyword">if</span> (len != *b++) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">for</span> (i=0; i&lt;len; i++)
    {
        mDNSu8 ac = *a++;
        mDNSu8 bc = *b++;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(bc)) bc += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (ac != bc) <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    <span class="enscript-keyword">return</span>(mDNStrue);
}

mDNSexport mDNSBool <span class="enscript-function-name">SameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b)
{
    <span class="enscript-keyword">return</span> (*SameDomainLabelPointer)(a, b);
}

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">GetRandomUUIDLabel</span>(domainlabel *label)
{
    uuid_t uuid;
    uuid_string_t uuidStr;
    uuid_generate_random(uuid);
    uuid_unparse_lower(uuid, uuidStr);
    MakeDomainLabelFromLiteralString(label, uuidStr);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">GetRandomUUIDLocalHostname</span>(domainname *hostname)
{
    domainlabel uuidLabel;
    GetRandomUUIDLabel(&amp;uuidLabel);
    hostname-&gt;c[0] = 0;
    AppendDomainLabel(hostname, &amp;uuidLabel);
    AppendLiteralLabelString(hostname, <span class="enscript-string">&quot;local&quot;</span>);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../unittests/mdns_macosx_ut.c&quot;</span>
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>