<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>helper.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">helper.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="helper.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/libbsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ctype.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Security/Security.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;SystemConfiguration/SystemConfiguration.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;SystemConfiguration/SCPreferencesSetSpecific.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;TargetConditionals.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssd_ipc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;helper.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;helper-server.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;P2PPacketFilter.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMLibPrivate.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">RTF_IFSCOPE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RTF_IFSCOPE</span> 0x1000000
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_CFUSERNOTIFICATION</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span> 1
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Embed the client stub code here, so we can access private functions like ConnectToServer, create_hdr, deliver_request
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSShared/dnssd_ipc.c&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../mDNSShared/dnssd_clientstub.c&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> sadb_x_policy *ipsec_policy_t;

uid_t mDNSResponderUID;
gid_t mDNSResponderGID;

<span class="enscript-type">void</span> <span class="enscript-function-name">helper_exit</span>()
{
    os_log_info(log_handle,<span class="enscript-string">&quot;mDNSResponderHelper exiting&quot;</span>);
    exit(0);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RequestBPF</span>()
{
    DNSServiceRef ref;
    
    DNSServiceErrorType err = ConnectToServer(&amp;ref, 0, send_bpf, NULL, NULL, NULL);
    <span class="enscript-keyword">if</span> (err)
    {
        os_log(log_handle, <span class="enscript-string">&quot;RequestBPF: ConnectToServer %d&quot;</span>, err);
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-type">char</span> *ptr;
    size_t len = <span class="enscript-keyword">sizeof</span>(DNSServiceFlags);
    ipc_msg_hdr *hdr = create_hdr(send_bpf, &amp;len, &amp;ptr, 0, ref);
    <span class="enscript-keyword">if</span> (!hdr)
    {
        os_log(log_handle, <span class="enscript-string">&quot;RequestBPF: No mem to allocate&quot;</span>);
        DNSServiceRefDeallocate(ref);
        <span class="enscript-keyword">return</span>;
    }
    
    put_flags(0, &amp;ptr);
    deliver_request(hdr, ref);      <span class="enscript-comment">// Will free hdr for us
</span>    DNSServiceRefDeallocate(ref);
    update_idle_timer();

    os_log_info(log_handle,<span class="enscript-string">&quot;RequestBPF: Successful&quot;</span>);
}


<span class="enscript-type">void</span> <span class="enscript-function-name">PowerRequest</span>(<span class="enscript-type">int</span> key, <span class="enscript-type">int</span> interval, <span class="enscript-type">int</span> *err)
{
    *err = kHelperErr_DefaultErr;
    
    os_log_info(log_handle,<span class="enscript-string">&quot;PowerRequest: key %d interval %d, err %d&quot;</span>, key, interval, *err);
    
    CFArrayRef events = IOPMCopyScheduledPowerEvents();
    <span class="enscript-keyword">if</span> (events)
    {
        <span class="enscript-type">int</span> i;
        CFIndex count = CFArrayGetCount(events);
        <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
        {
            CFDictionaryRef dict = CFArrayGetValueAtIndex(events, i);
            CFStringRef id = CFDictionaryGetValue(dict, CFSTR(kIOPMPowerEventAppNameKey));
            <span class="enscript-keyword">if</span> (CFEqual(id, CFSTR(<span class="enscript-string">&quot;mDNSResponderHelper&quot;</span>)))
            {
                CFDateRef EventTime = CFDictionaryGetValue(dict, CFSTR(kIOPMPowerEventTimeKey));
                CFStringRef EventType = CFDictionaryGetValue(dict, CFSTR(kIOPMPowerEventTypeKey));
                IOReturn result = IOPMCancelScheduledPowerEvent(EventTime, id, EventType);
                <span class="enscript-comment">//os_log(log_handle, &quot;Deleting old event %s&quot;);
</span>                <span class="enscript-keyword">if</span> (result)
                    os_log(log_handle, <span class="enscript-string">&quot;IOPMCancelScheduledPowerEvent %d failed %d&quot;</span>, i, result);
            }
        }
        CFRelease(events);
    }
    
    <span class="enscript-keyword">if</span> (key &lt; 0) <span class="enscript-comment">// mDNSPowerRequest(-1,-1) means &quot;clear any stale schedules&quot; (see above)
</span>    {
        *err = kHelperErr_NoErr;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key == 0)      <span class="enscript-comment">// mDNSPowerRequest(0, 0) means &quot;sleep now&quot;
</span>    {
        IOReturn r = IOPMSleepSystem(IOPMFindPowerManagement(MACH_PORT_NULL));
        <span class="enscript-keyword">if</span> (r)
        {
            usleep(100000);
            os_log_info(log_handle, <span class="enscript-string">&quot;IOPMSleepSystem %d&quot;</span>, r);
        }
        *err = r;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key &gt; 0)
    {
        CFDateRef wakeTime = CFDateCreate(NULL, CFAbsoluteTimeGetCurrent() + interval);
        <span class="enscript-keyword">if</span> (wakeTime)
        {
            CFMutableDictionaryRef scheduleDict = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
            
            CFDictionaryAddValue(scheduleDict, CFSTR(kIOPMPowerEventTimeKey), wakeTime);
            CFDictionaryAddValue(scheduleDict, CFSTR(kIOPMPowerEventAppNameKey), CFSTR(<span class="enscript-string">&quot;mDNSResponderHelper&quot;</span>));
            CFDictionaryAddValue(scheduleDict, CFSTR(kIOPMPowerEventTypeKey), key ? CFSTR(kIOPMAutoWake) : CFSTR(kIOPMAutoSleep));
            
            IOReturn r = IOPMRequestSysWake(scheduleDict);
            <span class="enscript-keyword">if</span> (r)
            {
                usleep(100000);
                os_log_info(log_handle, <span class="enscript-string">&quot;IOPMRequestSysWake(%d) %d %x&quot;</span>, interval, r, r);
            }
            *err = r;
            CFRelease(wakeTime);
            CFRelease(scheduleDict);
        }
    }
    
    update_idle_timer();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">SetLocalAddressCacheEntry</span>(<span class="enscript-type">int</span> ifindex, <span class="enscript-type">int</span> family, <span class="enscript-type">const</span> v6addr_t ip, <span class="enscript-type">const</span> ethaddr_t eth, <span class="enscript-type">int</span> *err)
{
    
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPv6FMTSTRING</span> <span class="enscript-string">&quot;%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPv6FMTARGS</span>  ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7], ip[8], ip[9], ip[10], ip[11], ip[12], ip[13], ip[14], ip[15]
    
    <span class="enscript-keyword">if</span> (family == 4)
    {
        os_log_info(log_handle,<span class="enscript-string">&quot;SetLocalAddressCacheEntry %d IPv%d %d.%d.%d.%d %02X:%02X:%02X:%02X:%02X:%02X&quot;</span>,
                       ifindex, family, ip[0], ip[1], ip[2], ip[3], eth[0], eth[1], eth[2], eth[3], eth[4], eth[5]);
    }
    <span class="enscript-keyword">else</span>
    {
        os_log_info(log_handle,<span class="enscript-string">&quot;SetLocalAddressCacheEntry %d IPv%d &quot;</span> IPv6FMTSTRING <span class="enscript-string">&quot; %02X:%02X:%02X:%02X:%02X:%02X&quot;</span>,
                       ifindex, family, IPv6FMTARGS, eth[0], eth[1], eth[2], eth[3], eth[4], eth[5]);
    }
    
    *err = kHelperErr_DefaultErr;
    
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> s = -1, seq = 0;
    <span class="enscript-keyword">if</span> (s &lt; 0)
    {
        s = socket(PF_ROUTE, SOCK_RAW, 0);
        <span class="enscript-keyword">if</span> (s &lt; 0)
            os_log(log_handle, <span class="enscript-string">&quot;SetLocalAddressCacheEntry: socket(PF_ROUTE, SOCK_RAW, 0) failed %d (%s)&quot;</span>, errno, strerror(errno));
    }

    <span class="enscript-keyword">if</span> (s &gt;= 0)
    {
        <span class="enscript-type">struct</span> timeval tv;
        gettimeofday(&amp;tv, 0);
        <span class="enscript-keyword">if</span> (family == 4)
        {
            <span class="enscript-type">struct</span> { <span class="enscript-type">struct</span> rt_msghdr hdr; <span class="enscript-type">struct</span> sockaddr_inarp dst; <span class="enscript-type">struct</span> sockaddr_dl sdl; } rtmsg;
            memset(&amp;rtmsg, 0, <span class="enscript-keyword">sizeof</span>(rtmsg));
            
            rtmsg.hdr.rtm_msglen         = <span class="enscript-keyword">sizeof</span>(rtmsg);
            rtmsg.hdr.rtm_version        = RTM_VERSION;
            rtmsg.hdr.rtm_type           = RTM_ADD;
            rtmsg.hdr.rtm_index          = ifindex;
            rtmsg.hdr.rtm_flags          = RTF_HOST | RTF_STATIC | RTF_IFSCOPE;
            rtmsg.hdr.rtm_addrs          = RTA_DST | RTA_GATEWAY;
            rtmsg.hdr.rtm_pid            = 0;
            rtmsg.hdr.rtm_seq            = seq++;
            rtmsg.hdr.rtm_errno          = 0;
            rtmsg.hdr.rtm_use            = 0;
            rtmsg.hdr.rtm_inits          = RTV_EXPIRE;
            rtmsg.hdr.rtm_rmx.rmx_expire = tv.tv_sec + 30;
            
            rtmsg.dst.sin_len            = <span class="enscript-keyword">sizeof</span>(rtmsg.dst);
            rtmsg.dst.sin_family         = AF_INET;
            rtmsg.dst.sin_port           = 0;
            rtmsg.dst.sin_addr.s_addr    = *(in_addr_t*)ip;
            rtmsg.dst.sin_srcaddr.s_addr = 0;
            rtmsg.dst.sin_tos            = 0;
            rtmsg.dst.sin_other          = 0;
            
            rtmsg.sdl.sdl_len            = <span class="enscript-keyword">sizeof</span>(rtmsg.sdl);
            rtmsg.sdl.sdl_family         = AF_LINK;
            rtmsg.sdl.sdl_index          = ifindex;
            rtmsg.sdl.sdl_type           = IFT_ETHER;
            rtmsg.sdl.sdl_nlen           = 0;
            rtmsg.sdl.sdl_alen           = ETHER_ADDR_LEN;
            rtmsg.sdl.sdl_slen           = 0;
            
            <span class="enscript-comment">// Target MAC address goes in rtmsg.sdl.sdl_data[0..5]; (See LLADDR() in /usr/include/net/if_dl.h)
</span>            memcpy(rtmsg.sdl.sdl_data, eth, <span class="enscript-keyword">sizeof</span>(ethaddr_t));
            
            <span class="enscript-type">int</span> len = write(s, (<span class="enscript-type">char</span> *)&amp;rtmsg, <span class="enscript-keyword">sizeof</span>(rtmsg));
            <span class="enscript-keyword">if</span> (len &lt; 0)
                os_log(log_handle, <span class="enscript-string">&quot;SetLocalAddressCacheEntry: write(%zu) interface %d address %d.%d.%d.%d seq %d result %d errno %d (%s)&quot;</span>,
                        <span class="enscript-keyword">sizeof</span>(rtmsg), ifindex, ip[0], ip[1], ip[2], ip[3], rtmsg.hdr.rtm_seq, len, errno, strerror(errno));
            len = read(s, (<span class="enscript-type">char</span> *)&amp;rtmsg, <span class="enscript-keyword">sizeof</span>(rtmsg));
            <span class="enscript-keyword">if</span> (len &lt; 0 || rtmsg.hdr.rtm_errno)
                os_log(log_handle, <span class="enscript-string">&quot;SetLocalAddressCacheEntry: read (%zu) interface %d address %d.%d.%d.%d seq %d result %d errno %d (%s) %d&quot;</span>,
                        <span class="enscript-keyword">sizeof</span>(rtmsg), ifindex, ip[0], ip[1], ip[2], ip[3], rtmsg.hdr.rtm_seq, len, errno, strerror(errno), rtmsg.hdr.rtm_errno);
            
            *err = kHelperErr_NoErr;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-type">struct</span> { <span class="enscript-type">struct</span> rt_msghdr hdr; <span class="enscript-type">struct</span> sockaddr_in6 dst; <span class="enscript-type">struct</span> sockaddr_dl sdl; } rtmsg;
            memset(&amp;rtmsg, 0, <span class="enscript-keyword">sizeof</span>(rtmsg));
            
            rtmsg.hdr.rtm_msglen         = <span class="enscript-keyword">sizeof</span>(rtmsg);
            rtmsg.hdr.rtm_version        = RTM_VERSION;
            rtmsg.hdr.rtm_type           = RTM_ADD;
            rtmsg.hdr.rtm_index          = ifindex;
            rtmsg.hdr.rtm_flags          = RTF_HOST | RTF_STATIC | RTF_IFSCOPE;
            rtmsg.hdr.rtm_addrs          = RTA_DST | RTA_GATEWAY;
            rtmsg.hdr.rtm_pid            = 0;
            rtmsg.hdr.rtm_seq            = seq++;
            rtmsg.hdr.rtm_errno          = 0;
            rtmsg.hdr.rtm_use            = 0;
            rtmsg.hdr.rtm_inits          = RTV_EXPIRE;
            rtmsg.hdr.rtm_rmx.rmx_expire = tv.tv_sec + 30;
            
            rtmsg.dst.sin6_len           = <span class="enscript-keyword">sizeof</span>(rtmsg.dst);
            rtmsg.dst.sin6_family        = AF_INET6;
            rtmsg.dst.sin6_port          = 0;
            rtmsg.dst.sin6_flowinfo      = 0;
            rtmsg.dst.sin6_addr          = *(<span class="enscript-type">struct</span> in6_addr*)ip;
            rtmsg.dst.sin6_scope_id      = ifindex;
            
            rtmsg.sdl.sdl_len            = <span class="enscript-keyword">sizeof</span>(rtmsg.sdl);
            rtmsg.sdl.sdl_family         = AF_LINK;
            rtmsg.sdl.sdl_index          = ifindex;
            rtmsg.sdl.sdl_type           = IFT_ETHER;
            rtmsg.sdl.sdl_nlen           = 0;
            rtmsg.sdl.sdl_alen           = ETHER_ADDR_LEN;
            rtmsg.sdl.sdl_slen           = 0;
            
            <span class="enscript-comment">// Target MAC address goes in rtmsg.sdl.sdl_data[0..5]; (See LLADDR() in /usr/include/net/if_dl.h)
</span>            memcpy(rtmsg.sdl.sdl_data, eth, <span class="enscript-keyword">sizeof</span>(ethaddr_t));
            
            <span class="enscript-type">int</span> len = write(s, (<span class="enscript-type">char</span> *)&amp;rtmsg, <span class="enscript-keyword">sizeof</span>(rtmsg));
            <span class="enscript-keyword">if</span> (len &lt; 0)
                os_log(log_handle, <span class="enscript-string">&quot;SetLocalAddressCacheEntry: write(%zu) interface %d address &quot;</span> IPv6FMTSTRING <span class="enscript-string">&quot; seq %d result %d errno %d (%s)&quot;</span>,
                        <span class="enscript-keyword">sizeof</span>(rtmsg), ifindex, IPv6FMTARGS, rtmsg.hdr.rtm_seq, len, errno, strerror(errno));
            len = read(s, (<span class="enscript-type">char</span> *)&amp;rtmsg, <span class="enscript-keyword">sizeof</span>(rtmsg));
            <span class="enscript-keyword">if</span> (len &lt; 0 || rtmsg.hdr.rtm_errno)
                os_log(log_handle, <span class="enscript-string">&quot;SetLocalAddressCacheEntry: read (%zu) interface %d address &quot;</span> IPv6FMTSTRING <span class="enscript-string">&quot; seq %d result %d errno %d (%s) %d&quot;</span>,
                        <span class="enscript-keyword">sizeof</span>(rtmsg), ifindex, IPv6FMTARGS, rtmsg.hdr.rtm_seq, len, errno, strerror(errno), rtmsg.hdr.rtm_errno);
            
            *err = kHelperErr_NoErr;
        }
    }
    
    update_idle_timer();
}


<span class="enscript-type">void</span> <span class="enscript-function-name">UserNotify</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *title, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg)
{
    
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CFUSERNOTIFICATION</span>
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> footer[] = <span class="enscript-string">&quot;(Note: This message only appears on machines with 17.x.x.x IP addresses&quot;</span>
    <span class="enscript-string">&quot; or on debugging builds with ForceAlerts set — i.e. only at Apple — not on customer machines.)&quot;</span>;
    CFStringRef alertHeader  = CFStringCreateWithCString(NULL, title,  kCFStringEncodingUTF8);
    CFStringRef alertBody    = CFStringCreateWithCString(NULL, msg,    kCFStringEncodingUTF8);
    CFStringRef alertFooter  = CFStringCreateWithCString(NULL, footer, kCFStringEncodingUTF8);
    CFStringRef alertMessage = CFStringCreateWithFormat(NULL, NULL, CFSTR(<span class="enscript-string">&quot;%@\r\r%@&quot;</span>), alertBody, alertFooter);
    CFRelease(alertBody);
    CFRelease(alertFooter);
    <span class="enscript-type">int</span> err = CFUserNotificationDisplayNotice(0.0, kCFUserNotificationStopAlertLevel, NULL, NULL, NULL, alertHeader, alertMessage, NULL);
    <span class="enscript-keyword">if</span> (err)
        os_log(log_handle, <span class="enscript-string">&quot;CFUserNotificationDisplayNotice returned %d&quot;</span>, err);
    CFRelease(alertHeader);
    CFRelease(alertMessage);
#<span class="enscript-reference">else</span>
    (<span class="enscript-type">void</span>)title;
    (<span class="enscript-type">void</span>)msg;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_CFUSERNOTIFICATION */</span>
    
    update_idle_timer();
}


<span class="enscript-type">char</span> usercompname[MAX_DOMAIN_LABEL+1] = {0}; <span class="enscript-comment">// the last computer name the user saw
</span><span class="enscript-type">char</span> userhostname[MAX_DOMAIN_LABEL+1] = {0}; <span class="enscript-comment">// the last local host name the user saw
</span><span class="enscript-type">char</span> lastcompname[MAX_DOMAIN_LABEL+1] = {0}; <span class="enscript-comment">// the last computer name saved to preferences
</span><span class="enscript-type">char</span> lasthostname[MAX_DOMAIN_LABEL+1] = {0}; <span class="enscript-comment">// the last local host name saved to preferences
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CFUSERNOTIFICATION</span>
<span class="enscript-type">static</span> CFStringRef CFS_OQ = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_CQ = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_Format = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_ComputerName = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_ComputerNameMsg = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_LocalHostName = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_LocalHostNameMsg = NULL;
<span class="enscript-type">static</span> CFStringRef CFS_Problem = NULL;

<span class="enscript-type">static</span> CFUserNotificationRef gNotification    = NULL;
<span class="enscript-type">static</span> CFRunLoopSourceRef gNotificationRLS = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">NotificationCallBackDismissed</span>(CFUserNotificationRef userNotification, CFOptionFlags responseFlags)
{
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry&quot;</span>);
    (<span class="enscript-type">void</span>)responseFlags;    <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (userNotification != gNotification) os_log(log_handle, <span class="enscript-string">&quot;NotificationCallBackDismissed: Wrong CFUserNotificationRef&quot;</span>);
    <span class="enscript-keyword">if</span> (gNotificationRLS)
    {
        <span class="enscript-comment">// Caution: don't use CFRunLoopGetCurrent() here, because the currently executing thread may not be our &quot;CFRunLoopRun&quot; thread.
</span>        <span class="enscript-comment">// We need to explicitly specify the desired CFRunLoop from which we want to remove this event source.
</span>        CFRunLoopRemoveSource(gRunLoop, gNotificationRLS, kCFRunLoopDefaultMode);
        CFRelease(gNotificationRLS);
        gNotificationRLS = NULL;
        CFRelease(gNotification);
        gNotification = NULL;
    }
    <span class="enscript-comment">// By dismissing the alert, the user has conceptually acknowleged the rename.
</span>    <span class="enscript-comment">// (e.g. the machine's name is now officially &quot;computer-2.local&quot;, not &quot;computer.local&quot;.)
</span>    <span class="enscript-comment">// If we get *another* conflict, the new alert should refer to the 'old' name
</span>    <span class="enscript-comment">// as now being &quot;computer-2.local&quot;, not &quot;computer.local&quot;
</span>    usercompname[0] = 0;
    userhostname[0] = 0;
    lastcompname[0] = 0;
    lasthostname[0] = 0;
    update_idle_timer();
    unpause_idle_timer();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ShowNameConflictNotification</span>(CFMutableArrayRef header, CFStringRef subtext)
{
    CFMutableDictionaryRef dictionary = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
    <span class="enscript-keyword">if</span> (!dictionary) <span class="enscript-keyword">return</span>;

    os_log_debug(log_handle,<span class="enscript-string">&quot;entry&quot;</span>);

    CFDictionarySetValue(dictionary, kCFUserNotificationAlertHeaderKey, header);
    CFDictionarySetValue(dictionary, kCFUserNotificationAlertMessageKey, subtext);

    CFURLRef urlRef = CFURLCreateWithFileSystemPath(NULL, CFSTR(<span class="enscript-string">&quot;/System/Library/CoreServices/mDNSResponder.bundle&quot;</span>), kCFURLPOSIXPathStyle, true);
    <span class="enscript-keyword">if</span> (urlRef) { CFDictionarySetValue(dictionary, kCFUserNotificationLocalizationURLKey, urlRef); CFRelease(urlRef); }

    <span class="enscript-keyword">if</span> (gNotification)  <span class="enscript-comment">// If notification already on-screen, update it in place
</span>        CFUserNotificationUpdate(gNotification, 0, kCFUserNotificationCautionAlertLevel, dictionary);
    <span class="enscript-keyword">else</span>                <span class="enscript-comment">// else, we need to create it
</span>    {
        SInt32 error;
        gNotification = CFUserNotificationCreate(NULL, 0, kCFUserNotificationCautionAlertLevel, &amp;error, dictionary);
        <span class="enscript-keyword">if</span> (!gNotification || error) { os_log(log_handle, <span class="enscript-string">&quot;ShowNameConflictNotification: CFUserNotificationRef: Error %d&quot;</span>, error); <span class="enscript-keyword">return</span>; }
        gNotificationRLS = CFUserNotificationCreateRunLoopSource(NULL, gNotification, NotificationCallBackDismissed, 0);
        <span class="enscript-keyword">if</span> (!gNotificationRLS) { os_log(log_handle, <span class="enscript-string">&quot;ShowNameConflictNotification: RLS&quot;</span>); CFRelease(gNotification); gNotification = NULL; <span class="enscript-keyword">return</span>; }
        <span class="enscript-comment">// Caution: don't use CFRunLoopGetCurrent() here, because the currently executing thread may not be our &quot;CFRunLoopRun&quot; thread.
</span>        <span class="enscript-comment">// We need to explicitly specify the desired CFRunLoop to which we want to add this event source.
</span>        CFRunLoopAddSource(gRunLoop, gNotificationRLS, kCFRunLoopDefaultMode);
        os_log_debug(log_handle,<span class="enscript-string">&quot;gRunLoop=%p gNotification=%p gNotificationRLS=%p&quot;</span>, gRunLoop, gNotification, gNotificationRLS);
        pause_idle_timer();
    }

    CFRelease(dictionary);
}

<span class="enscript-type">static</span> CFMutableArrayRef <span class="enscript-function-name">CreateAlertHeader</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* oldname, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* newname, <span class="enscript-type">const</span> CFStringRef msg, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* suffix)
{
    CFMutableArrayRef alertHeader = NULL;

    <span class="enscript-type">const</span> CFStringRef cfoldname = CFStringCreateWithCString(NULL, oldname,  kCFStringEncodingUTF8);
    <span class="enscript-comment">// NULL newname means we've given up trying to construct a name that doesn't conflict
</span>    <span class="enscript-type">const</span> CFStringRef cfnewname = newname ? CFStringCreateWithCString(NULL, newname,  kCFStringEncodingUTF8) : NULL;
    <span class="enscript-comment">// We tag a zero-width non-breaking space at the end of the literal text to guarantee that, no matter what
</span>    <span class="enscript-comment">// arbitrary computer name the user may choose, this exact text (with zero-width non-breaking space added)
</span>    <span class="enscript-comment">// can never be one that occurs in the Localizable.strings translation file.
</span>    <span class="enscript-keyword">if</span> (!cfoldname)
    {
        os_log(log_handle, <span class="enscript-string">&quot;Could not construct CFStrings for old=%s&quot;</span>, newname);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newname &amp;&amp; !cfnewname)
    {
        os_log(log_handle, <span class="enscript-string">&quot;Could not construct CFStrings for new=%s&quot;</span>, newname);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">const</span> CFStringRef s1 = CFStringCreateWithFormat(NULL, NULL, CFS_Format, cfoldname, suffix);
        <span class="enscript-type">const</span> CFStringRef s2 = cfnewname ? CFStringCreateWithFormat(NULL, NULL, CFS_Format, cfnewname, suffix) : NULL;

        alertHeader = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks);

        <span class="enscript-keyword">if</span> (!s1)
        {
            os_log(log_handle, <span class="enscript-string">&quot;Could not construct secondary CFString for old=%s&quot;</span>, oldname);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cfnewname &amp;&amp; !s2)
        {
            os_log(log_handle, <span class="enscript-string">&quot;Could not construct secondary CFString for new=%s&quot;</span>, newname);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!alertHeader)
        {
            os_log(log_handle, <span class="enscript-string">&quot;Could not construct CFArray for notification&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Make sure someone is logged in.  We don't want this popping up over the login window
</span>            uid_t uid;
            gid_t gid;
            CFStringRef userName = SCDynamicStoreCopyConsoleUser(NULL, &amp;uid, &amp;gid);
            <span class="enscript-keyword">if</span> (userName)
            {
                <span class="enscript-keyword">if</span> (!CFEqual(userName, CFSTR(<span class="enscript-string">&quot;_mbsetupuser&quot;</span>)))
                {
                    CFArrayAppendValue(alertHeader, msg); <span class="enscript-comment">// Opening phrase of message, provided by caller
</span>                    CFArrayAppendValue(alertHeader, CFS_OQ); CFArrayAppendValue(alertHeader, s1); CFArrayAppendValue(alertHeader, CFS_CQ);
                    CFArrayAppendValue(alertHeader, CFSTR(<span class="enscript-string">&quot; is already in use on this network. &quot;</span>));
                    <span class="enscript-keyword">if</span> (s2)
                    {
                        CFArrayAppendValue(alertHeader, CFSTR(<span class="enscript-string">&quot;The name has been changed to &quot;</span>));
                        CFArrayAppendValue(alertHeader, CFS_OQ); CFArrayAppendValue(alertHeader, s2); CFArrayAppendValue(alertHeader, CFS_CQ);
                        CFArrayAppendValue(alertHeader, CFSTR(<span class="enscript-string">&quot;.&quot;</span>));
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        CFArrayAppendValue(alertHeader, CFSTR(<span class="enscript-string">&quot;All attempts to find an available name by adding a number to the name were also unsuccessful.&quot;</span>));
                    }
                }
                CFRelease(userName);
            }
        }
        <span class="enscript-keyword">if</span> (s1) CFRelease(s1);
        <span class="enscript-keyword">if</span> (s2) CFRelease(s2);
    }
    <span class="enscript-keyword">if</span> (cfoldname) CFRelease(cfoldname);
    <span class="enscript-keyword">if</span> (cfnewname) CFRelease(cfnewname);

    <span class="enscript-keyword">return</span> alertHeader;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ndef NO_CFUSERNOTIFICATION */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_notification</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CFUSERNOTIFICATION</span>
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry ucn=%s, uhn=%s, lcn=%s, lhn=%s&quot;</span>, usercompname, userhostname, lastcompname, lasthostname);
    <span class="enscript-keyword">if</span> (!CFS_OQ)
    {
        <span class="enscript-comment">// Note: The &quot;\xEF\xBB\xBF&quot; byte sequence (U+FEFF) in the CFS_Format string is the UTF-8 encoding of the zero-width non-breaking space character.
</span>        <span class="enscript-comment">// By appending this invisible character on the end of literal names, we ensure the these strings cannot inadvertently match any string
</span>        <span class="enscript-comment">// in the localization file -- since we know for sure that none of our strings in the localization file contain the ZWNBS character.
</span>        CFS_Format           = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;%@%s\xEF\xBB\xBF&quot;</span>, kCFStringEncodingUTF8);

        <span class="enscript-comment">// The strings CFS_OQ, CFS_CQ and the others below are the localization keys for the “Localizable.strings” files,
</span>        <span class="enscript-comment">// and MUST NOT BE CHANGED, or localization substitution will be broken.
</span>        <span class="enscript-comment">// To change the text displayed to the user, edit the values in the appropriate “Localizable.strings” file, not the keys here.
</span>        <span class="enscript-comment">// This includes making changes for adding appropriate directionality overrides like LRM, LRE, RLE, PDF, etc. These need to go in the values
</span>        <span class="enscript-comment">// in the appropriate “Localizable.strings” entries, not in the keys here (which then won’t match *any* entry in the localization files).
</span>        <span class="enscript-comment">// These localization keys here were broken in &lt;rdar://problem/8629082&gt; and then subsequently repaired in
</span>        <span class="enscript-comment">// &lt;rdar://problem/21071535&gt; [mDNSResponder]: TA: Gala15A185: Incorrect punctuation marks when Change the host name to an exist one
</span>        CFS_OQ               = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;“&quot;</span>,  kCFStringEncodingUTF8);	<span class="enscript-comment">// DO NOT CHANGE THIS STRING
</span>        CFS_CQ               = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;”&quot;</span>,  kCFStringEncodingUTF8);	<span class="enscript-comment">// DO NOT CHANGE THIS STRING
</span>        CFS_ComputerName     = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;The name of your computer &quot;</span>,  kCFStringEncodingUTF8);
        CFS_ComputerNameMsg  = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;To change the name of your computer, &quot;</span>
                                                         <span class="enscript-string">&quot;open System Preferences and click Sharing, then type the name in the Computer Name field.&quot;</span>,  kCFStringEncodingUTF8);
        CFS_LocalHostName    = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;This computer’s local hostname &quot;</span>,  kCFStringEncodingUTF8);
        CFS_LocalHostNameMsg = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;To change the local hostname, &quot;</span>
                                                         <span class="enscript-string">&quot;open System Preferences and click Sharing, then click “Edit” and type the name in the Local Hostname field.&quot;</span>,  kCFStringEncodingUTF8);
        CFS_Problem          = CFStringCreateWithCString(NULL, <span class="enscript-string">&quot;This may indicate a problem with the local network. &quot;</span>
                                                         <span class="enscript-string">&quot;Please inform your network administrator.&quot;</span>,  kCFStringEncodingUTF8);
    }

    <span class="enscript-keyword">if</span> (!usercompname[0] &amp;&amp; !userhostname[0])
    {
        <span class="enscript-keyword">if</span> (gNotificationRLS)
        {
            os_log_debug(log_handle,<span class="enscript-string">&quot;canceling notification %p&quot;</span>, gNotification);
            CFUserNotificationCancel(gNotification);
            unpause_idle_timer();
        }
    }
    <span class="enscript-keyword">else</span>
    {
        CFMutableArrayRef header = NULL;
        CFStringRef* subtext = NULL;
        <span class="enscript-keyword">if</span> (userhostname[0] &amp;&amp; !lasthostname[0]) <span class="enscript-comment">// we've given up trying to construct a name that doesn't conflict
</span>        {
            header = CreateAlertHeader(userhostname, NULL, CFS_LocalHostName, <span class="enscript-string">&quot;.local&quot;</span>);
            subtext = &amp;CFS_Problem;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (usercompname[0])
        {
            header = CreateAlertHeader(usercompname, lastcompname, CFS_ComputerName, <span class="enscript-string">&quot;&quot;</span>);
            subtext = &amp;CFS_ComputerNameMsg;
        }
        <span class="enscript-keyword">else</span>
        {
            header = CreateAlertHeader(userhostname, lasthostname, CFS_LocalHostName, <span class="enscript-string">&quot;.local&quot;</span>);
            subtext = &amp;CFS_LocalHostNameMsg;
        }
        ShowNameConflictNotification(header, *subtext);
        CFRelease(header);
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PreferencesSetName</span>(<span class="enscript-type">int</span> key, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* old, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* new)
{
    SCPreferencesRef session = NULL;
    Boolean ok = FALSE;
    Boolean locked = FALSE;
    CFStringRef cfstr = NULL;
    <span class="enscript-type">char</span>* user = NULL;
    <span class="enscript-type">char</span>* last = NULL;
    Boolean needUpdate = FALSE;
    
    os_log_info(log_handle,<span class="enscript-string">&quot;PreferencesSetName: entry %s old=%s new=%s&quot;</span>,
                   key==kmDNSComputerName ? <span class="enscript-string">&quot;ComputerName&quot;</span> : (key==kmDNSLocalHostName ? <span class="enscript-string">&quot;LocalHostName&quot;</span> : <span class="enscript-string">&quot;UNKNOWN&quot;</span>), old, new);
    
    <span class="enscript-keyword">switch</span> ((<span class="enscript-type">enum</span> mDNSPreferencesSetNameKey)key)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSComputerName</span>:
            user = usercompname;
            last = lastcompname;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSLocalHostName</span>:
            user = userhostname;
            last = lasthostname;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            os_log(log_handle, <span class="enscript-string">&quot;PreferencesSetName: unrecognized key: %d&quot;</span>, key);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    <span class="enscript-keyword">if</span> (!last)
    {
        os_log(log_handle, <span class="enscript-string">&quot;PreferencesSetName: no last ptr&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    <span class="enscript-keyword">if</span> (!user)
    {
        os_log(log_handle, <span class="enscript-string">&quot;PreferencesSetName:: no user ptr&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    <span class="enscript-keyword">if</span> (0 == strncmp(old, new, MAX_DOMAIN_LABEL+1))
    {
        <span class="enscript-comment">// old and new are same means the config changed i.e, the user has set something in the preferences pane.
</span>        <span class="enscript-comment">// This means the conflict has been resolved. We need to dismiss the dialogue.
</span>        <span class="enscript-keyword">if</span> (last[0] &amp;&amp; 0 != strncmp(last, new, MAX_DOMAIN_LABEL+1))
        {
            last[0] = 0;
            user[0] = 0;
            needUpdate = TRUE;
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// old and new are not same, this means there is a conflict. For the first conflict, we show
</span>        <span class="enscript-comment">// the old value and the new value. For all subsequent conflicts, while the dialogue is still
</span>        <span class="enscript-comment">// up, we do a real time update of the &quot;new&quot; value in the dialogue. That's why we update just
</span>        <span class="enscript-comment">// &quot;last&quot; here and not &quot;user&quot;.
</span>        <span class="enscript-keyword">if</span> (strncmp(last, new, MAX_DOMAIN_LABEL+1))
        {
            strncpy(last, new, MAX_DOMAIN_LABEL);
            needUpdate = TRUE;
        }
    }
    
    <span class="enscript-comment">// If we are not showing the dialogue, we need to remember the first &quot;old&quot; value so that
</span>    <span class="enscript-comment">// we maintain the same through the lifetime of the dialogue. Subsequent conflicts don't
</span>    <span class="enscript-comment">// update the &quot;old&quot; value.
</span>    <span class="enscript-keyword">if</span> (!user[0])
    {
        strncpy(user, old, MAX_DOMAIN_LABEL);
        needUpdate = TRUE;
    }
    
    <span class="enscript-keyword">if</span> (!new[0]) <span class="enscript-comment">// we've given up trying to construct a name that doesn't conflict
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    
    cfstr = CFStringCreateWithCString(NULL, new, kCFStringEncodingUTF8);
    
    session = SCPreferencesCreate(NULL, CFSTR(kHelperService), NULL);
    
    <span class="enscript-keyword">if</span> (cfstr == NULL || session == NULL)
    {
        os_log(log_handle, <span class="enscript-string">&quot;PreferencesSetName: SCPreferencesCreate failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">if</span> (!SCPreferencesLock(session, 0))
    {
        os_log(log_handle,<span class="enscript-string">&quot;PreferencesSetName: lock failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    locked = TRUE;
    
    <span class="enscript-keyword">switch</span> ((<span class="enscript-type">enum</span> mDNSPreferencesSetNameKey)key)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSComputerName</span>:
        {
            <span class="enscript-comment">// We want to write the new Computer Name to System Preferences, without disturbing the user-selected
</span>            <span class="enscript-comment">// system-wide default character set used for things like AppleTalk NBP and NETBIOS service advertising.
</span>            <span class="enscript-comment">// Note that this encoding is not used for the computer name, but since both are set by the same call,
</span>            <span class="enscript-comment">// we need to take care to set the name without changing the character set.
</span>            CFStringEncoding encoding = kCFStringEncodingUTF8;
            CFStringRef unused = SCDynamicStoreCopyComputerName(NULL, &amp;encoding);
            <span class="enscript-keyword">if</span> (unused)
            {
                CFRelease(unused);
                unused = NULL;
            }
            <span class="enscript-keyword">else</span>
            {
                encoding = kCFStringEncodingUTF8;
            }
            
            ok = SCPreferencesSetComputerName(session, cfstr, encoding);
        }
            <span class="enscript-keyword">break</span>;
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kmDNSLocalHostName</span>:
            ok = SCPreferencesSetLocalHostName(session, cfstr);
            <span class="enscript-keyword">break</span>;
            
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">break</span>;
    }
    
    <span class="enscript-keyword">if</span> (!ok || !SCPreferencesCommitChanges(session) ||
        !SCPreferencesApplyChanges(session))
    {
        os_log(log_handle, <span class="enscript-string">&quot;PreferencesSetName: SCPreferences update failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    os_log_info(log_handle,<span class="enscript-string">&quot;PreferencesSetName: succeeded&quot;</span>);
    
<span class="enscript-reference">fin</span>:
    <span class="enscript-keyword">if</span> (NULL != cfstr)
        CFRelease(cfstr);
    <span class="enscript-keyword">if</span> (NULL != session)
    {
        <span class="enscript-keyword">if</span> (locked)
            SCPreferencesUnlock(session);
        CFRelease(session);
    }
    update_idle_timer();
    <span class="enscript-keyword">if</span> (needUpdate)
        update_notification();
    
}


<span class="enscript-type">enum</span> DNSKeyFormat
{
    formatNotDNSKey,
    formatDdnsTypeItem,
    formatDnsPrefixedServiceItem,
};

<span class="enscript-comment">// On Mac OS X on Intel, the four-character string seems to be stored backwards, at least sometimes.
</span><span class="enscript-comment">// I suspect some overenthusiastic inexperienced engineer said, &quot;On Intel everything's backwards,
</span><span class="enscript-comment">// therefore I need to add some byte swapping in this API to make this four-character string backwards too.&quot;
</span><span class="enscript-comment">// To cope with this we allow *both* &quot;ddns&quot; and &quot;sndd&quot; as valid item types.
</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> dnsprefix[] = <span class="enscript-string">&quot;dns:&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> ddns[] = <span class="enscript-string">&quot;ddns&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> ddnsrev[] = <span class="enscript-string">&quot;sndd&quot;</span>;

<span class="enscript-type">static</span> <span class="enscript-type">enum</span> DNSKeyFormat <span class="enscript-function-name">getDNSKeyFormat</span>(SecKeychainItemRef item, SecKeychainAttributeList **attributesp)
{
    <span class="enscript-type">static</span> UInt32 tags[4] =
    {
        kSecTypeItemAttr, kSecServiceItemAttr, kSecAccountItemAttr, kSecLabelItemAttr
    };
    <span class="enscript-type">static</span> SecKeychainAttributeInfo attributeInfo =
    {
        <span class="enscript-keyword">sizeof</span>(tags)/<span class="enscript-keyword">sizeof</span>(tags[0]), tags, NULL
    };
    SecKeychainAttributeList *attributes = NULL;
    <span class="enscript-type">enum</span> DNSKeyFormat format;
    Boolean malformed = FALSE;
    OSStatus status = noErr;
    <span class="enscript-type">int</span> i = 0;
    
    *attributesp = NULL;
    <span class="enscript-keyword">if</span> (noErr != (status = SecKeychainItemCopyAttributesAndData(item, &amp;attributeInfo, NULL, &amp;attributes, NULL, NULL)))
    {
        os_log_info(log_handle,<span class="enscript-string">&quot;getDNSKeyFormat: SecKeychainItemCopyAttributesAndData %d - skipping&quot;</span>, status);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
    }
    <span class="enscript-keyword">if</span> (attributeInfo.count != attributes-&gt;count)
        malformed = TRUE;
    <span class="enscript-keyword">for</span> (i = 0; !malformed &amp;&amp; i &lt; (<span class="enscript-type">int</span>)attributeInfo.count; ++i)
        <span class="enscript-keyword">if</span> (attributeInfo.tag[i] != attributes-&gt;attr[i].tag)
            malformed = TRUE;
    <span class="enscript-keyword">if</span> (malformed)
    {
        os_log(log_handle, <span class="enscript-string">&quot;getDNSKeyFormat: malformed result from SecKeychainItemCopyAttributesAndData - skipping&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
    }
    
    os_log_info(log_handle,<span class="enscript-string">&quot;getDNSKeyFormat: entry (\&quot;%.*s\&quot;, \&quot;%.*s\&quot;, \&quot;%.*s\&quot;)&quot;</span>,
                   (<span class="enscript-type">int</span>)attributes-&gt;attr[0].length, attributes-&gt;attr[0].data,
                   (<span class="enscript-type">int</span>)attributes-&gt;attr[1].length, attributes-&gt;attr[1].data,
                   (<span class="enscript-type">int</span>)attributes-&gt;attr[2].length, attributes-&gt;attr[2].data);

    <span class="enscript-keyword">if</span> (attributes-&gt;attr[1].length &gt;= MAX_ESCAPED_DOMAIN_NAME +
        <span class="enscript-keyword">sizeof</span>(dnsprefix)-1)
    {
        os_log(log_handle, <span class="enscript-string">&quot;getDNSKeyFormat: kSecServiceItemAttr too long (%u) - skipping&quot;</span>,
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)attributes-&gt;attr[1].length);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
    }
    <span class="enscript-keyword">if</span> (attributes-&gt;attr[2].length &gt;= MAX_ESCAPED_DOMAIN_NAME)
    {
        os_log(log_handle, <span class="enscript-string">&quot;getDNSKeyFormat: kSecAccountItemAttr too long (%u) - skipping&quot;</span>,
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)attributes-&gt;attr[2].length);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
    }
    <span class="enscript-keyword">if</span> (attributes-&gt;attr[1].length &gt;= <span class="enscript-keyword">sizeof</span>(dnsprefix)-1 &amp;&amp; 0 == strncasecmp(attributes-&gt;attr[1].data, dnsprefix, <span class="enscript-keyword">sizeof</span>(dnsprefix)-1))
        format = formatDnsPrefixedServiceItem;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (attributes-&gt;attr[0].length == <span class="enscript-keyword">sizeof</span>(ddns)-1 &amp;&amp; 0 == strncasecmp(attributes-&gt;attr[0].data, ddns, <span class="enscript-keyword">sizeof</span>(ddns)-1))
        format = formatDdnsTypeItem;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (attributes-&gt;attr[0].length == <span class="enscript-keyword">sizeof</span>(ddnsrev)-1 &amp;&amp; 0 == strncasecmp(attributes-&gt;attr[0].data, ddnsrev, <span class="enscript-keyword">sizeof</span>(ddnsrev)-1))
        format = formatDdnsTypeItem;
    <span class="enscript-keyword">else</span>
    {
        os_log_info(log_handle,<span class="enscript-string">&quot;getDNSKeyFormat: uninterested in this entry&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
    }
    
    *attributesp = attributes;
    os_log_info(log_handle,<span class="enscript-string">&quot;getDNSKeyFormat: accepting this entry&quot;</span>);
    <span class="enscript-keyword">return</span> format;
    
<span class="enscript-reference">skip</span>:
    SecKeychainItemFreeAttributesAndData(attributes, NULL);
    <span class="enscript-keyword">return</span> formatNotDNSKey;
}

<span class="enscript-comment">// Insert the attributes as defined by mDNSKeyChainAttributes
</span><span class="enscript-type">static</span> CFPropertyListRef <span class="enscript-function-name">copyKeychainItemInfo</span>(SecKeychainItemRef item, SecKeychainAttributeList *attributes, <span class="enscript-type">enum</span> DNSKeyFormat format)
{
    CFMutableArrayRef entry = NULL;
    CFDataRef data = NULL;
    OSStatus status = noErr;
    UInt32 keylen = 0;
    <span class="enscript-type">void</span> *keyp = 0;
    
    <span class="enscript-keyword">if</span> (NULL == (entry = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: CFArrayCreateMutable failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    
    <span class="enscript-comment">// Insert the Account attribute (kmDNSKcWhere)
</span>    <span class="enscript-keyword">switch</span> ((<span class="enscript-type">enum</span> DNSKeyFormat)format)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">formatDdnsTypeItem</span>:
            data = CFDataCreate(kCFAllocatorDefault, attributes-&gt;attr[1].data, attributes-&gt;attr[1].length);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">formatDnsPrefixedServiceItem</span>:
            data = CFDataCreate(kCFAllocatorDefault, attributes-&gt;attr[1].data, attributes-&gt;attr[1].length);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: unknown DNSKeyFormat value&quot;</span>);
            <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (NULL == data)
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: CFDataCreate for attr[1] failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    CFArrayAppendValue(entry, data);
    CFRelease(data);
    
    <span class="enscript-comment">// Insert the Where attribute (kmDNSKcAccount)
</span>    <span class="enscript-keyword">if</span> (NULL == (data = CFDataCreate(kCFAllocatorDefault, attributes-&gt;attr[2].data, attributes-&gt;attr[2].length)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: CFDataCreate for attr[2] failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    
    CFArrayAppendValue(entry, data);
    CFRelease(data);
    
    <span class="enscript-comment">// Insert the Key attribute (kmDNSKcKey)
</span>    <span class="enscript-keyword">if</span> (noErr != (status = SecKeychainItemCopyAttributesAndData(item, NULL, NULL, NULL, &amp;keylen, &amp;keyp)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: could not retrieve key for \&quot;%.*s\&quot;: %d&quot;</span>,
              (<span class="enscript-type">int</span>)attributes-&gt;attr[1].length, attributes-&gt;attr[1].data, status);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    
    data = CFDataCreate(kCFAllocatorDefault, keyp, keylen);
    SecKeychainItemFreeAttributesAndData(NULL, keyp);
    <span class="enscript-keyword">if</span> (NULL == data)
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: CFDataCreate for keyp failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    CFArrayAppendValue(entry, data);
    CFRelease(data);
    
    <span class="enscript-comment">// Insert the Name attribute (kmDNSKcName)
</span>    <span class="enscript-keyword">if</span> (NULL == (data = CFDataCreate(kCFAllocatorDefault, attributes-&gt;attr[3].data, attributes-&gt;attr[3].length)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;copyKeychainItemInfo: CFDataCreate for attr[3] failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    
    CFArrayAppendValue(entry, data);
    CFRelease(data);
    <span class="enscript-keyword">return</span> entry;
    
<span class="enscript-reference">error</span>:
    <span class="enscript-keyword">if</span> (NULL != entry)
        CFRelease(entry);
    <span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">KeychainGetSecrets</span>(__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *numsecrets,__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *secrets, __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *secretsCnt, __unused <span class="enscript-type">int</span> *err)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    CFWriteStreamRef stream = NULL;
    CFDataRef result = NULL;
    CFPropertyListRef entry = NULL;
    CFMutableArrayRef keys = NULL;
    SecKeychainRef skc = NULL;
    SecKeychainItemRef item = NULL;
    SecKeychainSearchRef search = NULL;
    SecKeychainAttributeList *attributes = NULL;
    <span class="enscript-type">enum</span> DNSKeyFormat format;
    OSStatus status = 0;
   
    os_log_info(log_handle,<span class="enscript-string">&quot;KeychainGetSecrets: entry&quot;</span>);
    *err = kHelperErr_NoErr;
    *numsecrets = 0;
    *secrets = (vm_offset_t)NULL;

    <span class="enscript-keyword">if</span> (NULL == (keys = CFArrayCreateMutable(NULL, 0, &amp;kCFTypeArrayCallBacks)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;KeychainGetSecrets: CFArrayCreateMutable failed&quot;</span>);
        *err = kHelperErr_ApiErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">if</span> (noErr != (status = SecKeychainCopyDefault(&amp;skc)))
    {
        *err = kHelperErr_ApiErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wdeprecated-declarations&quot;</span>
    <span class="enscript-keyword">if</span> (noErr != (status = SecKeychainSearchCreateFromAttributes(skc, kSecGenericPasswordItemClass, NULL, &amp;search)))
    {
        *err = kHelperErr_ApiErr;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    <span class="enscript-keyword">for</span> (status = SecKeychainSearchCopyNext(search, &amp;item); noErr == status; status = SecKeychainSearchCopyNext(search, &amp;item))
    {
        <span class="enscript-keyword">if</span> (formatNotDNSKey != (format = getDNSKeyFormat(item, &amp;attributes)) &amp;&amp;
            NULL != (entry = copyKeychainItemInfo(item, attributes, format)))
        {
            CFArrayAppendValue(keys, entry);
            CFRelease(entry);
        }
        SecKeychainItemFreeAttributesAndData(attributes, NULL);
        CFRelease(item);
    }
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>
    <span class="enscript-keyword">if</span> (errSecItemNotFound != status)
         os_log(log_handle, <span class="enscript-string">&quot;KeychainGetSecrets: SecKeychainSearchCopyNext failed: %d&quot;</span>, status);
    
    <span class="enscript-keyword">if</span> (NULL == (stream = CFWriteStreamCreateWithAllocatedBuffers(kCFAllocatorDefault, kCFAllocatorDefault)))
    {
        *err = kHelperErr_ApiErr;
        os_log(log_handle, <span class="enscript-string">&quot;KeychainGetSecrets:CFWriteStreamCreateWithAllocatedBuffers failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    CFWriteStreamOpen(stream);
    <span class="enscript-keyword">if</span> (0 == CFPropertyListWrite(keys, stream, kCFPropertyListBinaryFormat_v1_0, 0, NULL))
    {
        *err = kHelperErr_ApiErr;
        os_log(log_handle, <span class="enscript-string">&quot;KeychainGetSecrets:CFPropertyListWriteToStream failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    result = CFWriteStreamCopyProperty(stream, kCFStreamPropertyDataWritten);
    
    <span class="enscript-keyword">if</span> (KERN_SUCCESS != vm_allocate(mach_task_self(), secrets, CFDataGetLength(result), VM_FLAGS_ANYWHERE))
    {
        *err = kHelperErr_ApiErr;
        os_log(log_handle, <span class="enscript-string">&quot;KeychainGetSecrets: vm_allocate failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fin</span>;
    }
    
    CFDataGetBytes(result, CFRangeMake(0, CFDataGetLength(result)), (<span class="enscript-type">void</span> *)*secrets);
    *secretsCnt = CFDataGetLength(result);
    *numsecrets = CFArrayGetCount(keys);
    
    os_log_info(log_handle,<span class="enscript-string">&quot;KeychainGetSecrets: succeeded&quot;</span>);
    
<span class="enscript-reference">fin</span>:
    os_log_info(log_handle,<span class="enscript-string">&quot;KeychainGetSecrets: returning numsecrets[%u] secrets[%lu] secrets addr[%p] secretscount[%u]&quot;</span>,
                   *numsecrets, *secrets, secrets, *secretsCnt);
    
    <span class="enscript-keyword">if</span> (NULL != stream)
    {
        CFWriteStreamClose(stream);
        CFRelease(stream);
    }
    <span class="enscript-keyword">if</span> (NULL != result)
        CFRelease(result);
    <span class="enscript-keyword">if</span> (NULL != keys)
        CFRelease(keys);
    <span class="enscript-keyword">if</span> (NULL != search)
        CFRelease(search);
    <span class="enscript-keyword">if</span> (NULL != skc)
        CFRelease(skc);
    update_idle_timer();
    
    *err = KERN_SUCCESS;
    
#<span class="enscript-reference">else</span>
    
    *err = KERN_FAILURE;
    
#<span class="enscript-reference">endif</span>
    
}


CF_EXPORT CFDictionaryRef <span class="enscript-function-name">_CFCopySystemVersionDictionary</span>(<span class="enscript-type">void</span>);
CF_EXPORT <span class="enscript-type">const</span> CFStringRef _kCFSystemVersionBuildVersionKey;


<span class="enscript-type">void</span> <span class="enscript-function-name">SendWakeupPacket</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *eth_addr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ip_addr, <span class="enscript-type">int</span> iteration)
{
    <span class="enscript-type">int</span> bpf_fd, i, j;
    <span class="enscript-type">struct</span> ifreq ifr;
    <span class="enscript-type">char</span> ifname[IFNAMSIZ];
    <span class="enscript-type">char</span> packet[512];
    <span class="enscript-type">char</span> *ptr = packet;
    <span class="enscript-type">char</span> bpf_device[12];
    <span class="enscript-type">struct</span> ether_addr *ea;
    <span class="enscript-comment">// (void) ip_addr; // unused
</span>    <span class="enscript-comment">// (void) iteration; // unused
</span>    
    os_log_info(log_handle,<span class="enscript-string">&quot;SendWakeupPacket() ether_addr[%s] ip_addr[%s] if_id[%d] iteration[%d]&quot;</span>,
                   eth_addr, ip_addr, ifid, iteration);
    
    <span class="enscript-keyword">if</span> (if_indextoname(ifid, ifname) == NULL)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: invalid interface index %u&quot;</span>, ifid);
        <span class="enscript-keyword">return</span>;
    }
    
    ea = ether_aton(eth_addr);
    <span class="enscript-keyword">if</span> (ea == NULL)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: invalid ethernet address %s&quot;</span>, eth_addr);
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 100; i++)
    {
        snprintf(bpf_device, <span class="enscript-keyword">sizeof</span>(bpf_device), <span class="enscript-string">&quot;/dev/bpf%d&quot;</span>, i);
        bpf_fd = open(bpf_device, O_RDWR, 0);
        
        <span class="enscript-keyword">if</span> (bpf_fd == -1)
            <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">break</span>;
    }
    
    <span class="enscript-keyword">if</span> (bpf_fd == -1)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: cannot find a bpf device&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    
    memset(&amp;ifr, 0, <span class="enscript-keyword">sizeof</span>(ifr));
    strlcpy(ifr.ifr_name, ifname, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name));
    
    <span class="enscript-keyword">if</span> (ioctl(bpf_fd, BIOCSETIF, (<span class="enscript-type">char</span> *)&amp;ifr) &lt; 0)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: BIOCSETIF failed %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">// 0x00 Destination address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
        *ptr++ = ea-&gt;octet[i];
    
    <span class="enscript-comment">// 0x06 Source address (Note: Since we don't currently set the BIOCSHDRCMPLT option,
</span>    <span class="enscript-comment">// BPF will fill in the real interface address for us)
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
        *ptr++ = 0;
    
    <span class="enscript-comment">// 0x0C Ethertype (0x0842)
</span>    *ptr++ = 0x08;
    *ptr++ = 0x42;
    
    <span class="enscript-comment">// 0x0E Wakeup sync sequence
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
        *ptr++ = 0xFF;
    
    <span class="enscript-comment">// 0x14 Wakeup data
</span>    <span class="enscript-keyword">for</span> (j=0; j&lt;16; j++)
        <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
            *ptr++ = ea-&gt;octet[i];
    
    <span class="enscript-comment">// 0x74 Password
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
        *ptr++ = 0;
    
    <span class="enscript-keyword">if</span> (write(bpf_fd, packet, ptr - packet) &lt; 0)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: write failed %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
    os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: sent unicast eth_addr %s, ip_addr %s&quot;</span>, eth_addr, ip_addr);
    
    <span class="enscript-comment">// Send a broadcast one to handle ethernet switches that don't flood forward packets with
</span>    <span class="enscript-comment">// unknown mac addresses.
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++)
        packet[i] = 0xFF;
    
    <span class="enscript-keyword">if</span> (write(bpf_fd, packet, ptr - packet) &lt; 0)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: write failed %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
    os_log(log_handle, <span class="enscript-string">&quot;SendWakeupPacket: sent broadcast eth_addr %s, ip_addr %s&quot;</span>, eth_addr, ip_addr);
    
    close(bpf_fd);

}


<span class="enscript-comment">// Open the specified port for protocol in the P2P firewall.
</span><span class="enscript-type">void</span> <span class="enscript-function-name">PacketFilterControl</span>(uint32_t command, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * ifname, uint32_t count, pfArray_t portArray, pfArray_t protocolArray)
{
    <span class="enscript-type">int</span> error;
    
    os_log_info(log_handle,<span class="enscript-string">&quot;PacketFilterControl: command %d ifname %s, count %d&quot;</span>,
                   command, ifname, count);
    os_log_info(log_handle,<span class="enscript-string">&quot;PacketFilterControl: portArray0[%d] portArray1[%d] portArray2[%d] portArray3[%d] protocolArray0[%d] protocolArray1[%d] protocolArray2[%d] protocolArray3[%d]&quot;</span>, portArray[0], portArray[1], portArray[2], portArray[3], protocolArray[0], protocolArray[1], protocolArray[2], protocolArray[3]);
    
    <span class="enscript-keyword">switch</span> (command)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">PF_SET_RULES</span>:
            error = P2PPacketFilterAddBonjourRuleSet(ifname, count, portArray, protocolArray);
            <span class="enscript-keyword">if</span> (error)
                os_log(log_handle, <span class="enscript-string">&quot;P2PPacketFilterAddBonjourRuleSet failed %s&quot;</span>, strerror(error));
            <span class="enscript-keyword">break</span>;
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">PF_CLEAR_RULES</span>:
            error = P2PPacketFilterClearBonjourRules();
            <span class="enscript-keyword">if</span> (error)
                os_log(log_handle, <span class="enscript-string">&quot;P2PPacketFilterClearBonjourRules failed %s&quot;</span>, strerror(error));
            <span class="enscript-keyword">break</span>;
            
        <span class="enscript-reference">default</span>:
            os_log(log_handle, <span class="enscript-string">&quot;PacketFilterControl: invalid command %d&quot;</span>, command);
            <span class="enscript-keyword">break</span>;
    }

}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-function-name">in_cksum</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *ptr, <span class="enscript-type">int</span> nbytes)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> sum;
    u_short oddbyte;
    
    <span class="enscript-comment">/*
     * Our algorithm is simple, using a 32-bit accumulator (sum),
     * we add sequential 16-bit words to it, and at the end, fold back
     * all the carry bits from the top 16 bits into the lower 16 bits.
     */</span>
    sum = 0;
    <span class="enscript-keyword">while</span> (nbytes &gt; 1)
    {
        sum += *ptr++;
        nbytes -= 2;
    }
    
    <span class="enscript-comment">/* mop up an odd byte, if necessary */</span>
    <span class="enscript-keyword">if</span> (nbytes == 1)
    {
        <span class="enscript-comment">/* make sure top half is zero */</span>
        oddbyte = 0;
        
        <span class="enscript-comment">/* one byte only */</span>
        *((u_char *)&amp;oddbyte) = *(u_char *)ptr;
        sum += oddbyte;
    }
    <span class="enscript-comment">/* Add back carry outs from top 16 bits to low 16 bits. */</span>
    sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
    
    <span class="enscript-comment">/* add carry */</span>
    sum += (sum &gt;&gt; 16);
    
    <span class="enscript-keyword">return</span> sum;
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> <span class="enscript-function-name">InetChecksum</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *ptr, <span class="enscript-type">int</span> nbytes)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> sum;
    
    sum = in_cksum(ptr, nbytes);
    <span class="enscript-keyword">return</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)~sum;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">TCPCheckSum</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> tcphdr *t, <span class="enscript-type">int</span> tcplen, <span class="enscript-type">const</span> v6addr_t sadd6, <span class="enscript-type">const</span> v6addr_t dadd6)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> sum = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *ptr;
    
    <span class="enscript-comment">/* TCP header checksum */</span>
    sum = in_cksum((<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)t, tcplen);
    
    <span class="enscript-keyword">if</span> (af == AF_INET)
    {
        <span class="enscript-comment">/* Pseudo header */</span>
        ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)sadd6;
        sum += *ptr++;
        sum += *ptr++;
        ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)dadd6;
        sum += *ptr++;
        sum += *ptr++;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6)
    {
        <span class="enscript-comment">/* Pseudo header */</span>
        ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)sadd6;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)dadd6;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
        sum += *ptr++;
    }
    
    sum += htons(tcplen);
    sum += htons(IPPROTO_TCP);
    
    <span class="enscript-keyword">while</span> (sum &gt;&gt; 16)
        sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF);
    
    t-&gt;th_sum = ~sum;
    
}

<span class="enscript-type">void</span> <span class="enscript-function-name">SendKeepalive</span>(<span class="enscript-type">const</span> v6addr_t sadd6, <span class="enscript-type">const</span> v6addr_t dadd6, uint16_t lport, uint16_t rport, uint32_t seq, uint32_t ack, uint16_t win)
{
    
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPv6FMTSTRING</span> <span class="enscript-string">&quot;%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPv6FMTSARGS</span>  sadd6[0], sadd6[1], sadd6[2], sadd6[3], sadd6[4], sadd6[5], sadd6[6], sadd6[7], sadd6[8], sadd6[9], sadd6[10], sadd6[11], sadd6[12], sadd6[13], sadd6[14], sadd6[15]
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPv6FMTDARGS</span>  dadd6[0], dadd6[1], dadd6[2], dadd6[3], dadd6[4], dadd6[5], dadd6[6], dadd6[7], dadd6[8], dadd6[9], dadd6[10], dadd6[11], dadd6[12], dadd6[13], dadd6[14], dadd6[15]

    os_log_info(log_handle, <span class="enscript-string">&quot;SendKeepalive:  &quot;</span>IPv6FMTSTRING<span class="enscript-string">&quot; :space: &quot;</span>IPv6FMTSTRING<span class="enscript-string">&quot;&quot;</span>,
                IPv6FMTSARGS, IPv6FMTDARGS);
    
    <span class="enscript-type">struct</span> packet4
    {
        <span class="enscript-type">struct</span> ip ip;
        <span class="enscript-type">struct</span> tcphdr tcp;
    } packet4;
    <span class="enscript-type">struct</span> packet6
    {
        <span class="enscript-type">struct</span> tcphdr tcp;
    } packet6;
    <span class="enscript-type">int</span> sock, on;
    <span class="enscript-type">struct</span> tcphdr *t;
    <span class="enscript-type">int</span> af;
    <span class="enscript-type">struct</span> sockaddr_storage ss_to;
    <span class="enscript-type">struct</span> sockaddr_in *sin_to = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;ss_to;
    <span class="enscript-type">struct</span> sockaddr_in6 *sin6_to = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ss_to;
    <span class="enscript-type">void</span> *packet;
    ssize_t packetlen;
    <span class="enscript-type">char</span> ctlbuf[CMSG_SPACE(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_pktinfo))];
    <span class="enscript-type">struct</span> msghdr msghdr;
    <span class="enscript-type">struct</span> iovec iov;
    ssize_t len;
    
    os_log_info(log_handle,<span class="enscript-string">&quot;SendKeepalive invoked: lport is[%d] rport is[%d] seq is[%d] ack is[%d] win is[%d]&quot;</span>,
                   lport, rport, seq, ack, win);
    
    <span class="enscript-type">char</span> buf1[INET6_ADDRSTRLEN];
    <span class="enscript-type">char</span> buf2[INET6_ADDRSTRLEN];
    
    buf1[0] = 0;
    buf2[0] = 0;
    
    inet_ntop(AF_INET6, sadd6, buf1, <span class="enscript-keyword">sizeof</span>(buf1));
    inet_ntop(AF_INET6, dadd6, buf2, <span class="enscript-keyword">sizeof</span>(buf2));
    
    os_log_info(log_handle,<span class="enscript-string">&quot;SendKeepalive invoked: sadd6 is %s, dadd6 is %s&quot;</span>, buf1, buf2);
    
    <span class="enscript-comment">// all the incoming arguments are in network order
</span>    <span class="enscript-keyword">if</span> ((*(<span class="enscript-type">unsigned</span> *)(sadd6 +4) == 0) &amp;&amp; (*(<span class="enscript-type">unsigned</span> *)(sadd6 + 8) == 0) &amp;&amp; (*(<span class="enscript-type">unsigned</span> *)(sadd6 + 12) == 0))
    {
        af = AF_INET;
        memset(&amp;packet4, 0, <span class="enscript-keyword">sizeof</span> (packet4));
        
        <span class="enscript-comment">/* Fill in all the IP header information - should be in host order*/</span>
        packet4.ip.ip_v = 4;            <span class="enscript-comment">/* 4-bit Version */</span>
        packet4.ip.ip_hl = 5;       <span class="enscript-comment">/* 4-bit Header Length */</span>
        packet4.ip.ip_tos = 0;      <span class="enscript-comment">/* 8-bit Type of service */</span>
        packet4.ip.ip_len = 40;     <span class="enscript-comment">/* 16-bit Total length */</span>
        packet4.ip.ip_id = 9864;        <span class="enscript-comment">/* 16-bit ID field */</span>
        packet4.ip.ip_off = 0;      <span class="enscript-comment">/* 13-bit Fragment offset */</span>
        packet4.ip.ip_ttl = 63;     <span class="enscript-comment">/* 8-bit Time To Live */</span>
        packet4.ip.ip_p = IPPROTO_TCP;  <span class="enscript-comment">/* 8-bit Protocol */</span>
        packet4.ip.ip_sum = 0;      <span class="enscript-comment">/* 16-bit Header checksum (below) */</span>
        memcpy(&amp;packet4.ip.ip_src.s_addr, sadd6, 4);
        memcpy(&amp;packet4.ip.ip_dst.s_addr, dadd6, 4);
        
        <span class="enscript-comment">/* IP header checksum */</span>
        packet4.ip.ip_sum = InetChecksum((<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *)&amp;packet4.ip, 20);
        t = &amp;packet4.tcp;
        packet = &amp;packet4;
        packetlen = 40; <span class="enscript-comment">// sum of IPv4 header len(20) and TCP header len(20)
</span>    }
    <span class="enscript-keyword">else</span>
    {
        af = AF_INET6;
        memset(&amp;packet6, 0, <span class="enscript-keyword">sizeof</span> (packet6));
        t = &amp;packet6.tcp;
        packet = &amp;packet6;
        <span class="enscript-comment">// We don't send IPv6 header, hence just the TCP header len (20)
</span>        packetlen = 20;
    }
    
    <span class="enscript-comment">/* Fill in all the TCP header information */</span>
    t-&gt;th_sport = lport;        <span class="enscript-comment">/* 16-bit Source port number */</span>
    t-&gt;th_dport = rport;        <span class="enscript-comment">/* 16-bit Destination port */</span>
    t-&gt;th_seq = seq;            <span class="enscript-comment">/* 32-bit Sequence Number */</span>
    t-&gt;th_ack = ack;            <span class="enscript-comment">/* 32-bit Acknowledgement Number */</span>
    t-&gt;th_off = 5;              <span class="enscript-comment">/* Data offset */</span>
    t-&gt;th_flags = TH_ACK;
    t-&gt;th_win = win;
    t-&gt;th_sum = 0;              <span class="enscript-comment">/* 16-bit checksum (below) */</span>
    t-&gt;th_urp = 0;              <span class="enscript-comment">/* 16-bit urgent offset */</span>
    
    TCPCheckSum(af, t, 20, sadd6, dadd6);
    
    <span class="enscript-comment">/* Open up a RAW socket */</span>
    <span class="enscript-keyword">if</span> ((sock = socket(af, SOCK_RAW, IPPROTO_TCP)) &lt; 0)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendKeepalive: socket %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-keyword">if</span> (af == AF_INET)
    {
        on = 1;
        <span class="enscript-keyword">if</span> (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="enscript-keyword">sizeof</span> (on)))
        {
            close(sock);
            os_log(log_handle, <span class="enscript-string">&quot;SendKeepalive: setsockopt %s&quot;</span>, strerror(errno));
            <span class="enscript-keyword">return</span>;
        }
        
        memset(sin_to, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
        sin_to-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
        sin_to-&gt;sin_family = AF_INET;
        memcpy(&amp;sin_to-&gt;sin_addr, sadd6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
        sin_to-&gt;sin_port = rport;
        
        msghdr.msg_control = NULL;
        msghdr.msg_controllen = 0;
        
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">struct</span> cmsghdr *ctl;
        
        memset(sin6_to, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6));
        sin6_to-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
        sin6_to-&gt;sin6_family = AF_INET6;
        memcpy(&amp;sin6_to-&gt;sin6_addr, dadd6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        
        sin6_to-&gt;sin6_port = rport;
        sin6_to-&gt;sin6_flowinfo = 0;
        
        
        msghdr.msg_control = ctlbuf;
        msghdr.msg_controllen = <span class="enscript-keyword">sizeof</span>(ctlbuf);
        ctl = CMSG_FIRSTHDR(&amp;msghdr);
        ctl-&gt;cmsg_len = CMSG_LEN(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_pktinfo));
        ctl-&gt;cmsg_level = IPPROTO_IPV6;
        ctl-&gt;cmsg_type = IPV6_PKTINFO;
        <span class="enscript-type">struct</span> in6_pktinfo *pktinfo = (<span class="enscript-type">struct</span> in6_pktinfo *) CMSG_DATA(ctl);
        memcpy(&amp;pktinfo-&gt;ipi6_addr, sadd6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        pktinfo-&gt;ipi6_ifindex = 0;
    }
    
    msghdr.msg_name = (<span class="enscript-type">struct</span> sockaddr *)&amp;ss_to;
    msghdr.msg_namelen = ss_to.ss_len;
    iov.iov_base = packet;
    iov.iov_len = packetlen;
    msghdr.msg_iov = &amp;iov;
    msghdr.msg_iovlen = 1;
    msghdr.msg_flags = 0;
    
<span class="enscript-reference">again</span>:
    len = sendmsg(sock, &amp;msghdr, 0);
    <span class="enscript-keyword">if</span> (len == -1)
    {
        <span class="enscript-keyword">if</span> (errno == EINTR)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
    }
    
    <span class="enscript-keyword">if</span> (len != packetlen)
    {
        os_log(log_handle, <span class="enscript-string">&quot;SendKeepalive: sendmsg failed %s&quot;</span>, strerror(errno));
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">char</span> source[INET6_ADDRSTRLEN], dest[INET6_ADDRSTRLEN];
        
        inet_ntop(af, (<span class="enscript-type">void</span> *)sadd6, source, <span class="enscript-keyword">sizeof</span>(source));
        inet_ntop(af, (<span class="enscript-type">void</span> *)dadd6, dest, <span class="enscript-keyword">sizeof</span>(dest));
        
        os_log(log_handle, <span class="enscript-string">&quot;SendKeepalive: Success Source %s:%d, Dest %s:%d, %u, %u, %u&quot;</span>,
                source, ntohs(lport), dest, ntohs(rport), ntohl(seq), ntohl(ack), ntohs(win));
        
    }
    close(sock);

}


<span class="enscript-type">void</span> <span class="enscript-function-name">RetrieveTCPInfo</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">const</span> v6addr_t laddr, uint16_t lport, <span class="enscript-type">const</span> v6addr_t raddr, uint16_t  rport, uint32_t *seq, uint32_t *ack, uint16_t *win, int32_t *intfid, <span class="enscript-type">int</span> *err)
{
    
    <span class="enscript-type">struct</span> tcp_info   ti;
    <span class="enscript-type">struct</span> info_tuple itpl;
    <span class="enscript-type">int</span>               mib[4];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>      miblen;
    size_t            len;
    size_t            sz;
    
    memset(&amp;itpl, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> info_tuple));
    memset(&amp;ti,   0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_info));
    
    <span class="enscript-type">char</span> buf1[INET6_ADDRSTRLEN];
    <span class="enscript-type">char</span> buf2[INET6_ADDRSTRLEN];
    
    buf1[0] = 0;
    buf2[0] = 0;
    
    inet_ntop(AF_INET6, laddr, buf1, <span class="enscript-keyword">sizeof</span>(buf1));
    inet_ntop(AF_INET6, raddr, buf2, <span class="enscript-keyword">sizeof</span>(buf2));

    os_log_info(log_handle, <span class="enscript-string">&quot;RetrieveTCPInfo invoked: laddr is %s, raddr is %s&quot;</span>, buf1, buf2);
    
    os_log_info(log_handle,<span class="enscript-string">&quot;RetrieveTCPInfo invoked: lport is[%d] rport is[%d] family is [%d]&quot;</span>,
                   lport, rport, family);

    <span class="enscript-keyword">if</span> (family == AF_INET)
    {
        memcpy(&amp;itpl.itpl_local_sin.sin_addr,  laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
        memcpy(&amp;itpl.itpl_remote_sin.sin_addr, raddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
        itpl.itpl_local_sin.sin_port    = lport;
        itpl.itpl_remote_sin.sin_port   = rport;
        itpl.itpl_local_sin.sin_family  = AF_INET;
        itpl.itpl_remote_sin.sin_family = AF_INET;
    }
    <span class="enscript-keyword">else</span>
    {
        memcpy(&amp;itpl.itpl_local_sin6.sin6_addr,  laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        memcpy(&amp;itpl.itpl_remote_sin6.sin6_addr, raddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
        itpl.itpl_local_sin6.sin6_port    = lport;
        itpl.itpl_remote_sin6.sin6_port   = rport;
        itpl.itpl_local_sin6.sin6_family  = AF_INET6;
        itpl.itpl_remote_sin6.sin6_family = AF_INET6;
    }
    itpl.itpl_proto = IPPROTO_TCP;
    sz = <span class="enscript-keyword">sizeof</span>(mib)/<span class="enscript-keyword">sizeof</span>(mib[0]);
    <span class="enscript-keyword">if</span> (sysctlnametomib(<span class="enscript-string">&quot;net.inet.tcp.info&quot;</span>, mib, &amp;sz) == -1)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> sysctl_errno = errno;
        os_log(log_handle, <span class="enscript-string">&quot;RetrieveTCPInfo: sysctlnametomib failed %d, %s&quot;</span>, sysctl_errno, strerror(sysctl_errno));
        *err = sysctl_errno;
    }
    miblen = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)sz;
    len    = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_info);
    <span class="enscript-keyword">if</span> (sysctl(mib, miblen, &amp;ti, &amp;len, &amp;itpl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> info_tuple)) == -1)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> sysctl_errno = errno;
        os_log(log_handle, <span class="enscript-string">&quot;RetrieveTCPInfo: sysctl failed %d, %s&quot;</span>, sysctl_errno, strerror(sysctl_errno));
        *err = sysctl_errno;
    }
    
    *seq    = ti.tcpi_snd_nxt - 1;
    *ack    = ti.tcpi_rcv_nxt;
    *win    = ti.tcpi_rcv_space &gt;&gt; ti.tcpi_rcv_wscale;
    *intfid = ti.tcpi_last_outif;
    *err    = KERN_SUCCESS;
    
}
</pre>
<hr />
</body></html>