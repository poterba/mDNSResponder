<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>D2D.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">D2D.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="D2D.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;D2D.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>        // Defines the interface provided to the client layer above
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSMacOSX.h&quot;</span>             // Defines the specific types needed to run mDNS on this platform
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd.h&quot;</span>                 // For mDNSInterface_LocalOnly etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd_internal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uds_daemon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;BLE.h&quot;</span>

D2DStatus <span class="enscript-function-name">D2DInitialize</span>(CFRunLoopRef runLoop, D2DServiceCallback serviceCallback, <span class="enscript-type">void</span>* userData) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DRetain</span>(D2DServiceInstance instanceHandle, D2DTransportType transportType) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DStopAdvertisingPairOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, <span class="enscript-type">const</span> Byte *value, <span class="enscript-type">const</span> size_t valueSize, D2DTransportType transport) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DRelease</span>(D2DServiceInstance instanceHandle, D2DTransportType transportType) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DStartAdvertisingPairOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, <span class="enscript-type">const</span> Byte *value, <span class="enscript-type">const</span> size_t valueSize, D2DTransportType transport) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DStartBrowsingForKeyOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, D2DTransportType transport) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DStopBrowsingForKeyOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, D2DTransportType transport) __attribute__((weak_import));
<span class="enscript-type">void</span> <span class="enscript-function-name">D2DStartResolvingPairOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, <span class="enscript-type">const</span> Byte *value, <span class="enscript-type">const</span> size_t valueSize, D2DTransportType transport) __attribute__((weak_import));
<span class="enscript-type">void</span> <span class="enscript-function-name">D2DStopResolvingPairOnTransport</span>(<span class="enscript-type">const</span> Byte *key, <span class="enscript-type">const</span> size_t keySize, <span class="enscript-type">const</span> Byte *value, <span class="enscript-type">const</span> size_t valueSize, D2DTransportType transport) __attribute__((weak_import));
D2DStatus <span class="enscript-function-name">D2DTerminate</span>(<span class="enscript-type">void</span>) __attribute__((weak_import));

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">D2D</span> <span class="enscript-variable-name">Support</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">D2D_start_advertising_interface</span>(NetworkInterfaceInfo *interface)
{
    <span class="enscript-comment">// AWDL wants the address and reverse address PTR record communicated
</span>    <span class="enscript-comment">// via the D2D interface layer.
</span>    <span class="enscript-keyword">if</span> (interface-&gt;InterfaceID == AWDLInterfaceID)
    {
        <span class="enscript-comment">// only log if we have a valid record to start advertising
</span>        <span class="enscript-keyword">if</span> (interface-&gt;RR_A.resrec.RecordType || interface-&gt;RR_PTR.resrec.RecordType)
            LogInfo(<span class="enscript-string">&quot;D2D_start_advertising_interface: %s&quot;</span>, interface-&gt;ifname);

        <span class="enscript-keyword">if</span> (interface-&gt;RR_A.resrec.RecordType)
            external_start_advertising_service(&amp;interface-&gt;RR_A.resrec, 0);
        <span class="enscript-keyword">if</span> (interface-&gt;RR_PTR.resrec.RecordType)
            external_start_advertising_service(&amp;interface-&gt;RR_PTR.resrec, 0);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">D2D_stop_advertising_interface</span>(NetworkInterfaceInfo *interface)
{
    <span class="enscript-keyword">if</span> (interface-&gt;InterfaceID == AWDLInterfaceID)
    {
        <span class="enscript-comment">// only log if we have a valid record to stop advertising
</span>        <span class="enscript-keyword">if</span> (interface-&gt;RR_A.resrec.RecordType || interface-&gt;RR_PTR.resrec.RecordType)
            LogInfo(<span class="enscript-string">&quot;D2D_stop_advertising_interface: %s&quot;</span>, interface-&gt;ifname);

        <span class="enscript-keyword">if</span> (interface-&gt;RR_A.resrec.RecordType)
            external_stop_advertising_service(&amp;interface-&gt;RR_A.resrec, 0);
        <span class="enscript-keyword">if</span> (interface-&gt;RR_PTR.resrec.RecordType)
            external_stop_advertising_service(&amp;interface-&gt;RR_PTR.resrec, 0);
    }
}

<span class="enscript-comment">// If record would have been advertised to the D2D plugin layer, stop that advertisement.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">D2D_stop_advertising_record</span>(AuthRecord *ar)
{
    DNSServiceFlags flags = deriveD2DFlagsFromAuthRecType(ar-&gt;ARType);
    <span class="enscript-keyword">if</span> (callExternalHelpers(ar-&gt;resrec.InterfaceID, ar-&gt;resrec.name, flags))
    {
        external_stop_advertising_service(&amp;ar-&gt;resrec, flags);
    }
}

<span class="enscript-comment">// If record should be advertised to the D2D plugin layer, start that advertisement.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">D2D_start_advertising_record</span>(AuthRecord *ar)
{
    DNSServiceFlags flags = deriveD2DFlagsFromAuthRecType(ar-&gt;ARType);
    <span class="enscript-keyword">if</span> (callExternalHelpers(ar-&gt;resrec.InterfaceID, ar-&gt;resrec.name, flags))
    {
        external_start_advertising_service(&amp;ar-&gt;resrec, flags);
    }
}

<span class="enscript-comment">// Name compression items for fake packet version number 1
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSu8 compression_packet_v1 = 0x01;

<span class="enscript-type">static</span> DNSMessage compression_base_msg = { { {{0}}, {{0}}, 2, 0, 0, 0 }, <span class="enscript-string">&quot;\x04_tcp\x05local\x00\x00\x0C\x00\x01\x04_udp\xC0\x11\x00\x0C\x00\x01&quot;</span> };
<span class="enscript-type">static</span> mDNSu8 *<span class="enscript-type">const</span> compression_limit = (mDNSu8 *) &amp;compression_base_msg + <span class="enscript-keyword">sizeof</span>(DNSMessage);
<span class="enscript-type">static</span> mDNSu8 *<span class="enscript-type">const</span> compression_lhs = (mDNSu8 *<span class="enscript-type">const</span>) compression_base_msg.data + 27;

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeD2DARElemCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> D2DRecordListElem
{
    <span class="enscript-type">struct</span> D2DRecordListElem *next;
    D2DServiceInstance       instanceHandle;
    D2DTransportType         transportType;
    AuthRecord               ar;    <span class="enscript-comment">// must be last in the structure to accomodate extra space
</span>                                    <span class="enscript-comment">// allocated for large records.
</span>} D2DRecordListElem;

<span class="enscript-type">static</span> D2DRecordListElem *D2DRecords = NULL; <span class="enscript-comment">// List of records returned with D2DServiceFound events
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> D2DBrowseListElem
{
    <span class="enscript-type">struct</span> D2DBrowseListElem *next;
    domainname name;
    mDNSu16 type;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> refCount;
} D2DBrowseListElem;

D2DBrowseListElem* D2DBrowseList = NULL;

mDNSlocal mDNSu8 *<span class="enscript-function-name">putVal16</span>(mDNSu8 *ptr, mDNSu16 val)
{
    ptr[0] = (mDNSu8)((val &gt;&gt; 8 ) &amp; 0xFF);
    ptr[1] = (mDNSu8)((val      ) &amp; 0xFF);
    <span class="enscript-keyword">return</span> ptr + <span class="enscript-keyword">sizeof</span>(mDNSu16);
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">putVal32</span>(mDNSu8 *ptr, mDNSu32 val)
{
    ptr[0] = (mDNSu8)((val &gt;&gt; 24) &amp; 0xFF);
    ptr[1] = (mDNSu8)((val &gt;&gt; 16) &amp; 0xFF);
    ptr[2] = (mDNSu8)((val &gt;&gt;  8) &amp; 0xFF);
    ptr[3] = (mDNSu8)((val      ) &amp; 0xFF);
    <span class="enscript-keyword">return</span> ptr + <span class="enscript-keyword">sizeof</span>(mDNSu32);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DomainnameToLower</span>(<span class="enscript-type">const</span> domainname * <span class="enscript-type">const</span> in, domainname * <span class="enscript-type">const</span> out)
{
    <span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span> start = (<span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span>)in;
    mDNSu8 *ptr = (mDNSu8*)start;
    <span class="enscript-keyword">while</span>(*ptr)
    {
        mDNSu8 c = *ptr;
        out-&gt;c[ptr-start] = *ptr;
        ptr++;
        <span class="enscript-keyword">for</span> (; c; c--,ptr++) out-&gt;c[ptr-start] = mDNSIsUpperCase(*ptr) ? (*ptr - <span class="enscript-string">'A'</span> + <span class="enscript-string">'a'</span>) : *ptr;
    }
    out-&gt;c[ptr-start] = *ptr;
}

mDNSlocal mDNSu8 * <span class="enscript-function-name">DNSNameCompressionBuildLHS</span>(<span class="enscript-type">const</span> domainname* typeDomain, DNS_TypeValues qtype)
{
    mDNSu8 *ptr = putDomainNameAsLabels(&amp;compression_base_msg, compression_lhs, compression_limit, typeDomain);
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> ptr;
    *ptr = (qtype &gt;&gt; 8) &amp; 0xff;
    ptr += 1;
    *ptr = qtype &amp; 0xff;
    ptr += 1;
    *ptr = compression_packet_v1;
    <span class="enscript-keyword">return</span> ptr + 1;
}

mDNSlocal mDNSu8 * <span class="enscript-function-name">DNSNameCompressionBuildRHS</span>(mDNSu8 *start, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> resourceRecord)
{
    <span class="enscript-keyword">return</span> putRData(&amp;compression_base_msg, start, compression_limit, resourceRecord);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintHelper</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> tag, mDNSu8 *lhs, mDNSu16 lhs_len, mDNSu8 *rhs, mDNSu16 rhs_len)
{
    <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
    {
        LogDebug(<span class="enscript-string">&quot;%s: LHS: (%d bytes) %.*H&quot;</span>, tag, lhs_len, lhs_len, lhs);
        <span class="enscript-keyword">if</span> (rhs) LogDebug(<span class="enscript-string">&quot;%s: RHS: (%d bytes) %.*H&quot;</span>, tag, rhs_len, rhs_len, rhs);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeD2DARElemCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m;  <span class="enscript-comment">// unused
</span>    <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        D2DRecordListElem **ptr = &amp;D2DRecords;
        D2DRecordListElem *tmp;
        <span class="enscript-keyword">while</span> (*ptr &amp;&amp; &amp;(*ptr)-&gt;ar != rr) ptr = &amp;(*ptr)-&gt;next;
        <span class="enscript-keyword">if</span> (!*ptr) { LogMsg(<span class="enscript-string">&quot;FreeD2DARElemCallback: Could not find in D2DRecords: %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }
        LogInfo(<span class="enscript-string">&quot;FreeD2DARElemCallback: Found in D2DRecords: %s&quot;</span>, ARDisplayString(m, rr));
        tmp = *ptr;
        *ptr = (*ptr)-&gt;next;
        <span class="enscript-comment">// Just because we stoppped browsing, doesn't mean we should tear down the PAN connection.
</span>        mDNSPlatformMemFree(tmp);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_connection_release</span>(<span class="enscript-type">const</span> domainname *instance)
{
    (<span class="enscript-type">void</span>) instance;
    D2DRecordListElem *ptr = D2DRecords;

    <span class="enscript-keyword">for</span> ( ; ptr ; ptr = ptr-&gt;next)
    {
        <span class="enscript-keyword">if</span> ((ptr-&gt;ar.resrec.rrtype == kDNSServiceType_PTR) &amp;&amp;
             SameDomainName(&amp;ptr-&gt;ar.rdatastorage.u.name, instance))
        {
            LogInfo(<span class="enscript-string">&quot;external_connection_release: Calling D2DRelease(instanceHandle = %p, transportType = %d&quot;</span>, 
                ptr-&gt;instanceHandle,  ptr-&gt;transportType);
            <span class="enscript-keyword">if</span> (D2DRelease) D2DRelease(ptr-&gt;instanceHandle, ptr-&gt;transportType);
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DClearCache</span>(<span class="enscript-type">const</span> domainname *regType, DNS_TypeValues qtype)
{
    D2DRecordListElem *ptr = D2DRecords;
    <span class="enscript-keyword">for</span> ( ; ptr ; ptr = ptr-&gt;next)
    {
        <span class="enscript-keyword">if</span> ((ptr-&gt;ar.resrec.rrtype == qtype) &amp;&amp; SameDomainName(&amp;ptr-&gt;ar.namestorage, regType))
        {
            LogInfo(<span class="enscript-string">&quot;xD2DClearCache: Clearing cache record and deregistering %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, &amp;ptr-&gt;ar));
            mDNS_Deregister(&amp;mDNSStorage, &amp;ptr-&gt;ar);
        }
    }
}

mDNSlocal D2DBrowseListElem ** <span class="enscript-function-name">D2DFindInBrowseList</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 type)
{
    D2DBrowseListElem **ptr = &amp;D2DBrowseList;

    <span class="enscript-keyword">for</span> ( ; *ptr; ptr = &amp;(*ptr)-&gt;next)
        <span class="enscript-keyword">if</span> ((*ptr)-&gt;type == type &amp;&amp; SameDomainName(&amp;(*ptr)-&gt;name, name))
            <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">return</span> ptr;
}

mDNSlocal <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">D2DBrowseListRefCount</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 type)
{
    D2DBrowseListElem **ptr = D2DFindInBrowseList(name, type);
    <span class="enscript-keyword">return</span> *ptr ? (*ptr)-&gt;refCount : 0;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">D2DBrowseListRetain</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 type)
{
    D2DBrowseListElem **ptr = D2DFindInBrowseList(name, type);

    <span class="enscript-keyword">if</span> (!*ptr)
    {
        *ptr = (D2DBrowseListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(**ptr));
        (*ptr)-&gt;type = type;
        AssignDomainName(&amp;(*ptr)-&gt;name, name);
    }
    (*ptr)-&gt;refCount += 1;

    LogInfo(<span class="enscript-string">&quot;D2DBrowseListRetain: %##s %s refcount now %u&quot;</span>, (*ptr)-&gt;name.c, DNSTypeName((*ptr)-&gt;type), (*ptr)-&gt;refCount);
}

<span class="enscript-comment">// Returns true if found in list, false otherwise
</span>mDNSlocal bool <span class="enscript-function-name">D2DBrowseListRelease</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 type)
{
    D2DBrowseListElem **ptr = D2DFindInBrowseList(name, type);

    <span class="enscript-keyword">if</span> (!*ptr) { LogMsg(<span class="enscript-string">&quot;D2DBrowseListRelease: Didn't find %##s %s in list&quot;</span>, name-&gt;c, DNSTypeName(type)); <span class="enscript-keyword">return</span> false; }

    (*ptr)-&gt;refCount -= 1;

    LogInfo(<span class="enscript-string">&quot;D2DBrowseListRelease: %##s %s refcount now %u&quot;</span>, (*ptr)-&gt;name.c, DNSTypeName((*ptr)-&gt;type), (*ptr)-&gt;refCount);

    <span class="enscript-keyword">if</span> (!(*ptr)-&gt;refCount)
    {
        D2DBrowseListElem *tmp = *ptr;
        *ptr = (*ptr)-&gt;next;
        mDNSPlatformMemFree(tmp);
    }
    <span class="enscript-keyword">return</span> true;
}

mDNSlocal mStatus <span class="enscript-function-name">xD2DParse</span>(<span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span> lhs, <span class="enscript-type">const</span> mDNSu16 lhs_len, <span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span> rhs, <span class="enscript-type">const</span> mDNSu16 rhs_len, D2DRecordListElem **D2DListp)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;

	<span class="enscript-comment">// Sanity check that key array (lhs) has one domain name, followed by the record type and single byte D2D
</span>    <span class="enscript-comment">// plugin protocol version number.
</span>    <span class="enscript-comment">// Note, we don't have a DNSMessage pointer at this point, so just pass in the lhs value as the lower bound
</span>    <span class="enscript-comment">// of the input bytes we are processing.  skipDomainName() does not try to follow name compression pointers,
</span>    <span class="enscript-comment">// so it is safe to pass it the key byte array since it will stop parsing the DNS name and return a pointer
</span>    <span class="enscript-comment">// to the byte after the first name compression pointer it encounters.
</span>    <span class="enscript-type">const</span> mDNSu8 *keyp = skipDomainName((<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span>) lhs, lhs, lhs + lhs_len);

    <span class="enscript-comment">// There should be 3 bytes remaining in a valid key,
</span>    <span class="enscript-comment">// two for the DNS record type, and one for the D2D protocol version number.
</span>    <span class="enscript-keyword">if</span> (keyp == NULL || (keyp + 3 != (lhs + lhs_len)))
    {
        LogInfo(<span class="enscript-string">&quot;xD2DParse: Could not parse DNS name in key&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_Incompatible;
    }
    keyp += 2;   <span class="enscript-comment">// point to D2D compression packet format version byte
</span>    <span class="enscript-keyword">if</span> (*keyp != compression_packet_v1)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DParse: Invalid D2D packet version: %d&quot;</span>, *keyp);
        <span class="enscript-keyword">return</span> mStatus_Incompatible;
    }

    <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = (<span class="enscript-type">int</span>)(compression_lhs - (mDNSu8*)&amp;compression_base_msg);
        LogInfo(<span class="enscript-string">&quot;xD2DParse: Static Bytes: (%d bytes) %.*H&quot;</span>, len, len, &amp;compression_base_msg);
    }

    mDNSu8 *ptr = compression_lhs; <span class="enscript-comment">// pointer to the end of our fake packet
</span>
    <span class="enscript-comment">// Check to make sure we're not going to go past the end of the DNSMessage data
</span>    <span class="enscript-comment">// 7 = 2 for CLASS (-1 for our version) + 4 for TTL + 2 for RDLENGTH
</span>    <span class="enscript-keyword">if</span> (ptr + lhs_len - 7 + rhs_len &gt;= compression_limit) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;

    <span class="enscript-comment">// Copy the LHS onto our fake wire packet
</span>    mDNSPlatformMemCopy(ptr, lhs, lhs_len);
    ptr += lhs_len - 1;

    <span class="enscript-comment">// Check the 'fake packet' version number, to ensure that we know how to decompress this data
</span>    <span class="enscript-keyword">if</span> (*ptr != compression_packet_v1) <span class="enscript-keyword">return</span> mStatus_Incompatible;

    <span class="enscript-comment">// two bytes of CLASS
</span>    ptr = putVal16(ptr, kDNSClass_IN | kDNSClass_UniqueRRSet);

    <span class="enscript-comment">// four bytes of TTL
</span>    ptr = putVal32(ptr, 120);

    <span class="enscript-comment">// Copy the RHS length into the RDLENGTH of our fake wire packet
</span>    ptr = putVal16(ptr, rhs_len);

    <span class="enscript-comment">// Copy the RHS onto our fake wire packet
</span>    mDNSPlatformMemCopy(ptr, rhs, rhs_len);
    ptr += rhs_len;

    <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = (<span class="enscript-type">int</span>)(ptr - compression_lhs);
        LogInfo(<span class="enscript-string">&quot;xD2DParse: Our Bytes (%d bytes): %.*H&quot;</span>, len, len, compression_lhs);
    }

    ptr = (mDNSu8 *) GetLargeResourceRecord(m, &amp;compression_base_msg, compression_lhs, ptr, mDNSInterface_Any, kDNSRecordTypePacketAns, &amp;m-&gt;rec);
    <span class="enscript-keyword">if</span> (!ptr || m-&gt;rec.r.resrec.RecordType == kDNSRecordTypePacketNegative)
    {
        LogMsg(<span class="enscript-string">&quot;xD2DParse: failed to get large RR&quot;</span>);
        m-&gt;rec.r.resrec.RecordType = 0;
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;xD2DParse: got rr: %s&quot;</span>, CRDisplayString(m, &amp;m-&gt;rec.r));
    }

    *D2DListp = (D2DRecordListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(D2DRecordListElem) + (m-&gt;rec.r.resrec.rdlength &lt;= <span class="enscript-keyword">sizeof</span>(RDataBody) ? 0 : m-&gt;rec.r.resrec.rdlength - <span class="enscript-keyword">sizeof</span>(RDataBody)));
    <span class="enscript-keyword">if</span> (!*D2DListp) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;

    AuthRecord *rr = &amp;(*D2DListp)-&gt;ar;
    mDNS_SetupResourceRecord(rr, mDNSNULL, mDNSInterface_P2P, m-&gt;rec.r.resrec.rrtype, 7200, kDNSRecordTypeShared, AuthRecordP2P, FreeD2DARElemCallback, NULL);
    AssignDomainName(&amp;rr-&gt;namestorage, &amp;m-&gt;rec.namestorage);
    rr-&gt;resrec.rdlength = m-&gt;rec.r.resrec.rdlength;
    rr-&gt;resrec.rdata-&gt;MaxRDLength = m-&gt;rec.r.resrec.rdlength;
    mDNSPlatformMemCopy(rr-&gt;resrec.rdata-&gt;u.data, m-&gt;rec.r.resrec.rdata-&gt;u.data, m-&gt;rec.r.resrec.rdlength);
    rr-&gt;resrec.namehash = DomainNameHashValue(rr-&gt;resrec.name);
    SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);  <span class="enscript-comment">// Sets rr-&gt;rdatahash for us
</span>
    m-&gt;rec.r.resrec.RecordType = 0; <span class="enscript-comment">// Mark m-&gt;rec as no longer in use
</span>
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DAddToCache</span>(D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize)
{
    mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
	<span class="enscript-keyword">if</span> (result == kD2DSuccess)
    {
        <span class="enscript-keyword">if</span> ( key == NULL || value == NULL || keySize == 0 || valueSize == 0) { LogMsg(<span class="enscript-string">&quot;xD2DAddToCache: NULL Byte * passed in or length == 0&quot;</span>); <span class="enscript-keyword">return</span>; }

        mStatus err;
        D2DRecordListElem *ptr = NULL;

        err = xD2DParse((<span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span>)key, (<span class="enscript-type">const</span> mDNSu16)keySize, (<span class="enscript-type">const</span> mDNSu8 * <span class="enscript-type">const</span>)value, (<span class="enscript-type">const</span> mDNSu16)valueSize, &amp;ptr);
        <span class="enscript-keyword">if</span> (err)
        {
            LogMsg(<span class="enscript-string">&quot;xD2DAddToCache: xD2DParse returned error: %d&quot;</span>, err);
            PrintHelper(__func__, (mDNSu8 *)key, (mDNSu16)keySize, (mDNSu8 *)value, (mDNSu16)valueSize);
            <span class="enscript-keyword">if</span> (ptr)
                mDNSPlatformMemFree(ptr);
            <span class="enscript-keyword">return</span>;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        <span class="enscript-comment">// If the record was created based on a BLE beacon, update the interface index to indicate
</span>        <span class="enscript-comment">// this and thus match BLE specific queries.
</span>        <span class="enscript-keyword">if</span> (transportType == D2DBLETransport)
            ptr-&gt;ar.resrec.InterfaceID = mDNSInterface_BLE;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>

        err = mDNS_Register(m, &amp;ptr-&gt;ar);
        <span class="enscript-keyword">if</span> (err)
        {
            LogMsg(<span class="enscript-string">&quot;xD2DAddToCache: mDNS_Register returned error %d for %s&quot;</span>, err, ARDisplayString(m, &amp;ptr-&gt;ar));
            mDNSPlatformMemFree(ptr);
            <span class="enscript-keyword">return</span>;
        }

        LogInfo(<span class="enscript-string">&quot;xD2DAddToCache: mDNS_Register succeeded for %s&quot;</span>, ARDisplayString(m, &amp;ptr-&gt;ar));
        ptr-&gt;instanceHandle = instanceHandle;
        ptr-&gt;transportType = transportType;
        ptr-&gt;next = D2DRecords;
        D2DRecords = ptr;
    }
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;xD2DAddToCache: Unexpected result %d&quot;</span>, result);
}

mDNSlocal D2DRecordListElem * <span class="enscript-function-name">xD2DFindInList</span>(<span class="enscript-type">const</span> Byte *<span class="enscript-type">const</span> key, <span class="enscript-type">const</span> size_t keySize, <span class="enscript-type">const</span> Byte *<span class="enscript-type">const</span> value, <span class="enscript-type">const</span> size_t valueSize)
{
    D2DRecordListElem *ptr = D2DRecords;
    D2DRecordListElem *arptr = NULL;

    <span class="enscript-keyword">if</span> ( key == NULL || value == NULL || keySize == 0 || valueSize == 0) { LogMsg(<span class="enscript-string">&quot;xD2DFindInList: NULL Byte * passed in or length == 0&quot;</span>); <span class="enscript-keyword">return</span> NULL; }

    mStatus err = xD2DParse((<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span>)key, (<span class="enscript-type">const</span> mDNSu16)keySize, (<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span>)value, (<span class="enscript-type">const</span> mDNSu16)valueSize, &amp;arptr);
    <span class="enscript-keyword">if</span> (err)
    {
        LogMsg(<span class="enscript-string">&quot;xD2DFindInList: xD2DParse returned error: %d&quot;</span>, err);
        PrintHelper(__func__, (mDNSu8 *)key, (mDNSu16)keySize, (mDNSu8 *)value, (mDNSu16)valueSize);
        <span class="enscript-keyword">if</span> (arptr)
            mDNSPlatformMemFree(arptr);
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">while</span> (ptr)
    {
        <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;arptr-&gt;ar.resrec, &amp;ptr-&gt;ar.resrec)) <span class="enscript-keyword">break</span>;
        ptr = ptr-&gt;next;
    }

    <span class="enscript-keyword">if</span> (!ptr) LogMsg(<span class="enscript-string">&quot;xD2DFindInList: Could not find in D2DRecords: %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, &amp;arptr-&gt;ar));
    mDNSPlatformMemFree(arptr);
    <span class="enscript-keyword">return</span> ptr;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DRemoveFromCache</span>(D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize)
{
    (<span class="enscript-type">void</span>)transportType; <span class="enscript-comment">// We don't care about this, yet.
</span>    (<span class="enscript-type">void</span>)instanceHandle; <span class="enscript-comment">// We don't care about this, yet.
</span>
    <span class="enscript-keyword">if</span> (result == kD2DSuccess)
    {
        D2DRecordListElem *ptr = xD2DFindInList(key, keySize, value, valueSize);
        <span class="enscript-keyword">if</span> (ptr)
        {
            LogInfo(<span class="enscript-string">&quot;xD2DRemoveFromCache: Remove from cache: %s&quot;</span>, ARDisplayString(&amp;mDNSStorage, &amp;ptr-&gt;ar));
            mDNS_Deregister(&amp;mDNSStorage, &amp;ptr-&gt;ar);
        }
    }
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;xD2DRemoveFromCache: Unexpected result %d&quot;</span>, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DServiceResolved</span>(D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize)
{
    (<span class="enscript-type">void</span>)key;
    (<span class="enscript-type">void</span>)keySize;
    (<span class="enscript-type">void</span>)value;
    (<span class="enscript-type">void</span>)valueSize;

    <span class="enscript-keyword">if</span> (result == kD2DSuccess)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DServiceResolved: Starting up PAN connection for %p&quot;</span>, instanceHandle);
        <span class="enscript-keyword">if</span> (D2DRetain) D2DRetain(instanceHandle, transportType);
    }
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;xD2DServiceResolved: Unexpected result %d&quot;</span>, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DRetainHappened</span>(D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize)
{
    (<span class="enscript-type">void</span>)instanceHandle;
    (<span class="enscript-type">void</span>)transportType;
    (<span class="enscript-type">void</span>)key;
    (<span class="enscript-type">void</span>)keySize;
    (<span class="enscript-type">void</span>)value;
    (<span class="enscript-type">void</span>)valueSize;

    <span class="enscript-keyword">if</span> (result == kD2DSuccess) LogInfo(<span class="enscript-string">&quot;xD2DRetainHappened: Opening up PAN connection for %p&quot;</span>, instanceHandle);
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;xD2DRetainHappened: Unexpected result %d&quot;</span>, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DReleaseHappened</span>(D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize)
{
    (<span class="enscript-type">void</span>)instanceHandle;
    (<span class="enscript-type">void</span>)transportType;
    (<span class="enscript-type">void</span>)key;
    (<span class="enscript-type">void</span>)keySize;
    (<span class="enscript-type">void</span>)value;
    (<span class="enscript-type">void</span>)valueSize;

    <span class="enscript-keyword">if</span> (result == kD2DSuccess) LogInfo(<span class="enscript-string">&quot;xD2DReleaseHappened: Closing PAN connection for %p&quot;</span>, instanceHandle);
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;xD2DReleaseHappened: Unexpected result %d&quot;</span>, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">xD2DServiceCallback</span>(D2DServiceEvent event, D2DStatus result, D2DServiceInstance instanceHandle, D2DTransportType transportType, <span class="enscript-type">const</span> Byte *key, size_t keySize, <span class="enscript-type">const</span> Byte *value, size_t valueSize, <span class="enscript-type">void</span> *userData)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *eventString = <span class="enscript-string">&quot;unknown&quot;</span>;

    KQueueLock();

    <span class="enscript-keyword">if</span> (keySize   &gt; 0xFFFF) LogMsg(<span class="enscript-string">&quot;xD2DServiceCallback: keySize too large: %u&quot;</span>, keySize);
    <span class="enscript-keyword">if</span> (valueSize &gt; 0xFFFF) LogMsg(<span class="enscript-string">&quot;xD2DServiceCallback: valueSize too large: %u&quot;</span>, valueSize);

    <span class="enscript-keyword">switch</span> (event)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceFound</span>:
        eventString = <span class="enscript-string">&quot;D2DServiceFound&quot;</span>;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceLost</span>:
        eventString = <span class="enscript-string">&quot;D2DServiceLost&quot;</span>;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceResolved</span>:
        eventString = <span class="enscript-string">&quot;D2DServiceResolved&quot;</span>;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceRetained</span>:
        eventString = <span class="enscript-string">&quot;D2DServiceRetained&quot;</span>;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceReleased</span>:
        eventString = <span class="enscript-string">&quot;D2DServiceReleased&quot;</span>;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">break</span>;
    }

    LogInfo(<span class="enscript-string">&quot;xD2DServiceCallback: event=%s result=%d instanceHandle=%p transportType=%d LHS=%p (%u) RHS=%p (%u) userData=%p&quot;</span>, eventString, result, instanceHandle, transportType, key, keySize, value, valueSize, userData);
    PrintHelper(__func__, (mDNSu8 *)key, (mDNSu16)keySize, (mDNSu8 *)value, (mDNSu16)valueSize);

    <span class="enscript-keyword">switch</span> (event)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceFound</span>:
        xD2DAddToCache(result, instanceHandle, transportType, key, keySize, value, valueSize);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceLost</span>:
        xD2DRemoveFromCache(result, instanceHandle, transportType, key, keySize, value, valueSize);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceResolved</span>:
        xD2DServiceResolved(result, instanceHandle, transportType, key, keySize, value, valueSize);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceRetained</span>:
        xD2DRetainHappened(result, instanceHandle, transportType, key, keySize, value, valueSize);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">D2DServiceReleased</span>:
        xD2DReleaseHappened(result, instanceHandle, transportType, key, keySize, value, valueSize);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-comment">// Need to tickle the main kqueue loop to potentially handle records we removed or added.
</span>    KQueueUnlock(<span class="enscript-string">&quot;xD2DServiceCallback&quot;</span>);
}

<span class="enscript-comment">// Map interface index and flags to a specific D2D transport type or D2DTransportMax if all plugins 
</span><span class="enscript-comment">// should be called.
</span><span class="enscript-comment">// When D2DTransportMax is returned, if a specific transport should not be called, *excludedTransportType 
</span><span class="enscript-comment">// will be set to the excluded transport value, otherwise, it will be set to D2DTransportMax.
</span><span class="enscript-comment">// If the return value is not D2DTransportMax, excludedTransportType is undefined.
</span>
mDNSlocal D2DTransportType <span class="enscript-function-name">xD2DInterfaceToTransportType</span>(mDNSInterfaceID InterfaceID, DNSServiceFlags flags, D2DTransportType * excludedTransportType)
{
    NetworkInterfaceInfoOSX *info;

    <span class="enscript-comment">// Default exludes the D2DAWDLTransport when D2DTransportMax is returned.
</span>    *excludedTransportType = D2DAWDLTransport;

    <span class="enscript-comment">// Call all D2D plugins when both kDNSServiceFlagsIncludeP2P and kDNSServiceFlagsIncludeAWDL are set.
</span>    <span class="enscript-keyword">if</span> ((flags &amp; kDNSServiceFlagsIncludeP2P) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeAWDL))
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DTransportMax (including AWDL) since both kDNSServiceFlagsIncludeP2P and kDNSServiceFlagsIncludeAWDL are set&quot;</span>);
        *excludedTransportType = D2DTransportMax;
        <span class="enscript-keyword">return</span> D2DTransportMax;
    } 
    <span class="enscript-comment">// Call all D2D plugins (exlcluding AWDL) when only kDNSServiceFlagsIncludeP2P is set.
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsIncludeP2P)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DTransportMax (excluding AWDL) since only kDNSServiceFlagsIncludeP2P is set&quot;</span>);
        <span class="enscript-keyword">return</span> D2DTransportMax;
    }
    <span class="enscript-comment">// Call AWDL D2D plugin when only kDNSServiceFlagsIncludeAWDL is set.
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsIncludeAWDL)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DAWDLTransport since only kDNSServiceFlagsIncludeAWDL is set&quot;</span>);
        <span class="enscript-keyword">return</span> D2DAWDLTransport;
    }

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DTransportMax (excluding AWDL) for interface index mDNSInterface_P2P&quot;</span>);
        <span class="enscript-keyword">return</span> D2DTransportMax; 
    }

    <span class="enscript-comment">// Compare to cached AWDL interface ID.
</span>    <span class="enscript-keyword">if</span> (AWDLInterfaceID &amp;&amp; (InterfaceID == AWDLInterfaceID))
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DAWDLTransport for interface index %d&quot;</span>, InterfaceID);
        <span class="enscript-keyword">return</span> D2DAWDLTransport;
    }

    info = IfindexToInterfaceInfoOSX(InterfaceID);
    <span class="enscript-keyword">if</span> (info == NULL)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: Invalid interface index %d&quot;</span>, InterfaceID);
        <span class="enscript-keyword">return</span> D2DTransportMax;
    }

    <span class="enscript-comment">// Recognize AirDrop specific p2p* interface based on interface name.
</span>    <span class="enscript-keyword">if</span> (strncmp(info-&gt;ifinfo.ifname, <span class="enscript-string">&quot;p2p&quot;</span>, 3) == 0)
    {
        LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning D2DWifiPeerToPeerTransport for interface index %d&quot;</span>, InterfaceID);
        <span class="enscript-keyword">return</span> D2DWifiPeerToPeerTransport;
    }

    <span class="enscript-comment">// Currently there is no way to identify Bluetooth interface by name,
</span>    <span class="enscript-comment">// since they use &quot;en*&quot; based name strings.
</span>
    LogInfo(<span class="enscript-string">&quot;xD2DInterfaceToTransportType: returning default D2DTransportMax for interface index %d&quot;</span>, InterfaceID);
    <span class="enscript-keyword">return</span> D2DTransportMax;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_start_browsing_for_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> typeDomain, DNS_TypeValues qtype, DNSServiceFlags flags)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-comment">// BLE support currently not handled by a D2D plugin
</span>    <span class="enscript-keyword">if</span> (applyToBLE(InterfaceID, flags))
    {
        domainname lower;

        DomainnameToLower(typeDomain, &amp;lower);
        <span class="enscript-comment">// pass in the key and keySize
</span>        mDNSu8 *end = DNSNameCompressionBuildLHS(&amp;lower, qtype);
        start_BLE_browse(InterfaceID, &amp;lower, qtype, flags, compression_lhs, end - compression_lhs);
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        internal_start_browsing_for_service(InterfaceID, typeDomain, qtype, flags);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">internal_start_browsing_for_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> typeDomain, DNS_TypeValues qtype, DNSServiceFlags flags)
{
    domainname lower;

    DomainnameToLower(typeDomain, &amp;lower);

    <span class="enscript-keyword">if</span> (!D2DBrowseListRefCount(&amp;lower, qtype))
    {
        D2DTransportType transportType, excludedTransport;

        LogInfo(<span class="enscript-string">&quot;%s: Starting browse for: %##s %s&quot;</span>, __func__, lower.c, DNSTypeName(qtype));
        mDNSu8 *end = DNSNameCompressionBuildLHS(&amp;lower, qtype);
        PrintHelper(__func__, compression_lhs, end - compression_lhs, mDNSNULL, 0);

        transportType = xD2DInterfaceToTransportType(InterfaceID, flags, &amp; excludedTransport);
        <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
        {
            D2DTransportType i;
            <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
            {
                <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
                <span class="enscript-keyword">if</span> (D2DStartBrowsingForKeyOnTransport) D2DStartBrowsingForKeyOnTransport(compression_lhs, end - compression_lhs, i);
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (D2DStartBrowsingForKeyOnTransport) D2DStartBrowsingForKeyOnTransport(compression_lhs, end - compression_lhs, transportType);
        }
    }
    D2DBrowseListRetain(&amp;lower, qtype);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_stop_browsing_for_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> typeDomain, DNS_TypeValues qtype, DNSServiceFlags flags)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-comment">// BLE support currently not handled by a D2D plugin
</span>    <span class="enscript-keyword">if</span> (applyToBLE(InterfaceID, flags))
    {
        domainname lower;

        <span class="enscript-comment">// If this is the last instance of this browse, clear any cached records recieved for it.
</span>        <span class="enscript-comment">// We are not guaranteed to get a D2DServiceLost event for all key, value pairs cached over BLE.
</span>        DomainnameToLower(typeDomain, &amp;lower);
        <span class="enscript-keyword">if</span> (stop_BLE_browse(InterfaceID, &amp;lower, qtype, flags))
            xD2DClearCache(&amp;lower, qtype);
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        internal_stop_browsing_for_service(InterfaceID, typeDomain, qtype, flags);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">internal_stop_browsing_for_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> typeDomain, DNS_TypeValues qtype, DNSServiceFlags flags)
{
    domainname lower;

    DomainnameToLower(typeDomain, &amp;lower);

    <span class="enscript-comment">// If found in list and this is the last reference to this browse, remove the key from the D2D plugins.
</span>    <span class="enscript-keyword">if</span> (D2DBrowseListRelease(&amp;lower, qtype) &amp;&amp; !D2DBrowseListRefCount(&amp;lower, qtype))
    {
        D2DTransportType transportType, excludedTransport;

        LogInfo(<span class="enscript-string">&quot;%s: Stopping browse for: %##s %s&quot;</span>, __func__, lower.c, DNSTypeName(qtype));
        mDNSu8 *end = DNSNameCompressionBuildLHS(&amp;lower, qtype);
        PrintHelper(__func__, compression_lhs, end - compression_lhs, mDNSNULL, 0);

        transportType = xD2DInterfaceToTransportType(InterfaceID, flags, &amp; excludedTransport);
        <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
        {
            D2DTransportType i;
            <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
            {
                <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
                <span class="enscript-keyword">if</span> (D2DStopBrowsingForKeyOnTransport) D2DStopBrowsingForKeyOnTransport(compression_lhs, end - compression_lhs, i);
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (D2DStopBrowsingForKeyOnTransport) D2DStopBrowsingForKeyOnTransport(compression_lhs, end - compression_lhs, transportType);
        }

        <span class="enscript-comment">// The D2D driver may not generate the D2DServiceLost event for this key after
</span>        <span class="enscript-comment">// the D2DStopBrowsingForKey*() call above.  So, we flush the key from the D2D 
</span>        <span class="enscript-comment">// record cache now.
</span>        xD2DClearCache(&amp;lower, qtype);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_start_advertising_service</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> resourceRecord, DNSServiceFlags flags)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-keyword">if</span> (applyToBLE(resourceRecord-&gt;InterfaceID, flags))
    {
        domainname lower;

        DomainnameToLower(resourceRecord-&gt;name, &amp;lower);
        start_BLE_advertise(resourceRecord, &amp;lower, resourceRecord-&gt;rrtype, flags);
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        internal_start_advertising_service(resourceRecord, flags);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">internal_start_advertising_service</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> resourceRecord, DNSServiceFlags flags)
{
    domainname lower;
    mDNSu8 *rhs = NULL;
    mDNSu8 *end = NULL;
    D2DTransportType transportType, excludedTransport;
    DomainnameToLower(resourceRecord-&gt;name, &amp;lower);

    LogInfo(<span class="enscript-string">&quot;%s: %s&quot;</span>, __func__, RRDisplayString(&amp;mDNSStorage, resourceRecord));

    <span class="enscript-comment">// For SRV records, update packet filter if p2p interface already exists, otherwise,
</span>    <span class="enscript-comment">// if will be updated when we get the KEV_DL_IF_ATTACHED event for the interface.
</span>    <span class="enscript-keyword">if</span> (resourceRecord-&gt;rrtype == kDNSType_SRV)
        mDNSUpdatePacketFilter(NULL);

    rhs = DNSNameCompressionBuildLHS(&amp;lower, resourceRecord-&gt;rrtype);
    end = DNSNameCompressionBuildRHS(rhs, resourceRecord);
    PrintHelper(__func__, compression_lhs, rhs - compression_lhs, rhs, end - rhs);

    transportType = xD2DInterfaceToTransportType(resourceRecord-&gt;InterfaceID, flags, &amp; excludedTransport);
    <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
    {
        D2DTransportType i;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
        {
            <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (D2DStartAdvertisingPairOnTransport) D2DStartAdvertisingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, i);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (D2DStartAdvertisingPairOnTransport) D2DStartAdvertisingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, transportType);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_stop_advertising_service</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> resourceRecord, DNSServiceFlags flags)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    <span class="enscript-comment">// BLE support currently not handled by a D2D plugin
</span>    <span class="enscript-keyword">if</span> (applyToBLE(resourceRecord-&gt;InterfaceID, flags))
    {
        domainname lower;

        DomainnameToLower(resourceRecord-&gt;name, &amp;lower);
        stop_BLE_advertise(&amp;lower, resourceRecord-&gt;rrtype, flags);
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        internal_stop_advertising_service(resourceRecord, flags);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">internal_stop_advertising_service</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> resourceRecord, DNSServiceFlags flags)
{
    domainname lower;
    mDNSu8 *rhs = NULL;
    mDNSu8 *end = NULL;
    D2DTransportType transportType, excludedTransport;
    DomainnameToLower(resourceRecord-&gt;name, &amp;lower);

    LogInfo(<span class="enscript-string">&quot;%s: %s&quot;</span>, __func__, RRDisplayString(&amp;mDNSStorage, resourceRecord));

    <span class="enscript-comment">// For SRV records, update packet filter if p2p interface already exists, otherwise,
</span>    <span class="enscript-comment">// For SRV records, update packet filter to to remove this port from list
</span>    <span class="enscript-keyword">if</span> (resourceRecord-&gt;rrtype == kDNSType_SRV)
        mDNSUpdatePacketFilter(resourceRecord);

    rhs = DNSNameCompressionBuildLHS(&amp;lower, resourceRecord-&gt;rrtype);
    end = DNSNameCompressionBuildRHS(rhs, resourceRecord);
    PrintHelper(__func__, compression_lhs, rhs - compression_lhs, rhs, end - rhs);

    transportType = xD2DInterfaceToTransportType(resourceRecord-&gt;InterfaceID, flags, &amp; excludedTransport);
    <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
    {
        D2DTransportType i;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
        {
            <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (D2DStopAdvertisingPairOnTransport) D2DStopAdvertisingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, i);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (D2DStopAdvertisingPairOnTransport) D2DStopAdvertisingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, transportType);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_start_resolving_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> fqdn, DNSServiceFlags flags)
{
    domainname lower;
    mDNSu8 *rhs = NULL;
    mDNSu8 *end = NULL;
    mDNSBool AWDL_used = false;   <span class="enscript-comment">// whether AWDL was used for this resolve
</span>    D2DTransportType transportType, excludedTransport;
    DomainnameToLower(SkipLeadingLabels(fqdn, 1), &amp;lower);

    LogInfo(<span class="enscript-string">&quot;external_start_resolving_service: %##s&quot;</span>, fqdn-&gt;c);
    rhs = DNSNameCompressionBuildLHS(&amp;lower, kDNSType_PTR);
    end = putDomainNameAsLabels(&amp;compression_base_msg, rhs, compression_limit, fqdn);
    PrintHelper(__func__, compression_lhs, rhs - compression_lhs, rhs, end - rhs);

    transportType = xD2DInterfaceToTransportType(InterfaceID, flags, &amp; excludedTransport);
    <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
    {
        <span class="enscript-comment">// Resolving over all the transports, except for excludedTransport if set.
</span>        D2DTransportType i;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
        {
            <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (D2DStartResolvingPairOnTransport) D2DStartResolvingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, i);

            <span class="enscript-keyword">if</span> (i == D2DAWDLTransport)
                AWDL_used = true;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Resolving over one specific transport.
</span>        <span class="enscript-keyword">if</span> (D2DStartResolvingPairOnTransport) D2DStartResolvingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, transportType);

        <span class="enscript-keyword">if</span> (transportType == D2DAWDLTransport)
            AWDL_used = true;
    }

    <span class="enscript-comment">// AWDL wants the SRV and TXT record queries communicated over the D2D interface.
</span>    <span class="enscript-comment">// We only want these records going to AWDL, so use AWDLInterfaceID as the
</span>    <span class="enscript-comment">// interface and don't set any other flags.
</span>    <span class="enscript-keyword">if</span> (AWDL_used &amp;&amp; AWDLInterfaceID)
    {
        LogInfo(<span class="enscript-string">&quot;external_start_resolving_service: browse for TXT and SRV over AWDL&quot;</span>);
        external_start_browsing_for_service(AWDLInterfaceID, fqdn, kDNSType_TXT, 0);
        external_start_browsing_for_service(AWDLInterfaceID, fqdn, kDNSType_SRV, 0);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">external_stop_resolving_service</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> fqdn, DNSServiceFlags flags)
{
    domainname lower;
    mDNSu8 *rhs = NULL;
    mDNSu8 *end = NULL;
    mDNSBool AWDL_used = false;   <span class="enscript-comment">// whether AWDL was used for this resolve
</span>    D2DTransportType transportType, excludedTransport;
    DomainnameToLower(SkipLeadingLabels(fqdn, 1), &amp;lower);

    LogInfo(<span class="enscript-string">&quot;external_stop_resolving_service: %##s&quot;</span>, fqdn-&gt;c);
    rhs = DNSNameCompressionBuildLHS(&amp;lower, kDNSType_PTR);
    end = putDomainNameAsLabels(&amp;compression_base_msg, rhs, compression_limit, fqdn);
    PrintHelper(__func__, compression_lhs, rhs - compression_lhs, rhs, end - rhs);

    transportType = xD2DInterfaceToTransportType(InterfaceID, flags, &amp; excludedTransport);
    <span class="enscript-keyword">if</span> (transportType == D2DTransportMax)
    {
        D2DTransportType i;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; D2DTransportMax; i++)
        {
            <span class="enscript-keyword">if</span> (i == excludedTransport) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (D2DStopResolvingPairOnTransport) D2DStopResolvingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, i);

            <span class="enscript-keyword">if</span> (i == D2DAWDLTransport)
                AWDL_used = true;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (D2DStopResolvingPairOnTransport) D2DStopResolvingPairOnTransport(compression_lhs, rhs - compression_lhs, rhs, end - rhs, transportType);

        <span class="enscript-keyword">if</span> (transportType == D2DAWDLTransport)
            AWDL_used = true;
    }

    <span class="enscript-comment">// AWDL wants the SRV and TXT record queries communicated over the D2D interface.
</span>    <span class="enscript-comment">// We only want these records going to AWDL, so use AWDLInterfaceID as the
</span>    <span class="enscript-comment">// interface and don't set any other flags.
</span>    <span class="enscript-keyword">if</span> (AWDL_used &amp;&amp; AWDLInterfaceID)
    {
        LogInfo(<span class="enscript-string">&quot;external_stop_resolving_service: stop browse for TXT and SRV on AWDL&quot;</span>);
        external_stop_browsing_for_service(AWDLInterfaceID, fqdn, kDNSType_TXT, 0);
        external_stop_browsing_for_service(AWDLInterfaceID, fqdn, kDNSType_SRV, 0);
    }
}

mDNSexport mDNSBool <span class="enscript-function-name">callExternalHelpers</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain, DNSServiceFlags flags)
{
    <span class="enscript-comment">// Only call D2D layer routines if request applies to a D2D interface and the domain is &quot;local&quot;.
</span>    <span class="enscript-keyword">if</span> (    (((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; (kDNSServiceFlagsIncludeP2P | kDNSServiceFlagsIncludeAWDL | kDNSServiceFlagsAutoTrigger)))
            || mDNSPlatformInterfaceIsD2D(InterfaceID) || (InterfaceID == mDNSInterface_BLE))
        &amp;&amp; IsLocalDomain(domain))
    {
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Used to derive the original D2D specific flags specified by the client in the registration
</span><span class="enscript-comment">// when we don't have access to the original flag (kDNSServiceFlags*) values.
</span>mDNSexport mDNSu32 <span class="enscript-function-name">deriveD2DFlagsFromAuthRecType</span>(AuthRecType authRecType)
{
    mDNSu32 flags = 0;
    <span class="enscript-keyword">if</span> ((authRecType == AuthRecordAnyIncludeP2P) || (authRecType == AuthRecordAnyIncludeAWDLandP2P))
        flags |= kDNSServiceFlagsIncludeP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((authRecType == AuthRecordAnyIncludeAWDL) || (authRecType == AuthRecordAnyIncludeAWDLandP2P))
        flags |= kDNSServiceFlagsIncludeAWDL;
    <span class="enscript-keyword">return</span> flags;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">initializeD2DPlugins</span>(mDNS *<span class="enscript-type">const</span> m)
{
        <span class="enscript-comment">// We only initialize if mDNSCore successfully initialized.
</span>        <span class="enscript-keyword">if</span> (D2DInitialize)
        {
            D2DStatus ds = D2DInitialize(CFRunLoopGetMain(), xD2DServiceCallback, m);
            <span class="enscript-keyword">if</span> (ds != kD2DSuccess)
                LogMsg(<span class="enscript-string">&quot;D2DInitialiize failed: %d&quot;</span>, ds);
            <span class="enscript-keyword">else</span>
                LogMsg(<span class="enscript-string">&quot;D2DInitialize succeeded&quot;</span>);
        }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">terminateD2DPlugins</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (D2DTerminate)
    {
        D2DStatus ds = D2DTerminate();
        <span class="enscript-keyword">if</span> (ds != kD2DSuccess)
            LogMsg(<span class="enscript-string">&quot;D2DTerminate failed: %d&quot;</span>, ds);
        <span class="enscript-keyword">else</span>
            LogMsg(<span class="enscript-string">&quot;D2DTerminate succeeded&quot;</span>);
    }
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Unit</span> <span class="enscript-variable-name">test</span> <span class="enscript-variable-name">support</span> <span class="enscript-variable-name">routines</span>

<span class="enscript-comment">// These unit test support routines are called from unittests/ framework
</span><span class="enscript-comment">// and are not compiled for the mDNSResponder runtime code paths.
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">D2D_unitTest</span>(<span class="enscript-type">void</span>)
{
}

#<span class="enscript-reference">endif</span>  //  <span class="enscript-variable-name">UNIT_TEST</span>
</pre>
<hr />
</body></html>