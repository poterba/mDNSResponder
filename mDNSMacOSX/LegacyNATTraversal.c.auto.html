<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>LegacyNATTraversal.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">LegacyNATTraversal.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="LegacyNATTraversal.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;stdlib.h&quot;</span>         // For strtol()
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;string.h&quot;</span>         // For strlcpy(), For strncpy(), strncasecmp()
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;assert.h&quot;</span>         // For assert()

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name"> WIN32 </span>)
#   <span class="enscript-reference">include</span> <span class="enscript-string">&quot;CommonServices.h&quot;</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&lt;winsock2.h&gt;</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&lt;ws2tcpip.h&gt;</span>
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">strcasecmp</span>   _stricmp
#   <span class="enscript-reference">define</span> <span class="enscript-variable-name">strncasecmp</span>  _strnicmp

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">inet_pton</span>( <span class="enscript-type">int</span> family, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * addr, <span class="enscript-type">void</span> * dst )
{
    <span class="enscript-type">struct</span> sockaddr_storage ss;
    <span class="enscript-type">int</span> sslen = <span class="enscript-keyword">sizeof</span>( ss );

    ZeroMemory( &amp;ss, <span class="enscript-keyword">sizeof</span>( ss ) );
    ss.ss_family = (ADDRESS_FAMILY)family;

    <span class="enscript-keyword">if</span> ( WSAStringToAddressA( (LPSTR)addr, family, NULL, ( <span class="enscript-type">struct</span> sockaddr* ) &amp;ss, &amp;sslen ) == 0 )
    {
        <span class="enscript-keyword">if</span> ( family == AF_INET ) { memcpy( dst, &amp;( ( <span class="enscript-type">struct</span> sockaddr_in* ) &amp;ss)-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>( IN_ADDR ) ); <span class="enscript-keyword">return</span> 1; }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( family == AF_INET6 ) { memcpy( dst, &amp;( ( <span class="enscript-type">struct</span> sockaddr_in6* ) &amp;ss)-&gt;sin6_addr, <span class="enscript-keyword">sizeof</span>( IN6_ADDR ) ); <span class="enscript-keyword">return</span> 1; }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">else</span>
#   <span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>       // For inet_pton()
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uDNS.h&quot;</span>           // For natTraversalHandleAddressReply() etc.

<span class="enscript-comment">// used to format SOAP port mapping arguments
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> Property_struct
{
    <span class="enscript-type">char</span> *name;
    <span class="enscript-type">char</span> *type;
    <span class="enscript-type">char</span> *value;
} Property;

<span class="enscript-comment">// All of the text parsing in this file is intentionally transparent so that we know exactly
</span><span class="enscript-comment">// what's being done to the text, with an eye towards preventing security problems.
</span>
<span class="enscript-comment">// This is an evolving list of useful acronyms to know. Please add to it at will.
</span><span class="enscript-comment">// ST      Service Type
</span><span class="enscript-comment">// NT      Notification Type
</span><span class="enscript-comment">// USN     Unique Service Name
</span><span class="enscript-comment">// UDN     Unique Device Name
</span><span class="enscript-comment">// UUID    Universally Unique Identifier
</span><span class="enscript-comment">// URN/urn Universal Resource Name
</span>
<span class="enscript-comment">// Forward declaration because of circular reference:
</span><span class="enscript-comment">// SendPortMapRequest -&gt; SendSOAPMsgControlAction -&gt; MakeTCPConnection -&gt; tcpConnectionCallback -&gt; handleLNTPortMappingResponse
</span><span class="enscript-comment">// In the event of a port conflict, handleLNTPortMappingResponse then increments tcpInfo-&gt;retries and calls back to SendPortMapRequest to try again
</span>mDNSlocal mStatus <span class="enscript-function-name">SendPortMapRequest</span>(mDNS *m, NATTraversalInfo *n);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RequestedPortNum</span>(n) (mDNSVal16(mDNSIPPortIsZero((n)-&gt;RequestedPort) ? (n)-&gt;IntPort : (n)-&gt;RequestedPort) + (mDNSu16)(n)-&gt;tcpInfo.retries)

<span class="enscript-comment">// Note that this function assumes src is already NULL terminated
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AllocAndCopy</span>(<span class="enscript-type">char</span> **<span class="enscript-type">const</span> dst, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> src)
{
    size_t srcLen;
    <span class="enscript-keyword">if</span> (src == mDNSNULL) <span class="enscript-keyword">return</span>;
    srcLen = strlen(src) + 1;
    <span class="enscript-keyword">if</span> ((srcLen &gt; UINT32_MAX) || ((*dst = mDNSPlatformMemAllocate((mDNSu32)srcLen)) == mDNSNULL))
    {
        LogMsg(<span class="enscript-string">&quot;AllocAndCopy: can't allocate string&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    memcpy(*dst, src, srcLen);
}

<span class="enscript-comment">// This function does a simple parse of an HTTP URL that may include a hostname, port, and path
</span><span class="enscript-comment">// If found in the URL, addressAndPort and path out params will point to newly allocated space (and will leak if they were previously pointing at allocated space)
</span>mDNSlocal mStatus <span class="enscript-function-name">ParseHttpUrl</span>(<span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">char</span> **<span class="enscript-type">const</span> addressAndPort, mDNSIPPort *<span class="enscript-type">const</span> port, <span class="enscript-type">char</span> **<span class="enscript-type">const</span> path)
{
    <span class="enscript-comment">// if the data begins with &quot;http://&quot;, we assume there is a hostname and possibly a port number
</span>    <span class="enscript-keyword">if</span> (end - ptr &gt;= 7 &amp;&amp; strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;http://&quot;</span>, 7) == 0)
    {
        <span class="enscript-type">int</span> i;
        <span class="enscript-type">const</span> mDNSu8 *stop = end;
        <span class="enscript-type">const</span> mDNSu8 *addrPtr = mDNSNULL;

        ptr += 7; <span class="enscript-comment">//skip over &quot;http://&quot;
</span>        <span class="enscript-keyword">if</span> (ptr &gt;= end) { LogInfo(<span class="enscript-string">&quot;ParseHttpUrl: past end of buffer parsing host:port&quot;</span>); <span class="enscript-keyword">return</span> mStatus_BadParamErr; }

        <span class="enscript-comment">// find the end of the host:port
</span>        addrPtr = ptr;
        <span class="enscript-keyword">for</span> (i = 0; addrPtr &amp;&amp; addrPtr != end; i++, addrPtr++) <span class="enscript-keyword">if</span> (*addrPtr == <span class="enscript-string">'/'</span>) <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// allocate the buffer (len i+1 so we have space to terminate the string)
</span>        <span class="enscript-keyword">if</span> ((*addressAndPort = mDNSPlatformMemAllocate(i+1)) == mDNSNULL)
        { LogMsg(<span class="enscript-string">&quot;ParseHttpUrl: can't allocate address string&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }
        strncpy((<span class="enscript-type">char</span>*)*addressAndPort, (<span class="enscript-type">char</span>*)ptr, i);
        (*addressAndPort)[i] = <span class="enscript-string">'\0'</span>;

        <span class="enscript-comment">// find the port number in the string, by looking backwards for the ':'
</span>        stop = ptr;    <span class="enscript-comment">// can't go back farther than the original start
</span>        ptr = addrPtr; <span class="enscript-comment">// move ptr to the path part
</span>
        <span class="enscript-keyword">for</span> (addrPtr--; addrPtr&gt;stop; addrPtr--)
        {
            <span class="enscript-keyword">if</span> (*addrPtr == <span class="enscript-string">':'</span>)
            {
                addrPtr++; <span class="enscript-comment">// skip over ':'
</span>                *port = mDNSOpaque16fromIntVal((mDNSu16)strtol((<span class="enscript-type">char</span>*)addrPtr, mDNSNULL, 10)); <span class="enscript-comment">// store it properly converted
</span>                <span class="enscript-keyword">break</span>;
            }
        }
    }

    <span class="enscript-comment">// ptr should now point to the first character we haven't yet processed
</span>    <span class="enscript-comment">// everything that remains is the path
</span>    <span class="enscript-keyword">if</span> (path &amp;&amp; ptr &lt; end)
    {
        <span class="enscript-keyword">if</span> ((*path = mDNSPlatformMemAllocate((mDNSu32)(end - ptr) + 1)) == mDNSNULL)
        { LogMsg(<span class="enscript-string">&quot;ParseHttpUrl: can't mDNSPlatformMemAllocate path&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }
        strncpy((<span class="enscript-type">char</span>*)*path, (<span class="enscript-type">char</span>*)ptr, end - ptr);
        (*path)[end - ptr] = <span class="enscript-string">'\0'</span>;
    }

    <span class="enscript-keyword">return</span> mStatus_NoError;
}

<span class="enscript-type">enum</span>
{
    HTTPCode_NeedMoreData = -1, <span class="enscript-comment">// No code found in stream
</span>    HTTPCode_Other        = -2, <span class="enscript-comment">// Valid code other than those below found in stream
</span>    HTTPCode_Bad          = -3,
    HTTPCode_200          = 200,
    HTTPCode_404          = 404,
    HTTPCode_500          = 500,
};

mDNSlocal mDNSs16 <span class="enscript-function-name">ParseHTTPResponseCode</span>(<span class="enscript-type">const</span> mDNSu8 **<span class="enscript-type">const</span> data, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = *data;
    <span class="enscript-type">const</span> mDNSu8 *code;

    <span class="enscript-keyword">if</span> (end - ptr &lt; 5) <span class="enscript-keyword">return</span> HTTPCode_NeedMoreData;
    <span class="enscript-keyword">if</span> (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;HTTP/&quot;</span>, 5) != 0) <span class="enscript-keyword">return</span> HTTPCode_Bad;
    ptr += 5;
    <span class="enscript-comment">// should we care about the HTTP protocol version?
</span>
    <span class="enscript-comment">// look for first space, which must come before first LF
</span>    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
    {
        <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">'\n'</span>) <span class="enscript-keyword">return</span> HTTPCode_Bad;
        <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">' '</span>) <span class="enscript-keyword">break</span>;
        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == end) <span class="enscript-keyword">return</span> HTTPCode_NeedMoreData;
    ptr++;

    <span class="enscript-keyword">if</span> (end - ptr &lt; 3) <span class="enscript-keyword">return</span> HTTPCode_NeedMoreData;

    code = ptr;
    ptr += 3;
    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
    {
        <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">'\n'</span>) <span class="enscript-keyword">break</span>;
        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == end) <span class="enscript-keyword">return</span> HTTPCode_NeedMoreData;
    *data = ++ptr;

    <span class="enscript-keyword">if</span> (memcmp((<span class="enscript-type">char</span>*)code, <span class="enscript-string">&quot;200&quot;</span>, 3) == 0) <span class="enscript-keyword">return</span> HTTPCode_200;
    <span class="enscript-keyword">if</span> (memcmp((<span class="enscript-type">char</span>*)code, <span class="enscript-string">&quot;404&quot;</span>, 3) == 0) <span class="enscript-keyword">return</span> HTTPCode_404;
    <span class="enscript-keyword">if</span> (memcmp((<span class="enscript-type">char</span>*)code, <span class="enscript-string">&quot;500&quot;</span>, 3) == 0) <span class="enscript-keyword">return</span> HTTPCode_500;

    LogInfo(<span class="enscript-string">&quot;ParseHTTPResponseCode found unexpected result code: %c%c%c&quot;</span>, code[0], code[1], code[2]);
    <span class="enscript-keyword">return</span> HTTPCode_Other;
}

<span class="enscript-comment">// This function parses the xml body of the device description response from the router. Basically, we look to
</span><span class="enscript-comment">// make sure this is a response referencing a service we care about (WANIPConnection or WANPPPConnection),
</span><span class="enscript-comment">// look for the &quot;controlURL&quot; header immediately following, and copy the addressing and URL info we need
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handleLNTDeviceDescriptionResponse</span>(tcpLNTInfo *tcpInfo)
{
    mDNS    *m    = tcpInfo-&gt;m;
    <span class="enscript-type">const</span> mDNSu8 *ptr  = tcpInfo-&gt;Reply;
    <span class="enscript-type">const</span> mDNSu8 *end  = tcpInfo-&gt;Reply + tcpInfo-&gt;nread;
    <span class="enscript-type">const</span> mDNSu8 *stop;
    mDNSs16 http_result;

    <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(m-&gt;UPnPSOAPPort)) <span class="enscript-keyword">return</span>; <span class="enscript-comment">// already have the info we need
</span>
    http_result = ParseHTTPResponseCode(&amp;ptr, end); <span class="enscript-comment">// Note: modifies ptr
</span>    <span class="enscript-keyword">if</span> (http_result == HTTPCode_404) LNT_ClearState(m);
    <span class="enscript-keyword">if</span> (http_result != HTTPCode_200)
    {
        LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: HTTP Result code: %d&quot;</span>, http_result);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Always reset our flag to use WANIPConnection.  We'll use WANPPPConnection if we find it and don't find WANIPConnection.
</span>    m-&gt;UPnPWANPPPConnection = mDNSfalse;

    <span class="enscript-comment">// find either service we care about
</span>    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr &lt; end)
    {
        <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'W'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;WANIPConnection:1&quot;</span>, 17) == 0)) <span class="enscript-keyword">break</span>;
        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == end)
    {
        ptr = tcpInfo-&gt;Reply;
        <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr &lt; end)
        {
            <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'W'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;WANPPPConnection:1&quot;</span>, 18) == 0))
            {
                m-&gt;UPnPWANPPPConnection = mDNStrue;
                <span class="enscript-keyword">break</span>;
            }
            ptr++;
        }
    }
    <span class="enscript-keyword">if</span> (ptr == mDNSNULL || ptr == end) { LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: didn't find WANIPConnection:1 or WANPPPConnection:1 string&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// find &quot;controlURL&quot;, starting from where we left off
</span>    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr &lt; end)
    {
        <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'C'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;controlURL&quot;</span>, 10) == 0)) <span class="enscript-keyword">break</span>;            <span class="enscript-comment">// find the first 'c'; is this controlURL? if not, keep looking
</span>        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == mDNSNULL || ptr == end) { LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: didn't find controlURL string&quot;</span>); <span class="enscript-keyword">return</span>; }
    ptr += 11;                          <span class="enscript-comment">// skip over &quot;controlURL&gt;&quot;
</span>    <span class="enscript-keyword">if</span> (ptr &gt;= end) { LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: past end of buffer and no body!&quot;</span>); <span class="enscript-keyword">return</span>; } <span class="enscript-comment">// check ptr again in case we skipped over the end of the buffer
</span>
    <span class="enscript-comment">// find the end of the controlURL element
</span>    <span class="enscript-keyword">for</span> (stop = ptr; stop &lt; end; stop++) { <span class="enscript-keyword">if</span> (*stop == <span class="enscript-string">'&lt;'</span>) { end = stop; <span class="enscript-keyword">break</span>; } }

    <span class="enscript-comment">// fill in default port
</span>    m-&gt;UPnPSOAPPort = m-&gt;UPnPRouterPort;

    <span class="enscript-comment">// free string pointers and set to NULL
</span>    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPAddressString != mDNSNULL)
    {
        mDNSPlatformMemFree(m-&gt;UPnPSOAPAddressString);
        m-&gt;UPnPSOAPAddressString = mDNSNULL;
    }
    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPURL != mDNSNULL)
    {
        mDNSPlatformMemFree(m-&gt;UPnPSOAPURL);
        m-&gt;UPnPSOAPURL = mDNSNULL;
    }

    <span class="enscript-keyword">if</span> (ParseHttpUrl(ptr, end, &amp;m-&gt;UPnPSOAPAddressString, &amp;m-&gt;UPnPSOAPPort, &amp;m-&gt;UPnPSOAPURL) != mStatus_NoError) <span class="enscript-keyword">return</span>;
    <span class="enscript-comment">// the SOAPURL should look something like &quot;/uuid:0013-108c-4b3f0000f3dc&quot;
</span>
    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPAddressString == mDNSNULL)
    {
        ptr = tcpInfo-&gt;Reply;
        <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr &lt; end)
        {
            <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'U'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;URLBase&quot;</span>, 7) == 0)) <span class="enscript-keyword">break</span>;
            ptr++;
        }

        <span class="enscript-keyword">if</span> (ptr &lt; end)      <span class="enscript-comment">// found URLBase
</span>        {
            LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: found URLBase&quot;</span>);
            ptr += 8; <span class="enscript-comment">// skip over &quot;URLBase&gt;&quot;
</span>            <span class="enscript-comment">// find the end of the URLBase element
</span>            <span class="enscript-keyword">for</span> (stop = ptr; stop &lt; end; stop++) { <span class="enscript-keyword">if</span> (stop &amp;&amp; *stop == <span class="enscript-string">'&lt;'</span>) { end = stop; <span class="enscript-keyword">break</span>; } }
            <span class="enscript-keyword">if</span> (ParseHttpUrl(ptr, end, &amp;m-&gt;UPnPSOAPAddressString, &amp;m-&gt;UPnPSOAPPort, mDNSNULL) != mStatus_NoError)
            {
                LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: failed to parse URLBase&quot;</span>);
            }
        }

        <span class="enscript-comment">// if all else fails, use the router address string
</span>        <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPAddressString == mDNSNULL) AllocAndCopy(&amp;m-&gt;UPnPSOAPAddressString, m-&gt;UPnPRouterAddressString);
    }
    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPAddressString == mDNSNULL) LogMsg(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: UPnPSOAPAddressString is NULL&quot;</span>);
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: SOAP address string [%s]&quot;</span>, m-&gt;UPnPSOAPAddressString);

    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPURL == mDNSNULL) AllocAndCopy(&amp;m-&gt;UPnPSOAPURL, m-&gt;UPnPRouterURL);
    <span class="enscript-keyword">if</span> (m-&gt;UPnPSOAPURL == mDNSNULL) LogMsg(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: UPnPSOAPURL is NULL&quot;</span>);
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;handleLNTDeviceDescriptionResponse: SOAP URL [%s]&quot;</span>, m-&gt;UPnPSOAPURL);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handleLNTGetExternalAddressResponse</span>(tcpLNTInfo *tcpInfo)
{
    mDNS       *m = tcpInfo-&gt;m;
    mDNSu16 err = NATErr_None;
    mDNSv4Addr ExtAddr;
    <span class="enscript-type">const</span> mDNSu8 *ptr = tcpInfo-&gt;Reply;
    <span class="enscript-type">const</span> mDNSu8 *end = tcpInfo-&gt;Reply + tcpInfo-&gt;nread;
    mDNSu8       *addrend;
    <span class="enscript-type">static</span> <span class="enscript-type">char</span> tagname[20] = { <span class="enscript-string">'N'</span>,<span class="enscript-string">'e'</span>,<span class="enscript-string">'w'</span>,<span class="enscript-string">'E'</span>,<span class="enscript-string">'x'</span>,<span class="enscript-string">'t'</span>,<span class="enscript-string">'e'</span>,<span class="enscript-string">'r'</span>,<span class="enscript-string">'n'</span>,<span class="enscript-string">'a'</span>,<span class="enscript-string">'l'</span>,<span class="enscript-string">'I'</span>,<span class="enscript-string">'P'</span>,<span class="enscript-string">'A'</span>,<span class="enscript-string">'d'</span>,<span class="enscript-string">'d'</span>,<span class="enscript-string">'r'</span>,<span class="enscript-string">'e'</span>,<span class="enscript-string">'s'</span>,<span class="enscript-string">'s'</span> };
    <span class="enscript-comment">// Array NOT including a terminating nul
</span>
<span class="enscript-comment">//	LogInfo(&quot;handleLNTGetExternalAddressResponse: %s&quot;, ptr);
</span>
    mDNSs16 http_result = ParseHTTPResponseCode(&amp;ptr, end); <span class="enscript-comment">// Note: modifies ptr
</span>    <span class="enscript-keyword">if</span> (http_result == HTTPCode_404) LNT_ClearState(m);
    <span class="enscript-keyword">if</span> (http_result != HTTPCode_200)
    {
        LogInfo(<span class="enscript-string">&quot;handleLNTGetExternalAddressResponse: HTTP Result code: %d&quot;</span>, http_result);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">while</span> (ptr &lt; end &amp;&amp; strncasecmp((<span class="enscript-type">char</span>*)ptr, tagname, <span class="enscript-keyword">sizeof</span>(tagname))) ptr++;
    ptr += <span class="enscript-keyword">sizeof</span>(tagname);                     <span class="enscript-comment">// Skip over &quot;NewExternalIPAddress&quot;
</span>    <span class="enscript-keyword">while</span> (ptr &lt; end &amp;&amp; *ptr != <span class="enscript-string">'&gt;'</span>) ptr++;
    ptr += 1;                                   <span class="enscript-comment">// Skip over &quot;&gt;&quot;
</span>
    <span class="enscript-comment">// Find the end of the address and terminate the string so inet_pton() can convert it
</span>    <span class="enscript-comment">// (Might be better to copy this to a local string here -- this is overwriting tcpInfo-&gt;Reply in-place
</span>    addrend = (mDNSu8*)ptr;
    <span class="enscript-keyword">while</span> (addrend &lt; end &amp;&amp; (mDNSIsDigit(*addrend) || *addrend == <span class="enscript-string">'.'</span>)) addrend++;
    <span class="enscript-keyword">if</span> (addrend &gt;= end) <span class="enscript-keyword">return</span>;
    *addrend = 0;

    <span class="enscript-keyword">if</span> (inet_pton(AF_INET, (<span class="enscript-type">char</span>*)ptr, &amp;ExtAddr) &lt;= 0)
    {
        LogMsg(<span class="enscript-string">&quot;handleLNTGetExternalAddressResponse: Router returned bad address %s&quot;</span>, ptr);
        err = NATErr_NetFail;
        ExtAddr = zerov4Addr;
    }
    <span class="enscript-keyword">if</span> (!err) LogInfo(<span class="enscript-string">&quot;handleLNTGetExternalAddressResponse: External IP address is %.4a&quot;</span>, &amp;ExtAddr);

    natTraversalHandleAddressReply(m, err, ExtAddr);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handleLNTPortMappingResponse</span>(tcpLNTInfo *tcpInfo)
{
    mDNS             *m         = tcpInfo-&gt;m;
    mDNSIPPort extport   = zeroIPPort;
    <span class="enscript-type">const</span> mDNSu8     *ptr       = tcpInfo-&gt;Reply;
    <span class="enscript-type">const</span> mDNSu8     *<span class="enscript-type">const</span> end = tcpInfo-&gt;Reply + tcpInfo-&gt;nread;
    NATTraversalInfo *natInfo;
    mDNSs16 http_result;

    <span class="enscript-keyword">for</span> (natInfo = m-&gt;NATTraversals; natInfo; natInfo=natInfo-&gt;next) { <span class="enscript-keyword">if</span> (natInfo == tcpInfo-&gt;parentNATInfo) <span class="enscript-keyword">break</span>;}

    <span class="enscript-keyword">if</span> (!natInfo) { LogInfo(<span class="enscript-string">&quot;handleLNTPortMappingResponse: can't find matching tcpInfo in NATTraversals!&quot;</span>); <span class="enscript-keyword">return</span>; }

    http_result = ParseHTTPResponseCode(&amp;ptr, end); <span class="enscript-comment">// Note: modifies ptr
</span>    <span class="enscript-keyword">if</span> (http_result == HTTPCode_200)
    {
        LogInfo(<span class="enscript-string">&quot;handleLNTPortMappingResponse: got a valid response, sending reply to natTraversalHandlePortMapReply(internal %d external %d retries %d)&quot;</span>,
                mDNSVal16(natInfo-&gt;IntPort), RequestedPortNum(natInfo), tcpInfo-&gt;retries);

        <span class="enscript-comment">// Make sure to compute extport *before* we zero tcpInfo-&gt;retries
</span>        extport = mDNSOpaque16fromIntVal(RequestedPortNum(natInfo));
        tcpInfo-&gt;retries = 0;
        natTraversalHandlePortMapReply(m, natInfo, m-&gt;UPnPInterfaceID, mStatus_NoError, extport, NATMAP_DEFAULT_LEASE, NATTProtocolUPNPIGD);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (http_result == HTTPCode_500)
    {
        <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
        {
            <span class="enscript-keyword">if</span> (((*ptr &amp; 0xDF) == <span class="enscript-string">'C'</span> &amp;&amp; end - ptr &gt;= 8 &amp;&amp; strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;Conflict&quot;</span>, 8) == 0) ||
                (*ptr == <span class="enscript-string">'&gt;'</span> &amp;&amp; end - ptr &gt;= 15 &amp;&amp; strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;&gt;718&lt;/errorCode&quot;</span>, 15) == 0))
            {
                <span class="enscript-keyword">if</span> (tcpInfo-&gt;retries &lt; 100)
                {
                    tcpInfo-&gt;retries++; SendPortMapRequest(tcpInfo-&gt;m, natInfo);
                    LogInfo(<span class="enscript-string">&quot;handleLNTPortMappingResponse: Conflict retry %d&quot;</span>, tcpInfo-&gt;retries);
                }
                <span class="enscript-keyword">else</span>
                {
                    LogMsg(<span class="enscript-string">&quot;handleLNTPortMappingResponse too many conflict retries %d %d&quot;</span>, mDNSVal16(natInfo-&gt;IntPort), mDNSVal16(natInfo-&gt;RequestedPort));
                    natTraversalHandlePortMapReply(m, natInfo, m-&gt;UPnPInterfaceID, NATErr_Res, zeroIPPort, 0, NATTProtocolUPNPIGD);
                }
                <span class="enscript-keyword">return</span>;
            }
            ptr++;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (http_result == HTTPCode_Bad) LogMsg(<span class="enscript-string">&quot;handleLNTPortMappingResponse got data that was not a valid HTTP response&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (http_result == HTTPCode_Other) LogMsg(<span class="enscript-string">&quot;handleLNTPortMappingResponse got unexpected response code&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (http_result == HTTPCode_404) LNT_ClearState(m);
    <span class="enscript-keyword">if</span> (http_result != HTTPCode_200 &amp;&amp; http_result != HTTPCode_500)
        LogInfo(<span class="enscript-string">&quot;handleLNTPortMappingResponse: HTTP Result code: %d&quot;</span>, http_result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DisposeInfoFromUnmapList</span>(mDNS *m, tcpLNTInfo *tcpInfo)
{
    tcpLNTInfo **ptr = &amp;m-&gt;tcpInfoUnmapList;
    <span class="enscript-keyword">while</span> (*ptr &amp;&amp; *ptr != tcpInfo) ptr = &amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (*ptr) { *ptr = (*ptr)-&gt;next; mDNSPlatformMemFree(tcpInfo); }    <span class="enscript-comment">// If we found it, cut it from our list and free the memory
</span>}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">tcpConnectionCallback</span>(TCPSocket *sock, <span class="enscript-type">void</span> *context, mDNSBool ConnectionEstablished, mStatus err)
{
    mStatus status  = mStatus_NoError;
    tcpLNTInfo *tcpInfo = (tcpLNTInfo *)context;
    mDNSBool closed  = mDNSfalse;
    <span class="enscript-type">long</span> n       = 0;
    <span class="enscript-type">long</span> nsent   = 0;
    <span class="enscript-type">static</span> mDNSu32 LNTERRORcount = 0;

    <span class="enscript-keyword">if</span> (tcpInfo-&gt;sock != sock)
    {
        LogMsg(<span class="enscript-string">&quot;tcpConnectionCallback: WARNING- tcpInfo-&gt;sock(%p) != sock(%p) !!! Printing tcpInfo struct&quot;</span>, tcpInfo-&gt;sock, sock);
        LogMsg(<span class="enscript-string">&quot;tcpConnectionCallback: tcpInfo-&gt;Address:Port [%#a:%d] tcpInfo-&gt;op[%d] tcpInfo-&gt;retries[%d] tcpInfo-&gt;Request[%s] tcpInfo-&gt;Reply[%s]&quot;</span>, 
                &amp;tcpInfo-&gt;Address, mDNSVal16(tcpInfo-&gt;Port), tcpInfo-&gt;op, tcpInfo-&gt;retries, tcpInfo-&gt;Request, tcpInfo-&gt;Reply);  
    }
        
    <span class="enscript-comment">// The handlers below expect to be called with the lock held
</span>    mDNS_Lock(tcpInfo-&gt;m);

    <span class="enscript-keyword">if</span> (err) { LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: received error&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

    <span class="enscript-keyword">if</span> (ConnectionEstablished)      <span class="enscript-comment">// connection is established - send the message
</span>    {
        LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: connection established, sending message&quot;</span>);
        nsent = mDNSPlatformWriteTCP(sock, (<span class="enscript-type">char</span>*)tcpInfo-&gt;Request, tcpInfo-&gt;requestLen);
        <span class="enscript-keyword">if</span> (nsent != (<span class="enscript-type">long</span>)tcpInfo-&gt;requestLen) { LogMsg(<span class="enscript-string">&quot;tcpConnectionCallback: error writing&quot;</span>); status = mStatus_UnknownErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
    }
    <span class="enscript-keyword">else</span>
    {
        n = mDNSPlatformReadTCP(sock, (<span class="enscript-type">char</span>*)tcpInfo-&gt;Reply + tcpInfo-&gt;nread, tcpInfo-&gt;replyLen - tcpInfo-&gt;nread, &amp;closed);
        LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: mDNSPlatformReadTCP read %d bytes&quot;</span>, n);

        <span class="enscript-keyword">if</span>      (n &lt; 0)  { LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback - read returned %d&quot;</span>, n);                           status = mStatus_ConnFailed; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (closed) { LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: socket closed by remote end %d&quot;</span>, tcpInfo-&gt;nread); status = mStatus_ConnFailed; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

        tcpInfo-&gt;nread += n;
        LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback tcpInfo-&gt;nread %d&quot;</span>, tcpInfo-&gt;nread);
        <span class="enscript-keyword">if</span> (tcpInfo-&gt;nread &gt; LNT_MAXBUFSIZE)
        {
            LogInfo(<span class="enscript-string">&quot;result truncated...&quot;</span>);
            tcpInfo-&gt;nread = LNT_MAXBUFSIZE;
        }

        <span class="enscript-keyword">switch</span> (tcpInfo-&gt;op)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTDiscoveryOp</span>:     handleLNTDeviceDescriptionResponse (tcpInfo); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTExternalAddrOp</span>:  handleLNTGetExternalAddressResponse(tcpInfo); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTPortMapOp</span>:       handleLNTPortMappingResponse       (tcpInfo); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTPortMapDeleteOp</span>: status = mStatus_ConfigChanged;               <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>: LogMsg(<span class="enscript-string">&quot;tcpConnectionCallback: bad tcp operation! %d&quot;</span>, tcpInfo-&gt;op); status = mStatus_Invalid; <span class="enscript-keyword">break</span>;
        }
    }
<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (err || status)
    {
        mDNS *<span class="enscript-type">const</span> m = tcpInfo-&gt;m;
        <span class="enscript-type">static</span> mDNSs32 lastErrorTime = 0;

        <span class="enscript-keyword">if</span> ((LNTERRORcount &gt; 0) &amp;&amp; (((mDNSu32)(m-&gt;timenow - lastErrorTime)) &gt;= ((mDNSu32)mDNSPlatformOneSecond)))
        {
            LNTERRORcount = 0;
        }
        lastErrorTime = m-&gt;timenow;
        <span class="enscript-keyword">if</span> ((++LNTERRORcount % 1000) == 0)
        {   
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                <span class="enscript-string">&quot;ERROR: tcpconnectioncallback -&gt; got error status %u times&quot;</span>, LNTERRORcount);
            assert(LNTERRORcount &lt; 1000);
            <span class="enscript-comment">// Recovery Mechanism to bail mDNSResponder out of trouble: It has been seen that we can get into 
</span>            <span class="enscript-comment">// this loop: [tcpKQSocketCallback()--&gt; doTcpSocketCallback()--&gt;tcpconnectionCallback()--&gt;mDNSASLLog()],
</span>            <span class="enscript-comment">// if mDNSPlatformTCPCloseConnection() does not close the TCPSocket. Instead of calling mDNSASLLog()
</span>            <span class="enscript-comment">// repeatedly and logging the same error msg causing 100% CPU usage, we 
</span>            <span class="enscript-comment">// crash mDNSResponder using assert() and restart fresh. See advantages below:
</span>            <span class="enscript-comment">// 1.Better User Experience 
</span>            <span class="enscript-comment">// 2.CrashLogs frequency can be monitored 
</span>            <span class="enscript-comment">// 3.StackTrace can be used for more info 
</span>        }   

        <span class="enscript-keyword">switch</span> (tcpInfo-&gt;op)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTDiscoveryOp</span>:
            LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: DeviceDescription SOAP address %s SOAP path %s&quot;</span>,
                m-&gt;UPnPSOAPAddressString ? m-&gt;UPnPSOAPAddressString : <span class="enscript-string">&quot;NULL&quot;</span>, m-&gt;UPnPSOAPURL ? m-&gt;UPnPSOAPURL : <span class="enscript-string">&quot;NULL&quot;</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTExternalAddrOp</span>:
            LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: AddressRequest %s&quot;</span>, mDNSIPv4AddressIsZero(m-&gt;ExtAddress) ? <span class="enscript-string">&quot;failure&quot;</span> : <span class="enscript-string">&quot;success&quot;</span>);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTPortMapOp</span>:
            <span class="enscript-keyword">if</span> (tcpInfo-&gt;parentNATInfo)
                LogInfo(<span class="enscript-string">&quot;tcpConnectionCallback: PortMapRequest %s result %d&quot;</span>,
                    (tcpInfo-&gt;parentNATInfo-&gt;Result) ? <span class="enscript-string">&quot;failure&quot;</span> : <span class="enscript-string">&quot;success&quot;</span>, tcpInfo-&gt;parentNATInfo-&gt;Result);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LNTPortMapDeleteOp</span>: <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:                 <span class="enscript-keyword">break</span>;
        }

        mDNSPlatformTCPCloseConnection(sock);
        tcpInfo-&gt;sock = mDNSNULL;
        <span class="enscript-keyword">if</span> (tcpInfo-&gt;Request) { mDNSPlatformMemFree(tcpInfo-&gt;Request); tcpInfo-&gt;Request = mDNSNULL; }
        <span class="enscript-keyword">if</span> (tcpInfo-&gt;Reply  ) { mDNSPlatformMemFree(tcpInfo-&gt;Reply);   tcpInfo-&gt;Reply   = mDNSNULL; }
    }
    <span class="enscript-keyword">else</span>
    {
        LNTERRORcount = 0;  <span class="enscript-comment">// clear LNTERRORcount
</span>    }

    <span class="enscript-keyword">if</span> (tcpInfo) mDNS_Unlock(tcpInfo-&gt;m);

    <span class="enscript-keyword">if</span> (status == mStatus_ConfigChanged) DisposeInfoFromUnmapList(tcpInfo-&gt;m, tcpInfo);
}

mDNSlocal mStatus <span class="enscript-function-name">MakeTCPConnection</span>(mDNS *<span class="enscript-type">const</span> m, tcpLNTInfo *info, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> Addr, <span class="enscript-type">const</span> mDNSIPPort Port, LNTOp_t op)
{
    mStatus err = mStatus_NoError;
    mDNSIPPort srcport = zeroIPPort;

    <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(Addr-&gt;ip.v4) || mDNSIPPortIsZero(Port))
    { LogMsg(<span class="enscript-string">&quot;LNT MakeTCPConnection: bad address/port %#a:%d&quot;</span>, Addr, mDNSVal16(Port)); <span class="enscript-keyword">return</span>(mStatus_Invalid); }
    info-&gt;m         = m;
    info-&gt;Address   = *Addr;
    info-&gt;Port      = Port;
    info-&gt;op        = op;
    info-&gt;nread     = 0;
    info-&gt;replyLen  = LNT_MAXBUFSIZE;
    <span class="enscript-keyword">if</span>      (info-&gt;Reply != mDNSNULL) mDNSPlatformMemZero(info-&gt;Reply, LNT_MAXBUFSIZE);   <span class="enscript-comment">// reuse previously allocated buffer
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((info-&gt;Reply = mDNSPlatformMemAllocate(LNT_MAXBUFSIZE)) == mDNSNULL) { LogInfo(<span class="enscript-string">&quot;can't allocate reply buffer&quot;</span>); <span class="enscript-keyword">return</span> (mStatus_NoMemoryErr); }

    <span class="enscript-keyword">if</span> (info-&gt;sock) { LogInfo(<span class="enscript-string">&quot;MakeTCPConnection: closing previous open connection&quot;</span>); mDNSPlatformTCPCloseConnection(info-&gt;sock); info-&gt;sock = mDNSNULL; }
    info-&gt;sock = mDNSPlatformTCPSocket(kTCPSocketFlags_Zero, Addr-&gt;type, &amp;srcport, mDNSNULL, mDNSfalse);
    <span class="enscript-keyword">if</span> (!info-&gt;sock) { LogMsg(<span class="enscript-string">&quot;LNT MakeTCPConnection: unable to create TCP socket&quot;</span>); mDNSPlatformMemFree(info-&gt;Reply); info-&gt;Reply = mDNSNULL; <span class="enscript-keyword">return</span>(mStatus_NoMemoryErr); }
    LogInfo(<span class="enscript-string">&quot;MakeTCPConnection: connecting to %#a:%d&quot;</span>, &amp;info-&gt;Address, mDNSVal16(info-&gt;Port));
    err = mDNSPlatformTCPConnect(info-&gt;sock, Addr, Port, 0, tcpConnectionCallback, info);

    <span class="enscript-keyword">if</span>      (err == mStatus_ConnPending) err = mStatus_NoError;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err == mStatus_ConnEstablished)
    {
        mDNS_DropLockBeforeCallback();
        tcpConnectionCallback(info-&gt;sock, info, mDNStrue, mStatus_NoError);
        mDNS_ReclaimLockAfterCallback();
        err = mStatus_NoError;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Don't need to log this in customer builds -- it happens quite often during sleep, wake, configuration changes, etc.
</span>        LogInfo(<span class="enscript-string">&quot;LNT MakeTCPConnection: connection failed&quot;</span>);
        mDNSPlatformTCPCloseConnection(info-&gt;sock); <span class="enscript-comment">// Dispose the socket we created with mDNSPlatformTCPSocket() above
</span>        info-&gt;sock = mDNSNULL;
        mDNSPlatformMemFree(info-&gt;Reply);
        info-&gt;Reply = mDNSNULL;
    }
    <span class="enscript-keyword">return</span>(err);
}

mDNSlocal <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">AddSOAPArguments</span>(<span class="enscript-type">char</span> *<span class="enscript-type">const</span> buf, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> maxlen, <span class="enscript-type">const</span> <span class="enscript-type">int</span> numArgs, <span class="enscript-type">const</span> Property *<span class="enscript-type">const</span> a)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> f1[] = <span class="enscript-string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> f2[] = <span class="enscript-string">&quot;&lt;%s xmlns:dt=\&quot;urn:schemas-microsoft-com:datatypes\&quot; dt:dt=\&quot;%s\&quot;&gt;%s&lt;/%s&gt;&quot;</span>;
    <span class="enscript-type">int</span> i, len = 0;
    *buf = 0;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; numArgs; i++)
    {
        <span class="enscript-keyword">if</span> (a[i].type) len += mDNS_snprintf(buf + len, maxlen - len, f2, a[i].name, a[i].type, a[i].value, a[i].name);
        <span class="enscript-keyword">else</span> len += mDNS_snprintf(buf + len, maxlen - len, f1, a[i].name,            a[i].value, a[i].name);
    }
    <span class="enscript-keyword">return</span>(len);
}

mDNSlocal mStatus <span class="enscript-function-name">SendSOAPMsgControlAction</span>(mDNS *m, tcpLNTInfo *info, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> Action, <span class="enscript-type">const</span> <span class="enscript-type">int</span> numArgs, <span class="enscript-type">const</span> Property *<span class="enscript-type">const</span> Arguments, <span class="enscript-type">const</span> LNTOp_t op)
{
    <span class="enscript-comment">// SOAP message header format -
</span>    <span class="enscript-comment">//  - control URL
</span>    <span class="enscript-comment">//  - action (string)
</span>    <span class="enscript-comment">//  - router's host/port (&quot;host:port&quot;)
</span>    <span class="enscript-comment">//  - content-length
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> header[] =
        <span class="enscript-string">&quot;POST %s HTTP/1.1\r\n&quot;</span>
        <span class="enscript-string">&quot;Content-Type: text/xml; charset=\&quot;utf-8\&quot;\r\n&quot;</span>
        <span class="enscript-string">&quot;SOAPAction: \&quot;urn:schemas-upnp-org:service:WAN%sConnection:1#%s\&quot;\r\n&quot;</span>
        <span class="enscript-string">&quot;User-Agent: Mozilla/4.0 (compatible; UPnP/1.0; Windows 9x)\r\n&quot;</span>
        <span class="enscript-string">&quot;Host: %s\r\n&quot;</span>
        <span class="enscript-string">&quot;Content-Length: %d\r\n&quot;</span>
        <span class="enscript-string">&quot;Connection: close\r\n&quot;</span>
        <span class="enscript-string">&quot;Pragma: no-cache\r\n&quot;</span>
        <span class="enscript-string">&quot;\r\n&quot;</span>
        <span class="enscript-string">&quot;%s\r\n&quot;</span>;

    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> body1[] =
        <span class="enscript-string">&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\r\n&quot;</span>
        <span class="enscript-string">&quot;&lt;SOAP-ENV:Envelope&quot;</span>
        <span class="enscript-string">&quot; xmlns:SOAP-ENV=\&quot;<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>\&quot;&quot;</span>
        <span class="enscript-string">&quot; SOAP-ENV:encodingStyle=\&quot;<a href="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</a>\&quot;&gt;&quot;</span>
        <span class="enscript-string">&quot;&lt;SOAP-ENV:Body&gt;&quot;</span>
        <span class="enscript-string">&quot;&lt;m:%s xmlns:m=\&quot;urn:schemas-upnp-org:service:WAN%sConnection:1\&quot;&gt;&quot;</span>;

    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> body2[] =
        <span class="enscript-string">&quot;&lt;/m:%s&gt;&quot;</span>
        <span class="enscript-string">&quot;&lt;/SOAP-ENV:Body&gt;&quot;</span>
        <span class="enscript-string">&quot;&lt;/SOAP-ENV:Envelope&gt;\r\n&quot;</span>;

    mStatus err;
    <span class="enscript-type">char</span>   *body = (<span class="enscript-type">char</span>*)&amp;m-&gt;omsg;         <span class="enscript-comment">// Typically requires 1110-1122 bytes; m-&gt;omsg is 8952 bytes, which is plenty
</span>    <span class="enscript-type">int</span> bodyLen;

    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;UPnPSOAPPort) || m-&gt;UPnPSOAPURL == mDNSNULL || m-&gt;UPnPSOAPAddressString == mDNSNULL)    <span class="enscript-comment">// if no SOAP URL or address exists get out here
</span>    { LogInfo(<span class="enscript-string">&quot;SendSOAPMsgControlAction: no SOAP port, URL or address string&quot;</span>); <span class="enscript-keyword">return</span> mStatus_Invalid; }

    <span class="enscript-comment">// Create body
</span>    bodyLen  = mDNS_snprintf   (body,           <span class="enscript-keyword">sizeof</span>(m-&gt;omsg),           body1,   Action,   m-&gt;UPnPWANPPPConnection ? <span class="enscript-string">&quot;PPP&quot;</span> : <span class="enscript-string">&quot;IP&quot;</span>);
    bodyLen += AddSOAPArguments(body + bodyLen, <span class="enscript-keyword">sizeof</span>(m-&gt;omsg) - bodyLen, numArgs, Arguments);
    bodyLen += mDNS_snprintf   (body + bodyLen, <span class="enscript-keyword">sizeof</span>(m-&gt;omsg) - bodyLen, body2,   Action);

    <span class="enscript-comment">// Create info-&gt;Request; the header needs to contain the bodyLen in the &quot;Content-Length&quot; field
</span>    <span class="enscript-keyword">if</span> (!info-&gt;Request) info-&gt;Request = mDNSPlatformMemAllocate(LNT_MAXBUFSIZE);
    <span class="enscript-keyword">if</span> (!info-&gt;Request) { LogMsg(<span class="enscript-string">&quot;SendSOAPMsgControlAction: Can't allocate info-&gt;Request&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }
    info-&gt;requestLen = mDNS_snprintf((<span class="enscript-type">char</span>*)info-&gt;Request, LNT_MAXBUFSIZE, header, m-&gt;UPnPSOAPURL, m-&gt;UPnPWANPPPConnection ? <span class="enscript-string">&quot;PPP&quot;</span> : <span class="enscript-string">&quot;IP&quot;</span>, Action, m-&gt;UPnPSOAPAddressString, bodyLen, body);

    err = MakeTCPConnection(m, info, &amp;m-&gt;Router, m-&gt;UPnPSOAPPort, op);
    <span class="enscript-keyword">if</span> (err) { mDNSPlatformMemFree(info-&gt;Request); info-&gt;Request = mDNSNULL; }
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">// Build port mapping request with new port (up to max) and send it
</span>mDNSlocal mStatus <span class="enscript-function-name">SendPortMapRequest</span>(mDNS *m, NATTraversalInfo *n)
{
    <span class="enscript-type">char</span> externalPort[6];
    <span class="enscript-type">char</span> internalPort[6];
    <span class="enscript-type">char</span> localIPAddrString[30];
    <span class="enscript-type">char</span> publicPortString[40];
    Property propArgs[8];
    mDNSu16 ReqPortNum = RequestedPortNum(n);
    NATTraversalInfo *n2 = m-&gt;NATTraversals;

    <span class="enscript-comment">// Scan our m-&gt;NATTraversals list to make sure the external port we're requesting is locally unique.
</span>    <span class="enscript-comment">// UPnP gateways will report conflicts if different devices request the same external port, but if two
</span>    <span class="enscript-comment">// clients on the same device request the same external port the second one just stomps over the first.
</span>    <span class="enscript-comment">// One way this can happen is like this:
</span>    <span class="enscript-comment">// 1. Client A binds local port 80
</span>    <span class="enscript-comment">// 2. Client A requests external port 80 -&gt; internal port 80
</span>    <span class="enscript-comment">// 3. UPnP NAT gateway refuses external port 80 (some other client already has it)
</span>    <span class="enscript-comment">// 4. Client A tries again, and successfully gets external port 80 -&gt; internal port 81
</span>    <span class="enscript-comment">// 5. Client B on same machine tries to bind local port 80, and fails
</span>    <span class="enscript-comment">// 6. Client B tries again, and successfully binds local port 81
</span>    <span class="enscript-comment">// 7. Client B now requests external port 81 -&gt; internal port 81
</span>    <span class="enscript-comment">// 8. UPnP NAT gateway allows this, stomping over Client A's existing mapping
</span>
    <span class="enscript-keyword">while</span> (n2)
    {
        <span class="enscript-keyword">if</span> (n2 == n || RequestedPortNum(n2) != ReqPortNum) n2=n2-&gt;next;
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.retries &lt; 100)
            {
                n-&gt;tcpInfo.retries++;
                ReqPortNum = RequestedPortNum(n);   <span class="enscript-comment">// Pick a new port number
</span>                n2 = m-&gt;NATTraversals;              <span class="enscript-comment">// And re-scan the list looking for conflicts
</span>            }
            <span class="enscript-keyword">else</span>
            {
                natTraversalHandlePortMapReply(m, n, m-&gt;UPnPInterfaceID, NATErr_Res, zeroIPPort, 0, NATTProtocolUPNPIGD);
                <span class="enscript-keyword">return</span> mStatus_NoError;
            }
        }
    }

    <span class="enscript-comment">// create strings to use in the message
</span>    mDNS_snprintf(externalPort,      <span class="enscript-keyword">sizeof</span>(externalPort),      <span class="enscript-string">&quot;%u&quot;</span>,   ReqPortNum);
    mDNS_snprintf(internalPort,      <span class="enscript-keyword">sizeof</span>(internalPort),      <span class="enscript-string">&quot;%u&quot;</span>,   mDNSVal16(n-&gt;IntPort));
    mDNS_snprintf(publicPortString,  <span class="enscript-keyword">sizeof</span>(publicPortString),  <span class="enscript-string">&quot;iC%u&quot;</span>, ReqPortNum);
    mDNS_snprintf(localIPAddrString, <span class="enscript-keyword">sizeof</span>(localIPAddrString), <span class="enscript-string">&quot;%u.%u.%u.%u&quot;</span>,
                  m-&gt;AdvertisedV4.ip.v4.b[0], m-&gt;AdvertisedV4.ip.v4.b[1], m-&gt;AdvertisedV4.ip.v4.b[2], m-&gt;AdvertisedV4.ip.v4.b[3]);

    <span class="enscript-comment">// build the message
</span>    mDNSPlatformMemZero(propArgs, <span class="enscript-keyword">sizeof</span>(propArgs));
    propArgs[0].name  = <span class="enscript-string">&quot;NewRemoteHost&quot;</span>;
    propArgs[0].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[0].value = <span class="enscript-string">&quot;&quot;</span>;
    propArgs[1].name  = <span class="enscript-string">&quot;NewExternalPort&quot;</span>;
    propArgs[1].type  = <span class="enscript-string">&quot;ui2&quot;</span>;
    propArgs[1].value = externalPort;
    propArgs[2].name  = <span class="enscript-string">&quot;NewProtocol&quot;</span>;
    propArgs[2].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[2].value = (n-&gt;Protocol == NATOp_MapUDP) ? <span class="enscript-string">&quot;UDP&quot;</span> : <span class="enscript-string">&quot;TCP&quot;</span>;
    propArgs[3].name  = <span class="enscript-string">&quot;NewInternalPort&quot;</span>;
    propArgs[3].type  = <span class="enscript-string">&quot;ui2&quot;</span>;
    propArgs[3].value = internalPort;
    propArgs[4].name  = <span class="enscript-string">&quot;NewInternalClient&quot;</span>;
    propArgs[4].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[4].value = localIPAddrString;
    propArgs[5].name  = <span class="enscript-string">&quot;NewEnabled&quot;</span>;
    propArgs[5].type  = <span class="enscript-string">&quot;boolean&quot;</span>;
    propArgs[5].value = <span class="enscript-string">&quot;1&quot;</span>;
    propArgs[6].name  = <span class="enscript-string">&quot;NewPortMappingDescription&quot;</span>;
    propArgs[6].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[6].value = publicPortString;
    propArgs[7].name  = <span class="enscript-string">&quot;NewLeaseDuration&quot;</span>;
    propArgs[7].type  = <span class="enscript-string">&quot;ui4&quot;</span>;
    propArgs[7].value = <span class="enscript-string">&quot;0&quot;</span>;

    LogInfo(<span class="enscript-string">&quot;SendPortMapRequest: internal %u external %u&quot;</span>, mDNSVal16(n-&gt;IntPort), ReqPortNum);
    <span class="enscript-keyword">return</span> SendSOAPMsgControlAction(m, &amp;n-&gt;tcpInfo, <span class="enscript-string">&quot;AddPortMapping&quot;</span>, 8, propArgs, LNTPortMapOp);
}

mDNSexport mStatus <span class="enscript-function-name">LNT_MapPort</span>(mDNS *m, NATTraversalInfo *<span class="enscript-type">const</span> n)
{
    LogInfo(<span class="enscript-string">&quot;LNT_MapPort&quot;</span>);
    <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.sock) <span class="enscript-keyword">return</span>(mStatus_NoError);   <span class="enscript-comment">// If we already have a connection up don't make another request for the same thing
</span>    n-&gt;tcpInfo.parentNATInfo = n;
    n-&gt;tcpInfo.retries       = 0;
    <span class="enscript-keyword">return</span> SendPortMapRequest(m, n);
}

mDNSexport mStatus <span class="enscript-function-name">LNT_UnmapPort</span>(mDNS *m, NATTraversalInfo *<span class="enscript-type">const</span> n)
{
    <span class="enscript-type">char</span> externalPort[10];
    Property propArgs[3];
    tcpLNTInfo  *info;
    tcpLNTInfo  **infoPtr = &amp;m-&gt;tcpInfoUnmapList;
    mStatus err;

    <span class="enscript-comment">// If no NAT gateway to talk to, no need to do all this work for nothing
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;UPnPSOAPPort) || !m-&gt;UPnPSOAPURL || !m-&gt;UPnPSOAPAddressString) <span class="enscript-keyword">return</span> mStatus_NoError;

    mDNS_snprintf(externalPort, <span class="enscript-keyword">sizeof</span>(externalPort), <span class="enscript-string">&quot;%u&quot;</span>, mDNSVal16(mDNSIPPortIsZero(n-&gt;RequestedPort) ? n-&gt;IntPort : n-&gt;RequestedPort));

    mDNSPlatformMemZero(propArgs, <span class="enscript-keyword">sizeof</span>(propArgs));
    propArgs[0].name  = <span class="enscript-string">&quot;NewRemoteHost&quot;</span>;
    propArgs[0].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[0].value = <span class="enscript-string">&quot;&quot;</span>;
    propArgs[1].name  = <span class="enscript-string">&quot;NewExternalPort&quot;</span>;
    propArgs[1].type  = <span class="enscript-string">&quot;ui2&quot;</span>;
    propArgs[1].value = externalPort;
    propArgs[2].name  = <span class="enscript-string">&quot;NewProtocol&quot;</span>;
    propArgs[2].type  = <span class="enscript-string">&quot;string&quot;</span>;
    propArgs[2].value = (n-&gt;Protocol == NATOp_MapUDP) ? <span class="enscript-string">&quot;UDP&quot;</span> : <span class="enscript-string">&quot;TCP&quot;</span>;

    n-&gt;tcpInfo.parentNATInfo = n;

    <span class="enscript-comment">// clean up previous port mapping requests and allocations
</span>    <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.sock) LogInfo(<span class="enscript-string">&quot;LNT_UnmapPort: closing previous open connection&quot;</span>);
    <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.sock   ) { mDNSPlatformTCPCloseConnection(n-&gt;tcpInfo.sock); n-&gt;tcpInfo.sock    = mDNSNULL; }
    <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.Request) { mDNSPlatformMemFree(n-&gt;tcpInfo.Request);         n-&gt;tcpInfo.Request = mDNSNULL; }
    <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.Reply  ) { mDNSPlatformMemFree(n-&gt;tcpInfo.Reply);           n-&gt;tcpInfo.Reply   = mDNSNULL; }

    <span class="enscript-comment">// make a copy of the tcpInfo that we can clean up later (the one passed in will be destroyed by the client as soon as this returns)
</span>    <span class="enscript-keyword">if</span> ((info = (tcpLNTInfo *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(*info))) == mDNSNULL)
    { LogInfo(<span class="enscript-string">&quot;LNT_UnmapPort: can't allocate tcpInfo&quot;</span>); <span class="enscript-keyword">return</span>(mStatus_NoMemoryErr); }
    *info = n-&gt;tcpInfo;

    <span class="enscript-keyword">while</span> (*infoPtr) infoPtr = &amp;(*infoPtr)-&gt;next;   <span class="enscript-comment">// find the end of the list
</span>    *infoPtr = info;    <span class="enscript-comment">// append
</span>
    err = SendSOAPMsgControlAction(m, info, <span class="enscript-string">&quot;DeletePortMapping&quot;</span>, 3, propArgs, LNTPortMapDeleteOp);
    <span class="enscript-keyword">if</span> (err) DisposeInfoFromUnmapList(m, info);
    <span class="enscript-keyword">return</span> err;
}

mDNSexport mStatus <span class="enscript-function-name">LNT_GetExternalAddress</span>(mDNS *m)
{
    <span class="enscript-keyword">return</span> SendSOAPMsgControlAction(m, &amp;m-&gt;tcpAddrInfo, <span class="enscript-string">&quot;GetExternalIPAddress&quot;</span>, 0, mDNSNULL, LNTExternalAddrOp);
}

mDNSlocal mStatus <span class="enscript-function-name">GetDeviceDescription</span>(mDNS *m, tcpLNTInfo *info)
{
    <span class="enscript-comment">// Device description format -
</span>    <span class="enscript-comment">//  - device description URL
</span>    <span class="enscript-comment">//  - host/port
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> szSSDPMsgDescribeDeviceFMT[] =
        <span class="enscript-string">&quot;GET %s HTTP/1.1\r\n&quot;</span>
        <span class="enscript-string">&quot;Accept: text/xml, application/xml\r\n&quot;</span>
        <span class="enscript-string">&quot;User-Agent: Mozilla/4.0 (compatible; UPnP/1.0; Windows NT/5.1)\r\n&quot;</span>
        <span class="enscript-string">&quot;Host: %s\r\n&quot;</span>
        <span class="enscript-string">&quot;Connection: close\r\n&quot;</span>
        <span class="enscript-string">&quot;\r\n&quot;</span>;

    <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(m-&gt;UPnPSOAPPort)) <span class="enscript-keyword">return</span> mStatus_NoError; <span class="enscript-comment">// already have the info we need
</span>
    <span class="enscript-keyword">if</span> (m-&gt;UPnPRouterURL == mDNSNULL || m-&gt;UPnPRouterAddressString == mDNSNULL) { LogInfo(<span class="enscript-string">&quot;GetDeviceDescription: no router URL or address string!&quot;</span>); <span class="enscript-keyword">return</span> (mStatus_Invalid); }

    <span class="enscript-comment">// build message
</span>    <span class="enscript-keyword">if</span>      (info-&gt;Request != mDNSNULL) mDNSPlatformMemZero(info-&gt;Request, LNT_MAXBUFSIZE); <span class="enscript-comment">// reuse previously allocated buffer
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((info-&gt;Request = mDNSPlatformMemAllocate(LNT_MAXBUFSIZE)) == mDNSNULL) { LogInfo(<span class="enscript-string">&quot;can't allocate send buffer for discovery&quot;</span>); <span class="enscript-keyword">return</span> (mStatus_NoMemoryErr); }
    info-&gt;requestLen = mDNS_snprintf((<span class="enscript-type">char</span>*)info-&gt;Request, LNT_MAXBUFSIZE, szSSDPMsgDescribeDeviceFMT, m-&gt;UPnPRouterURL, m-&gt;UPnPRouterAddressString);
    LogInfo(<span class="enscript-string">&quot;Describe Device: [%s]&quot;</span>, info-&gt;Request);
    <span class="enscript-keyword">return</span> MakeTCPConnection(m, info, &amp;m-&gt;Router, m-&gt;UPnPRouterPort, LNTDiscoveryOp);
}

<span class="enscript-comment">// This function parses the response to our SSDP discovery message. Basically, we look to make sure this is a response
</span><span class="enscript-comment">// referencing a service we care about (WANIPConnection or WANPPPConnection), then look for the &quot;Location:&quot; header and copy the addressing and
</span><span class="enscript-comment">// URL info we need.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LNT_ConfigureRouterInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> data, <span class="enscript-type">const</span> mDNSu16 len)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = data;
    <span class="enscript-type">const</span> mDNSu8 *end = data + len;
    <span class="enscript-type">const</span> mDNSu8 *stop;

    <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(m-&gt;UPnPRouterPort)) <span class="enscript-keyword">return</span>; <span class="enscript-comment">// already have the info we need
</span>
    <span class="enscript-comment">// The formatting of the HTTP header is not always the same when it comes to the placement of
</span>    <span class="enscript-comment">// the service and location strings, so we just look for each of them from the beginning for every response
</span>
    <span class="enscript-comment">// figure out if this is a message from a service we care about
</span>    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
    {
        <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'W'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;WANIPConnection:1&quot;</span>, 17) == 0)) <span class="enscript-keyword">break</span>;
        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == end)
    {
        ptr = data;
        <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
        {
            <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'W'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;WANPPPConnection:1&quot;</span>, 18) == 0)) <span class="enscript-keyword">break</span>;
            ptr++;
        }
    }
    <span class="enscript-keyword">if</span> (ptr == mDNSNULL || ptr == end) <span class="enscript-keyword">return</span>;  <span class="enscript-comment">// not a message we care about
</span>
    <span class="enscript-comment">// find &quot;Location:&quot;, starting from the beginning
</span>    ptr = data;
    <span class="enscript-keyword">while</span> (ptr &amp;&amp; ptr != end)
    {
        <span class="enscript-keyword">if</span> ((*ptr &amp; 0xDF) == <span class="enscript-string">'L'</span> &amp;&amp; (strncasecmp((<span class="enscript-type">char</span>*)ptr, <span class="enscript-string">&quot;Location:&quot;</span>, 9) == 0)) <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// find the first 'L'; is this Location? if not, keep looking
</span>        ptr++;
    }
    <span class="enscript-keyword">if</span> (ptr == mDNSNULL || ptr == end)
    {
        LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Location field not found&quot;</span>);
        <span class="enscript-keyword">return</span>; <span class="enscript-comment">// not a message we care about
</span>    }
    ptr += 9; <span class="enscript-comment">//Skip over 'Location:'
</span>    <span class="enscript-keyword">while</span> (*ptr == <span class="enscript-string">' '</span> &amp;&amp; ptr &lt; end) ptr++; <span class="enscript-comment">// skip over spaces
</span>    <span class="enscript-keyword">if</span> (ptr &gt;= end) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// find the end of the line
</span>    <span class="enscript-keyword">for</span> (stop = ptr; stop != end; stop++) { <span class="enscript-keyword">if</span> (*stop == <span class="enscript-string">'\r'</span>) { end = stop; <span class="enscript-keyword">break</span>; } }

    <span class="enscript-comment">// fill in default port
</span>    m-&gt;UPnPRouterPort = mDNSOpaque16fromIntVal(80);

    <span class="enscript-comment">// free string pointers and set to NULL
</span>    <span class="enscript-keyword">if</span> (m-&gt;UPnPRouterAddressString != mDNSNULL)
    {
        mDNSPlatformMemFree(m-&gt;UPnPRouterAddressString);
        m-&gt;UPnPRouterAddressString = mDNSNULL;
    }
    <span class="enscript-keyword">if</span> (m-&gt;UPnPRouterURL != mDNSNULL)
    {
        mDNSPlatformMemFree(m-&gt;UPnPRouterURL);
        m-&gt;UPnPRouterURL = mDNSNULL;
    }

    <span class="enscript-comment">// the Router URL should look something like &quot;/dyndev/uuid:0013-108c-4b3f0000f3dc&quot;
</span>    <span class="enscript-keyword">if</span> (ParseHttpUrl(ptr, end, &amp;m-&gt;UPnPRouterAddressString, &amp;m-&gt;UPnPRouterPort, &amp;m-&gt;UPnPRouterURL) != mStatus_NoError)
    {
        LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Failed to parse URL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    m-&gt;UPnPInterfaceID = InterfaceID;

    <span class="enscript-keyword">if</span> (m-&gt;UPnPRouterAddressString == mDNSNULL)
    {
        LogMsg(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: UPnPRouterAddressString is NULL&quot;</span>);
    }
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Router address string [%s]&quot;</span>, m-&gt;UPnPRouterAddressString);

    <span class="enscript-keyword">if</span> (m-&gt;UPnPRouterURL == mDNSNULL)
    {
        LogMsg(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: UPnPRouterURL is NULL&quot;</span>);
    }
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Router URL [%s]&quot;</span>, m-&gt;UPnPRouterURL);

    LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Router port %d&quot;</span>, mDNSVal16(m-&gt;UPnPRouterPort));
    LogInfo(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo: Router interface %d&quot;</span>, m-&gt;UPnPInterfaceID);

    <span class="enscript-comment">// Don't need the SSDP socket anymore
</span>    <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket) { debugf(<span class="enscript-string">&quot;LNT_ConfigureRouterInfo destroying SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); mDNSPlatformUDPClose(m-&gt;SSDPSocket); m-&gt;SSDPSocket = mDNSNULL; }

    <span class="enscript-comment">// now send message to get the device description
</span>    GetDeviceDescription(m, &amp;m-&gt;tcpDeviceInfo);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LNT_SendDiscoveryMsg</span>(mDNS *m)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg[] =
        <span class="enscript-string">&quot;M-SEARCH * HTTP/1.1\r\n&quot;</span>
        <span class="enscript-string">&quot;Host:239.255.255.250:1900\r\n&quot;</span>
        <span class="enscript-string">&quot;ST:urn:schemas-upnp-org:service:WAN%sConnection:1\r\n&quot;</span>
        <span class="enscript-string">&quot;Man:\&quot;ssdp:discover\&quot;\r\n&quot;</span>
        <span class="enscript-string">&quot;MX:3\r\n\r\n&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSAddr multicastDest = { mDNSAddrType_IPv4, { { { 239, 255, 255, 250 } } } };

    mDNSu8 *<span class="enscript-type">const</span> buf = (mDNSu8*)&amp;m-&gt;omsg; <span class="enscript-comment">//m-&gt;omsg is 8952 bytes, which is plenty
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bufLen;

    <span class="enscript-keyword">if</span> (m-&gt;SleepState != SleepState_Awake) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (!mDNSIPPortIsZero(m-&gt;UPnPRouterPort))
    {
        <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket) { debugf(<span class="enscript-string">&quot;LNT_SendDiscoveryMsg destroying SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); mDNSPlatformUDPClose(m-&gt;SSDPSocket); m-&gt;SSDPSocket = mDNSNULL; }
        <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;UPnPSOAPPort) &amp;&amp; !m-&gt;tcpDeviceInfo.sock) GetDeviceDescription(m, &amp;m-&gt;tcpDeviceInfo);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Always query for WANIPConnection in the first SSDP packet
</span>    <span class="enscript-keyword">if</span> (m-&gt;retryIntervalGetAddr &lt;= NATMAP_INIT_RETRY) m-&gt;SSDPWANPPPConnection = mDNSfalse;

    <span class="enscript-comment">// Create message
</span>    bufLen = mDNS_snprintf((<span class="enscript-type">char</span>*)buf, <span class="enscript-keyword">sizeof</span>(m-&gt;omsg), msg, m-&gt;SSDPWANPPPConnection ? <span class="enscript-string">&quot;PPP&quot;</span> : <span class="enscript-string">&quot;IP&quot;</span>);

    debugf(<span class="enscript-string">&quot;LNT_SendDiscoveryMsg Router %.4a Current External Address %.4a&quot;</span>, &amp;m-&gt;Router.ip.v4, &amp;m-&gt;ExtAddress);

    <span class="enscript-keyword">if</span> (!mDNSIPv4AddressIsZero(m-&gt;Router.ip.v4))
    {
        <span class="enscript-keyword">if</span> (!m-&gt;SSDPSocket) { m-&gt;SSDPSocket = mDNSPlatformUDPSocket(zeroIPPort); debugf(<span class="enscript-string">&quot;LNT_SendDiscoveryMsg created SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); }
        mDNSPlatformSendUDP(m, buf, buf + bufLen, 0, m-&gt;SSDPSocket, &amp;m-&gt;Router,     SSDPPort, mDNSfalse);
        mDNSPlatformSendUDP(m, buf, buf + bufLen, 0, m-&gt;SSDPSocket, &amp;multicastDest, SSDPPort, mDNSfalse);
    }

    m-&gt;SSDPWANPPPConnection = !m-&gt;SSDPWANPPPConnection;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LNT_ClearState</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-keyword">if</span> (m-&gt;tcpAddrInfo.sock)   { mDNSPlatformTCPCloseConnection(m-&gt;tcpAddrInfo.sock);   m-&gt;tcpAddrInfo.sock   = mDNSNULL; }
    <span class="enscript-keyword">if</span> (m-&gt;tcpDeviceInfo.sock) { mDNSPlatformTCPCloseConnection(m-&gt;tcpDeviceInfo.sock); m-&gt;tcpDeviceInfo.sock = mDNSNULL; }
    m-&gt;UPnPSOAPPort = m-&gt;UPnPRouterPort = zeroIPPort;   <span class="enscript-comment">// Reset UPnP ports
</span>}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _LEGACY_NAT_TRAVERSAL_ */</span>
</pre>
<hr />
</body></html>