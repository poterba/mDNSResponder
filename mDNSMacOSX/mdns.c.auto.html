<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mdns.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mdns.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="mdns.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mdns_private.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mdns_object.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreUtils/CoreUtils.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;network_information.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;os/log.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;os/object_private.h&gt;</span>

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - Kind Declarations
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MDNS_STRUCT</span>(NAME)	struct mdns_ ## NAME ## _s

<span class="enscript-comment">// Note: The last check checks if the base's type is equal to that of the superkind. If it's not, then the pointer
</span><span class="enscript-comment">// comparison used as the argument to sizeof will cause a &quot;comparison of distinct pointer types&quot; warning, so long as
</span><span class="enscript-comment">// the warning hasn't been disabled.
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MDNS_BASE_CHECK</span>(NAME, SUPER)															\
	check_compile_time(offsetof(MDNS_STRUCT(NAME), base) == 0);									\
	check_compile_time(sizeof_field(MDNS_STRUCT(NAME), base) == sizeof(MDNS_STRUCT(SUPER)));	\
	extern int _mdns_base_type_check[sizeof(&amp;(((mdns_ ## NAME ## _t)0)-&gt;base) == ((mdns_ ## SUPER ## _t)0))]

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MDNS_OBJECT_SUBKIND_DEFINE</span>(NAME)														\
	static void																					\
	_mdns_ ## NAME ## _finalize(mdns_ ## NAME ## _t object);									\
																								\
	static char *																				\
	_mdns_ ## NAME ## _copy_description(mdns_ ## NAME ## _t object, bool debug, bool privacy);	\
																								\
	static const struct mdns_kind_s _mdns_ ## NAME ## _kind = {									\
		&amp;_mdns_object_kind,																		\
		# NAME,																					\
		_mdns_ ## NAME ## _copy_description,													\
		_mdns_ ## NAME ## _finalize																\
	};																							\
																								\
	static mdns_ ## NAME ## _t																	\
	_mdns_ ## NAME ## _alloc(void)																\
	{																							\
		mdns_ ## NAME ## _t obj = mdns_object_ ## NAME ## _alloc(sizeof(*obj));					\
		require_quiet(obj, exit);																\
																								\
		const mdns_object_t base = (mdns_object_t)obj;											\
		base-&gt;kind = &amp;_mdns_ ## NAME ## _kind;													\
																								\
	exit:																						\
		return obj;																				\
	}																							\
	MDNS_BASE_CHECK(NAME, object)

<span class="enscript-type">typedef</span> <span class="enscript-type">char</span> *	(*mdns_copy_description_f)(mdns_any_t object, bool debug, bool privacy);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span>	(*mdns_finalize_f)(mdns_any_t object);

<span class="enscript-type">typedef</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> mdns_kind_s *	mdns_kind_t;
<span class="enscript-type">struct</span> mdns_kind_s {
	mdns_kind_t				superkind;			<span class="enscript-comment">// This kind's superkind.
</span>	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *			name;				<span class="enscript-comment">// Name of this kind.
</span>	mdns_copy_description_f	copy_description;	<span class="enscript-comment">// Creates a textual description of object.
</span>	mdns_finalize_f			finalize;			<span class="enscript-comment">// Releases object's resources right before the object is freed.
</span>};

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_object Kind Definition
</span>
<span class="enscript-type">struct</span> mdns_object_s {
	_OS_OBJECT_HEADER(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *_os_obj_isa, _os_obj_refcnt, _os_obj_xref_cnt);
	mdns_kind_t	kind;	<span class="enscript-comment">// Pointer to an object's kind.
</span>};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> mdns_kind_s _mdns_object_kind = {
	NULL,		<span class="enscript-comment">// No superkind.
</span>	<span class="enscript-string">&quot;object&quot;</span>,	<span class="enscript-comment">// Name.
</span>	NULL,		<span class="enscript-comment">// No copy_description method.
</span>	NULL		<span class="enscript-comment">// No finalize method.
</span>};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">_mdns_cf_collection_callback_retain</span>(CFAllocatorRef allocator, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *object);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_cf_collection_callback_release</span>(CFAllocatorRef allocator, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *object);

<span class="enscript-type">static</span> CFStringRef
<span class="enscript-function-name">_mdns_cf_collection_callback_copy_description</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *object);

<span class="enscript-type">const</span> CFArrayCallBacks mdns_cfarray_callbacks = {
	0,												<span class="enscript-comment">// version
</span>	_mdns_cf_collection_callback_retain,			<span class="enscript-comment">// retain
</span>	_mdns_cf_collection_callback_release,			<span class="enscript-comment">// release
</span>	_mdns_cf_collection_callback_copy_description,	<span class="enscript-comment">// copy description
</span>	NULL											<span class="enscript-comment">// equal (NULL for pointer equality)
</span>};

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_interface_monitor Kind Definition
</span>
<span class="enscript-type">struct</span> mdns_interface_monitor_s {
	<span class="enscript-type">struct</span> mdns_object_s					base;					<span class="enscript-comment">// Object base.
</span>	mdns_interface_monitor_t				next;					<span class="enscript-comment">// Next monitor in list.
</span>	dispatch_queue_t						user_queue;				<span class="enscript-comment">// User's queue for invoking handlers.
</span>	nw_path_evaluator_t						path_evaluator;			<span class="enscript-comment">// Path evaluator for interface properties.
</span>	dispatch_source_t						update_source;			<span class="enscript-comment">// Data source for triggering user's update handler.
</span>	mdns_interface_monitor_update_handler_t	update_handler;			<span class="enscript-comment">// User's update handler.
</span>	mdns_event_handler_t					event_handler;			<span class="enscript-comment">// User's event handler.
</span>	<span class="enscript-type">char</span> *									ifname;					<span class="enscript-comment">// Name of monitored interface.
</span>	uint32_t								ifindex;				<span class="enscript-comment">// Index of monitored interface.
</span>	mdns_interface_flags_t					pending_flags;			<span class="enscript-comment">// The latest interface flags from path updates.
</span>	mdns_interface_flags_t					flags;					<span class="enscript-comment">// The current interface flags made known to user.
</span>	bool									user_activated;			<span class="enscript-comment">// True if user called activate method.
</span>	bool									activated;				<span class="enscript-comment">// True if the monitor has been activated.
</span>	bool									invalidated;			<span class="enscript-comment">// True if the monitor has been invalidated.
</span>	bool									path_evaluator_started;	<span class="enscript-comment">// True if the path evaluator has been started.
</span>};

<span class="enscript-function-name">MDNS_OBJECT_SUBKIND_DEFINE</span>(interface_monitor);

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - Local Prototypes
</span>
<span class="enscript-type">static</span> dispatch_queue_t
<span class="enscript-function-name">_mdns_internal_queue</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> dispatch_queue_t
<span class="enscript-function-name">_mdns_nwi_state_mutex_queue</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_activate_async</span>(mdns_interface_monitor_t monitor);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_terminate</span>(mdns_interface_monitor_t me, <span class="enscript-type">const</span> OSStatus error);

<span class="enscript-type">static</span> mdns_interface_flags_t
<span class="enscript-function-name">_mdns_get_interface_flags_from_nw_path</span>(nw_path_t path, mdns_interface_flags_t current_flags);

<span class="enscript-type">static</span> mdns_interface_flags_t
<span class="enscript-function-name">_mdns_get_interface_flags_from_nwi_state</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, mdns_interface_flags_t current_flags);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">_mdns_snprintf_add</span>(<span class="enscript-type">char</span> **ptr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lim, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_start_nwi_state_monitoring</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">nw_forget</span>)
	#define nw_forget(X)	ForgetCustom(X, nw_release)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">nw_release_null_safe</span>)
	#define nw_release_null_safe(X)	<span class="enscript-keyword">do</span> { <span class="enscript-keyword">if</span> (X) { nw_release(X); } } <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">nwi_state_release_null_safe</span>)
	#define nwi_state_release_null_safe(X)	<span class="enscript-keyword">do</span> { <span class="enscript-keyword">if</span> (X) { nwi_state_release(X); } } <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - Globals
</span>
<span class="enscript-type">static</span> mdns_interface_monitor_t	g_monitor_list	= NULL;
<span class="enscript-type">static</span> nwi_state_t				g_nwi_state		= NULL;

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - Internals
</span>
<span class="enscript-type">static</span> dispatch_queue_t
<span class="enscript-function-name">_mdns_internal_queue</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> dispatch_once_t	s_once	= 0;
	<span class="enscript-type">static</span> dispatch_queue_t	s_queue	= NULL;
	dispatch_once(&amp;s_once,
	^{
		s_queue = dispatch_queue_create(<span class="enscript-string">&quot;com.apple.mdns.internal_queue&quot;</span>, DISPATCH_QUEUE_SERIAL);
	});
	<span class="enscript-keyword">return</span> s_queue;	
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> dispatch_queue_t
<span class="enscript-function-name">_mdns_nwi_state_mutex_queue</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> dispatch_once_t	s_once	= 0;
	<span class="enscript-type">static</span> dispatch_queue_t	s_queue	= NULL;
	dispatch_once(&amp;s_once,
	^{
		s_queue = dispatch_queue_create(<span class="enscript-string">&quot;com.apple.mdns.nwi_state_mutex&quot;</span>, DISPATCH_QUEUE_SERIAL);
	});
	<span class="enscript-keyword">return</span> s_queue;
}

<span class="enscript-comment">//======================================================================================================================
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MDNS_LOG_CATEGORY_DEFINE</span>(SHORT_NAME, CATEGORY_STR)			\
	static os_log_t													\
	_mdns_ ## SHORT_NAME ## _log(void)								\
	{																\
		static dispatch_once_t	s_once	= 0;						\
		static os_log_t			s_log	= NULL;						\
		dispatch_once(&amp;s_once,										\
		^{															\
			s_log = os_log_create(<span class="enscript-string">&quot;com.apple.mdns&quot;</span>, CATEGORY_STR);	\
		});															\
		return s_log;												\
	}																\
	extern int _mdns_dummy_variable

<span class="enscript-function-name">MDNS_LOG_CATEGORY_DEFINE</span>(ifmon, <span class="enscript-string">&quot;interface_monitor&quot;</span>);
<span class="enscript-function-name">MDNS_LOG_CATEGORY_DEFINE</span>(nwi,   <span class="enscript-string">&quot;NWI&quot;</span>);

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_object Public Methods
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_retain</span>(mdns_any_t object)
{
	os_retain(object.base);
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_release</span>(mdns_any_t object)
{
	os_release(object.base);
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">mdns_copy_description</span>(mdns_any_t object)
{
	<span class="enscript-keyword">return</span> mdns_object_copy_description(object, false, false);
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_object Private Methods
</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">mdns_object_copy_description</span>(mdns_any_t object, bool debug, bool privacy)
{
	<span class="enscript-keyword">for</span> (mdns_kind_t kind = object.base-&gt;kind; kind; kind = kind-&gt;superkind) {
		<span class="enscript-keyword">if</span> (kind-&gt;copy_description) {
			<span class="enscript-keyword">return</span> kind-&gt;copy_description(object, debug, privacy);
		}
	}
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">//======================================================================================================================
</span>
CFStringRef
<span class="enscript-function-name">mdns_object_copy_description_as_cfstring</span>(mdns_any_t object, bool debug, bool privacy)
{
	CFStringRef description = NULL;
	<span class="enscript-type">char</span> *cstring = mdns_object_copy_description(object, debug, privacy);
	require_quiet(cstring, exit);

	description = CFStringCreateWithCStringNoCopy(NULL, cstring, kCFStringEncodingUTF8, kCFAllocatorMalloc);
	require_quiet(description, exit);
	cstring = NULL;

<span class="enscript-reference">exit</span>:
	FreeNullSafe(cstring);
	<span class="enscript-keyword">return</span> description;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_object_finalize</span>(mdns_any_t object)
{
	<span class="enscript-keyword">for</span> (mdns_kind_t kind = object.base-&gt;kind; kind; kind = kind-&gt;superkind) {
		<span class="enscript-keyword">if</span> (kind-&gt;finalize) {
			kind-&gt;finalize(object);
		}
	}
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">_mdns_cf_collection_callback_retain</span>(__unused CFAllocatorRef allocator, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *object)
{
	mdns_retain((mdns_object_t)object);
	<span class="enscript-keyword">return</span> object;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_cf_collection_callback_release</span>(__unused CFAllocatorRef allocator, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *object)
{
	mdns_release((mdns_object_t)object);
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> CFStringRef
<span class="enscript-function-name">_mdns_cf_collection_callback_copy_description</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *object)
{
	<span class="enscript-keyword">return</span> mdns_object_copy_description_as_cfstring((mdns_object_t)object, false, false);
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_interface_monitor Public Methods
</span>
mdns_interface_monitor_t
<span class="enscript-function-name">mdns_interface_monitor_create</span>(uint32_t interface_index)
{
	mdns_interface_monitor_t	monitor		= NULL;
	nw_interface_t				interface	= NULL;
	nw_parameters_t				params		= NULL;

	mdns_interface_monitor_t obj = _mdns_interface_monitor_alloc();
	require_quiet(obj, exit);

	obj-&gt;ifindex = interface_index;
	<span class="enscript-type">char</span> ifname[IF_NAMESIZE + 1];
	<span class="enscript-keyword">if</span> (if_indextoname(obj-&gt;ifindex, ifname) == NULL) {
		os_log_error(_mdns_ifmon_log(), <span class="enscript-string">&quot;if_indextoname returned NULL for index %u&quot;</span>, obj-&gt;ifindex);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	obj-&gt;ifname = strdup(ifname);
	require_quiet(obj-&gt;ifname, exit);

	interface = nw_interface_create_with_index(obj-&gt;ifindex);
	<span class="enscript-keyword">if</span> (!interface) {
		os_log_error(_mdns_ifmon_log(), <span class="enscript-string">&quot;nw_interface_create_with_index returned NULL for index %u&quot;</span>, obj-&gt;ifindex);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	params = nw_parameters_create();
	require_quiet(params, exit);

	nw_parameters_require_interface(params, interface);
	obj-&gt;path_evaluator = nw_path_create_evaluator_for_endpoint(NULL, params);
	<span class="enscript-keyword">if</span> (!obj-&gt;path_evaluator) {
		os_log_error(_mdns_ifmon_log(), <span class="enscript-string">&quot;nw_path_create_evaluator_for_endpoint returned NULL for params: %@&quot;</span>, params);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	nw_path_t path = nw_path_evaluator_copy_path(obj-&gt;path_evaluator);
	require_quiet(path, exit);

	obj-&gt;pending_flags = _mdns_get_interface_flags_from_nw_path(path, mdns_interface_flag_null);
	obj-&gt;pending_flags = _mdns_get_interface_flags_from_nwi_state(obj-&gt;ifname, obj-&gt;pending_flags);
	obj-&gt;flags = obj-&gt;pending_flags;
	nw_forget(&amp;path);

	monitor = obj;
	obj = NULL;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (obj) {
		mdns_release(obj);
	}
	nw_release_null_safe(interface);
	nw_release_null_safe(params);
	<span class="enscript-keyword">return</span> monitor;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_interface_monitor_activate</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">if</span> (!me-&gt;user_activated) {
		<span class="enscript-keyword">if</span> (me-&gt;user_queue) {
			_mdns_interface_monitor_activate_async(me);
		}
		me-&gt;user_activated = true;
	}
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_interface_monitor_invalidate</span>(mdns_interface_monitor_t me)
{
	mdns_retain(me);
	dispatch_async(_mdns_internal_queue(),
	^{
		<span class="enscript-keyword">if</span> (!me-&gt;invalidated) {
			_mdns_interface_monitor_terminate(me, kNoErr);
			me-&gt;invalidated = true;
		}
		mdns_release(me);
	});
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_interface_monitor_set_queue</span>(mdns_interface_monitor_t me, dispatch_queue_t queue)
{
	<span class="enscript-keyword">if</span> (!me-&gt;user_activated) {
		dispatch_retain(queue);
		dispatch_release_null_safe(me-&gt;user_queue);
		me-&gt;user_queue = queue;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!me-&gt;user_queue) {
		me-&gt;user_queue = queue;
		dispatch_retain(me-&gt;user_queue);
		_mdns_interface_monitor_activate_async(me);
	}
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_interface_monitor_set_event_handler</span>(mdns_interface_monitor_t me, mdns_event_handler_t handler)
{
	mdns_event_handler_t <span class="enscript-type">const</span> new_handler = handler ? Block_copy(handler) : NULL;
	<span class="enscript-keyword">if</span> (me-&gt;event_handler) {
		Block_release(me-&gt;event_handler);
	}
	me-&gt;event_handler = new_handler;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mdns_interface_monitor_set_update_handler</span>(mdns_interface_monitor_t me, mdns_interface_monitor_update_handler_t handler)
{
	mdns_interface_monitor_update_handler_t <span class="enscript-type">const</span> new_handler = handler ? Block_copy(handler) : NULL;
	<span class="enscript-keyword">if</span> (me-&gt;update_handler) {
		Block_release(me-&gt;update_handler);
	}
	me-&gt;update_handler = new_handler;
}

<span class="enscript-comment">//======================================================================================================================
</span>
uint32_t
<span class="enscript-function-name">mdns_interface_monitor_get_interface_index</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> me-&gt;ifindex;
}

<span class="enscript-comment">//======================================================================================================================
</span>
bool
<span class="enscript-function-name">mdns_interface_monitor_has_ipv4_connectivity</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> ((me-&gt;flags &amp; mdns_interface_flag_ipv4_connectivity) ? true : false);
}

<span class="enscript-comment">//======================================================================================================================
</span>
bool
<span class="enscript-function-name">mdns_interface_monitor_has_ipv6_connectivity</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> ((me-&gt;flags &amp; mdns_interface_flag_ipv6_connectivity) ? true : false);
}

<span class="enscript-comment">//======================================================================================================================
</span>
bool
<span class="enscript-function-name">mdns_interface_monitor_is_expensive</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> ((me-&gt;flags &amp; mdns_interface_flag_expensive) ? true : false);
}

<span class="enscript-comment">//======================================================================================================================
</span>
bool
<span class="enscript-function-name">mdns_interface_monitor_is_constrained</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> ((me-&gt;flags &amp; mdns_interface_flag_constrained) ? true : false);
}

<span class="enscript-comment">//======================================================================================================================
</span>
bool
<span class="enscript-function-name">mdns_interface_monitor_is_clat46</span>(mdns_interface_monitor_t me)
{
	<span class="enscript-keyword">return</span> ((me-&gt;flags &amp; mdns_interface_flag_clat46) ? true : false);
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - mdns_interface_monitor Private Methods
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	mdns_interface_flags_t	flag;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *			desc;
} mdns_interface_flag_description_t;

<span class="enscript-type">const</span> mdns_interface_flag_description_t	mdns_interface_flag_descriptions[] = {
	{ mdns_interface_flag_ipv4_connectivity, <span class="enscript-string">&quot;IPv4&quot;</span> },
	{ mdns_interface_flag_ipv6_connectivity, <span class="enscript-string">&quot;IPv6&quot;</span> },
	{ mdns_interface_flag_expensive,         <span class="enscript-string">&quot;expensive&quot;</span> },
	{ mdns_interface_flag_constrained,       <span class="enscript-string">&quot;constrained&quot;</span> },
	{ mdns_interface_flag_clat46,            <span class="enscript-string">&quot;CLAT46&quot;</span> }
};

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">_mdns_interface_monitor_copy_description</span>(mdns_interface_monitor_t me, <span class="enscript-type">const</span> bool debug, __unused <span class="enscript-type">const</span> bool privacy)
{
	<span class="enscript-type">char</span> *				description	= NULL;
	<span class="enscript-type">char</span>				buffer[128];
	<span class="enscript-type">char</span> *				dst			= buffer;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span>	lim			= &amp;buffer[countof(buffer)];
	<span class="enscript-type">int</span>					n;

	*dst = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">if</span> (debug) {
		n = _mdns_snprintf_add(&amp;dst, lim, <span class="enscript-string">&quot;mdns_%s (%p): &quot;</span>, me-&gt;base.kind-&gt;name, me);
		require_quiet(n &gt;= 0, exit);
	}
	n = _mdns_snprintf_add(&amp;dst, lim, <span class="enscript-string">&quot;interface %s (%u): &quot;</span>, me-&gt;ifname, me-&gt;ifindex);
	require_quiet(n &gt;= 0, exit);

	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *separator = <span class="enscript-string">&quot;&quot;</span>;
	<span class="enscript-keyword">for</span> (size_t i = 0; i &lt; countof(mdns_interface_flag_descriptions); ++i) {
		<span class="enscript-type">const</span> mdns_interface_flag_description_t * <span class="enscript-type">const</span> flag_desc = &amp;mdns_interface_flag_descriptions[i];
		<span class="enscript-keyword">if</span> (me-&gt;flags &amp; flag_desc-&gt;flag) {
			n = _mdns_snprintf_add(&amp;dst, lim, <span class="enscript-string">&quot;%s%s&quot;</span>, separator, flag_desc-&gt;desc);
			require_quiet(n &gt;= 0, exit);
			separator = <span class="enscript-string">&quot;, &quot;</span>;
		}
	}
	description = strdup(buffer);

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> description;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_finalize</span>(mdns_interface_monitor_t me)
{
	dispatch_forget(&amp;me-&gt;user_queue);
	nw_forget(&amp;me-&gt;path_evaluator);
	BlockForget(&amp;me-&gt;update_handler);
	BlockForget(&amp;me-&gt;event_handler);
	ForgetMem(&amp;me-&gt;ifname);
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_activate_internal</span>(mdns_interface_monitor_t monitor);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_activate_async</span>(mdns_interface_monitor_t me)
{
	mdns_retain(me);
	dispatch_async(_mdns_internal_queue(),
	^{
		_mdns_interface_monitor_activate_internal(me);
		mdns_release(me);		
	});
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_activate_internal</span>(mdns_interface_monitor_t me)
{
	OSStatus err;
	require_action_quiet(!me-&gt;activated &amp;&amp; !me-&gt;invalidated, exit, err = kNoErr);
	me-&gt;activated = true;

	me-&gt;update_source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_REPLACE, 0, 0, me-&gt;user_queue);
	require_action_quiet(me-&gt;update_source, exit, err = kNoResourcesErr);

	mdns_retain(me);
	<span class="enscript-type">const</span> dispatch_source_t update_source = me-&gt;update_source;
	dispatch_source_set_event_handler(me-&gt;update_source,
	^{
		<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> data = dispatch_source_get_data(update_source);
		<span class="enscript-type">const</span> mdns_interface_flags_t new_flags = ((mdns_interface_flags_t)data) &amp; ~mdns_interface_flag_reserved;
		<span class="enscript-type">const</span> mdns_interface_flags_t changed_flags = me-&gt;flags ^ new_flags;
		<span class="enscript-keyword">if</span> (changed_flags != 0) {
			me-&gt;flags = new_flags;
			<span class="enscript-keyword">if</span> (me-&gt;update_handler) {
				me-&gt;update_handler(changed_flags);
			}
		}
	});
	dispatch_source_set_cancel_handler(me-&gt;update_source,
	^{
		mdns_release(me);
	});
	dispatch_activate(me-&gt;update_source);

	mdns_retain(me);
	nw_path_evaluator_set_update_handler(me-&gt;path_evaluator, _mdns_internal_queue(),
	^(nw_path_t path)
	{
		<span class="enscript-type">const</span> mdns_interface_flags_t new_flags = _mdns_get_interface_flags_from_nw_path(path, me-&gt;pending_flags);
		<span class="enscript-keyword">if</span> (new_flags != me-&gt;pending_flags) {
			me-&gt;pending_flags = new_flags;
			<span class="enscript-keyword">if</span> (me-&gt;update_source) {
				<span class="enscript-comment">// Note: mdns_interface_flag_reserved is used to ensure that the data is non-zero. According to the
</span>				<span class="enscript-comment">// dispatch_source_create(3) man page, if the data value is zero, the source handler won't be invoked.
</span>				dispatch_source_merge_data(me-&gt;update_source, me-&gt;pending_flags | mdns_interface_flag_reserved);
			}
		}
	});
	nw_path_evaluator_set_cancel_handler(me-&gt;path_evaluator,
	^{
		mdns_release(me);
	});
	nw_path_evaluator_start(me-&gt;path_evaluator);
	me-&gt;path_evaluator_started = true;

	mdns_interface_monitor_t *p = &amp;g_monitor_list;
	<span class="enscript-keyword">while</span> (*p != NULL) {
		p = &amp;(*p)-&gt;next;
	}
	mdns_retain(me);
	*p = me;

	<span class="enscript-comment">// This is called after adding the monitor to the global list to ensure that the initial NWI state check is aware
</span>	<span class="enscript-comment">// that the interface monitor exists.
</span>	_mdns_start_nwi_state_monitoring();
	err = kNoErr;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (err) {
		_mdns_interface_monitor_terminate(me, err);
	}
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_interface_monitor_terminate</span>(mdns_interface_monitor_t me, <span class="enscript-type">const</span> OSStatus error)
{
	dispatch_source_forget(&amp;me-&gt;update_source);
	<span class="enscript-keyword">if</span> (me-&gt;path_evaluator) {
		<span class="enscript-keyword">if</span> (me-&gt;path_evaluator_started) {
			nw_path_evaluator_cancel(me-&gt;path_evaluator);
		}
		nw_forget(&amp;me-&gt;path_evaluator);
	}
	<span class="enscript-keyword">for</span> (mdns_interface_monitor_t *p = &amp;g_monitor_list; *p; p = &amp;(*p)-&gt;next) {
		<span class="enscript-keyword">if</span> (*p == me) {
			*p = me-&gt;next;
			me-&gt;next = NULL;
			mdns_release(me);
			<span class="enscript-keyword">break</span>;
		}
	}
	mdns_retain(me);
	dispatch_async(me-&gt;user_queue,
	^{
		<span class="enscript-keyword">if</span> (me-&gt;event_handler) {
			me-&gt;event_handler(error ? mdns_event_error : mdns_event_invalidated, error);
		}
		mdns_release(me);
	});
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - NW Path Helpers
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MDNS_INTERFACE_FLAGS_FROM_NWPATH</span>		\
	(mdns_interface_flag_ipv4_connectivity |	\
	 mdns_interface_flag_ipv6_connectivity |	\
	 mdns_interface_flag_expensive         |	\
	 mdns_interface_flag_constrained)

<span class="enscript-type">static</span> mdns_interface_flags_t
<span class="enscript-function-name">_mdns_get_interface_flags_from_nw_path</span>(nw_path_t path, mdns_interface_flags_t current_flags)
{
	mdns_interface_flags_t flags = current_flags &amp; ~MDNS_INTERFACE_FLAGS_FROM_NWPATH;
	<span class="enscript-keyword">if</span> (nw_path_has_ipv4(path)) {
		flags |= mdns_interface_flag_ipv4_connectivity;
	}
	<span class="enscript-keyword">if</span> (nw_path_has_ipv6(path)) {
		flags |= mdns_interface_flag_ipv6_connectivity;
	}
	<span class="enscript-keyword">if</span> (nw_path_is_expensive(path)) {
		flags |= mdns_interface_flag_expensive;
	}
	<span class="enscript-keyword">if</span> (__builtin_available(macOS 10.15, *)) {
		<span class="enscript-keyword">if</span> (nw_path_is_constrained(path)) {
			flags |= mdns_interface_flag_constrained;
		}
	}
	<span class="enscript-keyword">return</span> flags;
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - NWI Helpers
</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NWI_IFSTATE_FLAGS_HAS_CLAT46</span>)
	#define NWI_IFSTATE_FLAGS_HAS_CLAT46	0x0040
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MDNS_INTERFACE_FLAGS_FROM_NWI_STATE</span>		mdns_interface_flag_clat46

<span class="enscript-type">static</span> mdns_interface_flags_t
<span class="enscript-function-name">_mdns_get_interface_flags_from_nwi_state</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, mdns_interface_flags_t current_flags)
{
	__block nwi_ifstate_flags ifstate_flags = 0;
	dispatch_sync(_mdns_nwi_state_mutex_queue(),
	^{
		<span class="enscript-keyword">if</span> (g_nwi_state) {
			<span class="enscript-type">const</span> nwi_ifstate_t ifstate = nwi_state_get_ifstate(g_nwi_state, ifname);
			<span class="enscript-keyword">if</span> (ifstate) {
				ifstate_flags = nwi_ifstate_get_flags(ifstate);
			}
		}
	});
	mdns_interface_flags_t flags = current_flags &amp; ~MDNS_INTERFACE_FLAGS_FROM_NWI_STATE;
	<span class="enscript-keyword">if</span> (ifstate_flags &amp; NWI_IFSTATE_FLAGS_HAS_CLAT46) {
		flags |= mdns_interface_flag_clat46;
	}
	<span class="enscript-keyword">return</span> flags;
}

<span class="enscript-comment">//======================================================================================================================
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_nwi_state_update</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_start_nwi_state_monitoring</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> s_nwi_notify_token = NOTIFY_TOKEN_INVALID;
	<span class="enscript-keyword">if</span> (s_nwi_notify_token == NOTIFY_TOKEN_INVALID) {
		<span class="enscript-type">const</span> uint32_t status = notify_register_dispatch(nwi_state_get_notify_key(), &amp;s_nwi_notify_token,
			_mdns_internal_queue(),
		^(__unused <span class="enscript-type">int</span> token)
		{
			_mdns_nwi_state_update();
		});
		<span class="enscript-keyword">if</span> (s_nwi_notify_token == NOTIFY_TOKEN_INVALID) {
			os_log_error(_mdns_nwi_log(), <span class="enscript-string">&quot;Failed to register for NWI state notifications (status %u)&quot;</span>, status);
		} <span class="enscript-keyword">else</span> {
			_mdns_nwi_state_update();
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_mdns_nwi_state_update</span>(<span class="enscript-type">void</span>)
{
	nwi_state_t new_state = nwi_state_copy();
	<span class="enscript-keyword">if</span> (!new_state) {
		os_log_error(_mdns_nwi_log(), <span class="enscript-string">&quot;Failed to copy NWI state&quot;</span>);
	}
	__block nwi_state_t old_state;
	dispatch_sync(_mdns_nwi_state_mutex_queue(),
	^{
		old_state	= g_nwi_state;
		g_nwi_state	= new_state;
	});
	nwi_state_release_null_safe(old_state);
	<span class="enscript-keyword">for</span> (mdns_interface_monitor_t m = g_monitor_list; m; m = m-&gt;next) {
		<span class="enscript-type">const</span> mdns_interface_flags_t new_flags = _mdns_get_interface_flags_from_nwi_state(m-&gt;ifname, m-&gt;pending_flags);
		<span class="enscript-keyword">if</span> (new_flags != m-&gt;pending_flags) {
			m-&gt;pending_flags = new_flags;
			<span class="enscript-keyword">if</span> (m-&gt;update_source) {
				<span class="enscript-comment">// Note: mdns_interface_flag_reserved is used to ensure that the data is non-zero. According to the
</span>				<span class="enscript-comment">// dispatch_source_create(3) man page, if the data value is zero, the source handler won't be invoked.
</span>				dispatch_source_merge_data(m-&gt;update_source, m-&gt;pending_flags | mdns_interface_flag_reserved);
			}
		}
	}
}

<span class="enscript-comment">//======================================================================================================================
</span><span class="enscript-comment">// MARK: - General Helpers
</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">_mdns_snprintf_add</span>(<span class="enscript-type">char</span> **ptr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lim, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	<span class="enscript-type">char</span> * <span class="enscript-type">const</span>	dst = *ptr;
	<span class="enscript-type">const</span> size_t	len = (size_t)(lim - dst);
	<span class="enscript-type">int</span>				n;

	require_action_quiet(len &gt; 0, exit, n = 0);

	va_list args;
	va_start(args, fmt);
	n = vsnprintf(dst, len, fmt, args);
	va_end(args);
	require_quiet(n &gt;= 0, exit);

	<span class="enscript-keyword">if</span> (((size_t)n) &gt; len) {
		n = (<span class="enscript-type">int</span>)len;
	}
	*ptr = dst + n;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> n;
}
</pre>
<hr />
</body></html>