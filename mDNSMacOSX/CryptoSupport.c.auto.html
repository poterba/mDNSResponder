<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CryptoSupport.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">CryptoSupport.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="CryptoSupport.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// CryptoSupport.c
</span><span class="enscript-comment">// Supporting routines for DNSSEC crypto
</span><span class="enscript-comment">// ***************************************************************************
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CommonCrypto/CommonDigest.h&gt;</span>  // For Hash algorithms SHA1 etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dispatch/dispatch.h&gt;</span>          // For Base32/Base64 encoding/decoding
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dispatch/private.h&gt;</span>          // dispatch_data_create_with_transform
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoAlg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoSupport.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssec.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSSECSupport.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Security/SecRSAKey.h&gt;</span>                  // For RSA_SHA1 etc. verification
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Security/Security.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">TARGET_OS_IPHONE</span>
mDNSlocal SecKeyRef <span class="enscript-function-name">SecKeyCreateRSAPublicKey_OSX</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *asn1, <span class="enscript-type">int</span> length);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    dispatch_data_t encData;
    dispatch_data_t encMap;
    dispatch_data_t encNULL;
}encContext;

mDNSlocal mStatus <span class="enscript-function-name">enc_create</span>(AlgContext *ctx)
{
    encContext *ptr;

    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE32</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE64</span>:
        ptr = (encContext *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*ptr));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;enc_create: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    ptr-&gt;encData = NULL;
    ptr-&gt;encMap = NULL;
    <span class="enscript-comment">// The encoded data is not NULL terminated. So, we concatenate a null byte later when we encode and map
</span>    <span class="enscript-comment">// the real data.
</span>    ptr-&gt;encNULL = dispatch_data_create(<span class="enscript-string">&quot;&quot;</span>, 1, dispatch_get_global_queue(0, 0), ^{});
    <span class="enscript-keyword">if</span> (!ptr-&gt;encNULL)
    {
        mDNSPlatformMemFree(ptr);
        <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
    }
    ctx-&gt;context = ptr;
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">enc_destroy</span>(AlgContext *ctx)
{
    encContext *ptr = (encContext *)ctx-&gt;context;
    <span class="enscript-keyword">if</span> (ptr-&gt;encData) dispatch_release(ptr-&gt;encData);
    <span class="enscript-keyword">if</span> (ptr-&gt;encMap) dispatch_release(ptr-&gt;encMap);
    <span class="enscript-keyword">if</span> (ptr-&gt;encNULL) dispatch_release(ptr-&gt;encNULL);
    mDNSPlatformMemFree(ptr);
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">enc_add</span>(AlgContext *ctx, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, mDNSu32 len)
{
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE32</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE64</span>:
    {
        encContext *ptr = (encContext *)ctx-&gt;context;
        dispatch_data_t src_data = dispatch_data_create(data, len, dispatch_get_global_queue(0, 0), ^{});
        <span class="enscript-keyword">if</span> (!src_data)
        {
            LogMsg(<span class="enscript-string">&quot;enc_add: dispatch_data_create src failed&quot;</span>);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }
        dispatch_data_t dest_data = dispatch_data_create_with_transform(src_data, DISPATCH_DATA_FORMAT_TYPE_NONE,
                                                                        (ctx-&gt;alg == ENC_BASE32 ? DISPATCH_DATA_FORMAT_TYPE_BASE32HEX : DISPATCH_DATA_FORMAT_TYPE_BASE64));
        dispatch_release(src_data);
        <span class="enscript-keyword">if</span> (!dest_data)
        {
            LogMsg(<span class="enscript-string">&quot;enc_add: dispatch_data_create dst failed&quot;</span>);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }
        ptr-&gt;encData = dest_data;

        <span class="enscript-keyword">return</span> mStatus_NoError;
    }
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;enc_add: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
}

mDNSlocal mDNSu8* <span class="enscript-function-name">enc_encode</span>(AlgContext *ctx)
{
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *result = NULL;

    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE32</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ENC_BASE64</span>:
    {
        encContext *ptr = (encContext *)ctx-&gt;context;
        size_t size;
        dispatch_data_t dest_data = ptr-&gt;encData;
        dispatch_data_t data = dispatch_data_create_concat(dest_data, ptr-&gt;encNULL);

        <span class="enscript-keyword">if</span> (!data)
        {
            LogMsg(<span class="enscript-string">&quot;enc_encode: cannot concatenate&quot;</span>);
            <span class="enscript-keyword">return</span> NULL;
        }

        dispatch_data_t map = dispatch_data_create_map(data, &amp;result, &amp;size);
        <span class="enscript-keyword">if</span> (!map)
        {
            LogMsg(<span class="enscript-string">&quot;enc_encode: cannot create map %d&quot;</span>, ctx-&gt;alg);
            <span class="enscript-keyword">return</span> NULL;
        }
        dispatch_release(dest_data);
        ptr-&gt;encData = data;
        ptr-&gt;encMap = map;

        <span class="enscript-keyword">return</span> (mDNSu8 *)result;
    }
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;enc_encode: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">sha_create</span>(AlgContext *ctx)
{
    mDNSu8 *ptr;
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
        ptr = (mDNSu8 *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(CC_SHA1_CTX));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        CC_SHA1_Init((CC_SHA1_CTX *)ptr);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        ptr = (mDNSu8 *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(CC_SHA256_CTX));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        CC_SHA256_Init((CC_SHA256_CTX *)ptr);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;sha_create: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    ctx-&gt;context = ptr;
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">sha_destroy</span>(AlgContext *ctx)
{
    mDNSPlatformMemFree(ctx-&gt;context);
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mDNSu32 <span class="enscript-function-name">sha_len</span>(AlgContext *ctx)
{
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
        <span class="enscript-keyword">return</span> CC_SHA1_DIGEST_LENGTH;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        <span class="enscript-keyword">return</span> CC_SHA256_DIGEST_LENGTH;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;sha_len: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">sha_add</span>(AlgContext *ctx, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, mDNSu32 len)
{
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
        CC_SHA1_Update((CC_SHA1_CTX *)ctx-&gt;context, data, len);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        CC_SHA256_Update((CC_SHA256_CTX *)ctx-&gt;context, data, len);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;sha_add: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">sha_verify</span>(AlgContext *ctx, mDNSu8 *key, mDNSu32 keylen, mDNSu8 *digestIn, mDNSu32 dlen)
{
    mDNSu8 digest[CC_SHA512_DIGEST_LENGTH];
    mDNSu32 digestLen;

    (<span class="enscript-type">void</span>) key;   <span class="enscript-comment">//unused
</span>    (<span class="enscript-type">void</span>)keylen; <span class="enscript-comment">//unused
</span>    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
        digestLen = CC_SHA1_DIGEST_LENGTH;
        CC_SHA1_Final(digest, (CC_SHA1_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        digestLen = CC_SHA256_DIGEST_LENGTH;
        CC_SHA256_Final(digest, (CC_SHA256_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;sha_verify: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (dlen != digestLen)
    {
        LogMsg(<span class="enscript-string">&quot;sha_verify(Alg %d): digest len mismatch len %u, expected %u&quot;</span>, ctx-&gt;alg, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)dlen, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)digestLen);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (!memcmp(digest, digestIn, digestLen))
        <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mStatus_NoAuth;
}

mDNSlocal mStatus <span class="enscript-function-name">sha_final</span>(AlgContext *ctx, <span class="enscript-type">void</span> *digestOut, mDNSu32 dlen)
{
    mDNSu8 digest[CC_SHA512_DIGEST_LENGTH];
    mDNSu32 digestLen;

    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
        digestLen = CC_SHA1_DIGEST_LENGTH;
        CC_SHA1_Final(digest, (CC_SHA1_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        digestLen = CC_SHA256_DIGEST_LENGTH;
        CC_SHA256_Final(digest, (CC_SHA256_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;sha_final: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (dlen != digestLen)
    {
        LogMsg(<span class="enscript-string">&quot;sha_final(Alg %d): digest len mismatch len %u, expected %u&quot;</span>, ctx-&gt;alg, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)dlen, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)digestLen);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    memcpy(digestOut, digest, digestLen);
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">rsa_sha_create</span>(AlgContext *ctx)
{
    mDNSu8 *ptr;
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
        ptr = (mDNSu8 *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(CC_SHA1_CTX));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        CC_SHA1_Init((CC_SHA1_CTX *)ptr);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
        ptr = (mDNSu8 *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(CC_SHA256_CTX));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        CC_SHA256_Init((CC_SHA256_CTX *)ptr);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        ptr = (mDNSu8 *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(CC_SHA512_CTX));
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
        CC_SHA512_Init((CC_SHA512_CTX *)ptr);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;rsa_sha_create: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    ctx-&gt;context = ptr;
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mStatus <span class="enscript-function-name">rsa_sha_destroy</span>(AlgContext *ctx)
{
    mDNSPlatformMemFree(ctx-&gt;context);
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal mDNSu32 <span class="enscript-function-name">rsa_sha_len</span>(AlgContext *ctx)
{
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
        <span class="enscript-keyword">return</span> CC_SHA1_DIGEST_LENGTH;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
        <span class="enscript-keyword">return</span> CC_SHA256_DIGEST_LENGTH;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        <span class="enscript-keyword">return</span> CC_SHA512_DIGEST_LENGTH;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;rsa_sha_len: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">rsa_sha_add</span>(AlgContext *ctx, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, mDNSu32 len)
{
    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
        CC_SHA1_Update((CC_SHA1_CTX *)ctx-&gt;context, data, len);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
        CC_SHA256_Update((CC_SHA256_CTX *)ctx-&gt;context, data, len);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        CC_SHA512_Update((CC_SHA512_CTX *)ctx-&gt;context, data, len);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;rsa_sha_add: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal SecKeyRef <span class="enscript-function-name">rfc3110_import</span>(<span class="enscript-type">const</span> mDNSu8 *data, <span class="enscript-type">const</span> mDNSu32 len)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> max_modulus_bytes = 512;    <span class="enscript-comment">// Modulus is limited to 4096 bits (512 octets) in length.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> max_exp_bytes = 512;        <span class="enscript-comment">// Exponent is limited to 4096 bits (512 octets) in length.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> asn1_type_bytes = 3;        <span class="enscript-comment">// Since there is an ASN1 SEQ and two INTs.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> asn1_max_len_bytes = 3 * 3; <span class="enscript-comment">// Capped at 3 due to max payload size.
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> asn1[max_modulus_bytes + 1 + max_exp_bytes + asn1_type_bytes + asn1_max_len_bytes]; <span class="enscript-comment">// +1 is for leading 0 for non negative asn1 number
</span>    <span class="enscript-type">const</span> mDNSu8 *modulus;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> modulus_length;
    <span class="enscript-type">const</span> mDNSu8 *exponent;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> exp_length;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_length_bytes;
    mDNSu32 index = 0;
    mDNSu32 asn1_length = 0;

    <span class="enscript-comment">// Validate Input
</span>    <span class="enscript-keyword">if</span> (!data)
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// we have to have at least 1 byte for the length
</span>    <span class="enscript-keyword">if</span> (len &lt; 1)
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// Parse Modulus and Exponent
</span>
    <span class="enscript-comment">// If the first byte is zero, then the exponent length is in the three-byte format, otherwise the length is in the first byte.
</span>    <span class="enscript-keyword">if</span> (data[0] == 0)
    {
        <span class="enscript-keyword">if</span> (len &lt; 3)
            <span class="enscript-keyword">return</span> NULL;
        exp_length = (data[1] &lt;&lt; 8) | data[2];
        num_length_bytes = 3;
    }
    <span class="enscript-keyword">else</span>
    {
        exp_length = data[0];
        num_length_bytes = 1;
    }

    <span class="enscript-comment">// RFC3110 limits the exponent length to 4096 bits (512 octets).
</span>    <span class="enscript-keyword">if</span> (exp_length &gt; 512)
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// We have to have at least len bytes + size of exponent.
</span>    <span class="enscript-keyword">if</span> (len &lt; (num_length_bytes + exp_length))
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// The modulus is the remaining space.
</span>    modulus_length = len - (num_length_bytes + exp_length);

    <span class="enscript-comment">// RFC3110 limits the modulus length to 4096 bits (512 octets).
</span>    <span class="enscript-keyword">if</span> (modulus_length &gt; 512)
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-keyword">if</span> (modulus_length &lt; 1)
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// add 1 to modulus length for pre-ceding 0 t make ASN1 value non-negative
</span>    ++modulus_length;

    exponent = &amp;data[num_length_bytes];
    modulus = &amp;data[num_length_bytes + exp_length];

    <span class="enscript-comment">// 2 bytes for commands since first doesn't count
</span>    <span class="enscript-comment">// 2 bytes for min 1 byte length field
</span>    asn1_length = modulus_length + exp_length + 2 + 2;

    <span class="enscript-comment">// Account for modulus length causing INT length field to grow.
</span>    <span class="enscript-keyword">if</span> (modulus_length &gt;= 128)
    {
        <span class="enscript-keyword">if</span> (modulus_length &gt; 255)
            asn1_length += 2;
        <span class="enscript-keyword">else</span>
            asn1_length += 1;
    }

    <span class="enscript-comment">// Account for exponent length causing INT length field to grow.
</span>    <span class="enscript-keyword">if</span> (exp_length &gt;= 128)
    {
        <span class="enscript-keyword">if</span> (exp_length &gt; 255)
            asn1_length += 2;
        <span class="enscript-keyword">else</span>
            asn1_length += 1;
    }

    <span class="enscript-comment">// Construct ASN1 formatted public key
</span>    <span class="enscript-comment">// Write ASN1 SEQ byte
</span>    asn1[index++] = 0x30;

    <span class="enscript-comment">// Write ASN1 length for SEQ
</span>    <span class="enscript-keyword">if</span> (asn1_length &lt; 128)
    {
        asn1[index++] = asn1_length &amp; 0xFF;
    }
    <span class="enscript-keyword">else</span>
    {
        asn1[index++] = (0x80 | ((asn1_length &gt; 255) ? 2 : 1));
        <span class="enscript-keyword">if</span> (asn1_length &gt; 255)
            asn1[index++] = (asn1_length &amp; 0xFF00) &gt;&gt; 8;
        asn1[index++] = asn1_length &amp; 0xFF;
    }

    <span class="enscript-comment">// Write ASN1 INT for modulus
</span>    asn1[index++] = 0x02;
    <span class="enscript-comment">// Write ASN1 length for INT
</span>    <span class="enscript-keyword">if</span> (modulus_length &lt; 128)
    {
        asn1[index++] = modulus_length &amp; 0xFF;
    }
    <span class="enscript-keyword">else</span>
    {
        asn1[index++] = 0x80 | ((modulus_length &gt; 255) ? 2 : 1);
        <span class="enscript-keyword">if</span> (modulus_length &gt; 255)
            asn1[index++] = (modulus_length &amp; 0xFF00) &gt;&gt; 8;
        asn1[index++] = modulus_length &amp; 0xFF;
    }

    <span class="enscript-comment">// Write preceding 0 so our integer isn't negative
</span>    asn1[index++] = 0x00;
    <span class="enscript-comment">// Write actual modulus (-1 for preceding 0)
</span>    memcpy(&amp;asn1[index], modulus, modulus_length - 1);
    index += (modulus_length - 1);

    <span class="enscript-comment">// Write ASN1 INT for exponent
</span>    asn1[index++] = 0x02;
    <span class="enscript-comment">// Write ASN1 length for INT
</span>    <span class="enscript-keyword">if</span> (exp_length &lt; 128)
    {
        asn1[index++] = exp_length &amp; 0xFF;
    }
    <span class="enscript-keyword">else</span>
    {
        asn1[index++] = 0x80 | ((exp_length &gt; 255) ? 2 : 1);
        <span class="enscript-keyword">if</span> (exp_length &gt; 255)
            asn1[index++] = (exp_length &amp; 0xFF00) &gt;&gt; 8;
        asn1[index++] = exp_length &amp; 0xFF;
    }
    <span class="enscript-comment">// Write exponent bytes
</span>    memcpy(&amp;asn1[index], exponent, exp_length);
    index += exp_length;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
    <span class="enscript-comment">// index contains bytes written, use it for length
</span>    <span class="enscript-keyword">return</span> (SecKeyCreateRSAPublicKey(NULL, asn1, index, kSecKeyEncodingPkcs1));
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> (SecKeyCreateRSAPublicKey_OSX(asn1, index));
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
mDNSlocal mStatus <span class="enscript-function-name">rsa_sha_verify</span>(AlgContext *ctx, mDNSu8 *key, mDNSu32 keylen, mDNSu8 *signature, mDNSu32 siglen)
{
    SecKeyRef keyref;
    OSStatus result;
    mDNSu8 digest[CC_SHA512_DIGEST_LENGTH];
    <span class="enscript-type">int</span> digestlen;
    <span class="enscript-type">int</span> cryptoAlg;

    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
        cryptoAlg = kSecPaddingPKCS1SHA1;
        digestlen = CC_SHA1_DIGEST_LENGTH;
        CC_SHA1_Final(digest, (CC_SHA1_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
        cryptoAlg = kSecPaddingPKCS1SHA256;
        digestlen = CC_SHA256_DIGEST_LENGTH;
        CC_SHA256_Final(digest, (CC_SHA256_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        cryptoAlg = kSecPaddingPKCS1SHA512;
        digestlen = CC_SHA512_DIGEST_LENGTH;
        CC_SHA512_Final(digest, (CC_SHA512_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    keyref = rfc3110_import(key, keylen);
    <span class="enscript-keyword">if</span> (!keyref)
    {
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Error decoding rfc3110 key data&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
    }
    result = SecKeyRawVerify(keyref, cryptoAlg, digest, digestlen, signature, siglen);
    CFRelease(keyref);
    <span class="enscript-keyword">if</span> (result != noErr)
    {
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Failed for alg %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;rsa_sha_verify: Passed for alg %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_NoError;
    }
}
#<span class="enscript-reference">else</span> // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

mDNSlocal SecKeyRef <span class="enscript-function-name">SecKeyCreateRSAPublicKey_OSX</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *asn1, <span class="enscript-type">int</span> length)
{
    SecKeyRef result = NULL;
    
    SecExternalFormat extFormat = kSecFormatBSAFE;
    SecExternalItemType itemType = kSecItemTypePublicKey;
    CFArrayRef outArray = NULL;

    CFDataRef keyData = CFDataCreate(NULL, asn1, length);
    <span class="enscript-keyword">if</span> (!keyData)
        <span class="enscript-keyword">return</span> NULL;

    OSStatus err =  SecItemImport(keyData, NULL, &amp;extFormat, &amp;itemType, 0, NULL, NULL, &amp;outArray);
    
    CFRelease(keyData);
    <span class="enscript-keyword">if</span> (noErr != err || outArray == NULL)
    {
        <span class="enscript-keyword">if</span> (outArray)
            CFRelease(outArray);
        <span class="enscript-keyword">return</span> NULL;
    }
    
    result = (SecKeyRef)CFArrayGetValueAtIndex(outArray, 0);
    <span class="enscript-keyword">if</span> (result == NULL)
    {
        CFRelease(outArray);
        <span class="enscript-keyword">return</span> NULL;
    }
    
    CFRetain(result);
    CFRelease(outArray);
    <span class="enscript-keyword">return</span> result;
}

mDNSlocal Boolean <span class="enscript-function-name">VerifyData</span>(SecKeyRef key, CFStringRef digestStr, mDNSu8 *digest, <span class="enscript-type">int</span> dlen, <span class="enscript-type">int</span> digestlenAttr, mDNSu8 *sig, <span class="enscript-type">int</span> siglen, CFStringRef digest_type)
{
    CFErrorRef error;
    Boolean ret;
    
    CFDataRef signature = CFDataCreate(NULL, sig, siglen);
    <span class="enscript-keyword">if</span> (!signature)
        <span class="enscript-keyword">return</span> false;
    
    SecTransformRef verifyXForm = SecVerifyTransformCreate(key, signature, &amp;error);
    CFRelease(signature);
    <span class="enscript-keyword">if</span> (verifyXForm == NULL)
    {
        <span class="enscript-keyword">return</span> false;
    }
    
    <span class="enscript-comment">// tell the transform what type of data it is geting
</span>    <span class="enscript-keyword">if</span> (!SecTransformSetAttribute(verifyXForm, kSecInputIsAttributeName, digest_type, &amp;error))
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: SecTransformSetAttribute digest_type&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    
    <span class="enscript-keyword">if</span> (!SecTransformSetAttribute(verifyXForm, kSecDigestTypeAttribute, digestStr, &amp;error))
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: SecTransformSetAttribute digestStr&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    
    CFNumberRef digestLengthRef = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &amp;digestlenAttr);
    <span class="enscript-keyword">if</span> (digestLengthRef == NULL)
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: CFNumberCreate failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    
    ret = SecTransformSetAttribute(verifyXForm, kSecDigestLengthAttribute, digestLengthRef, &amp;error);
    CFRelease(digestLengthRef);
    <span class="enscript-keyword">if</span> (!ret)
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: SecTransformSetAttribute digestLengthRef&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    
    CFDataRef dataToSign = CFDataCreate(NULL, digest, dlen);
    <span class="enscript-keyword">if</span> (dataToSign ==  NULL)
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: CFDataCreate failed&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }

    ret = SecTransformSetAttribute(verifyXForm, kSecTransformInputAttributeName, dataToSign, &amp;error);
    CFRelease(dataToSign);
    <span class="enscript-keyword">if</span> (!ret)
    {
        LogMsg(<span class="enscript-string">&quot;VerifyData: SecTransformSetAttribute TransformAttributeName&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    
    CFBooleanRef boolRef = SecTransformExecute(verifyXForm, &amp;error);
    ret = (boolRef != NULL) ? CFBooleanGetValue(boolRef) : false;
    <span class="enscript-keyword">if</span> (boolRef != NULL) CFRelease(boolRef);
    CFRelease(verifyXForm);

    <span class="enscript-keyword">if</span> (error != NULL)
    {
        CFStringRef errStr = CFErrorCopyDescription(error);
        <span class="enscript-type">char</span> errorbuf[128];
        errorbuf[0] = 0;
        <span class="enscript-keyword">if</span> (errStr != NULL)
        {
            <span class="enscript-keyword">if</span> (!CFStringGetCString(errStr, errorbuf, <span class="enscript-keyword">sizeof</span>(errorbuf), kCFStringEncodingUTF8))
            {
                LogMsg(<span class="enscript-string">&quot;VerifyData: CFStringGetCString failed&quot;</span>);
            }
            CFRelease(errStr);
        }
        LogMsg(<span class="enscript-string">&quot;VerifyData: SecTransformExecute failed with %s&quot;</span>, errorbuf);
        <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-keyword">return</span> ret;
<span class="enscript-reference">err</span>:
    CFRelease(verifyXForm);
    <span class="enscript-keyword">return</span> false;
}

mDNSlocal mStatus <span class="enscript-function-name">rsa_sha_verify</span>(AlgContext *ctx, mDNSu8 *key, mDNSu32 keylen, mDNSu8 *signature, mDNSu32 siglen)
{
    SecKeyRef keyref;
    mDNSu8 digest[CC_SHA512_DIGEST_LENGTH];
    <span class="enscript-type">int</span> digestlen;
    <span class="enscript-type">int</span> digestlenAttr;
    CFStringRef digestStr;
    mDNSBool ret;

    <span class="enscript-keyword">switch</span> (ctx-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
        digestStr = kSecDigestSHA1;
        digestlen = CC_SHA1_DIGEST_LENGTH;
        digestlenAttr = 0;
        CC_SHA1_Final(digest, (CC_SHA1_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
        digestStr = kSecDigestSHA2;
        digestlen = CC_SHA256_DIGEST_LENGTH;
        digestlenAttr = 256;
        CC_SHA256_Final(digest, (CC_SHA256_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        digestStr = kSecDigestSHA2;
        digestlen = CC_SHA512_DIGEST_LENGTH;
        digestlenAttr = 512;
        CC_SHA512_Final(digest, (CC_SHA512_CTX *)ctx-&gt;context);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Unsupported algorithm %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    keyref = rfc3110_import(key, keylen);
    <span class="enscript-keyword">if</span> (!keyref)
    {
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Error decoding rfc3110 key data&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
    }
    ret = VerifyData(keyref, digestStr, digest, digestlen, digestlenAttr, signature, siglen, kSecInputIsDigest);
    CFRelease(keyref);
    <span class="enscript-keyword">if</span> (!ret)
    {
        LogMsg(<span class="enscript-string">&quot;rsa_sha_verify: Failed for alg %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;rsa_sha_verify: Passed for alg %d&quot;</span>, ctx-&gt;alg);
        <span class="enscript-keyword">return</span> mStatus_NoError;
    }
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">TARGET_OS_IPHONE</span>

AlgFuncs sha_funcs = {sha_create, sha_destroy, sha_len, sha_add, sha_verify, mDNSNULL, sha_final};
AlgFuncs rsa_sha_funcs = {rsa_sha_create, rsa_sha_destroy, rsa_sha_len, rsa_sha_add, rsa_sha_verify, mDNSNULL, mDNSNULL};
AlgFuncs enc_funcs = {enc_create, enc_destroy, mDNSNULL, enc_add, mDNSNULL, enc_encode, mDNSNULL};

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DNSSEC_DISABLED</span>

mDNSexport mStatus <span class="enscript-function-name">DNSSECCryptoInit</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mStatus result;

    result = DigestAlgInit(SHA1_DIGEST_TYPE, &amp;sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = DigestAlgInit(SHA256_DIGEST_TYPE, &amp;sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = CryptoAlgInit(CRYPTO_RSA_SHA1, &amp;rsa_sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = CryptoAlgInit(CRYPTO_RSA_NSEC3_SHA1, &amp;rsa_sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = CryptoAlgInit(CRYPTO_RSA_SHA256, &amp;rsa_sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = CryptoAlgInit(CRYPTO_RSA_SHA512, &amp;rsa_sha_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = EncAlgInit(ENC_BASE32, &amp;enc_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;
    result = EncAlgInit(ENC_BASE64, &amp;enc_funcs);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span> result;

    result = DNSSECPlatformInit(m);

    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>

mDNSexport mStatus <span class="enscript-function-name">DNSSECCryptoInit</span>(mDNS *<span class="enscript-type">const</span> m)
{
    (<span class="enscript-type">void</span>) m;
    
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>


</pre>
<hr />
</body></html>