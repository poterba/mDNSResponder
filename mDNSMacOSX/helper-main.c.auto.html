<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>helper-main.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">helper-main.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="helper-main.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_FORTIFY_SOURCE</span> 2

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_error.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;servers/bootstrap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;launch.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pwd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Security/Security.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;helper.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;helper-server.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;xpc/private.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TARGET_OS_IPHONE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span> 1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">LAUNCH_JOBKEY_MACHSERVICES</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LAUNCH_JOBKEY_MACHSERVICES</span> <span class="enscript-string">&quot;MachServices&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LAUNCH_DATA_MACHPORT</span> 10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">launch_data_get_machport</span> launch_data_get_fd
#<span class="enscript-reference">endif</span>


<span class="enscript-type">int</span> mDNSHelperLogEnabled = 0;
os_log_t  log_handle = NULL;

<span class="enscript-type">static</span> dispatch_queue_t xpc_queue = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> opt_debug;
<span class="enscript-type">static</span> pthread_t idletimer_thread;

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> maxidle = 15;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> actualidle = 3600;

CFRunLoopRef gRunLoop = NULL;
CFRunLoopTimerRef gTimer = NULL;


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">handle_sigterm</span>(<span class="enscript-type">int</span> sig)
{
    <span class="enscript-comment">// os_log_debug(log_handle,&quot;entry sig=%d&quot;, sig);	Can't use syslog from within a signal handler
</span>    assert(sig == SIGTERM);
    helper_exit();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">initialize_logging</span>(<span class="enscript-type">void</span>)
{
    log_handle   = os_log_create(<span class="enscript-string">&quot;com.apple.mDNSResponderHelper&quot;</span>, <span class="enscript-string">&quot;INFO&quot;</span>);
    
    <span class="enscript-keyword">if</span> (!log_handle)
    {
        <span class="enscript-comment">// OS_LOG_DEFAULT is the default logging object, if you are not creating a custom subsystem/category
</span>        os_log_error(OS_LOG_DEFAULT, <span class="enscript-string">&quot;Could NOT create log handle in mDNSResponderHelper&quot;</span>);
    }
    
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">initialize_id</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">static</span> <span class="enscript-type">char</span> login[] = <span class="enscript-string">&quot;_mdnsresponder&quot;</span>;
    <span class="enscript-type">struct</span> passwd hardcode;
    <span class="enscript-type">struct</span> passwd *pwd = &amp;hardcode; <span class="enscript-comment">// getpwnam(login);
</span>    hardcode.pw_uid = 65;
    hardcode.pw_gid = 65;

    <span class="enscript-keyword">if</span> (!pwd)
    {
        os_log(log_handle, <span class="enscript-string">&quot;Could not find account name `%s'.  I will only help root.&quot;</span>, login);
        <span class="enscript-keyword">return</span>;
    }
    mDNSResponderUID = pwd-&gt;pw_uid;
    mDNSResponderGID = pwd-&gt;pw_gid;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">diediedie</span>(CFRunLoopTimerRef timer, <span class="enscript-type">void</span> *context)
{
    os_log_info(log_handle, <span class="enscript-string">&quot;entry %p %p %lu&quot;</span>, timer, context, actualidle);
    
    assert(gTimer == timer);
    os_log_info(log_handle, <span class="enscript-string">&quot;mDNSResponderHelper exiting after [%lu] seconds&quot;</span>, actualidle);
    
    <span class="enscript-keyword">if</span> (actualidle)
        helper_exit();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">pause_idle_timer</span>(<span class="enscript-type">void</span>)
{
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry&quot;</span>);
    assert(gTimer);
    assert(gRunLoop);
    CFRunLoopRemoveTimer(gRunLoop, gTimer, kCFRunLoopDefaultMode);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">unpause_idle_timer</span>(<span class="enscript-type">void</span>)
{
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry&quot;</span>);
    assert(gRunLoop);
    assert(gTimer);
    CFRunLoopAddTimer(gRunLoop, gTimer, kCFRunLoopDefaultMode);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">update_idle_timer</span>(<span class="enscript-type">void</span>)
{
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry&quot;</span>);
    assert(gTimer);
    CFRunLoopTimerSetNextFireDate(gTimer, CFAbsoluteTimeGetCurrent() + actualidle);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">idletimer</span>(<span class="enscript-type">void</span> *context)
{
    os_log_debug(log_handle,<span class="enscript-string">&quot;entry context=%p&quot;</span>, context);
    gRunLoop = CFRunLoopGetMain();

    unpause_idle_timer();

    <span class="enscript-keyword">for</span> (;;)
    {
        <span class="enscript-comment">// os_log_debug(log_handle,&quot;Running CFRunLoop&quot;);
</span>        CFRunLoopRun();
        sleep(1);
    }

    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">initialize_timer</span>()
{
    gTimer = CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + actualidle, actualidle, 0, 0, diediedie, NULL);
    <span class="enscript-type">int</span> err = 0;
    os_log_info(log_handle, <span class="enscript-string">&quot;mDNSResponderHelper initialize_timer() started&quot;</span>);

    <span class="enscript-keyword">if</span> (0 != (err = pthread_create(&amp;idletimer_thread, NULL, idletimer, NULL)))
        os_log(log_handle, <span class="enscript-string">&quot;Could not start idletimer thread: %s&quot;</span>, strerror(err));

    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/* 
 Reads the user's program arguments for mDNSResponderHelper
 For now we have only one option: mDNSHelperDebugLogging which is used to turn on mDNSResponderHelperLogging
 
 To turn ON mDNSResponderHelper Verbose Logging,
 1] sudo defaults write /Library/Preferences/com.apple.mDNSResponderHelper.plist mDNSHelperDebugLogging -bool YES
 2] sudo reboot
 
 To turn OFF mDNSResponderHelper Logging,
 1] sudo defaults delete /Library/Preferences/com.apple.mDNSResponderHelper.plist

 To view the current options set,
 1] plutil -p /Library/Preferences/com.apple.mDNSResponderHelper.plist
 OR
 1] sudo defaults read /Library/Preferences/com.apple.mDNSResponderHelper.plist
*/</span>

<span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">HelperPrefsGetValueBool</span>(CFStringRef key, mDNSBool defaultVal)
{
    CFBooleanRef boolean;
    mDNSBool result = defaultVal;
    
    boolean = CFPreferencesCopyAppValue(key, kmDNSHelperProgramArgs);
    <span class="enscript-keyword">if</span> (boolean != NULL)
    {
        <span class="enscript-keyword">if</span> (CFGetTypeID(boolean) == CFBooleanGetTypeID())
            result = CFBooleanGetValue(boolean) ? mDNStrue : mDNSfalse;
        CFRelease(boolean);
    }
    
    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">// Verify Client's Entitlement
</span><span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">check_entitlement</span>(xpc_connection_t conn, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *password)
{
    mDNSBool entitled = mDNSfalse;
    xpc_object_t ent = xpc_connection_copy_entitlement_value(conn, password);
    
    <span class="enscript-keyword">if</span> (ent)
    {
        <span class="enscript-keyword">if</span> (xpc_get_type(ent) == XPC_TYPE_BOOL &amp;&amp; xpc_bool_get_value(ent))
        {
            entitled = mDNStrue;
        }
        xpc_release(ent);
    }
    <span class="enscript-keyword">else</span>
    {
        os_log(log_handle, <span class="enscript-string">&quot;client entitlement is NULL&quot;</span>);
    }
    
    <span class="enscript-keyword">if</span> (!entitled)
        os_log(log_handle, <span class="enscript-string">&quot;entitlement check failed -&gt; client is missing entitlement!&quot;</span>);
    
    <span class="enscript-keyword">return</span> entitled;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">handle_request</span>(xpc_object_t req)
{
    mDNSu32 helper_mode = 0;
    <span class="enscript-type">int</span> error_code = 0;
    
    xpc_connection_t remote_conn = xpc_dictionary_get_remote_connection(req);
    xpc_object_t response = xpc_dictionary_create_reply(req);
    
    <span class="enscript-comment">// switch here based on dictionary to handle different requests from mDNSResponder
</span>    <span class="enscript-keyword">if</span> ((xpc_dictionary_get_uint64(req, kHelperMode)))
    {
        os_log_info(log_handle, <span class="enscript-string">&quot;Getting mDNSResponder request mode&quot;</span>);
        helper_mode = (mDNSu32)(xpc_dictionary_get_uint64(req, kHelperMode));
    }
   
    <span class="enscript-keyword">switch</span> (helper_mode)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">bpf_request</span>:
        {
            os_log_info(log_handle, <span class="enscript-string">&quot;Calling new RequestBPF()&quot;</span>);
            RequestBPF();
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">set_name</span>:
        {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *old_name;
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *new_name;
            <span class="enscript-type">int</span> pref_key = 0;
            
            pref_key = (<span class="enscript-type">int</span>)(xpc_dictionary_get_uint64(req, kPrefsNameKey));
            old_name = xpc_dictionary_get_string(req, kPrefsOldName);
            new_name = xpc_dictionary_get_string(req, kPrefsNewName);
            
            os_log_info(log_handle, <span class="enscript-string">&quot;Calling new SetName() oldname: %s newname: %s key:%d&quot;</span>, old_name, new_name, pref_key);
            PreferencesSetName(pref_key, old_name, new_name);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">p2p_packetfilter</span>:
        {
            size_t count = 0;
            pfArray_t pfports;
            pfArray_t pfprotocols;
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *if_name;
            uint32_t cmd;
            xpc_object_t xpc_obj_port_array;
            size_t port_array_count = 0;
            xpc_object_t xpc_obj_protocol_array;
            size_t protocol_array_count = 0;
            
            cmd = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;pf_opcode&quot;</span>);
            if_name = xpc_dictionary_get_string(req, <span class="enscript-string">&quot;pf_ifname&quot;</span>);
            xpc_obj_port_array = xpc_dictionary_get_value(req, <span class="enscript-string">&quot;xpc_obj_array_port&quot;</span>);
            <span class="enscript-keyword">if</span> ((<span class="enscript-type">void</span> *)xpc_obj_port_array != NULL)
                port_array_count = xpc_array_get_count(xpc_obj_port_array);
            xpc_obj_protocol_array = xpc_dictionary_get_value(req, <span class="enscript-string">&quot;xpc_obj_array_protocol&quot;</span>);
            <span class="enscript-keyword">if</span> ((<span class="enscript-type">void</span> *)xpc_obj_protocol_array != NULL)
                protocol_array_count = xpc_array_get_count(xpc_obj_protocol_array);
            <span class="enscript-keyword">if</span> (port_array_count != protocol_array_count)
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (port_array_count &gt; PFPortArraySize)
                <span class="enscript-keyword">break</span>;
            count = port_array_count;

            <span class="enscript-keyword">for</span> (size_t i = 0; i &lt; count; i++) {
                pfports[i] = (uint16_t)xpc_array_get_uint64(xpc_obj_port_array, i);
                pfprotocols[i] = (uint16_t)xpc_array_get_uint64(xpc_obj_protocol_array, i);
            }

            os_log_info(log_handle,<span class="enscript-string">&quot;Calling new PacketFilterControl()&quot;</span>);
            PacketFilterControl(cmd, if_name, count, pfports, pfprotocols);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">user_notify</span>:
        {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *title;
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg;
            title = xpc_dictionary_get_string(req, <span class="enscript-string">&quot;notify_title&quot;</span>);
            msg   = xpc_dictionary_get_string(req, <span class="enscript-string">&quot;notify_msg&quot;</span>);
            
            os_log_info(log_handle,<span class="enscript-string">&quot;Calling new UserNotify() title:%s msg:%s&quot;</span>, title, msg);
            UserNotify(title, msg);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">power_req</span>:
        {
            <span class="enscript-type">int</span> key, interval;
            key        = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;powerreq_key&quot;</span>);
            interval   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;powerreq_interval&quot;</span>);
            
            os_log_info(log_handle,<span class="enscript-string">&quot;Calling new PowerRequest() key[%d] interval[%d]&quot;</span>, key, interval);
            PowerRequest(key, interval, &amp;error_code);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">send_wakepkt</span>:
        {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ether_addr;
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ip_addr;
            <span class="enscript-type">int</span> iteration;
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> if_id;
            
            if_id = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;interface_index&quot;</span>);
            ether_addr = xpc_dictionary_get_string(req, <span class="enscript-string">&quot;ethernet_address&quot;</span>);
            ip_addr = xpc_dictionary_get_string(req, <span class="enscript-string">&quot;ip_address&quot;</span>);
            iteration = (<span class="enscript-type">int</span>)xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;swp_iteration&quot;</span>);
            
            os_log_info(log_handle, <span class="enscript-string">&quot;Calling new SendWakeupPacket() ether_addr[%s] ip_addr[%s] if_id[%d] iteration[%d]&quot;</span>,
                           ether_addr, ip_addr, if_id, iteration);
            SendWakeupPacket(if_id, ether_addr, ip_addr, iteration);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">set_localaddr_cacheentry</span>:
        {
            <span class="enscript-type">int</span> if_index, family;
            size_t ip_len, eth_len;

            if_index = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;slace_ifindex&quot;</span>);
            family   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;slace_family&quot;</span>);

            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> ip = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;slace_ip&quot;</span>, &amp;ip_len);
            <span class="enscript-keyword">if</span> (ip_len != <span class="enscript-keyword">sizeof</span>(v6addr_t))
            {
                error_code = kHelperErr_ParamErr;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> eth = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;slace_eth&quot;</span>, &amp;eth_len);
            <span class="enscript-keyword">if</span> (eth_len != <span class="enscript-keyword">sizeof</span>(ethaddr_t))
            {
                error_code = kHelperErr_ParamErr;
                <span class="enscript-keyword">break</span>;
            }

            os_log_info(log_handle, <span class="enscript-string">&quot;Calling new SetLocalAddressCacheEntry() if_index[%d] family[%d] &quot;</span>, if_index, family);

            SetLocalAddressCacheEntry(if_index, family, ip, eth, &amp;error_code);
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">send_keepalive</span>:
        {
            uint16_t lport, rport, win;
            uint32_t seq, ack;
            size_t sadd6_len, dadd6_len;
            
            lport = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;send_keepalive_lport&quot;</span>);
            rport = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;send_keepalive_rport&quot;</span>);
            seq   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;send_keepalive_seq&quot;</span>);
            ack   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;send_keepalive_ack&quot;</span>);
            win   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;send_keepalive_win&quot;</span>);
            
            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> sadd6 = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;send_keepalive_sadd&quot;</span>, &amp;sadd6_len);
            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> dadd6 = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;send_keepalive_dadd&quot;</span>, &amp;dadd6_len);
            <span class="enscript-keyword">if</span> ((sadd6_len != <span class="enscript-keyword">sizeof</span>(v6addr_t)) || (dadd6_len != <span class="enscript-keyword">sizeof</span>(v6addr_t)))
            {
                error_code = kHelperErr_ParamErr;
                <span class="enscript-keyword">break</span>;
            }

            os_log_info(log_handle, <span class="enscript-string">&quot;helper-main: handle_request: send_keepalive: lport is[%d] rport is[%d] seq is[%d] ack is[%d] win is[%d]&quot;</span>,
                           lport, rport, seq, ack, win);
            
            SendKeepalive(sadd6, dadd6, lport, rport, seq, ack, win);
            <span class="enscript-keyword">break</span>;
        }
    
        <span class="enscript-keyword">case</span> <span class="enscript-reference">retreive_tcpinfo</span>:
        {
            uint16_t lport, rport;
            <span class="enscript-type">int</span> family;
            uint32_t seq, ack;
            uint16_t win;
            int32_t  intfid;
            size_t laddr_len, raddr_len;
            
            lport    = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;retreive_tcpinfo_lport&quot;</span>);
            rport    = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;retreive_tcpinfo_rport&quot;</span>);
            family   = xpc_dictionary_get_uint64(req, <span class="enscript-string">&quot;retreive_tcpinfo_family&quot;</span>);

            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> laddr = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;retreive_tcpinfo_laddr&quot;</span>, &amp;laddr_len);
            <span class="enscript-type">const</span> uint8_t * <span class="enscript-type">const</span> raddr = (<span class="enscript-type">const</span> uint8_t *)xpc_dictionary_get_data(req, <span class="enscript-string">&quot;retreive_tcpinfo_raddr&quot;</span>, &amp;raddr_len);
            <span class="enscript-keyword">if</span> ((laddr_len != <span class="enscript-keyword">sizeof</span>(v6addr_t)) || (raddr_len != <span class="enscript-keyword">sizeof</span>(v6addr_t)))
            {
                error_code = kHelperErr_ParamErr;
                <span class="enscript-keyword">break</span>;
            }

            os_log_info(log_handle, <span class="enscript-string">&quot;helper-main: handle_request: retreive_tcpinfo: lport is[%d] rport is[%d] family is [%d]&quot;</span>,
                           lport, rport, family);
            
            RetrieveTCPInfo(family, laddr, lport, raddr, rport, &amp;seq, &amp;ack, &amp;win, &amp;intfid, &amp;error_code);
            
            <span class="enscript-keyword">if</span> (response)
            {
                xpc_dictionary_set_uint64(response, <span class="enscript-string">&quot;retreive_tcpinfo_seq&quot;</span>,  seq);
                xpc_dictionary_set_uint64(response, <span class="enscript-string">&quot;retreive_tcpinfo_ack&quot;</span>,  ack);
                xpc_dictionary_set_uint64(response, <span class="enscript-string">&quot;retreive_tcpinfo_win&quot;</span>,  win);
                xpc_dictionary_set_uint64(response, <span class="enscript-string">&quot;retreive_tcpinfo_ifid&quot;</span>, intfid);
            }
            
            os_log_info(log_handle, <span class="enscript-string">&quot;helper-main: handle_request: retreive_tcpinfo: seq is[%d] ack is[%d] win is [%d] intfid is [%d]&quot;</span>,
                           seq, ack, win, intfid);

            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-keyword">case</span> <span class="enscript-reference">keychain_getsecrets</span>:
        {
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_sec  = 0;
            <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> secrets = 0;
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> sec_cnt  = 0;
            
            os_log_info(log_handle,<span class="enscript-string">&quot;Calling new KeyChainGetSecrets()&quot;</span>);
            
            KeychainGetSecrets(&amp;num_sec, &amp;secrets, &amp;sec_cnt, &amp;error_code);
            
            <span class="enscript-keyword">if</span> (response)
            {
                xpc_dictionary_set_uint64(response, <span class="enscript-string">&quot;keychain_num_secrets&quot;</span>, num_sec);
                xpc_dictionary_set_data(response, <span class="enscript-string">&quot;keychain_secrets&quot;</span>, (<span class="enscript-type">void</span> *)secrets, sec_cnt);
            }
            
            os_log_info(log_handle,<span class="enscript-string">&quot;helper-main: handle_request: keychain_getsecrets: num_secrets is %u, secrets is %lu, secrets_Cnt is %u&quot;</span>,
                        num_sec, secrets, sec_cnt);
            
            <span class="enscript-keyword">if</span> (secrets)
                vm_deallocate(mach_task_self(), secrets, sec_cnt);
            
            <span class="enscript-keyword">break</span>;
        }
            
        <span class="enscript-reference">default</span>:
        {
            os_log(log_handle, <span class="enscript-string">&quot;handle_request: Unrecognized mode!&quot;</span>);
            error_code  = kHelperErr_UndefinedMode;
            <span class="enscript-keyword">break</span>;
        }
    }
    
    <span class="enscript-comment">// Return Response Status back to the client (essentially ACKing the request)
</span>    <span class="enscript-keyword">if</span> (response)
    {
        xpc_dictionary_set_uint64(response, kHelperReplyStatus, kHelperReply_ACK);
        xpc_dictionary_set_int64(response, kHelperErrCode, error_code);
        xpc_connection_send_message(remote_conn, response);
        xpc_release(response);
    }
    <span class="enscript-keyword">else</span>
    {
        os_log(log_handle, <span class="enscript-string">&quot;handle_requests: Response Dictionary could not be created!&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">accept_client</span>(xpc_connection_t conn)
{
    <span class="enscript-type">int</span> c_pid = xpc_connection_get_pid(conn);
    
    <span class="enscript-keyword">if</span> (!(check_entitlement(conn, kHelperService)))
    {
        os_log(log_handle, <span class="enscript-string">&quot;accept_client: Helper Client PID[%d] is missing Entitlement. Cancelling connection&quot;</span>, c_pid);
        xpc_connection_cancel(conn);
        <span class="enscript-keyword">return</span>;
    }
    
    xpc_retain(conn);
    xpc_connection_set_target_queue(conn, xpc_queue);
    xpc_connection_set_event_handler(conn, ^(xpc_object_t req_msg)
    {
        xpc_type_t type = xpc_get_type(req_msg);
                                         
        <span class="enscript-keyword">if</span> (type == XPC_TYPE_DICTIONARY)
        {
            os_log_info(log_handle,<span class="enscript-string">&quot;accept_client:conn:[%p] client[%d](mDNSResponder) requesting service&quot;</span>, (<span class="enscript-type">void</span> *) conn, c_pid);
            handle_request(req_msg);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-comment">// We hit this case ONLY if Client Terminated Connection OR Crashed
</span>        {
            os_log(log_handle, <span class="enscript-string">&quot;accept_client:conn:[%p] client[%d](mDNSResponder) teared down the connection (OR Crashed)&quot;</span>, (<span class="enscript-type">void</span> *) conn, c_pid);
            <span class="enscript-comment">// handle_termination();
</span>            xpc_release(conn);
        }
    });
    
    xpc_connection_resume(conn);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_helper_service</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *service_name)
{
    
    xpc_connection_t xpc_listener = xpc_connection_create_mach_service(service_name, NULL, XPC_CONNECTION_MACH_SERVICE_LISTENER);
    <span class="enscript-keyword">if</span> (!xpc_listener || xpc_get_type(xpc_listener) != XPC_TYPE_CONNECTION)
    {
        os_log(log_handle, <span class="enscript-string">&quot;init_helper_service: Error Creating XPC Listener for mDNSResponderHelperService !!&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    
    os_log_info(log_handle,<span class="enscript-string">&quot;init_helper_service: XPC Listener for mDNSResponderHelperService Listening&quot;</span>);
    
    xpc_queue = dispatch_queue_create(<span class="enscript-string">&quot;com.apple.mDNSHelper.service_queue&quot;</span>, NULL);
    
    xpc_connection_set_event_handler(xpc_listener, ^(xpc_object_t eventmsg)
    {
        xpc_type_t type = xpc_get_type(eventmsg);
                                         
        <span class="enscript-keyword">if</span> (type == XPC_TYPE_CONNECTION)
        {
            os_log_info(log_handle,<span class="enscript-string">&quot;init_helper_service: new mDNSResponderHelper Client %p&quot;</span>, eventmsg);
            accept_client(eventmsg);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type == XPC_TYPE_ERROR) <span class="enscript-comment">// Ideally, we would never hit these cases below
</span>        {
            os_log(log_handle, <span class="enscript-string">&quot;init_helper_service: XPCError: %s&quot;</span>, xpc_dictionary_get_string(eventmsg, XPC_ERROR_KEY_DESCRIPTION));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span>
        {
            os_log(log_handle, <span class="enscript-string">&quot;init_helper_service: Unknown EventMsg type&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
    });
    
    xpc_connection_resume(xpc_listener);
}


<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> ac, <span class="enscript-type">char</span> *av[])
{
    <span class="enscript-type">char</span> *p = NULL;
    <span class="enscript-type">long</span> n;
    <span class="enscript-type">int</span> ch;

    <span class="enscript-keyword">while</span> ((ch = getopt(ac, av, <span class="enscript-string">&quot;dt:&quot;</span>)) != -1)
    {
        <span class="enscript-keyword">switch</span> (ch)
        {
            <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
                opt_debug = 1;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
                n = strtol(optarg, &amp;p, 0);
                <span class="enscript-keyword">if</span> (<span class="enscript-string">'\0'</span> == optarg[0] || <span class="enscript-string">'\0'</span> != *p || n &gt; LONG_MAX || n &lt; 0)
                {
                    fprintf(stderr, <span class="enscript-string">&quot;Invalid idle timeout: %s\n&quot;</span>, optarg);
                    exit(EXIT_FAILURE);
                }
                maxidle = n;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
            <span class="enscript-reference">default</span>:
                fprintf(stderr, <span class="enscript-string">&quot;Usage: mDNSResponderHelper [-d] [-t maxidle]\n&quot;</span>);
                exit(EXIT_FAILURE);
        }
    }
    ac -= optind;
    av += optind;
    (<span class="enscript-type">void</span>)ac; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)av; <span class="enscript-comment">// Unused
</span>
    initialize_logging();
    initialize_id();

    mDNSHelperLogEnabled = HelperPrefsGetValueBool(kPreferencesKey_mDNSHelperLog, mDNSHelperLogEnabled);

<span class="enscript-comment">// Currently on Fuji/Whitetail releases we are keeping the logging always enabled.
</span><span class="enscript-comment">// Hence mDNSHelperLogEnabled is set to true below by default.
</span>    mDNSHelperLogEnabled      = 1;

    os_log_info(log_handle,<span class="enscript-string">&quot;mDNSResponderHelper Starting to run&quot;</span>);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_SECURITYFRAMEWORK</span>
    <span class="enscript-comment">// We should normally be running as a system daemon.  However, that might not be the case in some scenarios (e.g. debugging).
</span>    <span class="enscript-comment">// Explicitly ensure that our Keychain operations utilize the system domain.
</span>    <span class="enscript-keyword">if</span> (opt_debug)
        SecKeychainSetPreferenceDomain(kSecPreferencesDomainSystem);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (maxidle)
        actualidle = maxidle;

    signal(SIGTERM, handle_sigterm);

    <span class="enscript-keyword">if</span> (initialize_timer())
        exit(EXIT_FAILURE);
    <span class="enscript-keyword">for</span> (n=0; n&lt;100000; n++)
        <span class="enscript-keyword">if</span> (!gRunLoop)
            usleep(100);
    
    <span class="enscript-keyword">if</span> (!gRunLoop)
    {
        os_log(log_handle, <span class="enscript-string">&quot;gRunLoop not set after waiting&quot;</span>);
        exit(EXIT_FAILURE);
    }

    init_helper_service(kHelperService);
    os_log_info(log_handle,<span class="enscript-string">&quot;mDNSResponderHelper is now running&quot;</span>);
    dispatch_main();
    
}

<span class="enscript-comment">// Note: The C preprocessor stringify operator ('#') makes a string from its argument, without macro expansion
</span><span class="enscript-comment">// e.g. If &quot;version&quot; is #define'd to be &quot;4&quot;, then STRINGIFY_AWE(version) will return the string &quot;version&quot;, not &quot;4&quot;
</span><span class="enscript-comment">// To expand &quot;version&quot; to its value before making the string, use STRINGIFY(version) instead
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">STRINGIFY_ARGUMENT_WITHOUT_EXPANSION</span>(s) # s
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STRINGIFY</span>(s) STRINGIFY_ARGUMENT_WITHOUT_EXPANSION(s)

<span class="enscript-comment">// For convenience when using the &quot;strings&quot; command, this is the last thing in the file
</span><span class="enscript-comment">// The &quot;@(#) &quot; pattern is a special prefix the &quot;what&quot; command looks for
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> VersionString_SCCS[] = <span class="enscript-string">&quot;@(#) mDNSResponderHelper &quot;</span> STRINGIFY(mDNSResponderVersion) <span class="enscript-string">&quot; (&quot;</span> __DATE__ <span class="enscript-string">&quot; &quot;</span> __TIME__ <span class="enscript-string">&quot;)&quot;</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">_BUILDING_XCODE_PROJECT_</span>
<span class="enscript-comment">// If the process crashes, then this string will be magically included in the automatically-generated crash log
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> *__crashreporter_info__ = VersionString_SCCS + 5;
<span class="enscript-function-name">asm</span> (<span class="enscript-string">&quot;.desc ___crashreporter_info__, 0x10&quot;</span>);
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>