<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>srp-gw.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">srp-gw.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="srp-gw.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* srp-gw.c
 *
 * Copyright (c) 2018 Apple Computer, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This is a DNSSD Service Registration Protocol gateway.   The purpose of this is to make it possible
 * for SRP clients to update DNS servers that don't support SRP.
 *
 * The way it works is that this gateway listens on port ANY:53 and forwards either to another port on
 * the same host (not recommended) or to any port (usually 53) on a different host.   Requests are accepted
 * over both TCP and UDP in principle, but UDP requests should be from constrained nodes, and rely on
 * network topology for authentication.
 *
 * Note that this is not a full DNS proxy, so you can't just put it in front of a DNS server.
 */</span>

<span class="enscript-comment">// Get DNS server IP address
</span><span class="enscript-comment">// Get list of permitted source subnets for TCP updates
</span><span class="enscript-comment">// Get list of permitted source subnet/interface tuples for UDP updates
</span><span class="enscript-comment">// Set up UDP listener
</span><span class="enscript-comment">// Set up TCP listener (no TCP Fast Open)
</span><span class="enscript-comment">// Event loop
</span><span class="enscript-comment">// Transaction processing:
</span><span class="enscript-comment">//   1. If UDP, validate that it's from a subnet that is valid for the interface on which it was received.
</span><span class="enscript-comment">//   2. If TCP, validate that it's from a permitted subnet
</span><span class="enscript-comment">//   3. Check that the message is a valid SRP update according to the rules
</span><span class="enscript-comment">//   4. Check the signature
</span><span class="enscript-comment">//   5. Do a DNS Update with prerequisites to prevent overwriting a host record with the same owner name but
</span><span class="enscript-comment">//      a different key.
</span><span class="enscript-comment">//   6. Send back the response
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__APPLE_USE_RFC_3542</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns-msg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp-crypto.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ioloop.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssd-proxy.h&quot;</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">structures</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> subnet subnet_t;
<span class="enscript-type">struct</span> subnet {
    subnet_t *NULLABLE next;
    uint8_t preflen;
    uint8_t family;
    <span class="enscript-type">char</span> bytes[8];
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> udp_validator udp_validator_t;
<span class="enscript-type">struct</span> udp_validator {
    udp_validator_t *NULLABLE next;
    <span class="enscript-type">char</span> *NONNULL ifname;
    <span class="enscript-type">int</span> ifindex;
    subnet_t *subnets;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">usage</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *progname)
{
    ERROR(<span class="enscript-string">&quot;usage: %s -s &lt;addr&gt; &lt;port&gt; -t &lt;subnet&gt; ... -u &lt;ifname&gt; &lt;subnet&gt; ...&quot;</span>, progname);
    ERROR(<span class="enscript-string">&quot;  -s can only appear once.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  -t can only appear once, and is followed by one or more subnets.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  -u can appear more than once, is followed by one interface name, and&quot;</span>);
    ERROR(<span class="enscript-string">&quot;     one or more subnets.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  &lt;addr&gt; is an IPv4 address or IPv6 address.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  &lt;port&gt; is a UDP port number.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  &lt;subnet&gt; is an IP address followed by a slash followed by the prefix width.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;  &lt;ifname&gt; is the printable name of the interface.&quot;</span>);
    ERROR(<span class="enscript-string">&quot;ex: srp-gw -s 2001:DB8::1 53 -t 2001:DB8:1300::/48 -u en0 2001:DB8:1300:1100::/56&quot;</span>);
    <span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> delete delete_t;
<span class="enscript-type">struct</span> delete {
    delete_t *next;
    dns_name_t *name;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dns_host_description dns_host_description_t;
<span class="enscript-type">struct</span> dns_host_description {
    dns_name_t *name;
    dns_rr_t *a, *aaaa, *key;
    delete_t *delete;
    <span class="enscript-type">int</span> num_instances;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> service_instance service_instance_t;
<span class="enscript-type">struct</span> service_instance {
    service_instance_t *next;
    dns_host_description_t *host_description;
    dns_name_t *name;
    delete_t *delete;
    <span class="enscript-type">int</span> num_instances;
    dns_rr_t *srv, *txt;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> service service_t;
<span class="enscript-type">struct</span> service {
    service_t *next;
    service_instance_t *instance;
    dns_name_t *name;
    dns_rr_t *rr;
};

bool
<span class="enscript-function-name">srp_relay</span>(comm_t *comm, dns_message_t *message)
{
    dns_name_t *update_zone;
    bool updating_services_dot_arpa = false;
    <span class="enscript-type">int</span> i;
    dns_host_description_t *host_description = NULL;
    delete_t *deletes = NULL, *dp, **dpp = &amp;deletes;
    service_instance_t *service_instances = NULL, *sip, **sipp = &amp;service_instances;
    service_t *services = NULL, *sp, **spp = &amp;services;
    dns_rr_t *signature;
    <span class="enscript-type">char</span> namebuf[DNS_MAX_NAME_SIZE + 1], namebuf1[DNS_MAX_NAME_SIZE + 1];
    bool ret = false;
    <span class="enscript-type">struct</span> timeval now;

    <span class="enscript-comment">// Update requires a single SOA record as the question
</span>    <span class="enscript-keyword">if</span> (message-&gt;qdcount != 1) {
        ERROR(<span class="enscript-string">&quot;srp_relay: update received with qdcount &gt; 1&quot;</span>);
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-comment">// Update should contain zero answers.
</span>    <span class="enscript-keyword">if</span> (message-&gt;ancount != 0) {
        ERROR(<span class="enscript-string">&quot;srp_relay: update received with ancount &gt; 0&quot;</span>);
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> (message-&gt;questions[0].type != dns_rrtype_soa) {
        ERROR(<span class="enscript-string">&quot;srp_relay: update received with rrtype %d instead of SOA in question section.&quot;</span>,
              message-&gt;questions[0].type);
        <span class="enscript-keyword">return</span> false;
    }
    update_zone = message-&gt;questions[0].name;

    <span class="enscript-comment">// What zone are we updating?
</span>    <span class="enscript-keyword">if</span> (dns_names_equal_text(update_zone, <span class="enscript-string">&quot;services.arpa&quot;</span>)) {
        updating_services_dot_arpa = true;
    }

    <span class="enscript-comment">// Scan over the authority RRs; do the delete consistency check.  We can't do other consistency checks
</span>    <span class="enscript-comment">// because we can't assume a particular order to the records other than that deletes have to come before
</span>    <span class="enscript-comment">// adds.
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; message-&gt;nscount; i++) {
        dns_rr_t *rr = &amp;message-&gt;authority[i];

        <span class="enscript-comment">// If this is a delete for all the RRs on a name, record it in the list of deletes.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_any &amp;&amp; rr-&gt;qclass == dns_qclass_any &amp;&amp; rr-&gt;ttl == 0) {
            <span class="enscript-keyword">for</span> (dp = deletes; dp; dp = dp-&gt;next) {
                <span class="enscript-keyword">if</span> (dns_names_equal(dp-&gt;name, rr-&gt;name)) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: two deletes for the same name: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
            }
            dp = calloc(<span class="enscript-keyword">sizeof</span> *dp, 1);
            <span class="enscript-keyword">if</span> (!dp) {
                ERROR(<span class="enscript-string">&quot;srp_relay: no memory.&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            }
            dp-&gt;name = rr-&gt;name;
            *dpp = dp;
            dpp = &amp;dp-&gt;next;
        }

        <span class="enscript-comment">// Otherwise if it's an A or AAAA record, it's part of a hostname entry.
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_a || rr-&gt;type == dns_rrtype_aaaa || rr-&gt;type == dns_rrtype_key) {
            <span class="enscript-comment">// Allocate the hostname record
</span>            <span class="enscript-keyword">if</span> (!host_description) {
                host_description = calloc(<span class="enscript-keyword">sizeof</span> *host_description, 1);
                <span class="enscript-keyword">if</span> (!host_description) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: no memory&quot;</span>);
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
            }

            <span class="enscript-comment">// Make sure it's preceded by a deletion of all the RRs on the name.
</span>            <span class="enscript-keyword">if</span> (!host_description-&gt;delete) {
                <span class="enscript-keyword">for</span> (dp = deletes; dp; dp = dp-&gt;next) {
                    <span class="enscript-keyword">if</span> (dns_names_equal(dp-&gt;name, rr-&gt;name)) {
                        <span class="enscript-keyword">break</span>;
                    }
                }
                <span class="enscript-keyword">if</span> (dp == NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: ADD for hostname %s without a preceding delete.&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                host_description-&gt;delete = dp;
                host_description-&gt;name = dp-&gt;name;
            }
                          
            <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_a) {
                <span class="enscript-keyword">if</span> (host_description-&gt;a != NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: more than one A rrset received for name: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                host_description-&gt;a = rr;
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_aaaa) {
                <span class="enscript-keyword">if</span> (host_description-&gt;aaaa != NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: more than one AAAA rrset received for name: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                host_description-&gt;aaaa = rr;
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_key) {
                <span class="enscript-keyword">if</span> (host_description-&gt;key != NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: more than one KEY rrset received for name: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                host_description-&gt;key =  rr;
            }
        }

        <span class="enscript-comment">// Otherwise if it's an SRV entry, that should be a service instance name.
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_srv || rr-&gt;type == dns_rrtype_txt) {
            <span class="enscript-comment">// Should be a delete that precedes this service instance.
</span>            <span class="enscript-keyword">for</span> (dp = deletes; dp; dp = dp-&gt;next) {
                <span class="enscript-keyword">if</span> (dns_names_equal(dp-&gt;name, rr-&gt;name)) {
                    <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">if</span> (dp == NULL) {
                ERROR(<span class="enscript-string">&quot;srp_relay: ADD for service instance not preceded by delete: %s&quot;</span>,
                      dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            }
            <span class="enscript-keyword">for</span> (sip = service_instances; sip; sip = sip-&gt;next) {
                <span class="enscript-keyword">if</span> (dns_names_equal(sip-&gt;name, rr-&gt;name)) {
                    <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">if</span> (!sip) {
                sip = calloc(<span class="enscript-keyword">sizeof</span> *sip, 1);
                <span class="enscript-keyword">if</span> (sip == NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: no memory&quot;</span>);
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                sip-&gt;delete = dp;
                sip-&gt;name = dp-&gt;name;
                *sipp = sip;
                sipp = &amp;sip-&gt;next;
            }
            <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_srv) {
                <span class="enscript-keyword">if</span> (sip-&gt;srv != NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: more than one SRV rr received for service instance: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                sip-&gt;srv = rr;
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_txt) {
                <span class="enscript-keyword">if</span> (sip-&gt;txt != NULL) {
                    ERROR(<span class="enscript-string">&quot;srp_relay: more than one SRV rr received for service instance: %s&quot;</span>,
                          dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
                }
                sip-&gt;txt = rr;
            }
        }

        <span class="enscript-comment">// Otherwise if it's a PTR entry, that should be a service name
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;type == dns_rrtype_ptr) {
            sp = calloc(<span class="enscript-keyword">sizeof</span> *sp, 1);
            <span class="enscript-keyword">if</span> (sp == NULL) {
                ERROR(<span class="enscript-string">&quot;srp_relay: no memory&quot;</span>);
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            }
            sp-&gt;rr = rr;
            *spp = sp;
            spp = &amp;sp-&gt;next;
        }            

        <span class="enscript-comment">// Otherwise it's not a valid update
</span>        <span class="enscript-keyword">else</span> {
            ERROR(<span class="enscript-string">&quot;srp_relay: unexpected rrtype %d on %s in update.&quot;</span>, rr-&gt;type,
                      dns_name_print(rr-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
    }

    <span class="enscript-comment">// Now that we've scanned the whole update, do the consistency checks for updates that might
</span>    <span class="enscript-comment">// not have come in order.
</span>    
    <span class="enscript-comment">// First, make sure there's a host description.
</span>    <span class="enscript-keyword">if</span> (host_description == NULL) {
        ERROR(<span class="enscript-string">&quot;srp_relay: SRP update does not include a host description.&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-comment">// Make sure that each service add references a service instance that's in the same update.
</span>    <span class="enscript-keyword">for</span> (sp = services; sp; sp = sp-&gt;next) {
        <span class="enscript-keyword">for</span> (sip = service_instances; sip; sip = sip-&gt;next) {
            <span class="enscript-keyword">if</span> (dns_names_equal(sip-&gt;name, sp-&gt;rr-&gt;data.ptr.name)) {
                <span class="enscript-comment">// Note that we have already verified that there is only one service instance
</span>                <span class="enscript-comment">// with this name, so this could only ever happen once in this loop even without
</span>                <span class="enscript-comment">// the break statement.
</span>                sp-&gt;instance = sip;
                sip-&gt;num_instances++;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-comment">// If this service doesn't point to a service instance that's in the update, then the
</span>        <span class="enscript-comment">// update fails validation.
</span>        <span class="enscript-keyword">if</span> (sip == NULL) {
            ERROR(<span class="enscript-string">&quot;srp_relay: service %s points to an instance that's not included: %s&quot;</span>,
                  dns_name_print(sp-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf),
                  dns_name_print(sip-&gt;name, namebuf1, <span class="enscript-keyword">sizeof</span> namebuf1));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
    }

    <span class="enscript-keyword">for</span> (sip = service_instances; sip; sip = sip-&gt;next) {
        <span class="enscript-comment">// For each service instance, make sure that at least one service references it
</span>        <span class="enscript-keyword">if</span> (sip-&gt;num_instances == 0) {
            ERROR(<span class="enscript-string">&quot;srp_relay: service instance update for %s is not referenced by a service update.&quot;</span>,
                  dns_name_print(sip-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }

        <span class="enscript-comment">// For each service instance, make sure that it references the host description
</span>        <span class="enscript-keyword">if</span> (dns_names_equal(host_description-&gt;name, sip-&gt;srv-&gt;data.srv.name)) {
            sip-&gt;host_description = host_description;
            host_description-&gt;num_instances++;
        }
    }

    <span class="enscript-comment">// Make sure that at least one service instance references the host description
</span>    <span class="enscript-keyword">if</span> (host_description-&gt;num_instances == 0) {
        ERROR(<span class="enscript-string">&quot;srp_relay: host description %s is not referenced by any service instances.&quot;</span>,
              dns_name_print(host_description-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-comment">// Make sure the host description has at least one address record.
</span>    <span class="enscript-keyword">if</span> (host_description-&gt;a == NULL &amp;&amp; host_description-&gt;aaaa == NULL) {
        ERROR(<span class="enscript-string">&quot;srp_relay: host description %s doesn't contain any IP addresses.&quot;</span>,
              dns_name_print(host_description-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    <span class="enscript-comment">// And make sure it has a key record
</span>    <span class="enscript-keyword">if</span> (host_description-&gt;key == NULL) {
        ERROR(<span class="enscript-string">&quot;srp_relay: host description %s doesn't contain a key.&quot;</span>,
              dns_name_print(host_description-&gt;name, namebuf, <span class="enscript-keyword">sizeof</span> namebuf));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-comment">// The signature should be the last thing in the additional section.   Even if the signature
</span>    <span class="enscript-comment">// is valid, if it's not at the end we reject it.   Note that we are just checking for SIG(0)
</span>    <span class="enscript-comment">// so if we don't find what we're looking for, we forward it to the DNS auth server which
</span>    <span class="enscript-comment">// will either accept or reject it.
</span>    <span class="enscript-keyword">if</span> (message-&gt;arcount &lt; 1) {
        ERROR(<span class="enscript-string">&quot;srp_relay: signature not present&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    signature = &amp;message-&gt;additional[message-&gt;arcount -1];
    <span class="enscript-keyword">if</span> (signature-&gt;type != dns_rrtype_sig) {
        ERROR(<span class="enscript-string">&quot;srp_relay: signature is not at the end or is not present&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-comment">// Make sure that the signer name is the hostname.   If it's not, it could be a legitimate
</span>    <span class="enscript-comment">// update with a different key, but it's not an SRP update, so we pass it on.
</span>    <span class="enscript-keyword">if</span> (!dns_names_equal(signature-&gt;data.sig.signer, host_description-&gt;name)) {
        ERROR(<span class="enscript-string">&quot;srp_relay: signer %s doesn't match host %s&quot;</span>, 
              dns_name_print(signature-&gt;data.sig.signer, namebuf, <span class="enscript-keyword">sizeof</span> namebuf),
              dns_name_print(host_description-&gt;name, namebuf1, <span class="enscript-keyword">sizeof</span> namebuf1));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    <span class="enscript-comment">// Make sure we're in the time limit for the signature.   Zeroes for the inception and expiry times
</span>    <span class="enscript-comment">// mean the host that send this doesn't have a working clock.   One being zero and the other not isn't
</span>    <span class="enscript-comment">// valid unless it's 1970.
</span>    <span class="enscript-keyword">if</span> (signature-&gt;data.sig.inception != 0 || signature-&gt;data.sig.expiry != 0) {
        gettimeofday(&amp;now, NULL);
        <span class="enscript-comment">// The sender does the bracketing, so we can just do a simple comparison.
</span>        <span class="enscript-keyword">if</span> (now.tv_sec &gt; signature-&gt;data.sig.expiry || now.tv_sec &lt; signature-&gt;data.sig.inception) {
            ERROR(<span class="enscript-string">&quot;signature is not timely: %lu &lt; %lu &lt; %lu does not hold&quot;</span>,
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)signature-&gt;data.sig.inception, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)now.tv_sec,
                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)signature-&gt;data.sig.expiry);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">badsig</span>;
        }
    }

    <span class="enscript-comment">// Now that we have the key, we can validate the signature.   If the signature doesn't validate,
</span>    <span class="enscript-comment">// there is no need to pass the message on.
</span>    <span class="enscript-keyword">if</span> (!srp_sig0_verify(message-&gt;wire, host_description-&gt;key, signature)) {
        ERROR(<span class="enscript-string">&quot;signature is not valid&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">badsig</span>;
    }

<span class="enscript-reference">badsig</span>:
    <span class="enscript-comment">// True means we consumed it, not that it was valid.
</span>    ret = true;

<span class="enscript-reference">out</span>:
    <span class="enscript-comment">// free everything we allocated but (it turns out) aren't going to use
</span>    <span class="enscript-keyword">for</span> (dp = deletes; dp; ) {
        delete_t *next = dp-&gt;next;
        free(dp);
        dp = next;
    }
    <span class="enscript-keyword">for</span> (sip = service_instances; sip; ) {
        service_instance_t *next = sip-&gt;next;
        free(sip);
        sip = next;
    }
    <span class="enscript-keyword">for</span> (sp = services; sp; ) {
        service_t *next = sp-&gt;next;
        free(sp);
        sp = next;
    }
    <span class="enscript-keyword">if</span> (host_description != NULL) {
        free(host_description);
    }
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_evaluate</span>(comm_t *comm)
{
    dns_message_t *message;

    <span class="enscript-comment">// Drop incoming responses--we're a server, so we only accept queries.
</span>    <span class="enscript-keyword">if</span> (dns_qr_get(&amp;comm-&gt;message-&gt;wire) == dns_qr_response) {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Forward incoming messages that are queries but not updates.
</span>    <span class="enscript-comment">// XXX do this later--for now we operate only as a translator, not a proxy.
</span>    <span class="enscript-keyword">if</span> (dns_opcode_get(&amp;comm-&gt;message-&gt;wire) != dns_opcode_update) {
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">// Parse the UPDATE message.
</span>    <span class="enscript-keyword">if</span> (!dns_wire_parse(&amp;message, &amp;comm-&gt;message-&gt;wire, comm-&gt;message-&gt;length)) {
        ERROR(<span class="enscript-string">&quot;dns_wire_parse failed.&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">// We need the wire message to validate the signature...
</span>    message-&gt;wire = &amp;comm-&gt;message-&gt;wire;
    <span class="enscript-keyword">if</span> (!srp_relay(comm, message)) {
        <span class="enscript-comment">// The message wasn't invalid, but wasn't an SRP message.
</span>        <span class="enscript-comment">// dns_forward(comm)
</span>    }
    <span class="enscript-comment">// But we don't save it.
</span>    message-&gt;wire = NULL;

    <span class="enscript-comment">//dns_message_free(message);
</span>}

<span class="enscript-type">void</span> <span class="enscript-function-name">dns_input</span>(comm_t *comm)
{
    dns_evaluate(comm);
    message_free(comm-&gt;message);
    comm-&gt;message = NULL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
    <span class="enscript-type">int</span> i;
    subnet_t *tcp_validators = NULL;
    udp_validator_t *udp_validators = NULL;
    udp_validator_t *NULLABLE *NONNULL up = &amp;udp_validators;
    subnet_t *NULLABLE *NONNULL nt = &amp;tcp_validators;
    subnet_t *NULLABLE *NONNULL sp;
    addr_t server, pref;
    uint16_t port;
    socklen_t len, prefalen;
    <span class="enscript-type">char</span> *s, *p;
    <span class="enscript-type">int</span> width;
    uint16_t listen_port;

    listen_port = htons(53);

    <span class="enscript-comment">// Read the configuration from the command line.
</span>    <span class="enscript-keyword">for</span> (i = 1; i &lt; argc; i++) {
        <span class="enscript-keyword">if</span> (!strcmp(argv[i], <span class="enscript-string">&quot;-s&quot;</span>)) {
            <span class="enscript-keyword">if</span> (i++ == argc) {
                ERROR(<span class="enscript-string">&quot;-s is missing server IP address.&quot;</span>);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            len = getipaddr(&amp;server, argv[i]);
            <span class="enscript-keyword">if</span> (!len) {
                ERROR(<span class="enscript-string">&quot;Invalid IP address: %s.&quot;</span>, argv[i]);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            server.sa.sa_len = len;
            <span class="enscript-keyword">if</span> (i++ == argc) {
                ERROR(<span class="enscript-string">&quot;-s is missing server port.&quot;</span>);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            port = strtol(argv[i], &amp;s, 10);
            <span class="enscript-keyword">if</span> (s == argv[i] || s[0] != <span class="enscript-string">'\0'</span>) {
                ERROR(<span class="enscript-string">&quot;Invalid port number: %s&quot;</span>, argv[i]);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            <span class="enscript-keyword">if</span> (server.sa.sa_family == AF_INET) {
                server.sin.sin_port = htons(port);
            } <span class="enscript-keyword">else</span> {
                server.sin6.sin6_port = htons(port);
            }
            i += 2;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(argv[i], <span class="enscript-string">&quot;-t&quot;</span>) || !strcmp(argv[i], <span class="enscript-string">&quot;-u&quot;</span>)) {
            <span class="enscript-keyword">if</span> (!strcmp(argv[i], <span class="enscript-string">&quot;-u&quot;</span>)) {
                <span class="enscript-keyword">if</span> (i++ == argc) {
                    ERROR(<span class="enscript-string">&quot;-u is missing interface name.&quot;</span>);
                    <span class="enscript-keyword">return</span> usage(argv[0]);
                }
                *up = calloc(1, <span class="enscript-keyword">sizeof</span> **up);
                <span class="enscript-keyword">if</span> (*up == NULL) {
                    ERROR(<span class="enscript-string">&quot;udp_validators: out of memory.&quot;</span>);
                    <span class="enscript-keyword">return</span> usage(argv[0]);
                }
                (*up)-&gt;ifname = strdup(argv[i]);
                <span class="enscript-keyword">if</span> ((*up)-&gt;ifname == NULL) {
                    ERROR(<span class="enscript-string">&quot;udp validators: ifname: out of memory.&quot;</span>);
                    <span class="enscript-keyword">return</span> usage(argv[0]);
                }
                sp = &amp;((*up)-&gt;subnets);
            } <span class="enscript-keyword">else</span> {
                sp = nt;
            }

            <span class="enscript-keyword">if</span> (i++ == argc) {
                ERROR(<span class="enscript-string">&quot;%s requires at least one prefix.&quot;</span>, argv[i - 1]);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            s = strchr(argv[i], <span class="enscript-string">'/'</span>);
            <span class="enscript-keyword">if</span> (s == NULL) {
                ERROR(<span class="enscript-string">&quot;%s is not a prefix.&quot;</span>, argv[i]);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            *s = 0;
            ++s;
            prefalen = getipaddr(&amp;pref, argv[i]);
            <span class="enscript-keyword">if</span> (!prefalen) {
                ERROR(<span class="enscript-string">&quot;%s is not a valid prefix address.&quot;</span>, argv[i]);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            width = strtol(s, &amp;p, 10);
            <span class="enscript-keyword">if</span> (s == p || p[0] != <span class="enscript-string">'\0'</span>) {
                ERROR(<span class="enscript-string">&quot;%s (prefix width) is not a number.&quot;</span>, p);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }
            <span class="enscript-keyword">if</span> (width &lt; 0 ||
                (pref.sa.sa_family == AF_INET &amp;&amp; width &gt; 32) ||
                (pref.sa.sa_family == AF_INET6 &amp;&amp; width &gt; 64)) {
                ERROR(<span class="enscript-string">&quot;%s is not a valid prefix length for %s&quot;</span>, p,
                        pref.sa.sa_family == AF_INET ? <span class="enscript-string">&quot;IPv4&quot;</span> : <span class="enscript-string">&quot;IPv6&quot;</span>);
                <span class="enscript-keyword">return</span> usage(argv[0]);
            }

            *nt = calloc(1, <span class="enscript-keyword">sizeof</span> **nt);
            <span class="enscript-keyword">if</span> (!*nt) {
                ERROR(<span class="enscript-string">&quot;tcp_validators: out of memory.&quot;</span>);
                <span class="enscript-keyword">return</span> 1;
            }

            (*nt)-&gt;preflen = width;
            (*nt)-&gt;family = pref.sa.sa_family;
            <span class="enscript-keyword">if</span> (pref.sa.sa_family == AF_INET) {
                memcpy((*nt)-&gt;bytes, &amp;pref.sin.sin_addr, 4);
            } <span class="enscript-keyword">else</span> {
                memcpy((*nt)-&gt;bytes, &amp;pref.sin6.sin6_addr, 8);
            }

            <span class="enscript-comment">// *up will be non-null for -u and null for -t.
</span>            <span class="enscript-keyword">if</span> (*up) {
                up = &amp;((*up)-&gt;next);
            } <span class="enscript-keyword">else</span> {
                nt = sp;
            }
        }
    }

    <span class="enscript-keyword">if</span> (!ioloop_init()) {
        <span class="enscript-keyword">return</span> 1;
    }

    <span class="enscript-comment">// Set up listeners
</span>    <span class="enscript-keyword">if</span> (!setup_listener_socket(AF_INET, IPPROTO_UDP, listen_port, <span class="enscript-string">&quot;UDPv4 listener&quot;</span>, dns_input, 0, 0)) {
        ERROR(<span class="enscript-string">&quot;UDPv4 listener: fail.&quot;</span>);
        <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">if</span> (!setup_listener_socket(AF_INET6, IPPROTO_UDP, listen_port, <span class="enscript-string">&quot;UDPv6 listener&quot;</span>, dns_input, 0, 0)) {
        ERROR(<span class="enscript-string">&quot;UDPv6 listener: fail.&quot;</span>);
        <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">if</span> (!setup_listener_socket(AF_INET, IPPROTO_TCP, listen_port, <span class="enscript-string">&quot;TCPv4 listener&quot;</span>, dns_input, 0, 0)) {
        ERROR(<span class="enscript-string">&quot;TCPv4 listener: fail.&quot;</span>);
        <span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">if</span> (!setup_listener_socket(AF_INET6, IPPROTO_TCP, listen_port, <span class="enscript-string">&quot;TCPv6 listener&quot;</span>, dns_input, 0, 0)) {
        ERROR(<span class="enscript-string">&quot;TCPv4 listener: fail.&quot;</span>);
        <span class="enscript-keyword">return</span> 1;
    }
    
    <span class="enscript-keyword">do</span> {
        <span class="enscript-type">int</span> something = 0;
        something = ioloop_events(0);
        INFO(<span class="enscript-string">&quot;dispatched %d events.&quot;</span>, something);
    } <span class="enscript-keyword">while</span> (1);
}

<span class="enscript-comment">// Local Variables:
</span><span class="enscript-comment">// mode: C
</span><span class="enscript-comment">// tab-width: 4
</span><span class="enscript-comment">// c-file-style: &quot;bsd&quot;
</span><span class="enscript-comment">// c-basic-offset: 4
</span><span class="enscript-comment">// fill-column: 108
</span><span class="enscript-comment">// indent-tabs-mode: nil
</span><span class="enscript-comment">// End:
</span></pre>
<hr />
</body></html>