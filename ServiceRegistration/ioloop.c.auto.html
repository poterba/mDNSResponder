<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ioloop.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ioloop.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="ioloop.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* dispatch.c
 *
 * Copyright (c) 2018 Apple Computer, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Simple event dispatcher for DNS.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__APPLE_USE_RFC_3542</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns-msg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp-crypto.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ioloop.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssd-proxy.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USE_SELECT</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Globals</span>
io_t *ios;
int64_t ioloop_now;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_KQUEUE</span>
<span class="enscript-type">int</span> kq;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">getipaddr</span>(addr_t *addr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p)
{
    <span class="enscript-keyword">if</span> (inet_pton(AF_INET, p, &amp;addr-&gt;sin.sin_addr)) {
        addr-&gt;sa.sa_family = AF_INET;
        <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span> addr-&gt;sin;
    }  <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inet_pton(AF_INET6, p, &amp;addr-&gt;sin6.sin6_addr)) {
        addr-&gt;sa.sa_family = AF_INET6;
        <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span> addr-&gt;sin6;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> 0;
    }
}                

int64_t
<span class="enscript-function-name">ioloop_timenow</span>()
{
    int64_t now;
    <span class="enscript-type">struct</span> timeval tv;
    gettimeofday(&amp;tv, 0);
    now = (int64_t)tv.tv_sec * 1000 + (int64_t)tv.tv_usec / 1000;
    <span class="enscript-keyword">return</span> now;
}

message_t *
<span class="enscript-function-name">message_allocate</span>(size_t message_size)
{
    message_t *message = (message_t *)malloc(message_size + (<span class="enscript-keyword">sizeof</span> (message_t)) - (<span class="enscript-keyword">sizeof</span> (dns_wire_t)));
    <span class="enscript-keyword">if</span> (message)
        memset(message, 0, (<span class="enscript-keyword">sizeof</span> (message_t)) - (<span class="enscript-keyword">sizeof</span> (dns_wire_t)));
    <span class="enscript-keyword">return</span> message;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">message_free</span>(message_t *message)
{
    free(message);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">comm_free</span>(comm_t *comm)
{
    <span class="enscript-keyword">if</span> (comm-&gt;name) {
        free(comm-&gt;name);
        comm-&gt;name = NULL;
    }
    <span class="enscript-keyword">if</span> (comm-&gt;message) {
        message_free(comm-&gt;message);
        comm-&gt;message = NULL;
        comm-&gt;buf = NULL;
    }
    free(comm);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ioloop_close</span>(io_t *io)
{
    close(io-&gt;sock);
    io-&gt;sock = -1;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">add_reader</span>(io_t *io, io_callback_t callback, io_callback_t finalize)
{
    io-&gt;next = ios;
    ios = io;
    io-&gt;read_callback = callback;
    io-&gt;finalize = finalize;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SELECT</span>
    io-&gt;want_read = true;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_EPOLL</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_KQUEUE</span>
    <span class="enscript-type">struct</span> kevent ev;
    <span class="enscript-type">int</span> rv;
    EV_SET(&amp;ev, io-&gt;sock, EVFILT_READ, EV_ADD | EV_ENABLE, 0, 0, io);
    rv = kevent(kq, &amp;ev, 1, NULL, 0, NULL);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;kevent add: %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">USE_EPOLL</span>
}

bool
<span class="enscript-function-name">ioloop_init</span>(<span class="enscript-type">void</span>)
{
    signal(SIGPIPE, SIG_IGN); <span class="enscript-comment">// because why ever?
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_KQUEUE</span>
    kq = kqueue();
    <span class="enscript-keyword">if</span> (kq &lt; 0) {
        ERROR(<span class="enscript-string">&quot;kqueue(): %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span> false;
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ioloop_events</span>(int64_t timeout_when)
{
    io_t *io, **iop;
    <span class="enscript-type">int</span> nev = 0, rv;
    int64_t now = ioloop_timenow();
    int64_t next_event = timeout_when;
    int64_t timeout = 0;

    INFO(<span class="enscript-string">&quot;%qd.%03qd seconds have passed on entry to ioloop_events&quot;</span>, (now - ioloop_now) / 1000, (now - ioloop_now) % 1000);
    ioloop_now = now;

    <span class="enscript-comment">// A timeout of zero means don't time out.
</span>    <span class="enscript-keyword">if</span> (timeout_when == 0) {
        next_event = INT64_MAX;
    } <span class="enscript-keyword">else</span> {
        next_event = timeout_when;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SELECT</span>
    <span class="enscript-type">int</span> nfds = 0;
    fd_set reads, writes, errors;
    <span class="enscript-type">struct</span> timeval tv;

    FD_ZERO(&amp;reads);
    FD_ZERO(&amp;writes);
    FD_ZERO(&amp;errors);
    
#<span class="enscript-reference">endif</span>
    iop = &amp;ios;
    <span class="enscript-keyword">while</span> (*iop) {
        io = *iop;
        <span class="enscript-keyword">if</span> (io-&gt;sock != -1 &amp;&amp; io-&gt;wakeup_time != 0) {
            <span class="enscript-keyword">if</span> (io-&gt;wakeup_time &lt;= ioloop_now) {
                io-&gt;wakeup_time = 0;
                io-&gt;wakeup(io);
                ++nev;
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (io-&gt;wakeup_time &lt; next_event) {
                next_event = io-&gt;wakeup_time;
            }
        }

        <span class="enscript-keyword">if</span> (io-&gt;sock == -1) {
            *iop = io-&gt;next;
            <span class="enscript-keyword">if</span> (io-&gt;finalize) {
                io-&gt;finalize(io);
            } <span class="enscript-keyword">else</span> {
                free(io);
            }
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// INFO(&quot;now: %qd  io %d wakeup_time %qd  next_event %qd&quot;, ioloop_now, io-&gt;sock, io-&gt;wakeup_time, next_event);
</span>
        <span class="enscript-comment">// If we were given a timeout in the future, or told to wait indefinitely, wait until the next event.
</span>        <span class="enscript-keyword">if</span> (timeout_when == 0 || timeout_when &gt; ioloop_now) {
            timeout = next_event - ioloop_now;
            <span class="enscript-comment">// Don't choose a time so far in the future that it might overflow some math in the kernel.
</span>            <span class="enscript-keyword">if</span> (timeout &gt; IOLOOP_DAY * 100) {
                timeout = IOLOOP_DAY * 100;
            }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SELECT</span>
            tv.tv_sec = timeout / 1000;
            tv.tv_usec = (timeout % 1000) * 1000;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_KQUEUE</span>
            ts.tv_sec = timeout / 1000;
            ts.tv_nsec = (timeout % 1000) * 1000 * 1000;
#<span class="enscript-reference">endif</span>
        }
        iop = &amp;io-&gt;next;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SELECT</span>
    <span class="enscript-keyword">for</span> (io = ios; io; io = io-&gt;next) {
        <span class="enscript-keyword">if</span> (io-&gt;sock != -1 &amp;&amp; (io-&gt;want_read || io-&gt;want_write)) {
            <span class="enscript-keyword">if</span> (io-&gt;sock &gt;= nfds) {
                nfds = io-&gt;sock + 1;
            }
            <span class="enscript-keyword">if</span> (io-&gt;want_read) {
                FD_SET(io-&gt;sock, &amp;reads);
            }
            <span class="enscript-keyword">if</span> (io-&gt;want_write) {
                FD_SET(io-&gt;sock, &amp;writes);
            }
        }
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SELECT</span>
    INFO(<span class="enscript-string">&quot;waiting %ld %d seconds&quot;</span>, tv.tv_sec, tv.tv_usec);
    rv = select(nfds, &amp;reads, &amp;writes, &amp;writes, &amp;tv);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;select: %s&quot;</span>, strerror(errno));
        exit(1);
    }
    now = ioloop_timenow();
    INFO(<span class="enscript-string">&quot;%qd.%03qd seconds passed waiting, got %d events&quot;</span>, (now - ioloop_now) / 1000, (now - ioloop_now) % 1000, rv);
    ioloop_now = now;
    <span class="enscript-keyword">for</span> (io = ios; io; io = io-&gt;next) {
        <span class="enscript-keyword">if</span> (io-&gt;sock != -1) {
            <span class="enscript-keyword">if</span> (FD_ISSET(io-&gt;sock, &amp;reads)) {
                io-&gt;read_callback(io);
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (FD_ISSET(io-&gt;sock, &amp;writes)) {
                io-&gt;write_callback(io);
            }
        }
    }
    nev += rv;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">USE_SELECT</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_KQUEUE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_MAX</span> 20
    <span class="enscript-type">struct</span> kevent evs[KEV_MAX];
    <span class="enscript-type">int</span> i, rv;
    <span class="enscript-type">struct</span> timespec ts;

    INFO(<span class="enscript-string">&quot;waiting %qd/%qd seconds&quot;</span>, ts.tv_sec, ts.tv_nsec);
    <span class="enscript-keyword">do</span> {
        rv = kevent(kq, NULL, 0, evs, KEV_MAX, &amp;ts);
        now = ioloop_timenow();
        INFO(<span class="enscript-string">&quot;%qd.%03qd seconds passed waiting, got %d events&quot;</span>, (now - ioloop_now) / 1000, (now - ioloop_now) % 1000, rv);
        ioloop_now = now;
        ts.tv_sec = 0;
        ts.tv_nsec = 0;
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
            ERROR(<span class="enscript-string">&quot;kevent poll: %s&quot;</span>, strerror(errno));
            exit(1);
        }
        <span class="enscript-keyword">for</span> (i = 0; i &lt; nev; i++) {
            io = evs[i].udata;
            <span class="enscript-keyword">if</span> (evs[i].filter == EVFILT_WRITE) {
                io-&gt;write_callback(io);
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (evs[i].filter == EVFILT_READ) {
                io-&gt;read_callback(io);
            }
        }
        nev += rv;
    } <span class="enscript-keyword">while</span> (rv == KEV_MAX);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> nev;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_read_callback</span>(io_t *io)
{
    comm_t *connection = (comm_t *)io;
    addr_t src;
    <span class="enscript-type">int</span> rv;
    <span class="enscript-type">struct</span> msghdr msg;
    <span class="enscript-type">struct</span> iovec bufp;
    uint8_t msgbuf[DNS_MAX_UDP_PAYLOAD];
    <span class="enscript-type">char</span> cmsgbuf[128];
    <span class="enscript-type">struct</span> cmsghdr *cmh;
    message_t *message;

    bufp.iov_base = msgbuf;
    bufp.iov_len = DNS_MAX_UDP_PAYLOAD;
    msg.msg_iov = &amp;bufp;
    msg.msg_iovlen = 1;
    msg.msg_name = &amp;src;
    msg.msg_namelen = <span class="enscript-keyword">sizeof</span> src;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = <span class="enscript-keyword">sizeof</span> cmsgbuf;
    
    rv = recvmsg(connection-&gt;io.sock, &amp;msg, 0);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;udp_read_callback: %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span>;
    }
    message = message_allocate(rv);
    <span class="enscript-keyword">if</span> (!message) {
        ERROR(<span class="enscript-string">&quot;udp_read_callback: out of memory&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    memcpy(&amp;message-&gt;src, &amp;src, <span class="enscript-keyword">sizeof</span> src);
    message-&gt;length = rv;
    memcpy(&amp;message-&gt;wire, msgbuf, rv);
    
    <span class="enscript-comment">// For UDP, we use the interface index as part of the validation strategy, so go get
</span>    <span class="enscript-comment">// the interface index.
</span>    <span class="enscript-keyword">for</span> (cmh = CMSG_FIRSTHDR(&amp;msg); cmh; cmh = CMSG_NXTHDR(&amp;msg, cmh)) {
        <span class="enscript-keyword">if</span> (cmh-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp; cmh-&gt;cmsg_type == IPV6_PKTINFO) {
            <span class="enscript-type">struct</span> in6_pktinfo pktinfo;    

            memcpy(&amp;pktinfo, CMSG_DATA(cmh), <span class="enscript-keyword">sizeof</span> pktinfo);
            message-&gt;ifindex = pktinfo.ipi6_ifindex;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmh-&gt;cmsg_level == IPPROTO_IP &amp;&amp; cmh-&gt;cmsg_type == IP_PKTINFO) { 
            <span class="enscript-type">struct</span> in_pktinfo pktinfo;
          
            memcpy(&amp;pktinfo, CMSG_DATA(cmh), <span class="enscript-keyword">sizeof</span> pktinfo);
            message-&gt;ifindex = pktinfo.ipi_ifindex;
        }
    }
    connection-&gt;message = message;
    connection-&gt;datagram_callback(connection);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_read_callback</span>(io_t *context)
{
    comm_t *connection = (comm_t *)context;
    <span class="enscript-type">int</span> rv;
    <span class="enscript-keyword">if</span> (connection-&gt;message_length_len &lt; 2) {
        rv = read(connection-&gt;io.sock, &amp;connection-&gt;message_length_bytes[connection-&gt;message_length_len],
                  2 - connection-&gt;message_length_len);
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
        <span class="enscript-reference">read_error</span>:
            ERROR(<span class="enscript-string">&quot;tcp_read_callback: %s&quot;</span>, strerror(errno));
            close(connection-&gt;io.sock);
            connection-&gt;io.sock = -1;
            <span class="enscript-comment">// connection-&gt;io.finalize() will be called from the io loop.
</span>            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// If we read zero here, the remote endpoint has closed or shutdown the connection.  Either case is
</span>        <span class="enscript-comment">// effectively the same--if we are sensitive to read events, that means that we are done processing
</span>        <span class="enscript-comment">// the previous message.
</span>        <span class="enscript-keyword">if</span> (rv == 0) {
        <span class="enscript-reference">eof</span>:
            ERROR(<span class="enscript-string">&quot;tcp_read_callback: remote end (%s) closed connection on %d&quot;</span>, connection-&gt;name, connection-&gt;io.sock);
            close(connection-&gt;io.sock);
            connection-&gt;io.sock = -1;
            <span class="enscript-comment">// connection-&gt;io.finalize() will be called from the io loop.
</span>            <span class="enscript-keyword">return</span>;
        }
        connection-&gt;message_length_len += rv;
        <span class="enscript-keyword">if</span> (connection-&gt;message_length_len == 2) {
            connection-&gt;message_length = (((uint16_t)connection-&gt;message_length_bytes[0] &lt;&lt; 8) |
                                          ((uint16_t)connection-&gt;message_length_bytes[1]));
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// If we only just got the length, we need to allocate a message
</span>    <span class="enscript-keyword">if</span> (connection-&gt;message == NULL) {
        connection-&gt;message = message_allocate(connection-&gt;message_length);
        <span class="enscript-keyword">if</span> (!connection-&gt;message) {
            ERROR(<span class="enscript-string">&quot;udp_read_callback: out of memory&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        connection-&gt;buf = (uint8_t *)&amp;connection-&gt;message-&gt;wire;
        connection-&gt;message-&gt;length = connection-&gt;message_length;
        memset(&amp;connection-&gt;message-&gt;src, 0, <span class="enscript-keyword">sizeof</span> connection-&gt;message-&gt;src);
    }

    rv = read(connection-&gt;io.sock, &amp;connection-&gt;buf[connection-&gt;message_cur],
              connection-&gt;message_length - connection-&gt;message_cur);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">read_error</span>;
    }
    <span class="enscript-keyword">if</span> (rv == 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">eof</span>;
    }

    connection-&gt;message_cur += rv;
    <span class="enscript-keyword">if</span> (connection-&gt;message_cur == connection-&gt;message_length) {
        connection-&gt;datagram_callback(connection);
        <span class="enscript-comment">// Caller is expected to consume the message, we are immediately ready for the next read.
</span>        connection-&gt;message_length = connection-&gt;message_length_len = 0;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_send_response</span>(comm_t *comm, message_t *responding_to, <span class="enscript-type">struct</span> iovec *iov, <span class="enscript-type">int</span> iov_len)
{
    <span class="enscript-type">struct</span> msghdr mh;
    <span class="enscript-type">struct</span> iovec iovec[4];
    <span class="enscript-type">char</span> lenbuf[2];
    ssize_t status;
    size_t payload_length = 0;
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// We don't anticipate ever needing more than four hunks, but if we get more, handle then?
</span>    <span class="enscript-keyword">if</span> (iov_len &gt; 3) {
        ERROR(<span class="enscript-string">&quot;tcp_send_response: too many io buffers&quot;</span>);
        close(comm-&gt;io.sock);
        comm-&gt;io.sock = -1;
        <span class="enscript-keyword">return</span>;
    }

    iovec[0].iov_base = &amp;lenbuf[0];
    iovec[0].iov_len = 2;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; iov_len; i++) {
        iovec[i + 1] = iov[i];
        payload_length += iov[i].iov_len;
    }
    lenbuf[0] = payload_length / 256;
    lenbuf[1] = payload_length &amp; 0xff;
    payload_length += 2;

    memset(&amp;mh, 0, <span class="enscript-keyword">sizeof</span> mh);
    mh.msg_iov = &amp;iovec[0];
    mh.msg_iovlen = iov_len + 1;
    mh.msg_name = 0;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MSG_NOSIGNAL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MSG_NOSIGNAL</span> 0
#<span class="enscript-reference">endif</span>
    status = sendmsg(comm-&gt;io.sock, &amp;mh, MSG_NOSIGNAL);
    <span class="enscript-keyword">if</span> (status &lt; 0 || status != payload_length) {
        <span class="enscript-keyword">if</span> (status &lt; 0) {
            ERROR(<span class="enscript-string">&quot;tcp_send_response: write failed: %s&quot;</span>, strerror(errno));
        } <span class="enscript-keyword">else</span> {
            ERROR(<span class="enscript-string">&quot;tcp_send_response: short write (%zd out of %zu bytes)&quot;</span>, status, payload_length);
        }
        close(comm-&gt;io.sock);
        comm-&gt;io.sock = -1;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_send_response</span>(comm_t *comm, message_t *responding_to, <span class="enscript-type">struct</span> iovec *iov, <span class="enscript-type">int</span> iov_len)
{
    <span class="enscript-type">struct</span> msghdr mh;
    memset(&amp;mh, 0, <span class="enscript-keyword">sizeof</span> mh);
    mh.msg_iov = iov;
    mh.msg_iovlen = iov_len;
    mh.msg_name = &amp;responding_to-&gt;src;
    <span class="enscript-keyword">if</span> (responding_to-&gt;src.sa.sa_family == AF_INET) {
        mh.msg_namelen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (responding_to-&gt;src.sa.sa_family == AF_INET6) {
        mh.msg_namelen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
    } <span class="enscript-keyword">else</span> {
        ERROR(<span class="enscript-string">&quot;send_udp_response: unknown family %d&quot;</span>, responding_to-&gt;src.sa.sa_family);
        abort();
    }
    sendmsg(comm-&gt;io.sock, &amp;mh, 0);
}

<span class="enscript-comment">// When a communication is closed, scan the io event list to see if any other ios are referencing this one.
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">comm_finalize</span>(io_t *io_in) {
    io_t *io;

    <span class="enscript-keyword">for</span> (io = ios; io; io = io-&gt;next) {
        <span class="enscript-keyword">if</span> (io-&gt;cancel_on_close == io_in &amp;&amp; io-&gt;cancel != NULL) {
            io-&gt;cancel(io);
        }
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">listen_callback</span>(io_t *context)
{
    comm_t *listener = (comm_t *)context;
    <span class="enscript-type">int</span> rv;
    addr_t addr;
    socklen_t addr_len = <span class="enscript-keyword">sizeof</span> addr;
    comm_t *comm;
    <span class="enscript-type">char</span> addrbuf[INET6_ADDRSTRLEN + 7];
    <span class="enscript-type">int</span> addrlen;

    rv = accept(listener-&gt;io.sock, &amp;addr.sa, &amp;addr_len);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;accept: %s&quot;</span>, strerror(errno));
        close(listener-&gt;io.sock);
        listener-&gt;io.sock = -1;
        <span class="enscript-keyword">return</span>;
    }
    inet_ntop(addr.sa.sa_family, (addr.sa.sa_family == AF_INET
                                  ? (<span class="enscript-type">void</span> *)&amp;addr.sin.sin_addr
                                  : (<span class="enscript-type">void</span> *)&amp;addr.sin6.sin6_addr), addrbuf, <span class="enscript-keyword">sizeof</span> addrbuf);
    addrlen = strlen(addrbuf);
    snprintf(&amp;addrbuf[addrlen], (<span class="enscript-keyword">sizeof</span> addrbuf) - addrlen, <span class="enscript-string">&quot;%%%d&quot;</span>,
             (addr.sa.sa_family == AF_INET ? addr.sin.sin_port : addr.sin6.sin6_port));
    comm = calloc(1, <span class="enscript-keyword">sizeof</span> *comm);
    comm-&gt;name = strdup(addrbuf);
    comm-&gt;io.sock = rv;
    comm-&gt;address = addr;
    comm-&gt;datagram_callback = listener-&gt;datagram_callback;
    comm-&gt;send_response = tcp_send_response;
    comm-&gt;tcp_stream = true;

    <span class="enscript-keyword">if</span> (listener-&gt;connected) {
        listener-&gt;connected(comm);
    }
    add_reader(&amp;comm-&gt;io, tcp_read_callback, NULL);
    comm-&gt;io.finalize = comm_finalize;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SO_NOSIGPIPE</span>
    <span class="enscript-type">int</span> one = 1;
    rv = setsockopt(comm-&gt;io.sock, SOL_SOCKET, SO_NOSIGPIPE, &amp;one, <span class="enscript-keyword">sizeof</span> one);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;SO_NOSIGPIPE failed: %s&quot;</span>, strerror(errno));
    }
#<span class="enscript-reference">endif</span>
}

comm_t *
<span class="enscript-function-name">setup_listener_socket</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol, uint16_t port, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
                      comm_callback_t datagram_callback,
                      comm_callback_t connected, <span class="enscript-type">void</span> *context)
{
    comm_t *listener;
    socklen_t sl;
    <span class="enscript-type">int</span> rv;
    <span class="enscript-type">int</span> flag = 1;
    
    listener = calloc(1, <span class="enscript-keyword">sizeof</span> *listener);
    <span class="enscript-keyword">if</span> (listener == NULL) {
        <span class="enscript-keyword">return</span> NULL;
    }
    listener-&gt;name = strdup(name);
    <span class="enscript-keyword">if</span> (!listener-&gt;name) {
        free(listener);
        <span class="enscript-keyword">return</span> NULL;
    }
    listener-&gt;io.sock = socket(family, protocol == IPPROTO_UDP ? SOCK_DGRAM : SOCK_STREAM, protocol);
    <span class="enscript-keyword">if</span> (listener-&gt;io.sock &lt; 0) {
        ERROR(<span class="enscript-string">&quot;Can't get socket: %s&quot;</span>, strerror(errno));
        comm_free(listener);
        <span class="enscript-keyword">return</span> NULL;
    }
    rv = setsockopt(listener-&gt;io.sock, SOL_SOCKET, SO_REUSEPORT, &amp;flag, <span class="enscript-keyword">sizeof</span> flag);
    <span class="enscript-keyword">if</span> (rv &lt; 0) {
        ERROR(<span class="enscript-string">&quot;SO_REUSEPORT failed: %s&quot;</span>, strerror(errno));
        comm_free(listener);
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">if</span> (family == AF_INET) {
        sl = <span class="enscript-keyword">sizeof</span> listener-&gt;address.sin;
        listener-&gt;address.sin.sin_port = port ? port : htons(53);
    } <span class="enscript-keyword">else</span> {
        sl = <span class="enscript-keyword">sizeof</span> listener-&gt;address.sin6;
        listener-&gt;address.sin6.sin6_port = port ? port : htons(53);
    }
    listener-&gt;address.sa.sa_family = family;
    listener-&gt;address.sa.sa_len = sl;
    <span class="enscript-keyword">if</span> (bind(listener-&gt;io.sock, &amp;listener-&gt;address.sa, sl) &lt; 0) {
        ERROR(<span class="enscript-string">&quot;Can't bind to 0#53/%s%s: %s&quot;</span>,
                protocol == IPPROTO_UDP ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>, family == AF_INET ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;v6&quot;</span>,
                strerror(errno));
    <span class="enscript-reference">out</span>:
        close(listener-&gt;io.sock);
        free(listener);
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">if</span> (protocol == IPPROTO_TCP) {
        <span class="enscript-keyword">if</span> (listen(listener-&gt;io.sock, 5 <span class="enscript-comment">/* xxx */</span>) &lt; 0) {
            ERROR(<span class="enscript-string">&quot;Can't listen on 0#53/%s%s: %s.&quot;</span>,
                    protocol == IPPROTO_UDP ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>, family == AF_INET ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;v6&quot;</span>,
                    strerror(errno));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }                
        add_reader(&amp;listener-&gt;io, listen_callback, NULL);
    } <span class="enscript-keyword">else</span> {
        rv = setsockopt(listener-&gt;io.sock, family == AF_INET ? IPPROTO_IP : IPPROTO_IPV6,
                        family == AF_INET ? IP_PKTINFO : IPV6_RECVPKTINFO, &amp;flag, <span class="enscript-keyword">sizeof</span> flag);
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
            ERROR(<span class="enscript-string">&quot;Can't set %s: %s.&quot;</span>, family == AF_INET ? <span class="enscript-string">&quot;IP_PKTINFO&quot;</span> : <span class="enscript-string">&quot;IPV6_RECVPKTINFO&quot;</span>,
                    strerror(errno));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        add_reader(&amp;listener-&gt;io, udp_read_callback, NULL);
        listener-&gt;send_response = udp_send_response;
    }
    listener-&gt;datagram_callback = datagram_callback;
    listener-&gt;connected = connected;
    <span class="enscript-keyword">return</span> listener;
}

<span class="enscript-comment">// Local Variables:
</span><span class="enscript-comment">// mode: C
</span><span class="enscript-comment">// tab-width: 4
</span><span class="enscript-comment">// c-file-style: &quot;bsd&quot;
</span><span class="enscript-comment">// c-basic-offset: 4
</span><span class="enscript-comment">// fill-column: 108
</span><span class="enscript-comment">// indent-tabs-mode: nil
</span><span class="enscript-comment">// End:
</span></pre>
<hr />
</body></html>