<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>towire.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">towire.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="towire.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* wire.c
 *
 * Copyright (c) 2018 Apple Computer, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * DNS wire-format functions.
 *
 * These are really simple functions for constructing DNS messages wire format.
 * The flow is that there is a transaction structure which contains pointers to both
 * a message output buffer and a response input buffer.   The structure is initialized,
 * and then the various wire format functions are called repeatedly to store data.
 * If an error occurs during this process, it's okay to just keep going, because the
 * error is recorded in the transaction; once all of the copy-in functions have been
 * called, the error status can be checked once at the end.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns-msg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp-crypto.h&quot;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CLOCK</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Convert a name to wire format.   Does not store the root label (0) at the end.   Does not support binary labels.
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">dns_name_to_wire</span>(dns_name_pointer_t *NULLABLE r_pointer,
                 dns_towire_state_t *NONNULL txn,
                 <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL name)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *next, *cur, *end;
    dns_name_pointer_t np;
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        memset(&amp;np, 0, <span class="enscript-keyword">sizeof</span> np);
        np.message_start = (u_int8_t *)txn-&gt;message;
        np.name_start = txn-&gt;p;

        cur = name;
        <span class="enscript-keyword">do</span> {
            end = strchr(cur, <span class="enscript-string">'.'</span>);
            <span class="enscript-keyword">if</span> (end == NULL) {
                end = cur + strlen(cur);
                <span class="enscript-keyword">if</span> (end == cur) {
                    <span class="enscript-keyword">break</span>;
                }
                next = NULL;
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-keyword">if</span> (end == cur) {
                    <span class="enscript-keyword">break</span>;
                }
                next = end + 1;
            }

            <span class="enscript-comment">// Is there no space?
</span>            <span class="enscript-keyword">if</span> (txn-&gt;p + (1 + end - cur) &gt;= txn-&gt;lim) {
                txn-&gt;error = ENOBUFS;
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-comment">// Is the label too long?
</span>            <span class="enscript-keyword">if</span> (end - cur &gt; DNS_MAX_LABEL_SIZE) {
                txn-&gt;error = ENAMETOOLONG;
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-comment">// Store the label length
</span>            *txn-&gt;p++ = (uint8_t)(end - cur);

            <span class="enscript-comment">// Store the label.
</span>            memcpy(txn-&gt;p, cur, end - cur);
            txn-&gt;p += (end - cur);
            np.num_labels++;
            np.length += 1 + (end - cur);

            cur = next;
        } <span class="enscript-keyword">while</span> (next != NULL);

        <span class="enscript-keyword">if</span> (np.length &gt; DNS_MAX_NAME_SIZE) {
            txn-&gt;error = ENAMETOOLONG;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (r_pointer != NULL) {
            *r_pointer = np;
        }
    }
}

<span class="enscript-comment">// Like dns_name_to_wire, but includes the root label at the end.
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">dns_full_name_to_wire</span>(dns_name_pointer_t *NULLABLE r_pointer,
                      dns_towire_state_t *NONNULL txn,
                      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL name)
{
    dns_name_pointer_t np;
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        memset(&amp;np, 0, <span class="enscript-keyword">sizeof</span> np);
        dns_name_to_wire(&amp;np, txn, name);
        <span class="enscript-keyword">if</span> (!txn-&gt;error) {
            <span class="enscript-keyword">if</span> (txn-&gt;p + 1 &gt;= txn-&gt;lim) {
                txn-&gt;error = ENOBUFS;
                <span class="enscript-keyword">return</span>;
            }
            *txn-&gt;p++ = 0;
            np.num_labels++;
            np.length += 1;
            <span class="enscript-keyword">if</span> (np.length &gt; DNS_MAX_NAME_SIZE) {
                txn-&gt;error = ENAMETOOLONG;
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">if</span> (r_pointer) {
                *r_pointer = np;
            }
        }
    }
}

<span class="enscript-comment">// Store a pointer to a name that's already in the message.
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">dns_pointer_to_wire</span>(dns_name_pointer_t *NULLABLE r_pointer,
                    dns_towire_state_t *NONNULL txn,
                    dns_name_pointer_t *NONNULL pointer)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        u_int16_t offset = pointer-&gt;name_start - pointer-&gt;message_start;
        <span class="enscript-keyword">if</span> (offset &gt; DNS_MAX_POINTER) {
            txn-&gt;error = ETOOMANYREFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (txn-&gt;p + 2 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = 0xc0 | (offset &gt;&gt; 8);
        *txn-&gt;p++ = offset &amp; 0xff;
        <span class="enscript-keyword">if</span> (r_pointer) {
            r_pointer-&gt;num_labels += pointer-&gt;num_labels;
            r_pointer-&gt;length += pointer-&gt;length + 1;
            <span class="enscript-keyword">if</span> (r_pointer-&gt;length &gt; DNS_MAX_NAME_SIZE) {
                txn-&gt;error = ENAMETOOLONG;
                <span class="enscript-keyword">return</span>;
            }
        }
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_u8_to_wire</span>(dns_towire_state_t *NONNULL txn,
                 uint8_t val)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 1 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = val;
    }
}

<span class="enscript-comment">// Store a 16-bit integer in network byte order
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">dns_u16_to_wire</span>(dns_towire_state_t *NONNULL txn,
                 uint16_t val)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 2 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = val &gt;&gt; 8;
        *txn-&gt;p++ = val &amp; 0xff;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_u32_to_wire</span>(dns_towire_state_t *NONNULL txn,
                 uint32_t val)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 4 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = val &gt;&gt; 24;
        *txn-&gt;p++ = (val &gt;&gt; 16) &amp; 0xff;
        *txn-&gt;p++ = (val &gt;&gt; 8) &amp; 0xff;
        *txn-&gt;p++ = val &amp; 0xff;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_ttl_to_wire</span>(dns_towire_state_t *NONNULL txn,
                int32_t val)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (val &lt; 0) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span>;
        }
        dns_u32_to_wire(txn, (uint32_t)val);
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdlength_begin</span>(dns_towire_state_t *NONNULL txn)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 2 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (txn-&gt;p_rdlength != NULL) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span>;
        }
        txn-&gt;p_rdlength = txn-&gt;p;
        txn-&gt;p += 2;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdlength_end</span>(dns_towire_state_t *NONNULL txn)
{
    <span class="enscript-type">int</span> rdlength;
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p_rdlength == NULL) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span>;
        }
        rdlength = txn-&gt;p - txn-&gt;p_rdlength - 2;
        txn-&gt;p_rdlength[0] = rdlength &gt;&gt; 8;
        txn-&gt;p_rdlength[1] = rdlength &amp; 0xff;
        txn-&gt;p_rdlength = NULL;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdata_a_to_wire</span>(dns_towire_state_t *NONNULL txn,
                    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL ip_address)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 4 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (!inet_pton(AF_INET, ip_address, txn-&gt;p)) {
            txn-&gt;error = EINVAL;
        }
        txn-&gt;p += 4;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdata_aaaa_to_wire</span>(dns_towire_state_t *NONNULL txn,
                       <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL ip_address)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 16 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (!inet_pton(AF_INET6, ip_address, txn-&gt;p)) {
            txn-&gt;error = EINVAL;
        }
        txn-&gt;p += 16;
    }
}

uint16_t
<span class="enscript-function-name">dns_rdata_key_to_wire</span>(dns_towire_state_t *NONNULL txn,
                      <span class="enscript-type">unsigned</span> key_type,
                      <span class="enscript-type">unsigned</span> name_type,
                      <span class="enscript-type">unsigned</span> signatory,
                      srp_key_t *key)
{
    <span class="enscript-type">int</span> key_len = srp_pubkey_length(key);
    uint8_t *rdata = txn-&gt;p;
    uint32_t key_tag;
    <span class="enscript-type">int</span> i, rdlen;
    
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (key_type &gt; 3 || name_type &gt; 3 || signatory &gt; 15) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span> 0;
        }
        <span class="enscript-keyword">if</span> (txn-&gt;p + key_len + 4 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span> 0;
        }
        *txn-&gt;p++ = (key_type &lt;&lt; 6) | name_type;
        *txn-&gt;p++ = signatory;
        *txn-&gt;p++ = 3; <span class="enscript-comment">// protocol type is always 3
</span>        *txn-&gt;p++ = srp_key_algorithm(key);
        srp_pubkey_copy(txn-&gt;p, key_len, key);
        txn-&gt;p += key_len;
    }
    rdlen = txn-&gt;p - rdata;

    <span class="enscript-comment">// Compute the key tag
</span>    key_tag = 0;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; rdlen; i++) {
        key_tag += (i &amp; 1) ? rdata[i] : rdata[i] &lt;&lt; 8;
    }
    key_tag += (key_tag &gt;&gt; 16) &amp; 0xFFFF;
    <span class="enscript-keyword">return</span> (uint16_t)(key_tag &amp; 0xFFFF);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdata_txt_to_wire</span>(dns_towire_state_t *NONNULL txn,
                      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL txt_record)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-type">unsigned</span> len = strlen(txt_record);
        <span class="enscript-keyword">if</span> (txn-&gt;p + len + 1 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (len &gt; 255) {
            txn-&gt;error = ENAMETOOLONG;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = (u_int8_t)len;
        memcpy(txn-&gt;p, txt_record, len);
        txn-&gt;p += len;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_rdata_raw_data_to_wire</span>(dns_towire_state_t *NONNULL txn, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *NONNULL raw_data, size_t length)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + length &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        memcpy(txn-&gt;p, raw_data, length);
        txn-&gt;p += length;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_edns0_header_to_wire</span>(dns_towire_state_t *NONNULL txn,
                         <span class="enscript-type">int</span> mtu,
                         <span class="enscript-type">int</span> xrcode,
                         <span class="enscript-type">int</span> version,
                         <span class="enscript-type">int</span> DO)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 9 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        *txn-&gt;p++ = 0; <span class="enscript-comment">// root label
</span>        dns_u16_to_wire(txn, dns_rrtype_opt);
        dns_u16_to_wire(txn, mtu);
        *txn-&gt;p++ = xrcode;
        *txn-&gt;p++ = version;
        *txn-&gt;p++ = DO &lt;&lt; 7;	<span class="enscript-comment">// flags (usb)
</span>        *txn-&gt;p++ = 0;			<span class="enscript-comment">// flags (lsb, mbz)
</span>    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_edns0_option_begin</span>(dns_towire_state_t *NONNULL txn)
{
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p + 2 &gt;= txn-&gt;lim) {
            txn-&gt;error = ENOBUFS;
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (txn-&gt;p_opt != NULL) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span>;
        }
        txn-&gt;p_opt = txn-&gt;p;
        txn-&gt;p += 2;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_edns0_option_end</span>(dns_towire_state_t *NONNULL txn)
{
    <span class="enscript-type">int</span> opt_length;
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        <span class="enscript-keyword">if</span> (txn-&gt;p_opt == NULL) {
            txn-&gt;error = EINVAL;
            <span class="enscript-keyword">return</span>;
        }
        opt_length = txn-&gt;p - txn-&gt;p_opt - 2;
        txn-&gt;p_opt[0] = opt_length &gt;&gt; 8;
        txn-&gt;p_opt[1] = opt_length &amp; 0xff;
        txn-&gt;p_opt = NULL;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dns_sig0_signature_to_wire</span>(dns_towire_state_t *NONNULL txn,
                           srp_key_t *key,
                           uint16_t key_tag,
                           dns_name_pointer_t *NONNULL signer,
                           <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL signer_fqdn)
{
    <span class="enscript-type">int</span> siglen = srp_signature_length(key);
    uint8_t *start, *p_signer, *p_signature, *rrstart = txn-&gt;p;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NO_CLOCK</span>
    <span class="enscript-type">struct</span> timeval now;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// 1 name (root)
</span>    <span class="enscript-comment">// 2 type (SIG)
</span>    <span class="enscript-comment">// 2 class (0)
</span>    <span class="enscript-comment">// 4 TTL (0)
</span>    <span class="enscript-comment">// 18 SIG RDATA up to signer name
</span>    <span class="enscript-comment">// 2 signer name (always a pointer)
</span>    <span class="enscript-comment">// 29 bytes so far
</span>    <span class="enscript-comment">// signature data (depends on algorithm, e.g. 64 for ECDSASHA256)
</span>    <span class="enscript-comment">// so e.g. 93 bytes total
</span>    
    <span class="enscript-keyword">if</span> (!txn-&gt;error) {
        dns_u8_to_wire(txn, 0);	<span class="enscript-comment">// root label
</span>        dns_u16_to_wire(txn, dns_rrtype_sig);
        dns_u16_to_wire(txn, 0); <span class="enscript-comment">// class
</span>        dns_ttl_to_wire(txn, 0); <span class="enscript-comment">// SIG RR TTL
</span>        dns_rdlength_begin(txn);
        start = txn-&gt;p;
        dns_u16_to_wire(txn, 0); <span class="enscript-comment">// type = 0 for transaction signature
</span>        dns_u8_to_wire(txn, srp_key_algorithm(key));
        dns_u8_to_wire(txn, 0); <span class="enscript-comment">// labels field doesn't apply for transaction signature
</span>        dns_ttl_to_wire(txn, 0); <span class="enscript-comment">// original ttl doesn't apply
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NO_CLOCK</span>
        dns_u32_to_wire(txn, 0); <span class="enscript-comment">// Indicate that we have no clock: set expiry and inception times to zero
</span>        dns_u32_to_wire(txn, 0);
#<span class="enscript-reference">else</span>        
        gettimeofday(&amp;now, NULL);
        dns_u32_to_wire(txn, now.tv_sec + 300); <span class="enscript-comment">// signature expiration time is five minutes from now
</span>        dns_u32_to_wire(txn, now.tv_sec - 300); <span class="enscript-comment">// signature inception time, five minutes in the past
</span>#<span class="enscript-reference">endif</span>
        dns_u16_to_wire(txn, key_tag);
        p_signer = txn-&gt;p;
        <span class="enscript-comment">// We store the name in uncompressed form because that's what we have to sign
</span>        dns_full_name_to_wire(NULL, txn, signer_fqdn);
        <span class="enscript-comment">// And that means we're going to have to copy the signature back earlier in the packet.
</span>        p_signature = txn-&gt;p;

        <span class="enscript-comment">// Sign the message, signature RRDATA (less signature) first.
</span>        srp_sign(txn-&gt;p, siglen, (uint8_t *)txn-&gt;message, rrstart - (uint8_t *)txn-&gt;message,
                 start, txn-&gt;p - start, key);

        <span class="enscript-comment">// Now that it's signed, back up and store the pointer to the name, because we're trying
</span>        <span class="enscript-comment">// to be as compact as possible.
</span>        txn-&gt;p = p_signer;
        dns_pointer_to_wire(NULL, txn, signer); <span class="enscript-comment">// Pointer to the owner name the key is attached to
</span>        <span class="enscript-comment">// And move the signature earlier in the packet.
</span>        memmove(txn-&gt;p, p_signature, siglen);

        txn-&gt;p += siglen;
        dns_rdlength_end(txn);
    }
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">dns_send_to_server</span>(dns_transaction_t *NONNULL txn,
                   <span class="enscript-type">const</span> <span class="enscript-type">char</span> *NONNULL anycast_address, uint16_t port,
                   dns_response_callback_t NONNULL callback)
{
    <span class="enscript-type">union</span> {
        <span class="enscript-type">struct</span> sockaddr_storage s;
        <span class="enscript-type">struct</span> sockaddr sa;
        <span class="enscript-type">struct</span> sockaddr_in sin;
        <span class="enscript-type">struct</span> sockaddr_in6 sin6;
    } addr, from;
    socklen_t len, fromlen;
    ssize_t rv, datasize;

    <span class="enscript-keyword">if</span> (!txn-&gt;towire.error) {
        memset(&amp;addr, 0, <span class="enscript-keyword">sizeof</span> addr);

        <span class="enscript-comment">// Try IPv4 first because IPv6 addresses are never valid IPv4 addresses
</span>        <span class="enscript-keyword">if</span> (inet_pton(AF_INET, anycast_address, &amp;addr.sin.sin_addr)) {
            addr.sin.sin_family = AF_INET;
            addr.sin.sin_port = htons(port);
            len = <span class="enscript-keyword">sizeof</span> addr.sin;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inet_pton(AF_INET6, anycast_address, &amp;addr.sin6.sin6_addr)) {
            addr.sin6.sin6_family = AF_INET6;
            addr.sin6.sin6_port = htons(port);
            len = <span class="enscript-keyword">sizeof</span> addr.sin6;
        } <span class="enscript-keyword">else</span> {
            txn-&gt;towire.error = EPROTONOSUPPORT;
            <span class="enscript-keyword">return</span> -1;
        }
<span class="enscript-comment">//#ifdef HAVE_SA_LEN
</span>        addr.sa.sa_len = len;
<span class="enscript-comment">//#endif
</span>
        txn-&gt;sock = socket(addr.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);
        <span class="enscript-keyword">if</span> (txn-&gt;sock &lt; 0) {
            txn-&gt;towire.error = errno;
            <span class="enscript-keyword">return</span> -1;
        }

#<span class="enscript-reference">if</span> 0
        memset(&amp;myaddr, 0, <span class="enscript-keyword">sizeof</span> myaddr);
        myaddr.sin.sin_port = htons(9999);
        myaddr.sa.sa_len = len;
        myaddr.sa.sa_family = addr.sa.sa_family;
        rv = bind(txn-&gt;sock, &amp;myaddr.sa, len);
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
            txn-&gt;towire.error = errno;
            <span class="enscript-keyword">return</span> -1;
        }
#<span class="enscript-reference">endif</span>

        datasize = txn-&gt;towire.p - ((u_int8_t *)txn-&gt;towire.message);
        rv = sendto(txn-&gt;sock, txn-&gt;towire.message, datasize, 0, &amp;addr.sa, len);
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
            txn-&gt;towire.error = errno;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        <span class="enscript-keyword">if</span> (rv != datasize) {
            txn-&gt;towire.error = EMSGSIZE;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        fromlen = <span class="enscript-keyword">sizeof</span> from;
        rv = recvfrom(txn-&gt;sock, txn-&gt;response, <span class="enscript-keyword">sizeof</span> *txn-&gt;response, 0, &amp;from.sa, &amp;fromlen);
        <span class="enscript-keyword">if</span> (rv &lt; 0) {
            txn-&gt;towire.error = errno;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        txn-&gt;response_length = rv;
    }
<span class="enscript-reference">out</span>:
    close(txn-&gt;sock);
    txn-&gt;sock = 0;

    <span class="enscript-keyword">if</span> (txn-&gt;towire.error) {
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// Local Variables:
</span><span class="enscript-comment">// mode: C
</span><span class="enscript-comment">// tab-width: 4
</span><span class="enscript-comment">// c-file-style: &quot;bsd&quot;
</span><span class="enscript-comment">// c-basic-offset: 4
</span><span class="enscript-comment">// fill-column: 108
</span><span class="enscript-comment">// indent-tabs-mode: nil
</span><span class="enscript-comment">// End:
</span></pre>
<hr />
</body></html>