<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sign-mbedtls.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sign-mbedtls.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="sign-mbedtls.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* sign.c
 *
 * Copyright (c) 2018 Apple Computer, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * DNS SIG(0) signature generation for DNSSD SRP using mbedtls.
 *
 * Functions required for loading, saving, and generating public/private keypairs, extracting the public key
 * into KEY RR data, and computing signatures.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns-msg.h&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SRP_CRYPTO_MBEDTLS_INTERNAL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;srp-crypto.h&quot;</span>

<span class="enscript-comment">// For debugging
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEBUG_SHA256</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">srp_mbedtls_sha256_update_ret</span>(mbedtls_sha256_context *sha, uint8_t *data, size_t len)
{
    <span class="enscript-type">int</span> i;
    fprintf(stderr, <span class="enscript-string">&quot;data %lu: &quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)len);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; len; i++) {
        fprintf(stderr, <span class="enscript-string">&quot;%02x&quot;</span>, data[i]);
    }
    fputs(<span class="enscript-string">&quot;\n&quot;</span>, stderr);
    <span class="enscript-keyword">return</span> mbedtls_sha256_update_ret(sha, data, len);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">srp_mbedtls_sha256_finish_ret</span>(mbedtls_sha256_context *sha, uint8_t *hash)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> status = mbedtls_sha256_finish_ret(sha, hash);
    fprintf(stderr, <span class="enscript-string">&quot;hash:     &quot;</span>);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ECDSA_SHA256_HASH_SIZE; i++) {
        fprintf(stderr, <span class="enscript-string">&quot;%02x&quot;</span>, hash[i]);
    }
    fputs(<span class="enscript-string">&quot;\n&quot;</span>, stderr);
    <span class="enscript-keyword">return</span> status;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Key is stored in an opaque data structure, for mbedtls this is an mbedtls_pk_context.
</span><span class="enscript-comment">// Function to read a public key from a KEY record
</span><span class="enscript-comment">// Function to validate a signature given some data and a public key (not required on client)
</span>
<span class="enscript-comment">// Function to free a key
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">srp_keypair_free</span>(srp_key_t *key)
{
    mbedtls_pk_free(&amp;key-&gt;key);
    mbedtls_entropy_free(&amp;key-&gt;entropy);
    mbedtls_ctr_drbg_free(&amp;key-&gt;ctr);
    free(key);
}

<span class="enscript-comment">// Needed to see the RNG with good entropy data.
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_entropy</span>(<span class="enscript-type">void</span> *data, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *output, size_t len, size_t *outlen)
{
    <span class="enscript-type">int</span> result = getentropy(output, len);
    (<span class="enscript-type">void</span>)data;

    <span class="enscript-keyword">if</span> (result != 0) {
        ERROR(<span class="enscript-string">&quot;getentropy returned %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span> MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
    }
    *outlen = len;
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> srp_key_t *
<span class="enscript-function-name">srp_key_setup</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> status;
    srp_key_t *key = calloc(<span class="enscript-keyword">sizeof</span> *key, 1);
    <span class="enscript-type">char</span> errbuf[64];

    <span class="enscript-keyword">if</span> (key == NULL) {
        <span class="enscript-keyword">return</span> key;
    }
    
    mbedtls_pk_init(&amp;key-&gt;key);
    mbedtls_entropy_init(&amp;key-&gt;entropy);
    <span class="enscript-keyword">if</span> ((status = mbedtls_entropy_add_source(&amp;key-&gt;entropy, get_entropy,
                                             NULL, 1, MBEDTLS_ENTROPY_SOURCE_STRONG)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_entropy_add_source failed: %s&quot;</span>, errbuf);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((status = mbedtls_ctr_drbg_seed(&amp;key-&gt;ctr, mbedtls_entropy_func, &amp;key-&gt;entropy, NULL, 0)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_ctr_drbg_seed failed: %s&quot;</span>, errbuf);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> key;
    }
    mbedtls_pk_free(&amp;key-&gt;key);
    mbedtls_entropy_free(&amp;key-&gt;entropy);
    free(key);
    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">// Function to read a keypair from a file
</span>srp_key_t *
<span class="enscript-function-name">srp_load_keypair</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *file)
{
    <span class="enscript-type">int</span> fd = open(file, O_RDONLY);
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[256];
    ssize_t rv;
    srp_key_t *key;
    <span class="enscript-type">int</span> status;
    <span class="enscript-type">char</span> errbuf[64];

    <span class="enscript-keyword">if</span> (fd &lt; 0) {
        <span class="enscript-keyword">if</span> (errno != ENOENT) {
            ERROR(<span class="enscript-string">&quot;Unable to open srp.key: %s&quot;</span>, strerror(errno));
            <span class="enscript-keyword">return</span> NULL;
        }
        <span class="enscript-keyword">return</span> NULL;
    }        

    <span class="enscript-comment">// The key is of limited size, so there's no reason to get fancy.
</span>    rv = read(fd, buf, <span class="enscript-keyword">sizeof</span> buf);
    close(fd);
    <span class="enscript-keyword">if</span> (rv == <span class="enscript-keyword">sizeof</span> buf) {
        ERROR(<span class="enscript-string">&quot;key file is unreasonably large.&quot;</span>);
        <span class="enscript-keyword">return</span> NULL;
    }

    key = srp_key_setup();
    <span class="enscript-keyword">if</span> (key == NULL) {
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">if</span> ((status = mbedtls_pk_parse_key(&amp;key-&gt;key, buf, rv, NULL, 0)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_pk_parse_key failed: %s&quot;</span>, errbuf);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!mbedtls_pk_can_do(&amp;key-&gt;key, MBEDTLS_PK_ECDSA)) {
        ERROR(<span class="enscript-string">&quot;%s does not contain a usable ECDSA key.&quot;</span>, file);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> key;
    }
    srp_keypair_free(key);
    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">// Function to generate a key
</span>srp_key_t *
<span class="enscript-function-name">srp_generate_key</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> status;
    <span class="enscript-type">char</span> errbuf[64];
    srp_key_t *key = srp_key_setup();
    <span class="enscript-type">const</span> mbedtls_pk_info_t *key_type = mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);

    <span class="enscript-keyword">if</span> (key == NULL || key_type == NULL) {
        <span class="enscript-keyword">return</span> NULL;
    }
    
    <span class="enscript-keyword">if</span> ((status = mbedtls_pk_setup(&amp;key-&gt;key, key_type)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_pk_setup failed: %s&quot;</span>, errbuf);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((status = mbedtls_ecdsa_genkey(mbedtls_pk_ec(key-&gt;key), MBEDTLS_ECP_DP_SECP256R1,
                                              mbedtls_ctr_drbg_random, &amp;key-&gt;ctr)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_ecdsa_genkey failed: %s&quot;</span>, errbuf);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> key;
    }
    srp_keypair_free(key);
    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">// Function to write a keypair to a file
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">srp_write_key_to_file</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *file, srp_key_t *key)
{
    <span class="enscript-type">int</span> fd;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[256];
    ssize_t rv;
    <span class="enscript-type">int</span> len;
    <span class="enscript-type">char</span> errbuf[64];

    len = mbedtls_pk_write_key_der(&amp;key-&gt;key, buf, <span class="enscript-keyword">sizeof</span> buf);
    <span class="enscript-keyword">if</span> (len &lt;= 0) {
        mbedtls_strerror(len, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_pk_write_key_der failed: %s&quot;</span>, errbuf);
        <span class="enscript-keyword">return</span> 0;
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">O_DIRECT</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">O_DIRECT</span> 0
#<span class="enscript-reference">endif</span>
    fd = open(file, O_CREAT | O_EXCL | O_WRONLY | O_DIRECT, 0700);
    <span class="enscript-keyword">if</span> (fd &lt; 0) {
        ERROR(<span class="enscript-string">&quot;Unable to create srp.key: %s&quot;</span>, strerror(errno));
        <span class="enscript-keyword">return</span> 0;
    }        

    rv = write(fd, &amp;buf[<span class="enscript-keyword">sizeof</span> buf - len], len);
    close(fd);
    <span class="enscript-keyword">if</span> (rv != len) {
        ERROR(<span class="enscript-string">&quot;key file write truncated.&quot;</span>);
        unlink(file);
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">// Function to get the length of the public key
</span>size_t
<span class="enscript-function-name">srp_pubkey_length</span>(srp_key_t *key)
{
    <span class="enscript-keyword">return</span> ECDSA_KEY_SIZE;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">srp_key_algorithm</span>(srp_key_t *key)
{
    <span class="enscript-keyword">return</span> dnssec_keytype_ecdsa;
}

size_t
<span class="enscript-function-name">srp_signature_length</span>(srp_key_t *key)
{
    <span class="enscript-keyword">return</span> ECDSA_KEY_SIZE;
}

<span class="enscript-comment">// Function to copy out the public key as binary data
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">srp_pubkey_copy</span>(uint8_t *buf, size_t max, srp_key_t *key)
{
    mbedtls_ecp_keypair *ecp = mbedtls_pk_ec(key-&gt;key);
    <span class="enscript-type">char</span> errbuf[64];
    <span class="enscript-type">int</span> status;

    <span class="enscript-keyword">if</span> (max &lt; ECDSA_KEY_SIZE) {
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-comment">// Currently ECP only.
</span>    <span class="enscript-keyword">if</span> ((status = mbedtls_mpi_write_binary(&amp;ecp-&gt;Q.X, buf, ECDSA_KEY_PART_SIZE)) != 0 ||
        (status = mbedtls_mpi_write_binary(&amp;ecp-&gt;Q.Y, buf + ECDSA_KEY_PART_SIZE, ECDSA_KEY_PART_SIZE)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_mpi_write_binary: %s&quot;</span>, errbuf);
        <span class="enscript-keyword">return</span> 0;
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MBEDTLS_PUBKEY_DUMP</span>
    <span class="enscript-type">int</span> i;
    fprintf(stderr, <span class="enscript-string">&quot;pubkey %d: &quot;</span>, ECDSA_KEY_SIZE);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ECDSA_KEY_SIZE; i++) {
        fprintf(stderr, <span class="enscript-string">&quot;%02x&quot;</span>, buf[i]);
    }
    putc(<span class="enscript-string">'\n'</span>, stderr);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> ECDSA_KEY_SIZE;
}

<span class="enscript-comment">// Function to generate a signature given some data and a private key
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">srp_sign</span>(uint8_t *output, size_t max, uint8_t *message, size_t msglen, uint8_t *rr, size_t rdlen, srp_key_t *key)
{
    <span class="enscript-type">int</span> status;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hash[ECDSA_SHA256_HASH_SIZE];
    <span class="enscript-type">char</span> errbuf[64];
    mbedtls_sha256_context sha;
    mbedtls_ecp_keypair *ecp = mbedtls_pk_ec(key-&gt;key);
    mbedtls_mpi r, s;

    <span class="enscript-keyword">if</span> (max &lt; ECDSA_SHA256_SIG_SIZE) {
        ERROR(<span class="enscript-string">&quot;srp_sign: not enough space in output buffer (%lu) for signature (%d).&quot;</span>,
              (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)max, ECDSA_SHA256_SIG_SIZE);
        <span class="enscript-keyword">return</span> 0;
    }

    mbedtls_sha256_init(&amp;sha);
    memset(hash, 0, <span class="enscript-keyword">sizeof</span> hash);
    mbedtls_mpi_init(&amp;r);
    mbedtls_mpi_init(&amp;s);

    <span class="enscript-comment">// Calculate the hash across first the SIG RR (minus the signature) and then the message
</span>    <span class="enscript-comment">// up to but not including the SIG RR.
</span>    <span class="enscript-keyword">if</span> ((status = mbedtls_sha256_starts_ret(&amp;sha, 0)) != 0 ||
        (status = srp_mbedtls_sha256_update_ret(&amp;sha, rr, rdlen) != 0) ||
        (status = srp_mbedtls_sha256_update_ret(&amp;sha, message, msglen)) != 0 ||
        (status = srp_mbedtls_sha256_finish_ret(&amp;sha, hash)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_sha_256 hash failed: %s&quot;</span>, errbuf);
        <span class="enscript-keyword">return</span> 0;
    }

    status = mbedtls_ecdsa_sign(&amp;ecp-&gt;grp, &amp;r, &amp;s, &amp;ecp-&gt;d, hash, <span class="enscript-keyword">sizeof</span> hash,
                                mbedtls_ctr_drbg_random, &amp;key-&gt;ctr);
    <span class="enscript-keyword">if</span> (status != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_ecdsa_sign failed: %s&quot;</span>, errbuf);
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> ((status = mbedtls_mpi_write_binary(&amp;r, output, ECDSA_SHA256_SIG_PART_SIZE)) != 0 ||
        (status = mbedtls_mpi_write_binary(&amp;s, output + ECDSA_SHA256_SIG_PART_SIZE,
                                           ECDSA_SHA256_SIG_PART_SIZE)) != 0) {
        mbedtls_strerror(status, errbuf, <span class="enscript-keyword">sizeof</span> errbuf);
        ERROR(<span class="enscript-string">&quot;mbedtls_ecdsa_sign failed: %s&quot;</span>, errbuf);
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">return</span> 1;
}
    
<span class="enscript-comment">// Local Variables:
</span><span class="enscript-comment">// mode: C
</span><span class="enscript-comment">// tab-width: 4
</span><span class="enscript-comment">// c-file-style: &quot;bsd&quot;
</span><span class="enscript-comment">// c-basic-offset: 4
</span><span class="enscript-comment">// fill-column: 108
</span><span class="enscript-comment">// indent-tabs-mode: nil
</span><span class="enscript-comment">// End:
</span></pre>
<hr />
</body></html>