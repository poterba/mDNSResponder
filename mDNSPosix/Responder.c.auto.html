<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Responder.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">Responder.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="Responder.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2002-2004 Apple Computer, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__APPLE__</span>
<span class="enscript-comment">// In Mac OS X 10.5 and later trying to use the daemon function gives a “‘daemon’ is deprecated”
</span><span class="enscript-comment">// error, which prevents compilation because we build with &quot;-Werror&quot;.
</span><span class="enscript-comment">// Since this is supposed to be portable cross-platform code, we don't care that daemon is
</span><span class="enscript-comment">// deprecated on Mac OS X 10.5, so we use this preprocessor trick to eliminate the error message.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">daemon</span> yes_we_know_that_daemon_is_deprecated_in_os_x_10_5_thankyou
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>          // For printf()
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>         // For exit() etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>         // For strlen() etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>         // For select()
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>          // For errno, EINTR
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__APPLE__</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">daemon</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">daemon</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span> // Defines the interface to the client layer above
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSPosix.h&quot;</span>      // Defines the specific types needed to run mDNS on this platform
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSUNP.h&quot;</span>        // For daemon()

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> ***** <span class="enscript-variable-name">Globals</span>
#<span class="enscript-reference">endif</span>

mDNS mDNSStorage;       <span class="enscript-comment">// mDNS core uses this to store its globals
</span><span class="enscript-type">static</span> mDNS_PlatformSupport PlatformStorage;  <span class="enscript-comment">// Stores this platform's globals
</span>
mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> ProgramName[] = <span class="enscript-string">&quot;mDNSResponderPosix&quot;</span>;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gProgramName = ProgramName;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> ***** <span class="enscript-variable-name">Signals</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> mDNSBool gReceivedSigUsr1;
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> mDNSBool gReceivedSigHup;
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> mDNSBool gStopNow;

<span class="enscript-comment">// We support 4 signals.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// o SIGUSR1 toggles verbose mode on and off in debug builds
</span><span class="enscript-comment">// o SIGHUP  triggers the program to re-read its preferences.
</span><span class="enscript-comment">// o SIGINT  causes an orderly shutdown of the program.
</span><span class="enscript-comment">// o SIGQUIT causes a somewhat orderly shutdown (direct but dangerous)
</span><span class="enscript-comment">// o SIGKILL kills us dead (easy to implement :-)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// There are fatal race conditions in our signal handling, but there's not much
</span><span class="enscript-comment">// we can do about them while remaining within the Posix space.  Specifically,
</span><span class="enscript-comment">// if a signal arrives after we test the globals its sets but before we call
</span><span class="enscript-comment">// select, the signal will be dropped.  The user will have to send the signal
</span><span class="enscript-comment">// again.  Unfortunately, Posix does not have a &quot;sigselect&quot; to atomically
</span><span class="enscript-comment">// modify the signal mask and start a select.
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">HandleSigUsr1</span>(<span class="enscript-type">int</span> sigraised)
<span class="enscript-comment">// If we get a SIGUSR1 we toggle the state of the
</span><span class="enscript-comment">// verbose mode.
</span>{
    assert(sigraised == SIGUSR1);
    gReceivedSigUsr1 = mDNStrue;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">HandleSigHup</span>(<span class="enscript-type">int</span> sigraised)
<span class="enscript-comment">// A handler for SIGHUP that causes us to break out of the
</span><span class="enscript-comment">// main event loop when the user kill 1's us.  This has the
</span><span class="enscript-comment">// effect of triggered the main loop to deregister the
</span><span class="enscript-comment">// current services and re-read the preferences.
</span>{
    assert(sigraised == SIGHUP);
    gReceivedSigHup = mDNStrue;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">HandleSigInt</span>(<span class="enscript-type">int</span> sigraised)
<span class="enscript-comment">// A handler for SIGINT that causes us to break out of the
</span><span class="enscript-comment">// main event loop when the user types ^C.  This has the
</span><span class="enscript-comment">// effect of quitting the program.
</span>{
    assert(sigraised == SIGINT);

    <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
        fprintf(stderr, <span class="enscript-string">&quot;\nSIGINT\n&quot;</span>);
    }
    gStopNow = mDNStrue;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">HandleSigQuit</span>(<span class="enscript-type">int</span> sigraised)
<span class="enscript-comment">// If we get a SIGQUIT the user is desperate and we
</span><span class="enscript-comment">// just call mDNS_Close directly.  This is definitely
</span><span class="enscript-comment">// not safe (because it could reenter mDNS), but
</span><span class="enscript-comment">// we presume that the user has already tried the safe
</span><span class="enscript-comment">// alternatives.
</span>{
    assert(sigraised == SIGQUIT);

    <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
        fprintf(stderr, <span class="enscript-string">&quot;\nSIGQUIT\n&quot;</span>);
    }
    mDNS_Close(&amp;mDNSStorage);
    exit(0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> ***** <span class="enscript-variable-name">Parameter</span> <span class="enscript-variable-name">Checking</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">CheckThatRichTextNameIsUsable</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *richTextName, mDNSBool printExplanation)
<span class="enscript-comment">// Checks that richTextName is reasonable
</span><span class="enscript-comment">// label and, if it isn't and printExplanation is true, prints
</span><span class="enscript-comment">// an explanation of why not.
</span>{
    mDNSBool result = mDNStrue;
    <span class="enscript-keyword">if</span> (result &amp;&amp; strlen(richTextName) &gt; 63) {
        <span class="enscript-keyword">if</span> (printExplanation) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Service name is too long (must be 63 characters or less)\n&quot;</span>,
                    gProgramName);
        }
        result = mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (result &amp;&amp; richTextName[0] == 0) {
        <span class="enscript-keyword">if</span> (printExplanation) {
            fprintf(stderr, <span class="enscript-string">&quot;%s: Service name can't be empty\n&quot;</span>, gProgramName);
        }
        result = mDNSfalse;
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">CheckThatServiceTypeIsUsable</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *serviceType, mDNSBool printExplanation)
<span class="enscript-comment">// Checks that serviceType is a reasonable service type
</span><span class="enscript-comment">// label and, if it isn't and printExplanation is true, prints
</span><span class="enscript-comment">// an explanation of why not.
</span>{
    mDNSBool result;

    result = mDNStrue;
    <span class="enscript-keyword">if</span> (result &amp;&amp; strlen(serviceType) &gt; 63) {
        <span class="enscript-keyword">if</span> (printExplanation) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Service type is too long (must be 63 characters or less)\n&quot;</span>,
                    gProgramName);
        }
        result = mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (result &amp;&amp; serviceType[0] == 0) {
        <span class="enscript-keyword">if</span> (printExplanation) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Service type can't be empty\n&quot;</span>,
                    gProgramName);
        }
        result = mDNSfalse;
    }
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">CheckThatPortNumberIsUsable</span>(<span class="enscript-type">long</span> portNumber, mDNSBool printExplanation)
<span class="enscript-comment">// Checks that portNumber is a reasonable port number
</span><span class="enscript-comment">// and, if it isn't and printExplanation is true, prints
</span><span class="enscript-comment">// an explanation of why not.
</span>{
    mDNSBool result;

    result = mDNStrue;
    <span class="enscript-keyword">if</span> (result &amp;&amp; (portNumber &lt;= 0 || portNumber &gt; 65535)) {
        <span class="enscript-keyword">if</span> (printExplanation) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Port number specified by -p must be in range 1..65535\n&quot;</span>,
                    gProgramName);
        }
        result = mDNSfalse;
    }
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> ***** <span class="enscript-variable-name">Command</span> <span class="enscript-variable-name">Line</span> <span class="enscript-variable-name">Arguments</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> kDefaultPIDFile[]     = <span class="enscript-string">&quot;/var/run/mDNSResponder.pid&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> kDefaultServiceType[] = <span class="enscript-string">&quot;_afpovertcp._tcp.&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> kDefaultServiceDomain[] = <span class="enscript-string">&quot;local.&quot;</span>;
<span class="enscript-type">enum</span> {
    kDefaultPortNumber = 548
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">PrintUsage</span>()
{
    fprintf(stderr,
            <span class="enscript-string">&quot;Usage: %s [-v level ] [-r] [-n name] [-t type] [-d domain] [-p port] [-f file] [-b] [-P pidfile] [-x name=val ...]\n&quot;</span>,
            gProgramName);
    fprintf(stderr, <span class="enscript-string">&quot;          -v verbose mode, level is a number from 0 to 2\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             0 = no debugging info (default)\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             1 = standard debugging info\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             2 = intense debugging info\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             can be cycled kill -USR1\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -r also bind to port 53 (port 5353 is always bound)\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -n uses 'name' as the service name (required)\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -t uses 'type' as the service type (default is '%s')\n&quot;</span>, kDefaultServiceType);
    fprintf(stderr, <span class="enscript-string">&quot;          -d uses 'domain' as the service domain (default is '%s')\n&quot;</span>, kDefaultServiceDomain);
    fprintf(stderr, <span class="enscript-string">&quot;          -p uses 'port' as the port number (default is '%d')\n&quot;</span>,  kDefaultPortNumber);
    fprintf(stderr, <span class="enscript-string">&quot;          -f reads a service list from 'file'\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -b forces daemon (background) mode\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -P uses 'pidfile' as the PID file\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             (default is '%s')\n&quot;</span>,  kDefaultPIDFile);
    fprintf(stderr, <span class="enscript-string">&quot;             only meaningful if -b also specified\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;          -x stores name=val in TXT record (default is empty).\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             MUST be the last command-line argument;\n&quot;</span>);
    fprintf(stderr, <span class="enscript-string">&quot;             all subsequent arguments after -x are treated as name=val pairs.\n&quot;</span>);
}

<span class="enscript-type">static</span> mDNSBool gAvoidPort53      = mDNStrue;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gServiceName      = <span class="enscript-string">&quot;&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gServiceType      = kDefaultServiceType;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gServiceDomain    = kDefaultServiceDomain;
<span class="enscript-type">static</span> mDNSu8 gServiceText[<span class="enscript-keyword">sizeof</span>(RDataBody)];
<span class="enscript-type">static</span> mDNSu16 gServiceTextLen   = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> gPortNumber       = kDefaultPortNumber;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gServiceFile      = <span class="enscript-string">&quot;&quot;</span>;
<span class="enscript-type">static</span> mDNSBool gDaemon           = mDNSfalse;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *gPIDFile          = kDefaultPIDFile;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ParseArguments</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
<span class="enscript-comment">// Parses our command line arguments into the global variables
</span><span class="enscript-comment">// listed above.
</span>{
    <span class="enscript-type">int</span> ch;

    <span class="enscript-comment">// Set gProgramName to the last path component of argv[0]
</span>
    gProgramName = strrchr(argv[0], <span class="enscript-string">'/'</span>);
    <span class="enscript-keyword">if</span> (gProgramName == NULL) {
        gProgramName = argv[0];
    } <span class="enscript-keyword">else</span> {
        gProgramName += 1;
    }

    <span class="enscript-comment">// Parse command line options using getopt.
</span>
    <span class="enscript-keyword">do</span> {
        ch = getopt(argc, argv, <span class="enscript-string">&quot;v:rn:t:d:p:f:dP:bx&quot;</span>);
        <span class="enscript-keyword">if</span> (ch != -1) {
            <span class="enscript-keyword">switch</span> (ch) {
            <span class="enscript-keyword">case</span> <span class="enscript-string">'v'</span>:
                gMDNSPlatformPosixVerboseLevel = atoi(optarg);
                <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &lt; 0 || gMDNSPlatformPosixVerboseLevel &gt; 2) {
                    fprintf(stderr,
                            <span class="enscript-string">&quot;%s: Verbose mode must be in the range 0..2\n&quot;</span>,
                            gProgramName);
                    exit(1);
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:
                gAvoidPort53 = mDNSfalse;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
                gServiceName = optarg;
                <span class="enscript-keyword">if</span> ( !CheckThatRichTextNameIsUsable(gServiceName, mDNStrue) ) {
                    exit(1);
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
                gServiceType = optarg;
                <span class="enscript-keyword">if</span> ( !CheckThatServiceTypeIsUsable(gServiceType, mDNStrue) ) {
                    exit(1);
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
                gServiceDomain = optarg;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
                gPortNumber = atol(optarg);
                <span class="enscript-keyword">if</span> ( !CheckThatPortNumberIsUsable(gPortNumber, mDNStrue) ) {
                    exit(1);
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>:
                gServiceFile = optarg;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'b'</span>:
                gDaemon = mDNStrue;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'P'</span>:
                gPIDFile = optarg;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>:
                <span class="enscript-keyword">while</span> (optind &lt; argc)
                {
                    gServiceText[gServiceTextLen] = strlen(argv[optind]);
                    mDNSPlatformMemCopy(gServiceText+gServiceTextLen+1, argv[optind], gServiceText[gServiceTextLen]);
                    gServiceTextLen += 1 + gServiceText[gServiceTextLen];
                    optind++;
                }
                ch = -1;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
            <span class="enscript-reference">default</span>:
                PrintUsage();
                exit(1);
                <span class="enscript-keyword">break</span>;
            }
        }
    } <span class="enscript-keyword">while</span> (ch != -1);

    <span class="enscript-comment">// Check for any left over command line arguments.
</span>
    <span class="enscript-keyword">if</span> (optind != argc) {
        PrintUsage();
        fprintf(stderr, <span class="enscript-string">&quot;%s: Unexpected argument '%s'\n&quot;</span>, gProgramName, argv[optind]);
        exit(1);
    }

    <span class="enscript-comment">// Check for inconsistency between the arguments.
</span>
    <span class="enscript-keyword">if</span> ( (gServiceName[0] == 0) &amp;&amp; (gServiceFile[0] == 0) ) {
        PrintUsage();
        fprintf(stderr, <span class="enscript-string">&quot;%s: You must specify a service name to register (-n) or a service file (-f).\n&quot;</span>, gProgramName);
        exit(1);
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> ***** <span class="enscript-variable-name">Registration</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> PosixService PosixService;

<span class="enscript-type">struct</span> PosixService {
    ServiceRecordSet coreServ;
    PosixService *next;
    <span class="enscript-type">int</span> serviceID;
};

<span class="enscript-type">static</span> PosixService *gServiceList = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">RegistrationCallback</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> thisRegistration, mStatus status)
<span class="enscript-comment">// mDNS core calls this routine to tell us about the status of
</span><span class="enscript-comment">// our registration.  The appropriate action to take depends
</span><span class="enscript-comment">// entirely on the value of status.
</span>{
    <span class="enscript-keyword">switch</span> (status) {

    <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NoError</span>:
        debugf(<span class="enscript-string">&quot;Callback: %##s Name Registered&quot;</span>,   thisRegistration-&gt;RR_SRV.resrec.name-&gt;c);
        <span class="enscript-comment">// Do nothing; our name was successfully registered.  We may
</span>        <span class="enscript-comment">// get more call backs in the future.
</span>        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_NameConflict</span>:
        debugf(<span class="enscript-string">&quot;Callback: %##s Name Conflict&quot;</span>,     thisRegistration-&gt;RR_SRV.resrec.name-&gt;c);

        <span class="enscript-comment">// In the event of a conflict, this sample RegistrationCallback
</span>        <span class="enscript-comment">// just calls mDNS_RenameAndReregisterService to automatically
</span>        <span class="enscript-comment">// pick a new unique name for the service. For a device such as a
</span>        <span class="enscript-comment">// printer, this may be appropriate.  For a device with a user
</span>        <span class="enscript-comment">// interface, and a screen, and a keyboard, the appropriate response
</span>        <span class="enscript-comment">// may be to prompt the user and ask them to choose a new name for
</span>        <span class="enscript-comment">// the service.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Also, what do we do if mDNS_RenameAndReregisterService returns an
</span>        <span class="enscript-comment">// error.  Right now I have no place to send that error to.
</span>
        status = mDNS_RenameAndReregisterService(m, thisRegistration, mDNSNULL);
        assert(status == mStatus_NoError);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">mStatus_MemFree</span>:
        debugf(<span class="enscript-string">&quot;Callback: %##s Memory Free&quot;</span>,       thisRegistration-&gt;RR_SRV.resrec.name-&gt;c);

        <span class="enscript-comment">// When debugging is enabled, make sure that thisRegistration
</span>        <span class="enscript-comment">// is not on our gServiceList.
</span>
            #<span class="enscript-keyword">if</span> !defined(NDEBUG)
        {
            PosixService *cursor;

            cursor = gServiceList;
            <span class="enscript-keyword">while</span> (cursor != NULL) {
                assert(&amp;cursor-&gt;coreServ != thisRegistration);
                cursor = cursor-&gt;next;
            }
        }
            #endif
        free(thisRegistration);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
        debugf(<span class="enscript-string">&quot;Callback: %##s Unknown Status %ld&quot;</span>, thisRegistration-&gt;RR_SRV.resrec.name-&gt;c, status);
        <span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> gServiceID = 0;

<span class="enscript-type">static</span> mStatus <span class="enscript-function-name">RegisterOneService</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *  richTextName,
                                  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *  serviceType,
                                  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *  serviceDomain,
                                  <span class="enscript-type">const</span> mDNSu8 text[],
                                  mDNSu16 textLen,
                                  <span class="enscript-type">long</span> portNumber)
{
    mStatus status;
    PosixService *      thisServ;
    domainlabel name;
    domainname type;
    domainname domain;

    status = mStatus_NoError;
    thisServ = (PosixService *) calloc(<span class="enscript-keyword">sizeof</span>(*thisServ), 1);
    <span class="enscript-keyword">if</span> (thisServ == NULL) {
        status = mStatus_NoMemoryErr;
    }
    <span class="enscript-keyword">if</span> (status == mStatus_NoError) {
        MakeDomainLabelFromLiteralString(&amp;name,  richTextName);
        MakeDomainNameFromDNSNameString(&amp;type, serviceType);
        MakeDomainNameFromDNSNameString(&amp;domain, serviceDomain);
        status = mDNS_RegisterService(&amp;mDNSStorage, &amp;thisServ-&gt;coreServ,
                                      &amp;name, &amp;type, &amp;domain, <span class="enscript-comment">// Name, type, domain
</span>                                      NULL, mDNSOpaque16fromIntVal(portNumber),
                                      NULL, text, textLen, <span class="enscript-comment">// TXT data, length
</span>                                      NULL, 0,      <span class="enscript-comment">// Subtypes
</span>                                      mDNSInterface_Any, <span class="enscript-comment">// Interface ID
</span>                                      RegistrationCallback, thisServ, 0); <span class="enscript-comment">// Callback, context, flags
</span>    }
    <span class="enscript-keyword">if</span> (status == mStatus_NoError) {
        thisServ-&gt;serviceID = gServiceID;
        gServiceID += 1;

        thisServ-&gt;next = gServiceList;
        gServiceList = thisServ;

        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Registered service %d, name \&quot;%s\&quot;, type \&quot;%s\&quot;, domain \&quot;%s\&quot;,  port %ld\n&quot;</span>,
                    gProgramName,
                    thisServ-&gt;serviceID,
                    richTextName,
                    serviceType,
                    serviceDomain,
                    portNumber);
        }
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (thisServ != NULL) {
            free(thisServ);
        }
    }
    <span class="enscript-keyword">return</span> status;
}

<span class="enscript-type">static</span> mDNSBool <span class="enscript-function-name">ReadALine</span>(<span class="enscript-type">char</span> *buf, size_t bufSize, FILE *fp, mDNSBool skipBlankLines)
{
    size_t len;
    mDNSBool readNextLine;

    <span class="enscript-keyword">do</span> {
        readNextLine = mDNSfalse;

        <span class="enscript-keyword">if</span> (fgets(buf, bufSize, fp) == NULL)
            <span class="enscript-keyword">return</span> mDNSfalse;   <span class="enscript-comment">// encountered EOF or an error condition
</span>
        <span class="enscript-comment">// These first characters indicate a blank line.
</span>        <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">' '</span> || buf[0] == <span class="enscript-string">'\t'</span> || buf[0] == <span class="enscript-string">'\r'</span> || buf[0] == <span class="enscript-string">'\n'</span>) {
            <span class="enscript-keyword">if</span> (!skipBlankLines)
                <span class="enscript-keyword">return</span> mDNSfalse;
            readNextLine = mDNStrue;
        }
        <span class="enscript-comment">// always skip comment lines
</span>        <span class="enscript-keyword">if</span> (buf[0] == <span class="enscript-string">'#'</span>)
            readNextLine = mDNStrue;

    } <span class="enscript-keyword">while</span> (readNextLine);

    len = strlen( buf);
    <span class="enscript-keyword">if</span> ( buf[len - 1] == <span class="enscript-string">'\r'</span> || buf[len - 1] == <span class="enscript-string">'\n'</span>)
        buf[len - 1] = <span class="enscript-string">'\0'</span>;

    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-type">static</span> mStatus <span class="enscript-function-name">RegisterServicesInFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *filePath)
{
    mStatus status = mStatus_NoError;
    FILE *      fp = fopen(filePath, <span class="enscript-string">&quot;r&quot;</span>);
    <span class="enscript-type">int</span> rv;

    <span class="enscript-keyword">if</span> (fp == NULL) {
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }

    <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 1)
        fprintf(stderr, <span class="enscript-string">&quot;Parsing %s for services\n&quot;</span>, filePath);

    <span class="enscript-keyword">do</span> {
        <span class="enscript-type">char</span> nameBuf[256];
        <span class="enscript-type">char</span> * name = nameBuf;
        <span class="enscript-type">char</span> type[256];
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dom = kDefaultServiceDomain;
        <span class="enscript-type">char</span> rawText[1024];
        mDNSu8 text[<span class="enscript-keyword">sizeof</span>(RDataBody)];
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> textLen = 0;
        <span class="enscript-type">char</span> port[256];
        <span class="enscript-type">char</span> *p;

        <span class="enscript-comment">// Read the service name, type, port, and optional text record fields.
</span>        <span class="enscript-comment">// Skip blank lines while looking for the next service name.
</span>        <span class="enscript-keyword">if</span> (!ReadALine(name, <span class="enscript-keyword">sizeof</span>(nameBuf), fp, mDNStrue))
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Special case that allows service name to begin with a '#'
</span>        <span class="enscript-comment">// character by escaping it with a '\' to distiguish it from
</span>        <span class="enscript-comment">// a comment line.  Remove the leading '\' here before
</span>        <span class="enscript-comment">// registering the service.
</span>        <span class="enscript-keyword">if</span> (name[0] == <span class="enscript-string">'\\'</span> &amp;&amp; name[1] == <span class="enscript-string">'#'</span>)
            name++;

        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 1)
            fprintf(stderr, <span class="enscript-string">&quot;Service name: \&quot;%s\&quot;\n&quot;</span>, name);

        <span class="enscript-comment">// Don't skip blank lines in calls to ReadAline() after finding the
</span>        <span class="enscript-comment">// service name since the next blank line indicates the end
</span>        <span class="enscript-comment">// of this service record.
</span>        <span class="enscript-keyword">if</span> (!ReadALine(type, <span class="enscript-keyword">sizeof</span>(type), fp, mDNSfalse))
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// see if a domain name is specified
</span>        p = type;
        <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != <span class="enscript-string">' '</span> &amp;&amp; *p != <span class="enscript-string">'\t'</span>) p++;
        <span class="enscript-keyword">if</span> (*p) {
            *p = 0; <span class="enscript-comment">// NULL terminate the &lt;type&gt;.&lt;protocol&gt; string
</span>            <span class="enscript-comment">// skip any leading whitespace before domain name
</span>            p++;
            <span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">' '</span> || *p == <span class="enscript-string">'\t'</span>)) p++;
            <span class="enscript-keyword">if</span> (*p)
                dom = p;
        }
        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 1) {
            fprintf(stderr, <span class="enscript-string">&quot;Service type: \&quot;%s\&quot;\n&quot;</span>, type);
            fprintf(stderr, <span class="enscript-string">&quot;Service domain: \&quot;%s\&quot;\n&quot;</span>, dom);
        }

        <span class="enscript-keyword">if</span> (!ReadALine(port, <span class="enscript-keyword">sizeof</span>(port), fp, mDNSfalse))
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 1)
            fprintf(stderr, <span class="enscript-string">&quot;Service port: %s\n&quot;</span>, port);

        <span class="enscript-keyword">if</span> (   !CheckThatRichTextNameIsUsable(name, mDNStrue)
               || !CheckThatServiceTypeIsUsable(type, mDNStrue)
               || !CheckThatPortNumberIsUsable(atol(port), mDNStrue))
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// read the TXT record fields
</span>        <span class="enscript-keyword">while</span> (1) {
            <span class="enscript-type">int</span> len;
            <span class="enscript-keyword">if</span> (!ReadALine(rawText, <span class="enscript-keyword">sizeof</span>(rawText), fp, mDNSfalse)) <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 1)
                fprintf(stderr, <span class="enscript-string">&quot;Text string: \&quot;%s\&quot;\n&quot;</span>, rawText);
            len = strlen(rawText);
            <span class="enscript-keyword">if</span> (len &lt;= 255)
            {
                <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> newlen = textLen + 1 + len;
                <span class="enscript-keyword">if</span> (len == 0 || newlen &gt;= <span class="enscript-keyword">sizeof</span>(text)) <span class="enscript-keyword">break</span>;
                text[textLen] = len;
                mDNSPlatformMemCopy(text + textLen + 1, rawText, len);
                textLen = newlen;
            }
            <span class="enscript-keyword">else</span>
                fprintf(stderr, <span class="enscript-string">&quot;%s: TXT attribute too long for name = %s, type = %s, port = %s\n&quot;</span>,
                        gProgramName, name, type, port);
        }

        status = RegisterOneService(name, type, dom, text, textLen, atol(port));
        <span class="enscript-keyword">if</span> (status != mStatus_NoError) {
            <span class="enscript-comment">// print error, but try to read and register other services in the file
</span>            fprintf(stderr, <span class="enscript-string">&quot;%s: Failed to register service, name \&quot;%s\&quot;, type \&quot;%s\&quot;, domain \&quot;%s\&quot;, port %s\n&quot;</span>,
                    gProgramName, name, type, dom, port);
        }

    } <span class="enscript-keyword">while</span> (!feof(fp));

    <span class="enscript-keyword">if</span> (!feof(fp)) {
        fprintf(stderr, <span class="enscript-string">&quot;%s: Error reading service file %s\n&quot;</span>, gProgramName, filePath);
        status = mStatus_UnknownErr;
    }

    rv = fclose(fp);
    assert(rv == 0);

    <span class="enscript-keyword">return</span> status;
}

<span class="enscript-type">static</span> mStatus <span class="enscript-function-name">RegisterOurServices</span>(<span class="enscript-type">void</span>)
{
    mStatus status;

    status = mStatus_NoError;
    <span class="enscript-keyword">if</span> (gServiceName[0] != 0) {
        status = RegisterOneService(gServiceName,
                                    gServiceType,
                                    gServiceDomain,
                                    gServiceText, gServiceTextLen,
                                    gPortNumber);
    }
    <span class="enscript-keyword">if</span> (status == mStatus_NoError &amp;&amp; gServiceFile[0] != 0) {
        status = RegisterServicesInFile(gServiceFile);
    }
    <span class="enscript-keyword">return</span> status;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DeregisterOurServices</span>(<span class="enscript-type">void</span>)
{
    PosixService *thisServ;

    <span class="enscript-keyword">while</span> (gServiceList != NULL) {
        thisServ = gServiceList;
        gServiceList = thisServ-&gt;next;

        mDNS_DeregisterService(&amp;mDNSStorage, &amp;thisServ-&gt;coreServ);

        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
            fprintf(stderr,
                    <span class="enscript-string">&quot;%s: Deregistered service %d\n&quot;</span>,
                    gProgramName,
                    thisServ-&gt;serviceID);
        }
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> **** <span class="enscript-variable-name">Main</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
    mStatus status;
    <span class="enscript-type">int</span> result;

    <span class="enscript-comment">// Parse our command line arguments.  This won't come back if there's an error.
</span>
    ParseArguments(argc, argv);

    <span class="enscript-comment">// If we're told to run as a daemon, then do that straight away.
</span>    <span class="enscript-comment">// Note that we don't treat the inability to create our PID
</span>    <span class="enscript-comment">// file as an error.  Also note that we assign getpid to a long
</span>    <span class="enscript-comment">// because printf has no format specified for pid_t.
</span>
    <span class="enscript-keyword">if</span> (gDaemon) {
        <span class="enscript-type">int</span> result;
        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
            fprintf(stderr, <span class="enscript-string">&quot;%s: Starting in daemon mode\n&quot;</span>, gProgramName);
        }
        result = daemon(0,0);
        <span class="enscript-keyword">if</span> (result == 0) {
            FILE *fp;
            <span class="enscript-type">int</span> junk;

            fp = fopen(gPIDFile, <span class="enscript-string">&quot;w&quot;</span>);
            <span class="enscript-keyword">if</span> (fp != NULL) {
                fprintf(fp, <span class="enscript-string">&quot;%ld\n&quot;</span>, (<span class="enscript-type">long</span>) getpid());
                junk = fclose(fp);
                assert(junk == 0);
            }
        } <span class="enscript-keyword">else</span> {
            fprintf(stderr, <span class="enscript-string">&quot;%s: Could not run as daemon - exiting\n&quot;</span>, gProgramName);
            exit(result);
        }
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0) {
            fprintf(stderr, <span class="enscript-string">&quot;%s: Starting in foreground mode, PID %ld\n&quot;</span>, gProgramName, (<span class="enscript-type">long</span>) getpid());
        }
    }

    status = mDNS_Init(&amp;mDNSStorage, &amp;PlatformStorage,
                       mDNS_Init_NoCache, mDNS_Init_ZeroCacheSize,
                       mDNS_Init_AdvertiseLocalAddresses,
                       mDNS_Init_NoInitCallback, mDNS_Init_NoInitCallbackContext);
    <span class="enscript-keyword">if</span> (status != mStatus_NoError) <span class="enscript-keyword">return</span>(2);

    status = RegisterOurServices();
    <span class="enscript-keyword">if</span> (status != mStatus_NoError) <span class="enscript-keyword">return</span>(2);

    signal(SIGHUP,  HandleSigHup);      <span class="enscript-comment">// SIGHUP has to be sent by kill -HUP &lt;pid&gt;
</span>    signal(SIGINT,  HandleSigInt);      <span class="enscript-comment">// SIGINT is what you get for a Ctrl-C
</span>    signal(SIGQUIT, HandleSigQuit);     <span class="enscript-comment">// SIGQUIT is what you get for a Ctrl-\ (indeed)
</span>    signal(SIGUSR1, HandleSigUsr1);     <span class="enscript-comment">// SIGUSR1 has to be sent by kill -USR1 &lt;pid&gt;
</span>
    <span class="enscript-keyword">while</span> (!gStopNow)
    {
        <span class="enscript-type">int</span> nfds = 0;
        fd_set readfds, writefds;
        <span class="enscript-type">struct</span> timeval timeout;
        <span class="enscript-type">int</span> result;

        <span class="enscript-comment">// 1. Set up the fd_set as usual here.
</span>        <span class="enscript-comment">// This example client has no file descriptors of its own,
</span>        <span class="enscript-comment">// but a real application would call FD_SET to add them to the set here
</span>        FD_ZERO(&amp;readfds);
        FD_ZERO(&amp;writefds);

        <span class="enscript-comment">// 2. Set up the timeout.
</span>        <span class="enscript-comment">// This example client has no other work it needs to be doing,
</span>        <span class="enscript-comment">// so we set an effectively infinite timeout
</span>        timeout.tv_sec = FutureTime;
        timeout.tv_usec = 0;

        <span class="enscript-comment">// 3. Give the mDNSPosix layer a chance to add its information to the fd_set and timeout
</span>        mDNSPosixGetFDSet(&amp;mDNSStorage, &amp;nfds, &amp;readfds, &amp;writefds, &amp;timeout);

        <span class="enscript-comment">// 4. Call select as normal
</span>        verbosedebugf(<span class="enscript-string">&quot;select(%d, %d.%06d)&quot;</span>, nfds, timeout.tv_sec, timeout.tv_usec);
        result = select(nfds, &amp;readfds, NULL, NULL, &amp;timeout);

        <span class="enscript-keyword">if</span> (result &lt; 0)
        {
            verbosedebugf(<span class="enscript-string">&quot;select() returned %d errno %d&quot;</span>, result, errno);
            <span class="enscript-keyword">if</span> (errno != EINTR) gStopNow = mDNStrue;
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (gReceivedSigUsr1)
                {
                    gReceivedSigUsr1 = mDNSfalse;
                    gMDNSPlatformPosixVerboseLevel += 1;
                    <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 2)
                        gMDNSPlatformPosixVerboseLevel = 0;
                    <span class="enscript-keyword">if</span> ( gMDNSPlatformPosixVerboseLevel &gt; 0 )
                        fprintf(stderr, <span class="enscript-string">&quot;\nVerbose level %d\n&quot;</span>, gMDNSPlatformPosixVerboseLevel);
                }
                <span class="enscript-keyword">if</span> (gReceivedSigHup)
                {
                    <span class="enscript-keyword">if</span> (gMDNSPlatformPosixVerboseLevel &gt; 0)
                        fprintf(stderr, <span class="enscript-string">&quot;\nSIGHUP\n&quot;</span>);
                    gReceivedSigHup = mDNSfalse;
                    DeregisterOurServices();
                    status = mDNSPlatformPosixRefreshInterfaceList(&amp;mDNSStorage);
                    <span class="enscript-keyword">if</span> (status != mStatus_NoError) <span class="enscript-keyword">break</span>;
                    status = RegisterOurServices();
                    <span class="enscript-keyword">if</span> (status != mStatus_NoError) <span class="enscript-keyword">break</span>;
                }
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// 5. Call mDNSPosixProcessFDSet to let the mDNSPosix layer do its work
</span>            mDNSPosixProcessFDSet(&amp;mDNSStorage, &amp;readfds, &amp;writefds);

            <span class="enscript-comment">// 6. This example client has no other work it needs to be doing,
</span>            <span class="enscript-comment">// but a real client would do its work here
</span>            <span class="enscript-comment">// ... (do work) ...
</span>        }
    }

    debugf(<span class="enscript-string">&quot;Exiting&quot;</span>);

    DeregisterOurServices();
    mDNS_Close(&amp;mDNSStorage);

    <span class="enscript-keyword">if</span> (status == mStatus_NoError) {
        result = 0;
    } <span class="enscript-keyword">else</span> {
        result = 2;
    }
    <span class="enscript-keyword">if</span> ( (result != 0) || (gMDNSPlatformPosixVerboseLevel &gt; 0) ) {
        fprintf(stderr, <span class="enscript-string">&quot;%s: Finished with status %d, result %d\n&quot;</span>, gProgramName, (<span class="enscript-type">int</span>)status, result);
    }

    <span class="enscript-keyword">return</span> result;
}
</pre>
<hr />
</body></html>