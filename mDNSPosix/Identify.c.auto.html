<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Identify.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">Identify.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="Identify.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2002-2018 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */</span>

<span class="enscript-comment">//*************************************************************************************************************
</span><span class="enscript-comment">// Incorporate mDNS.c functionality
</span>
<span class="enscript-comment">// We want to use the functionality provided by &quot;mDNS.c&quot;,
</span><span class="enscript-comment">// except we'll sneak a peek at the packets before forwarding them to the normal mDNSCoreReceive() routine
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSCoreReceive</span> __MDNS__mDNSCoreReceive
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNS.c&quot;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">mDNSCoreReceive</span>

<span class="enscript-comment">//*************************************************************************************************************
</span><span class="enscript-comment">// Headers
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>       // For n_long, required by &lt;netinet/ip.h&gt; below
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>             // For IPTOS_LOWDELAY etc.
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span> // Defines the interface to the mDNS core code
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSPosix.h&quot;</span>    // Defines the specific types needed to run mDNS on this platform
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ExampleClientApp.h&quot;</span>

<span class="enscript-comment">//*************************************************************************************************************
</span><span class="enscript-comment">// Globals
</span>
mDNS mDNSStorage;       <span class="enscript-comment">// mDNS core uses this to store its globals
</span><span class="enscript-type">static</span> mDNS_PlatformSupport PlatformStorage;  <span class="enscript-comment">// Stores this platform's globals
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RR_CACHE_SIZE</span> 500
<span class="enscript-type">static</span> CacheEntity gRRCache[RR_CACHE_SIZE];
mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> ProgramName[] = <span class="enscript-string">&quot;mDNSIdentify&quot;</span>;

<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> <span class="enscript-type">int</span> StopNow;    <span class="enscript-comment">// 0 means running, 1 means stop because we got an answer, 2 means stop because of Ctrl-C
</span><span class="enscript-type">static</span> <span class="enscript-type">volatile</span> <span class="enscript-type">int</span> NumAnswers, NumAddr, NumAAAA, NumHINFO;
<span class="enscript-type">static</span> <span class="enscript-type">char</span> hostname[MAX_ESCAPED_DOMAIN_NAME], hardware[256], software[256];
<span class="enscript-type">static</span> mDNSAddr lastsrc, hostaddr, target;
<span class="enscript-type">static</span> mDNSOpaque16 lastid, id;

<span class="enscript-comment">//*************************************************************************************************************
</span><span class="enscript-comment">// Utilities
</span>
<span class="enscript-comment">// Special version of printf that knows how to print IP addresses, DNS-format name strings, etc.
</span>mDNSlocal mDNSu32 <span class="enscript-function-name">mprintf</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...) IS_A_PRINTF_STYLE_FUNCTION(1,2);
mDNSlocal mDNSu32 <span class="enscript-function-name">mprintf</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    mDNSu32 length;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buffer[512];
    va_list ptr;
    va_start(ptr,format);
    length = mDNS_vsnprintf((<span class="enscript-type">char</span> *)buffer, <span class="enscript-keyword">sizeof</span>(buffer), format, ptr);
    va_end(ptr);
    printf(<span class="enscript-string">&quot;%s&quot;</span>, buffer);
    <span class="enscript-keyword">return</span>(length);
}

<span class="enscript-comment">//*************************************************************************************************************
</span><span class="enscript-comment">// Main code
</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceive</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dstaddr, <span class="enscript-type">const</span> mDNSIPPort dstport,
                                <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    (<span class="enscript-type">void</span>)dstaddr; <span class="enscript-comment">// Unused
</span>    <span class="enscript-comment">// Snag copy of header ID, then call through
</span>    lastid = msg-&gt;h.id;
    lastsrc = *srcaddr;

    <span class="enscript-comment">// We *want* to allow off-net unicast responses here.
</span>    <span class="enscript-comment">// For now, the simplest way to allow that is to pretend it was received via multicast so that mDNSCore doesn't reject the packet
</span>    __MDNS__mDNSCoreReceive(m, msg, end, srcaddr, srcport, &amp;AllDNSLinkGroup_v4, dstport, InterfaceID);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NameCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    (<span class="enscript-type">void</span>)m;        <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)question; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)AddRecord; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (!id.NotAnInteger) id = lastid;
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_PTR || answer-&gt;rrtype == kDNSType_CNAME)
    {
        ConvertDomainNameToCString(&amp;answer-&gt;rdata-&gt;u.name, hostname);
        StopNow = 1;
        mprintf(<span class="enscript-string">&quot;%##s %s %##s\n&quot;</span>, answer-&gt;name-&gt;c, DNSTypeName(answer-&gt;rrtype), answer-&gt;rdata-&gt;u.name.c);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InfoCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    (<span class="enscript-type">void</span>)m;        <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)question; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)AddRecord; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_A)
    {
        <span class="enscript-keyword">if</span> (!id.NotAnInteger) id = lastid;
        NumAnswers++;
        NumAddr++;
        mprintf(<span class="enscript-string">&quot;%##s %s %.4a\n&quot;</span>, answer-&gt;name-&gt;c, DNSTypeName(answer-&gt;rrtype), &amp;answer-&gt;rdata-&gt;u.ipv4);
        hostaddr.type = mDNSAddrType_IPv4;  <span class="enscript-comment">// Prefer v4 target to v6 target, for now
</span>        hostaddr.ip.v4 = answer-&gt;rdata-&gt;u.ipv4;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_AAAA)
    {
        <span class="enscript-keyword">if</span> (!id.NotAnInteger) id = lastid;
        NumAnswers++;
        NumAAAA++;
        mprintf(<span class="enscript-string">&quot;%##s %s %.16a\n&quot;</span>, answer-&gt;name-&gt;c, DNSTypeName(answer-&gt;rrtype), &amp;answer-&gt;rdata-&gt;u.ipv6);
        <span class="enscript-keyword">if</span> (!hostaddr.type) <span class="enscript-comment">// Prefer v4 target to v6 target, for now
</span>        {
            hostaddr.type = mDNSAddrType_IPv6;
            hostaddr.ip.v6 = answer-&gt;rdata-&gt;u.ipv6;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_HINFO)
    {
        mDNSu8 *p = answer-&gt;rdata-&gt;u.data;
        strncpy(hardware, (<span class="enscript-type">char</span>*)(p+1), p[0]);
        hardware[p[0]] = 0;
        p += 1 + p[0];
        strncpy(software, (<span class="enscript-type">char</span>*)(p+1), p[0]);
        software[p[0]] = 0;
        NumAnswers++;
        NumHINFO++;
    }

    <span class="enscript-comment">// If we've got everything we're looking for, don't need to wait any more
</span>    <span class="enscript-keyword">if</span> (<span class="enscript-comment">/*NumHINFO &amp;&amp; */</span> (NumAddr || NumAAAA)) StopNow = 1;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ServicesCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    (<span class="enscript-type">void</span>)m;        <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)question; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)AddRecord; <span class="enscript-comment">// Unused
</span>    <span class="enscript-comment">// Right now the mDNSCore targeted-query code is incomplete --
</span>    <span class="enscript-comment">// it issues targeted queries, but accepts answers from anywhere
</span>    <span class="enscript-comment">// For now, we'll just filter responses here so we don't get confused by responses from someone else
</span>    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_PTR &amp;&amp; mDNSSameAddress(&amp;lastsrc, &amp;target))
    {
        NumAnswers++;
        mprintf(<span class="enscript-string">&quot;%##s %s %##s\n&quot;</span>, answer-&gt;name-&gt;c, DNSTypeName(answer-&gt;rrtype), answer-&gt;rdata-&gt;u.name.c);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">WaitForAnswer</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">int</span> seconds)
{
    <span class="enscript-type">struct</span> timeval end;
    gettimeofday(&amp;end, NULL);
    end.tv_sec += seconds;
    StopNow = 0;
    NumAnswers = 0;
    <span class="enscript-keyword">while</span> (!StopNow)
    {
        <span class="enscript-type">int</span> nfds = 0;
        fd_set readfds, writefds;
        <span class="enscript-type">struct</span> timeval now, remain = end;
        <span class="enscript-type">int</span> result;

        FD_ZERO(&amp;readfds);
        FD_ZERO(&amp;writefds);
        gettimeofday(&amp;now, NULL);
        <span class="enscript-keyword">if</span> (remain.tv_usec &lt; now.tv_usec) { remain.tv_usec += 1000000; remain.tv_sec--; }
        <span class="enscript-keyword">if</span> (remain.tv_sec &lt; now.tv_sec)
        {
            <span class="enscript-keyword">if</span> (!NumAnswers) printf(<span class="enscript-string">&quot;No response after %d seconds\n&quot;</span>, seconds);
            <span class="enscript-keyword">return</span>;
        }
        remain.tv_usec -= now.tv_usec;
        remain.tv_sec  -= now.tv_sec;
        mDNSPosixGetFDSet(m, &amp;nfds, &amp;readfds, &amp;writefds, &amp;remain);
        result = select(nfds, &amp;readfds, &amp;writefds, NULL, &amp;remain);
        <span class="enscript-keyword">if</span> (result &gt;= 0) mDNSPosixProcessFDSet(m, &amp;readfds, &amp;writefds);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (errno != EINTR) StopNow = 2;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">StartQuery</span>(DNSQuestion *q, <span class="enscript-type">char</span> *qname, mDNSu16 qtype, <span class="enscript-type">const</span> mDNSAddr *target, mDNSQuestionCallback callback)
{
    lastsrc = zeroAddr;
    <span class="enscript-keyword">if</span> (qname) MakeDomainNameFromDNSNameString(&amp;q-&gt;qname, qname);
    q-&gt;InterfaceID      = mDNSInterface_Any;
    q-&gt;flags            = 0;
    q-&gt;Target           = target ? *target : zeroAddr;
    q-&gt;TargetPort       = MulticastDNSPort;
    q-&gt;TargetQID        = zeroID;
    q-&gt;qtype            = qtype;
    q-&gt;qclass           = kDNSClass_IN;
    q-&gt;LongLived        = mDNSfalse;
    q-&gt;ExpectUnique     = mDNSfalse;    <span class="enscript-comment">// Don't want to stop after the first response packet
</span>    q-&gt;ForceMCast       = mDNStrue;     <span class="enscript-comment">// Query via multicast, even for apparently uDNS names like 1.1.1.17.in-addr.arpa.
</span>    q-&gt;ReturnIntermed   = mDNStrue;
    q-&gt;SuppressUnusable = mDNSfalse;
    q-&gt;AppendSearchDomains = 0;
    q-&gt;TimeoutQuestion  = 0;
    q-&gt;ValidationRequired = 0;
    q-&gt;ValidatingResponse = 0;
    q-&gt;WakeOnResolve    = 0;
    q-&gt;UseBackgroundTraffic = mDNSfalse;
    q-&gt;ProxyQuestion    = 0;
    q-&gt;pid              = mDNSPlatformGetPID();
    q-&gt;QuestionCallback = callback;
    q-&gt;QuestionContext  = NULL;

    <span class="enscript-comment">//mprintf(&quot;%##s %s ?\n&quot;, q-&gt;qname.c, DNSTypeName(qtype));
</span>    <span class="enscript-keyword">return</span>(mDNS_StartQuery(&amp;mDNSStorage, q));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DoOneQuery</span>(DNSQuestion *q, <span class="enscript-type">char</span> *qname, mDNSu16 qtype, <span class="enscript-type">const</span> mDNSAddr *target, mDNSQuestionCallback callback)
{
    mStatus status = StartQuery(q, qname, qtype, target, callback);
    <span class="enscript-keyword">if</span> (status != mStatus_NoError)
        StopNow = 2;
    <span class="enscript-keyword">else</span>
    {
        WaitForAnswer(&amp;mDNSStorage, 4);
        mDNS_StopQuery(&amp;mDNSStorage, q);
    }
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">DoQuery</span>(DNSQuestion *q, <span class="enscript-type">char</span> *qname, mDNSu16 qtype, <span class="enscript-type">const</span> mDNSAddr *target, mDNSQuestionCallback callback)
{
    DoOneQuery(q, qname, qtype, target, callback);
    <span class="enscript-keyword">if</span> (StopNow == 0 &amp;&amp; NumAnswers == 0 &amp;&amp; target &amp;&amp; target-&gt;type)
    {
        mprintf(<span class="enscript-string">&quot;%##s %s Trying multicast\n&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        DoOneQuery(q, qname, qtype, NULL, callback);
    }
    <span class="enscript-keyword">if</span> (StopNow == 0 &amp;&amp; NumAnswers == 0)
        mprintf(<span class="enscript-string">&quot;%##s %s *** No Answer ***\n&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
    <span class="enscript-keyword">return</span>(StopNow);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HandleSIG</span>(<span class="enscript-type">int</span> signal)
{
    (<span class="enscript-type">void</span>)signal;   <span class="enscript-comment">// Unused
</span>    debugf(<span class="enscript-string">&quot;%s&quot;</span>,<span class="enscript-string">&quot;&quot;</span>);
    debugf(<span class="enscript-string">&quot;HandleSIG&quot;</span>);
    StopNow = 2;
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *progname = strrchr(argv[0], <span class="enscript-string">'/'</span>) ? strrchr(argv[0], <span class="enscript-string">'/'</span>) + 1 : argv[0];
    <span class="enscript-type">int</span> this_arg = 1;
    mStatus status;
    <span class="enscript-type">struct</span> in_addr s4;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_IPV6</span>
    <span class="enscript-type">struct</span> in6_addr s6;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">char</span> buffer[256];
    DNSQuestion q;

    <span class="enscript-keyword">if</span> (argc &lt; 2) <span class="enscript-keyword">goto</span> <span class="enscript-reference">usage</span>;

    <span class="enscript-comment">// Since this is a special command-line tool, we want LogMsg() errors to go to stderr, not syslog
</span>    mDNS_DebugMode = mDNStrue;

    <span class="enscript-comment">// Initialise the mDNS core.
</span>    status = mDNS_Init(&amp;mDNSStorage, &amp;PlatformStorage,
                       gRRCache, RR_CACHE_SIZE,
                       mDNS_Init_DontAdvertiseLocalAddresses,
                       mDNS_Init_NoInitCallback, mDNS_Init_NoInitCallbackContext);
    <span class="enscript-keyword">if</span> (status) { fprintf(stderr, <span class="enscript-string">&quot;Daemon start: mDNS_Init failed %d\n&quot;</span>, (<span class="enscript-type">int</span>)status); <span class="enscript-keyword">return</span>(status); }

    signal(SIGINT, HandleSIG);  <span class="enscript-comment">// SIGINT is what you get for a Ctrl-C
</span>    signal(SIGTERM, HandleSIG);

    <span class="enscript-keyword">while</span> (this_arg &lt; argc)
    {
        <span class="enscript-type">char</span> *arg = argv[this_arg++];
        <span class="enscript-keyword">if</span> (this_arg &gt; 2) printf(<span class="enscript-string">&quot;\n&quot;</span>);

        lastid = id = zeroID;
        hostaddr = target = zeroAddr;
        hostname[0] = hardware[0] = software[0] = 0;
        NumAddr = NumAAAA = NumHINFO = 0;

        <span class="enscript-keyword">if</span> (inet_pton(AF_INET, arg, &amp;s4) == 1)
        {
            mDNSu8 *p = (mDNSu8 *)&amp;s4;
            <span class="enscript-comment">// Note: This is reverse order compared to a normal dotted-decimal IP address, so we can't use our customary &quot;%.4a&quot; format code
</span>            mDNS_snprintf(buffer, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot;%d.%d.%d.%d.in-addr.arpa.&quot;</span>, p[3], p[2], p[1], p[0]);
            printf(<span class="enscript-string">&quot;%s\n&quot;</span>, buffer);
            target.type = mDNSAddrType_IPv4;
            target.ip.v4.NotAnInteger = s4.s_addr;
            DoQuery(&amp;q, buffer, kDNSType_PTR, &amp;target, NameCallback);
            <span class="enscript-keyword">if</span> (StopNow == 2) <span class="enscript-keyword">break</span>;
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAVE_IPV6</span>
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inet_pton(AF_INET6, arg, &amp;s6) == 1)
        {
            <span class="enscript-type">int</span> i;
            mDNSu8 *p = (mDNSu8 *)&amp;s6;
            <span class="enscript-keyword">for</span> (i = 0; i &lt; 16; i++)
            {
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> hexValues[] = <span class="enscript-string">&quot;0123456789ABCDEF&quot;</span>;
                buffer[i * 4    ] = hexValues[p[15-i] &amp; 0x0F];
                buffer[i * 4 + 1] = <span class="enscript-string">'.'</span>;
                buffer[i * 4 + 2] = hexValues[p[15-i] &gt;&gt; 4];
                buffer[i * 4 + 3] = <span class="enscript-string">'.'</span>;
            }
            mDNS_snprintf(&amp;buffer[64], <span class="enscript-keyword">sizeof</span>(buffer)-64, <span class="enscript-string">&quot;ip6.arpa.&quot;</span>);
            target.type = mDNSAddrType_IPv6;
            mDNSPlatformMemCopy(&amp;target.ip.v6, &amp;s6, <span class="enscript-keyword">sizeof</span>(target.ip.v6));
            DoQuery(&amp;q, buffer, kDNSType_PTR, &amp;target, NameCallback);
            <span class="enscript-keyword">if</span> (StopNow == 2) <span class="enscript-keyword">break</span>;
        }
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (strlen(arg) &gt;= <span class="enscript-keyword">sizeof</span>(hostname))
            {
                fprintf(stderr, <span class="enscript-string">&quot;hostname must be &lt; %d characters\n&quot;</span>, (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(hostname));
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">usage</span>;
            }
            strcpy(hostname, arg);
        }

        <span class="enscript-comment">// Now we have the host name; get its A, AAAA, and HINFO
</span>        <span class="enscript-keyword">if</span> (hostname[0]) DoQuery(&amp;q, hostname, kDNSQType_ANY, &amp;target, InfoCallback);
        <span class="enscript-keyword">if</span> (StopNow == 2) <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">if</span> (hardware[0] || software[0])
        {
            printf(<span class="enscript-string">&quot;HINFO Hardware: %s\n&quot;</span>, hardware);
            printf(<span class="enscript-string">&quot;HINFO Software: %s\n&quot;</span>, software);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NumAnswers) printf(<span class="enscript-string">&quot;%s has no HINFO record\n&quot;</span>, hostname);
        <span class="enscript-keyword">else</span> printf(<span class="enscript-string">&quot;Incorrect dot-local hostname, address, or no mDNSResponder running on that machine\n&quot;</span>);

        <span class="enscript-keyword">if</span> (NumAnswers)
        {
            <span class="enscript-comment">// Because of the way we use lastsrc in ServicesCallback, we need to clear the cache to make sure we're getting fresh answers
</span>            mDNS *<span class="enscript-type">const</span> m = &amp;mDNSStorage;
            mDNSu32 slot;
            CacheGroup *cg;
            CacheRecord *rr;
            FORALL_CACHERECORDS(slot, cg, rr)
            {
                mDNS_PurgeCacheResourceRecord(m, rr);
            }
            <span class="enscript-keyword">if</span> (target.type == 0) target = hostaddr;        <span class="enscript-comment">// Make sure the services query is targeted
</span>            DoQuery(&amp;q, <span class="enscript-string">&quot;_services._dns-sd._udp.local.&quot;</span>, kDNSType_PTR, &amp;target, ServicesCallback);
            <span class="enscript-keyword">if</span> (StopNow == 2) <span class="enscript-keyword">break</span>;
        }
    }

    mDNS_Close(&amp;mDNSStorage);
    <span class="enscript-keyword">return</span>(0);

<span class="enscript-reference">usage</span>:
    fprintf(stderr, <span class="enscript-string">&quot;Usage: %s &lt;dot-local hostname&gt; or &lt;IPv4 address&gt; or &lt;IPv6 address&gt; ...\n&quot;</span>, progname);
    <span class="enscript-keyword">return</span>(-1);
}
</pre>
<hr />
</body></html>