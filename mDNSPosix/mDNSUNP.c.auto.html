<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mDNSUNP.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mDNSUNP.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="mDNSUNP.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2002-2018 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSUNP.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>

<span class="enscript-comment">/* Some weird platforms derived from 4.4BSD Lite (e.g. EFI) need the ALIGN(P)
   macro, usually defined in &lt;sys/param.h&gt; or someplace like that, to make sure the
   CMSG_NXTHDR macro is well-formed. On such platforms, the symbol NEED_ALIGN_MACRO
   should be set to the name of the header to include to get the ALIGN(P) macro.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NEED_ALIGN_MACRO</span>
#<span class="enscript-reference">include</span> <span class="enscript-variable-name">NEED_ALIGN_MACRO</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* sockaddr_dl is only referenced if we're using IP_RECVIF,
   so only include the header in that case.
 */</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">IP_RECVIF</span>
    #include &lt;net/if_dl.h&gt;
#<span class="enscript-reference">endif</span>

ssize_t
<span class="enscript-function-name">recvfrom_flags</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">void</span> *ptr, size_t nbytes, <span class="enscript-type">int</span> *flagsp,
               <span class="enscript-type">struct</span> sockaddr *sa, socklen_t *salenptr, <span class="enscript-type">struct</span> my_in_pktinfo *pktp, u_char *ttl)
{
    <span class="enscript-type">struct</span> msghdr msg;
    <span class="enscript-type">struct</span> iovec iov[1];
    ssize_t n;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CMSG_FIRSTHDR</span>
    <span class="enscript-type">struct</span> cmsghdr  *cmptr;
    <span class="enscript-type">union</span> {
        <span class="enscript-type">struct</span> cmsghdr cm;
        <span class="enscript-type">char</span> control[1024];
    } control_un;

    *ttl = 255;         <span class="enscript-comment">// If kernel fails to provide TTL data then assume the TTL was 255 as it should be
</span>
    msg.msg_control = control_un.control;
    msg.msg_controllen = <span class="enscript-keyword">sizeof</span>(control_un.control);
    msg.msg_flags = 0;
#<span class="enscript-reference">else</span>
    memset(&amp;msg, 0, <span class="enscript-keyword">sizeof</span>(msg));   <span class="enscript-comment">/* make certain msg_accrightslen = 0 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CMSG_FIRSTHDR */</span>

    msg.msg_name = (<span class="enscript-type">char</span> *) sa;
    msg.msg_namelen = *salenptr;
    iov[0].iov_base = (<span class="enscript-type">char</span> *)ptr;
    iov[0].iov_len = nbytes;
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    <span class="enscript-keyword">if</span> ( (n = recvmsg(fd, &amp;msg, *flagsp)) &lt; 0)
        <span class="enscript-keyword">return</span>(n);

    *salenptr = msg.msg_namelen;    <span class="enscript-comment">/* pass back results */</span>
    <span class="enscript-keyword">if</span> (pktp) {
        <span class="enscript-comment">/* 0.0.0.0, i/f = -1 */</span>
        <span class="enscript-comment">/* We set the interface to -1 so that the caller can
           tell whether we returned a meaningful value or
           just some default.  Previously this code just
           set the value to 0, but I'm concerned that 0
           might be a valid interface value.
         */</span>
        memset(pktp, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> my_in_pktinfo));
        pktp-&gt;ipi_ifindex = -1;
    }
<span class="enscript-comment">/* end recvfrom_flags1 */</span>

<span class="enscript-comment">/* include recvfrom_flags2 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CMSG_FIRSTHDR</span>
    #warning CMSG_FIRSTHDR not defined. Will not be able to determine destination address, received interface, etc.
    *flagsp = 0;                    <span class="enscript-comment">/* pass back results */</span>
    <span class="enscript-keyword">return</span>(n);
#<span class="enscript-reference">else</span>

    *flagsp = msg.msg_flags;        <span class="enscript-comment">/* pass back results */</span>
    <span class="enscript-keyword">if</span> (msg.msg_controllen &lt; (socklen_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cmsghdr) ||
        (msg.msg_flags &amp; MSG_CTRUNC) || pktp == NULL)
        <span class="enscript-keyword">return</span>(n);

    <span class="enscript-keyword">for</span> (cmptr = CMSG_FIRSTHDR(&amp;msg); cmptr != NULL;
         cmptr = CMSG_NXTHDR(&amp;msg, cmptr)) {

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">IP_PKTINFO</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">in_pktinfo_definition_is_missing</span>
        <span class="enscript-type">struct</span> in_pktinfo
        {
            <span class="enscript-type">int</span> ipi_ifindex;
            <span class="enscript-type">struct</span> in_addr ipi_spec_dst;
            <span class="enscript-type">struct</span> in_addr ipi_addr;
        };
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
            cmptr-&gt;cmsg_type == IP_PKTINFO) {
            <span class="enscript-type">struct</span> in_pktinfo *tmp;
            <span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;pktp-&gt;ipi_addr;

            tmp = (<span class="enscript-type">struct</span> in_pktinfo *) CMSG_DATA(cmptr);
            sin-&gt;sin_family = AF_INET;
            sin-&gt;sin_addr = tmp-&gt;ipi_addr;
            sin-&gt;sin_port = 0;
            pktp-&gt;ipi_ifindex = tmp-&gt;ipi_ifindex;
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">IP_RECVDSTADDR</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
            cmptr-&gt;cmsg_type == IP_RECVDSTADDR) {
            <span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;pktp-&gt;ipi_addr;

            sin-&gt;sin_family = AF_INET;
            sin-&gt;sin_addr = *(<span class="enscript-type">struct</span> in_addr*)CMSG_DATA(cmptr);
            sin-&gt;sin_port = 0;
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">IP_RECVIF</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
            cmptr-&gt;cmsg_type == IP_RECVIF) {
            <span class="enscript-type">struct</span> sockaddr_dl  *sdl = (<span class="enscript-type">struct</span> sockaddr_dl *) CMSG_DATA(cmptr);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HAVE_BROKEN_RECVIF_NAME</span>
            <span class="enscript-type">int</span> nameLen = (sdl-&gt;sdl_nlen &lt; IFI_NAME - 1) ? sdl-&gt;sdl_nlen : (IFI_NAME - 1);
            strncpy(pktp-&gt;ipi_ifname, sdl-&gt;sdl_data, nameLen);
#<span class="enscript-reference">endif</span>
            pktp-&gt;ipi_ifindex = sdl-&gt;sdl_index;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HAVE_BROKEN_RECVIF_NAME</span>
            <span class="enscript-keyword">if</span> (sdl-&gt;sdl_index == 0) {
                pktp-&gt;ipi_ifindex = *(uint_t*)sdl;
            }
#<span class="enscript-reference">endif</span>
            assert(pktp-&gt;ipi_ifname[IFI_NAME - 1] == 0);
            <span class="enscript-comment">// null terminated because of memset above
</span>            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">IP_RECVTTL</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
            cmptr-&gt;cmsg_type == IP_RECVTTL) {
            *ttl = *(u_char*)CMSG_DATA(cmptr);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;
                 cmptr-&gt;cmsg_type == IP_TTL) {  <span class="enscript-comment">// some implementations seem to send IP_TTL instead of IP_RECVTTL
</span>            *ttl = *(<span class="enscript-type">int</span>*)CMSG_DATA(cmptr);
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">IPV6_PKTINFO</span>) &amp;&amp; <span class="enscript-variable-name">HAVE_IPV6</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;
            cmptr-&gt;cmsg_type  == IPV6_2292_PKTINFO) {
            <span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6*)&amp;pktp-&gt;ipi_addr;
            <span class="enscript-type">struct</span> in6_pktinfo *ip6_info = (<span class="enscript-type">struct</span> in6_pktinfo*)CMSG_DATA(cmptr);

            sin6-&gt;sin6_family   = AF_INET6;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NOT_HAVE_SA_LEN</span>
            sin6-&gt;sin6_len      = <span class="enscript-keyword">sizeof</span>(*sin6);
#<span class="enscript-reference">endif</span>
            sin6-&gt;sin6_addr     = ip6_info-&gt;ipi6_addr;
            sin6-&gt;sin6_flowinfo = 0;
            sin6-&gt;sin6_scope_id = 0;
            sin6-&gt;sin6_port     = 0;
            pktp-&gt;ipi_ifindex   = ip6_info-&gt;ipi6_ifindex;
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">IPV6_HOPLIMIT</span>) &amp;&amp; <span class="enscript-variable-name">HAVE_IPV6</span>
        <span class="enscript-keyword">if</span> (cmptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;
            cmptr-&gt;cmsg_type == IPV6_2292_HOPLIMIT) {
            *ttl = *(<span class="enscript-type">int</span>*)CMSG_DATA(cmptr);
            <span class="enscript-keyword">continue</span>;
        }
#<span class="enscript-reference">endif</span>
        assert(0);  <span class="enscript-comment">// unknown ancillary data
</span>    }
    <span class="enscript-keyword">return</span>(n);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CMSG_FIRSTHDR */</span>
}

<span class="enscript-comment">// **********************************************************************************************
</span>
<span class="enscript-comment">// daemonize the process. Adapted from &quot;Unix Network Programming&quot; vol 1 by Stevens, section 12.4.
</span><span class="enscript-comment">// Returns 0 on success, -1 on failure.
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NOT_HAVE_DAEMON</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">daemon</span>(<span class="enscript-type">int</span> nochdir, <span class="enscript-type">int</span> noclose)
{
    <span class="enscript-keyword">switch</span> (fork())
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>: <span class="enscript-keyword">return</span> (-1);       <span class="enscript-comment">// Fork failed
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:  <span class="enscript-keyword">break</span>;             <span class="enscript-comment">// Child -- continue
</span>    <span class="enscript-reference">default</span>: _exit(0);          <span class="enscript-comment">// Parent -- exit
</span>    }

    <span class="enscript-keyword">if</span> (setsid() == -1) <span class="enscript-keyword">return</span>(-1);

    signal(SIGHUP, SIG_IGN);

    <span class="enscript-keyword">switch</span> (fork())             <span class="enscript-comment">// Fork again, primarily for reasons of Unix trivia
</span>    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>: <span class="enscript-keyword">return</span> (-1);       <span class="enscript-comment">// Fork failed
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:  <span class="enscript-keyword">break</span>;             <span class="enscript-comment">// Child -- continue
</span>    <span class="enscript-reference">default</span>: _exit(0);          <span class="enscript-comment">// Parent -- exit
</span>    }

    <span class="enscript-keyword">if</span> (!nochdir) (<span class="enscript-type">void</span>)chdir(<span class="enscript-string">&quot;/&quot;</span>);
    umask(0);

    <span class="enscript-keyword">if</span> (!noclose)
    {
        <span class="enscript-type">int</span> fd = open(<span class="enscript-string">&quot;/dev/null&quot;</span>, O_RDWR, 0);
        <span class="enscript-keyword">if</span> (fd != -1)
        {
            <span class="enscript-comment">// Avoid unnecessarily duplicating a file descriptor to itself
</span>            <span class="enscript-keyword">if</span> (fd != STDIN_FILENO) (<span class="enscript-type">void</span>)dup2(fd, STDIN_FILENO);
            <span class="enscript-keyword">if</span> (fd != STDOUT_FILENO) (<span class="enscript-type">void</span>)dup2(fd, STDOUT_FILENO);
            <span class="enscript-keyword">if</span> (fd != STDERR_FILENO) (<span class="enscript-type">void</span>)dup2(fd, STDERR_FILENO);
            <span class="enscript-keyword">if</span> (fd != STDIN_FILENO &amp;&amp; fd != STDOUT_FILENO &amp;&amp; fd != STDERR_FILENO)
                (<span class="enscript-type">void</span>)close (fd);
        }
    }
    <span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NOT_HAVE_DAEMON */</span>
</pre>
<hr />
</body></html>