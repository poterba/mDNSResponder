<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nss_mdns.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nss_mdns.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="nss_mdns.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
   NICTA Public Software Licence
   Version 1.0

   Copyright Â© 2004 National ICT Australia Ltd

   All rights reserved.

   By this licence, National ICT Australia Ltd (NICTA) grants permission,
   free of charge, to any person who obtains a copy of this software
   and any associated documentation files (&quot;the Software&quot;) to use and
   deal with the Software in source code and binary forms without
   restriction, with or without modification, and to permit persons
   to whom the Software is furnished to do so, provided that the
   following conditions are met:

   - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimers.
   - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimers in
   the documentation and/or other materials provided with the
   distribution.
   - The name of NICTA may not be used to endorse or promote products
   derived from this Software without specific prior written permission.

   EXCEPT AS EXPRESSLY STATED IN THIS LICENCE AND TO THE FULL EXTENT
   PERMITTED BY APPLICABLE LAW, THE SOFTWARE IS PROVIDED &quot;AS-IS&quot; AND
   NICTA MAKES NO REPRESENTATIONS, WARRANTIES OR CONDITIONS OF ANY
   KIND, EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, ANY
   REPRESENTATIONS, WARRANTIES OR CONDITIONS REGARDING THE CONTENTS
   OR ACCURACY OF THE SOFTWARE, OR OF TITLE, MERCHANTABILITY, FITNESS
   FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, THE ABSENCE OF LATENT
   OR OTHER DEFECTS, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR
   NOT DISCOVERABLE.

   TO THE FULL EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL
   NICTA BE LIABLE ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
   NEGLIGENCE) FOR ANY LOSS OR DAMAGE WHATSOEVER, INCLUDING (WITHOUT
   LIMITATION) LOSS OF PRODUCTION OR OPERATION TIME, LOSS, DAMAGE OR
   CORRUPTION OF DATA OR RECORDS; OR LOSS OF ANTICIPATED SAVINGS,
   OPPORTUNITY, REVENUE, PROFIT OR GOODWILL, OR OTHER ECONOMIC LOSS;
   OR ANY SPECIAL, INCIDENTAL, INDIRECT, CONSEQUENTIAL, PUNITIVE OR
   EXEMPLARY DAMAGES ARISING OUT OF OR IN CONNECTION WITH THIS LICENCE,
   THE SOFTWARE OR THE USE OF THE SOFTWARE, EVEN IF NICTA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

   If applicable legislation implies warranties or conditions, or
   imposes obligations or liability on NICTA in respect of the Software
   that cannot be wholly or partly excluded, restricted or modified,
   NICTA's liability is limited, to the full extent permitted by the
   applicable legislation, at its option, to:

   a. in the case of goods, any one or more of the following:
   i.   the replacement of the goods or the supply of equivalent goods;
   ii.  the repair of the goods;
   iii. the payment of the cost of replacing the goods or of acquiring
       equivalent goods;
   iv.  the payment of the cost of having the goods repaired; or
   b. in the case of services:
   i.   the supplying of the services again; or
   ii.  the payment of the cost of having the services supplied
       again.
 */</span>

<span class="enscript-comment">/*
    NSSwitch Implementation of mDNS interface.

    Andrew White (<a href="mailto:Andrew.White@nicta.com.au">Andrew.White@nicta.com.au</a>)
    May 2004
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ctype.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BIND_8_COMPAT</span> 1
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/nameser.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dns_sd.h&gt;</span>


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Public functions
</span>
<span class="enscript-comment">/*
    Count the number of dots in a name string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">count_dots</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name);


<span class="enscript-comment">/*
    Test whether a domain name is local.

    Returns
        1 if name ends with &quot;.local&quot; or &quot;.local.&quot;
        0 otherwise
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">islocal</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name);


<span class="enscript-comment">/*
    Format an address structure as a string appropriate for DNS reverse (PTR)
    lookup, based on address type.

    Parameters
        prefixlen
            Prefix length, in bits.  When formatting, this will be rounded up
            to the nearest appropriate size.  If -1, assume maximum.
        buf
            Output buffer.  Must be long enough to hold largest possible
            output.
    Returns
        Pointer to (first character of) output buffer,
        or NULL on error.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr</span> (<span class="enscript-type">int</span> af, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr, <span class="enscript-type">int</span> prefixlen, <span class="enscript-type">char</span> * buf);


<span class="enscript-comment">/*
    Format an address structure as a string appropriate for DNS reverse (PTR)
    lookup for AF_INET.  Output is in .in-addr.arpa domain.

    Parameters
        prefixlen
            Prefix length, in bits.  When formatting, this will be rounded up
            to the nearest byte (8).  If -1, assume 32.
        buf
            Output buffer.  Must be long enough to hold largest possible
            output.  For AF_INET, this is 29 characters (including null).
    Returns
        Pointer to (first character of) output buffer,
        or NULL on error.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr_in</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr * addr,
    <span class="enscript-type">int</span> prefixlen,
    <span class="enscript-type">char</span> * buf
    );
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_PTR_AF_INET_SIZE</span> 29

<span class="enscript-comment">/*
    Format an address structure as a string appropriate for DNS reverse (PTR)
    lookup for AF_INET6.  Output is in .ip6.arpa domain.

    Parameters
        prefixlen
            Prefix length, in bits.  When formatting, this will be rounded up
            to the nearest nibble (4).  If -1, assume 128.
        buf
            Output buffer.  Must be long enough to hold largest possible
            output.  For AF_INET6, this is 72 characters (including null).
    Returns
        Pointer to (first character of) output buffer,
        or NULL on error.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr_in6</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr * addr,
    <span class="enscript-type">int</span> prefixlen,
    <span class="enscript-type">char</span> * buf
    );
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_PTR_AF_INET6_SIZE</span> 72


<span class="enscript-comment">/*
    Compare whether the given dns name has the given domain suffix.
    A single leading '.' on the name or leading or trailing '.' on the
    domain is ignored for the purposes of the comparison.
    Multiple leading or trailing '.'s are an error.  Other DNS syntax
    errors are not checked for.  The comparison is case insensitive.

    Returns
        1 on success (match)
        0 on failure (no match)
        &lt; 0 on error
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cmp_dns_suffix</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain);
<span class="enscript-type">enum</span>
{
    CMP_DNS_SUFFIX_SUCCESS = 1,
    CMP_DNS_SUFFIX_FAILURE = 0,
    CMP_DNS_SUFFIX_BAD_NAME = 1,
    CMP_DNS_SUFFIX_BAD_DOMAIN = -2
};

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> ns_type_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> ns_class_t;

<span class="enscript-comment">/*
    Convert a DNS resource record (RR) code to an address family (AF) code.

    Parameters
        rrtype
            resource record type (from nameser.h)

    Returns
        Appropriate AF code (from socket.h), or AF_UNSPEC if an appropriate
        mapping couldn't be determined
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rr_to_af</span> (ns_type_t rrtype);


<span class="enscript-comment">/*
    Convert an address family (AF) code to a DNS resource record (RR) code.

    Parameters
        int
            address family code (from socket.h)
    Returns
        Appropriate RR code (from nameser.h), or ns_t_invalid if an appropriate
        mapping couldn't be determined
 */</span>
ns_type_t
<span class="enscript-function-name">af_to_rr</span> (<span class="enscript-type">int</span> af);


<span class="enscript-comment">/*
    Convert a string to an address family (case insensitive).

    Returns
        Matching AF code, or AF_UNSPEC if no match found.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">str_to_af</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);


<span class="enscript-comment">/*
    Convert a string to an ns_class_t (case insensitive).

    Returns
        Matching ns_class_t, or ns_c_invalid if no match found.
 */</span>
ns_class_t
<span class="enscript-function-name">str_to_ns_class</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);


<span class="enscript-comment">/*
    Convert a string to an ns_type_t (case insensitive).

    Returns
        Matching ns_type_t, or ns_t_invalid if no match found.
 */</span>
ns_type_t
<span class="enscript-function-name">str_to_ns_type</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);


<span class="enscript-comment">/*
    Convert an address family code to a string.

    Returns
        String representation of AF,
        or NULL if address family unrecognised or invalid.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">af_to_str</span> (<span class="enscript-type">int</span> in);


<span class="enscript-comment">/*
    Convert an ns_class_t code to a string.

    Returns
        String representation of ns_class_t,
        or NULL if ns_class_t unrecognised or invalid.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ns_class_to_str</span> (ns_class_t in);


<span class="enscript-comment">/*
    Convert an ns_type_t code to a string.

    Returns
        String representation of ns_type_t,
        or NULL if ns_type_t unrecognised or invalid.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ns_type_to_str</span> (ns_type_t in);


<span class="enscript-comment">/*
    Convert DNS rdata in label format (RFC1034, RFC1035) to a name.

    On error, partial data is written to name (as much as was successfully
    processed) and an error code is returned.  Errors include a name too
    long for the buffer and a pointer in the label (which cannot be
    resolved).

    Parameters
        rdata
            Rdata formatted as series of labels.
        rdlen
            Length of rdata buffer.
        name
            Buffer to store fully qualified result in.
            By RFC1034 section 3.1, a 255 character buffer (256 characters
            including null) is long enough for any legal name.
        name_len
            Number of characters available in name buffer, not including
            trailing null.

    Returns
        Length of name buffer (not including trailing null).
        &lt; 0 on error.
        A return of 0 implies the empty domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dns_rdata_to_name</span> (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * rdata, <span class="enscript-type">int</span> rdlen, <span class="enscript-type">char</span> * name, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> name_len);
<span class="enscript-type">enum</span>
{
    DNS_RDATA_TO_NAME_BAD_FORMAT = -1,
    <span class="enscript-comment">// Format is broken.  Usually because we ran out of data
</span>    <span class="enscript-comment">// (according to rdata) before the labels said we should.
</span>    DNS_RDATA_TO_NAME_TOO_LONG = -2,
    <span class="enscript-comment">// The converted rdata is longer than the name buffer.
</span>    DNS_RDATA_TO_NAME_PTR = -3,
    <span class="enscript-comment">// The rdata contains a pointer.
</span>};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_LABEL_MAXLEN</span> 63
<span class="enscript-comment">// Maximum length of a single DNS label
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_NAME_MAXLEN</span> 256
<span class="enscript-comment">// Maximum length of a DNS name
</span>
<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Public types
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> errcode_t;
<span class="enscript-comment">// Used for 0 = success, non-zero = error code functions
</span>

<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Public functions
</span>
<span class="enscript-comment">/*
    Test whether a domain name is in a domain covered by nss_mdns.
    The name is assumed to be fully qualified (trailing dot optional);
    unqualified names will be processed but may return unusual results
    if the unqualified prefix happens to match a domain suffix.

    Returns
         1 success
         0 failure
        -1 error, check errno
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">config_is_mdns_suffix</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name);


<span class="enscript-comment">/*
    Loads all relevant data from configuration file.  Other code should
    rarely need to call this function, since all other public configuration
    functions do so implicitly.  Once loaded, configuration info doesn't
    change.

    Returns
        0 configuration ready
        non-zero configuration error code
 */</span>
errcode_t
<span class="enscript-function-name">init_config</span> ();

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ENTNAME</span>  hostent
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DATABASE</span> <span class="enscript-string">&quot;hosts&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nss.h&gt;</span>
<span class="enscript-comment">// For nss_status
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netdb.h&gt;</span>
<span class="enscript-comment">// For hostent
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
<span class="enscript-comment">// For size_t
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> nss_status nss_status;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hostent hostent;

<span class="enscript-comment">/*
   gethostbyname implementation

    name:
        name to look up
    result_buf:
        resulting entry
    buf:
        auxillary buffer
    buflen:
        length of auxillary buffer
    errnop:
        pointer to errno
    h_errnop:
        pointer to h_errno
 */</span>
nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyname_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    );


<span class="enscript-comment">/*
   gethostbyname2 implementation

    name:
        name to look up
    af:
        address family
    result_buf:
        resulting entry
    buf:
        auxillary buffer
    buflen:
        length of auxillary buffer
    errnop:
        pointer to errno
    h_errnop:
        pointer to h_errno
 */</span>
nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyname2_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    );


<span class="enscript-comment">/*
   gethostbyaddr implementation

    addr:
        address structure to look up
    len:
        length of address structure
    af:
        address family
    result_buf:
        resulting entry
    buf:
        auxillary buffer
    buflen:
        length of auxillary buffer
    errnop:
        pointer to errno
    h_errnop:
        pointer to h_errno
 */</span>
nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyaddr_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *addr,
    socklen_t len,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    );


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Types and Constants
</span>
<span class="enscript-type">const</span> <span class="enscript-type">int</span> MDNS_VERBOSE = 0;
<span class="enscript-comment">// This enables verbose syslog messages
</span><span class="enscript-comment">// If zero, only &quot;imporant&quot; messages will appear in syslog
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">k_hostname_maxlen</span> 256
<span class="enscript-comment">// As per RFC1034 and RFC1035
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">k_aliases_max</span> 15
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">k_addrs_max</span> 15

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> buf_header
{
    <span class="enscript-type">char</span> hostname [k_hostname_maxlen + 1];
    <span class="enscript-type">char</span> * aliases [k_aliases_max + 1];
    <span class="enscript-type">char</span> * addrs [k_addrs_max + 1];
} buf_header_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> result_map
{
    <span class="enscript-type">int</span> done;
    nss_status status;
    hostent * hostent;
    buf_header_t * header;
    <span class="enscript-type">int</span> aliases_count;
    <span class="enscript-type">int</span> addrs_count;
    <span class="enscript-type">char</span> * buffer;
    <span class="enscript-type">int</span> addr_idx;
    <span class="enscript-comment">// Index for addresses - grow from low end
</span>    <span class="enscript-comment">// Index points to first empty space
</span>    <span class="enscript-type">int</span> alias_idx;
    <span class="enscript-comment">// Index for aliases - grow from high end
</span>    <span class="enscript-comment">// Index points to lowest entry
</span>    <span class="enscript-type">int</span> r_errno;
    <span class="enscript-type">int</span> r_h_errno;
} result_map_t;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval
k_select_time = { 0, 500000 };
<span class="enscript-comment">// 0 seconds, 500 milliseconds
</span>
<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local prototypes
</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">mdns_gethostbyname2</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    );


<span class="enscript-comment">/*
    Lookup name using mDNS server
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">mdns_lookup_name</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname,
    <span class="enscript-type">int</span> af,
    result_map_t * result
    );

<span class="enscript-comment">/*
    Lookup address using mDNS server
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">mdns_lookup_addr</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr,
    socklen_t len,
    <span class="enscript-type">int</span> af,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * addr_str,
    result_map_t * result
    );


<span class="enscript-comment">/*
    Handle incoming MDNS events
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">handle_events</span> (DNSServiceRef sdref, result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);


<span class="enscript-comment">// Callback for mdns_lookup operations
</span><span class="enscript-comment">//DNSServiceQueryRecordReply mdns_lookup_callback;
</span><span class="enscript-type">typedef</span> <span class="enscript-type">void</span>
mdns_lookup_callback_t
(
    DNSServiceRef sdref,
    DNSServiceFlags flags,
    uint32_t interface_index,
    DNSServiceErrorType error_code,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          *fullname,
    uint16_t rrtype,
    uint16_t rrclass,
    uint16_t rdlen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>          *rdata,
    uint32_t ttl,
    <span class="enscript-type">void</span>                *context
);

mdns_lookup_callback_t mdns_lookup_callback;


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">init_result</span> (
    result_map_t * result,
    hostent * result_buf,
    <span class="enscript-type">char</span> * buf,
    size_t buflen
    );

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">callback_body_ptr</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname,
    result_map_t * result,
    <span class="enscript-type">int</span> rdlen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * rdata
    );

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">add_address_to_buffer</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, <span class="enscript-type">int</span> len);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_alias_to_buffer</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * data, <span class="enscript-type">int</span> len);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_hostname_len</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname, <span class="enscript-type">int</span> len);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_hostname_or_alias</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * data, <span class="enscript-type">int</span> len);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">contains_address</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, <span class="enscript-type">int</span> len);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">contains_alias</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * data);


<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">is_applicable_name</span> (
    result_map_t * result,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
    <span class="enscript-type">char</span> * lookup_name
    );

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">is_applicable_addr</span> (
    result_map_t * result,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr,
    <span class="enscript-type">int</span> af,
    <span class="enscript-type">char</span> * addr_str
    );


<span class="enscript-comment">// Error code functions
</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err</span> (result_map_t * result, nss_status status, <span class="enscript-type">int</span> err, <span class="enscript-type">int</span> herr);

<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_notfound</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_bad_hostname</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_buf_too_small</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_internal_resource_full</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_system</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_mdns_failed</span> (result_map_t * result);
<span class="enscript-type">static</span> nss_status <span class="enscript-function-name">set_err_success</span> (result_map_t * result);


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Global variables
</span>

<span class="enscript-comment">//----------
</span><span class="enscript-comment">// NSS functions
</span>
nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyname_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    )
{
    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Called nss_mdns_gethostbyname with %s&quot;</span>,
                name
                );

    <span class="enscript-keyword">return</span>
        mdns_gethostbyname2 (
            name, AF_INET, result_buf, buf, buflen, errnop, h_errnop
            );
}


nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyname2_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    )
{
    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Called nss_mdns_gethostbyname2 with %s&quot;</span>,
                name
                );

    <span class="enscript-keyword">return</span>
        mdns_gethostbyname2 (
            name, af, result_buf, buf, buflen, errnop, h_errnop
            );
}


nss_status
<span class="enscript-function-name">_nss_mdns_gethostbyaddr_r</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *addr,
    socklen_t len,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    )
{
    <span class="enscript-type">char</span> addr_str [NI_MAXHOST + 1];
    result_map_t result;
    <span class="enscript-type">int</span> err_status;

    <span class="enscript-keyword">if</span> (inet_ntop (af, addr, addr_str, NI_MAXHOST) == NULL)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * family = af_to_str (af);
        <span class="enscript-keyword">if</span> (family == NULL)
        {
            family = <span class="enscript-string">&quot;Unknown&quot;</span>;
        }

        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Couldn't covert address, family %d (%s) in nss_mdns_gethostbyaddr: %s&quot;</span>,
                af,
                family,
                strerror (errno)
                );

        <span class="enscript-comment">// This address family never applicable to us, so return NOT_FOUND
</span>
        *errnop = ENOENT;
        *h_errnop = HOST_NOT_FOUND;
        <span class="enscript-keyword">return</span> NSS_STATUS_NOTFOUND;
    }
    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
    {
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Called nss_mdns_gethostbyaddr with %s&quot;</span>,
                addr_str
                );
    }

    <span class="enscript-comment">// Initialise result
</span>    err_status = init_result (&amp;result, result_buf, buf, buflen);
    <span class="enscript-keyword">if</span> (err_status)
    {
        *errnop = err_status;
        *h_errnop = NETDB_INTERNAL;
        <span class="enscript-keyword">return</span> NSS_STATUS_TRYAGAIN;
    }

    <span class="enscript-keyword">if</span> (is_applicable_addr (&amp;result, addr, af, addr_str))
    {
        nss_status rv;

        rv = mdns_lookup_addr (addr, len, af, addr_str, &amp;result);
        <span class="enscript-keyword">if</span> (rv == NSS_STATUS_SUCCESS)
        {
            <span class="enscript-keyword">return</span> rv;
        }
    }

    <span class="enscript-comment">// Return current error status (defaults to NOT_FOUND)
</span>
    *errnop = result.r_errno;
    *h_errnop = result.r_h_errno;
    <span class="enscript-keyword">return</span> result.status;
}


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local functions
</span>
nss_status
<span class="enscript-function-name">mdns_gethostbyname2</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
    <span class="enscript-type">int</span> af,
    hostent * result_buf,
    <span class="enscript-type">char</span> *buf,
    size_t buflen,
    <span class="enscript-type">int</span> *errnop,
    <span class="enscript-type">int</span> *h_errnop
    )
{
    <span class="enscript-type">char</span> lookup_name [k_hostname_maxlen + 1];
    result_map_t result;
    <span class="enscript-type">int</span> err_status;

    <span class="enscript-comment">// Initialise result
</span>    err_status = init_result (&amp;result, result_buf, buf, buflen);
    <span class="enscript-keyword">if</span> (err_status)
    {
        *errnop = err_status;
        *h_errnop = NETDB_INTERNAL;
        <span class="enscript-keyword">return</span> NSS_STATUS_TRYAGAIN;
    }

    <span class="enscript-keyword">if</span> (is_applicable_name (&amp;result, name, lookup_name))
    {
        <span class="enscript-comment">// Try using mdns
</span>        nss_status rv;

        <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
            syslog (LOG_DEBUG,
                    <span class="enscript-string">&quot;mdns: Local name: %s&quot;</span>,
                    name
                    );

        rv = mdns_lookup_name (name, af, &amp;result);
        <span class="enscript-keyword">if</span> (rv == NSS_STATUS_SUCCESS)
        {
            <span class="enscript-keyword">return</span> rv;
        }
    }

    <span class="enscript-comment">// Return current error status (defaults to NOT_FOUND)
</span>
    *errnop = result.r_errno;
    *h_errnop = result.r_h_errno;
    <span class="enscript-keyword">return</span> result.status;
}


<span class="enscript-comment">/*
    Lookup a fully qualified hostname using the default record type
    for the specified address family.

    Parameters
        fullname
            Fully qualified hostname.  If not fully qualified the code will
            still 'work', but the lookup is unlikely to succeed.
        af
            Either AF_INET or AF_INET6.  Other families are not supported.
        result
            Initialised 'result' data structure.
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">mdns_lookup_name</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname,
    <span class="enscript-type">int</span> af,
    result_map_t * result
    )
{
    <span class="enscript-comment">// Lookup using mDNS.
</span>    DNSServiceErrorType errcode;
    DNSServiceRef sdref;
    ns_type_t rrtype;
    nss_status status;

    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Attempting lookup of %s&quot;</span>,
                fullname
                );

    <span class="enscript-keyword">switch</span> (af)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
        rrtype = kDNSServiceType_A;
        result-&gt;hostent-&gt;h_length = 4;
        <span class="enscript-comment">// Length of an A record
</span>        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
        rrtype = kDNSServiceType_AAAA;
        result-&gt;hostent-&gt;h_length = 16;
        <span class="enscript-comment">// Length of an AAAA record
</span>        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Unsupported address family %d&quot;</span>,
                af
                );
        <span class="enscript-keyword">return</span> set_err_bad_hostname (result);
    }
    result-&gt;hostent-&gt;h_addrtype = af;

    errcode =
        DNSServiceQueryRecord (
            &amp;sdref,
            kDNSServiceFlagsForceMulticast,     <span class="enscript-comment">// force multicast query
</span>            kDNSServiceInterfaceIndexAny,   <span class="enscript-comment">// all interfaces
</span>            fullname,   <span class="enscript-comment">// full name to query for
</span>            rrtype,     <span class="enscript-comment">// resource record type
</span>            kDNSServiceClass_IN,    <span class="enscript-comment">// internet class records
</span>            mdns_lookup_callback,   <span class="enscript-comment">// callback
</span>            result      <span class="enscript-comment">// Context - result buffer
</span>            );

    <span class="enscript-keyword">if</span> (errcode)
    {
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Failed to initialise lookup, error %d&quot;</span>,
                errcode
                );
        <span class="enscript-keyword">return</span> set_err_mdns_failed (result);
    }

    status = handle_events (sdref, result, fullname);
    DNSServiceRefDeallocate (sdref);
    <span class="enscript-keyword">return</span> status;
}


<span class="enscript-comment">/*
    Reverse (PTR) lookup for the specified address.

    Parameters
        addr
            Either a struct in_addr or a struct in6_addr
        addr_len
            size of the address
        af
            Either AF_INET or AF_INET6.  Other families are not supported.
            Must match addr
        addr_str
            Address in format suitable for PTR lookup.
            AF_INET: a.b.c.d -&gt; d.c.b.a.in-addr.arpa
            AF_INET6: reverse nibble format, x.x.x...x.ip6.arpa
        result
            Initialised 'result' data structure.
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">mdns_lookup_addr</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr,
    socklen_t addr_len,
    <span class="enscript-type">int</span> af,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * addr_str,
    result_map_t * result
    )
{
    DNSServiceErrorType errcode;
    DNSServiceRef sdref;
    nss_status status;

    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Attempting lookup of %s&quot;</span>,
                addr_str
                );

    result-&gt;hostent-&gt;h_addrtype = af;
    result-&gt;hostent-&gt;h_length = addr_len;

    <span class="enscript-comment">// Query address becomes &quot;address&quot; in result.
</span>    <span class="enscript-keyword">if</span> (!add_address_to_buffer (result, addr, addr_len))
    {
        <span class="enscript-keyword">return</span> result-&gt;status;
    }

    result-&gt;hostent-&gt;h_name [0] = 0;

    errcode =
        DNSServiceQueryRecord (
            &amp;sdref,
            kDNSServiceFlagsForceMulticast,     <span class="enscript-comment">// force multicast query
</span>            kDNSServiceInterfaceIndexAny,   <span class="enscript-comment">// all interfaces
</span>            addr_str,   <span class="enscript-comment">// address string to query for
</span>            kDNSServiceType_PTR,    <span class="enscript-comment">// pointer RRs
</span>            kDNSServiceClass_IN,    <span class="enscript-comment">// internet class records
</span>            mdns_lookup_callback,   <span class="enscript-comment">// callback
</span>            result      <span class="enscript-comment">// Context - result buffer
</span>            );

    <span class="enscript-keyword">if</span> (errcode)
    {
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Failed to initialise mdns lookup, error %d&quot;</span>,
                errcode
                );
        <span class="enscript-keyword">return</span> set_err_mdns_failed (result);
    }

    status = handle_events (sdref, result, addr_str);
    DNSServiceRefDeallocate (sdref);
    <span class="enscript-keyword">return</span> status;
}


<span class="enscript-comment">/*
    Wait on result of callback, and process it when it arrives.

    Parameters
        sdref
            dns-sd reference
        result
            Initialised 'result' data structure.
        str
            lookup string, used for status/error reporting.
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">handle_events</span> (DNSServiceRef sdref, result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-type">int</span> dns_sd_fd = DNSServiceRefSockFD(sdref);
    <span class="enscript-type">int</span> nfds = dns_sd_fd + 1;
    fd_set readfds;
    <span class="enscript-type">struct</span> timeval tv;
    <span class="enscript-type">int</span> select_result;

    <span class="enscript-keyword">while</span> (!result-&gt;done)
    {
        FD_ZERO(&amp;readfds);
        FD_SET(dns_sd_fd, &amp;readfds);

        tv = k_select_time;

        select_result =
            select (nfds, &amp;readfds, (fd_set*)NULL, (fd_set*)NULL, &amp;tv);
        <span class="enscript-keyword">if</span> (select_result &gt; 0)
        {
            <span class="enscript-keyword">if</span> (FD_ISSET(dns_sd_fd, &amp;readfds))
            {
                <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
                    syslog (LOG_DEBUG,
                            <span class="enscript-string">&quot;mdns: Reply received for %s&quot;</span>,
                            str
                            );
                DNSServiceProcessResult(sdref);
            }
            <span class="enscript-keyword">else</span>
            {
                syslog (LOG_WARNING,
                        <span class="enscript-string">&quot;mdns: Unexpected return from select on lookup of %s&quot;</span>,
                        str
                        );
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Terminate loop due to timer expiry
</span>            <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
                syslog (LOG_DEBUG,
                        <span class="enscript-string">&quot;mdns: %s not found - timer expired&quot;</span>,
                        str
                        );
            set_err_notfound (result);
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">return</span> result-&gt;status;
}


<span class="enscript-comment">/*
    Examine incoming data and add to relevant fields in result structure.
    This routine is called from DNSServiceProcessResult where appropriate.
 */</span>
<span class="enscript-type">void</span>
mdns_lookup_callback
(
    DNSServiceRef sdref,
    DNSServiceFlags flags,
    uint32_t interface_index,
    DNSServiceErrorType error_code,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          *fullname,
    uint16_t rrtype,
    uint16_t rrclass,
    uint16_t rdlen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span>          *rdata,
    uint32_t ttl,
    <span class="enscript-type">void</span>                *context
)
{
    <span class="enscript-comment">// A single record is received
</span>
    result_map_t * result = (result_map_t *) context;

    (<span class="enscript-type">void</span>)sdref; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)interface_index; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)ttl; <span class="enscript-comment">// Unused
</span>
    <span class="enscript-keyword">if</span> (!(flags &amp; kDNSServiceFlagsMoreComing) )
    {
        result-&gt;done = 1;
    }

    <span class="enscript-keyword">if</span> (error_code == kDNSServiceErr_NoError)
    {
        ns_type_t expected_rr_type =
            af_to_rr (result-&gt;hostent-&gt;h_addrtype);

        <span class="enscript-comment">// Idiot check class
</span>        <span class="enscript-keyword">if</span> (rrclass != C_IN)
        {
            syslog (LOG_WARNING,
                    <span class="enscript-string">&quot;mdns: Received bad RR class: expected %d (%s),&quot;</span>
                    <span class="enscript-string">&quot; got %d (%s), RR type %d (%s)&quot;</span>,
                    C_IN,
                    ns_class_to_str (C_IN),
                    rrclass,
                    ns_class_to_str (rrclass),
                    rrtype,
                    ns_type_to_str (rrtype)
                    );
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// If a PTR
</span>        <span class="enscript-keyword">if</span> (rrtype == kDNSServiceType_PTR)
        {
            <span class="enscript-keyword">if</span> (callback_body_ptr (fullname, result, rdlen, rdata) &lt; 0)
                <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rrtype == expected_rr_type)
        {
            <span class="enscript-keyword">if</span> (!
                add_hostname_or_alias (
                    result,
                    fullname,
                    strlen (fullname)
                    )
                )
            {
                result-&gt;done = 1;
                <span class="enscript-keyword">return</span>;
                <span class="enscript-comment">// Abort on error
</span>            }

            <span class="enscript-keyword">if</span> (!add_address_to_buffer (result, rdata, rdlen) )
            {
                result-&gt;done = 1;
                <span class="enscript-keyword">return</span>;
                <span class="enscript-comment">// Abort on error
</span>            }
        }
        <span class="enscript-keyword">else</span>
        {
            syslog (LOG_WARNING,
                    <span class="enscript-string">&quot;mdns: Received bad RR type: expected %d (%s),&quot;</span>
                    <span class="enscript-string">&quot; got %d (%s)&quot;</span>,
                    expected_rr_type,
                    ns_type_to_str (expected_rr_type),
                    rrtype,
                    ns_type_to_str (rrtype)
                    );
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-keyword">if</span> (result-&gt;status != NSS_STATUS_SUCCESS)
            set_err_success (result);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// For now, dump message to syslog and continue
</span>        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: callback returned error %d&quot;</span>,
                error_code
                );
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">callback_body_ptr</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname,
    result_map_t * result,
    <span class="enscript-type">int</span> rdlen,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * rdata
    )
{
    <span class="enscript-type">char</span> result_name [k_hostname_maxlen + 1];
    <span class="enscript-type">int</span> rv;

    <span class="enscript-comment">// Fullname should be .in-addr.arpa or equivalent, which we're
</span>    <span class="enscript-comment">// not interested in.  Ignore it.
</span>
    rv = dns_rdata_to_name (rdata, rdlen, result_name, k_hostname_maxlen);
    <span class="enscript-keyword">if</span> (rv &lt; 0)
    {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> * errmsg;

        <span class="enscript-keyword">switch</span> (rv)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DNS_RDATA_TO_NAME_BAD_FORMAT</span>:
            errmsg = <span class="enscript-string">&quot;mdns: PTR '%s' result badly formatted ('%s...')&quot;</span>;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">DNS_RDATA_TO_NAME_TOO_LONG</span>:
            errmsg = <span class="enscript-string">&quot;mdns: PTR '%s' result too long ('%s...')&quot;</span>;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">DNS_RDATA_TO_NAME_PTR</span>:
            errmsg = <span class="enscript-string">&quot;mdns: PTR '%s' result contained pointer ('%s...')&quot;</span>;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            errmsg = <span class="enscript-string">&quot;mdns: PTR '%s' result conversion failed ('%s...')&quot;</span>;
        }

        syslog (LOG_WARNING,
                errmsg,
                fullname,
                result_name
                );

        <span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
    {
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: PTR '%s' resolved to '%s'&quot;</span>,
                fullname,
                result_name
                );
    }

    <span class="enscript-comment">// Data should be a hostname
</span>    <span class="enscript-keyword">if</span> (!
        add_hostname_or_alias (
            result,
            result_name,
            rv
            )
        )
    {
        result-&gt;done = 1;
        <span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
    Add an address to the buffer.

    Parameter
        result
            Result structure to write to
        data
            Incoming address data buffer
            Must be 'int' aligned
        len
            Length of data buffer (in bytes)
            Must match data alignment

    Result
        Pointer to start of newly written data,
        or NULL on error.
        If address already exists in buffer, returns pointer to that instead.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">add_address_to_buffer</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> new_addr;
    <span class="enscript-type">void</span> * start;
    <span class="enscript-type">void</span> * temp;

    <span class="enscript-keyword">if</span> ((temp = contains_address (result, data, len)))
    {
        <span class="enscript-keyword">return</span> temp;
    }

    <span class="enscript-keyword">if</span> (result-&gt;addrs_count &gt;= k_addrs_max)
    {
        <span class="enscript-comment">// Not enough addr slots
</span>        set_err_internal_resource_full (result);
        syslog (LOG_ERR,
                <span class="enscript-string">&quot;mdns: Internal address buffer full; increase size&quot;</span>
                );
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-comment">// Idiot check
</span>    <span class="enscript-keyword">if</span> (len != result-&gt;hostent-&gt;h_length)
    {
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Unexpected rdata length for address.  Expected %d, got %d&quot;</span>,
                result-&gt;hostent-&gt;h_length,
                len
                );
        <span class="enscript-comment">// XXX And continue for now.
</span>    }

    new_addr = result-&gt;addr_idx + len;

    <span class="enscript-keyword">if</span> (new_addr &gt; result-&gt;alias_idx)
    {
        <span class="enscript-comment">// Not enough room
</span>        set_err_buf_too_small (result);
        <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
            syslog (LOG_DEBUG,
                    <span class="enscript-string">&quot;mdns: Ran out of buffer when adding address %d&quot;</span>,
                    result-&gt;addrs_count + 1
                    );
        <span class="enscript-keyword">return</span> NULL;
    }

    start = result-&gt;buffer + result-&gt;addr_idx;
    memcpy (start, data, len);
    result-&gt;addr_idx = new_addr;
    result-&gt;header-&gt;addrs [result-&gt;addrs_count] = start;
    result-&gt;addrs_count++;
    result-&gt;header-&gt;addrs [result-&gt;addrs_count] = NULL;

    <span class="enscript-keyword">return</span> start;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">contains_address</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// Idiot check
</span>    <span class="enscript-keyword">if</span> (len != result-&gt;hostent-&gt;h_length)
    {
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Unexpected rdata length for address.  Expected %d, got %d&quot;</span>,
                result-&gt;hostent-&gt;h_length,
                len
                );
        <span class="enscript-comment">// XXX And continue for now.
</span>    }

    <span class="enscript-keyword">for</span> (i = 0; result-&gt;header-&gt;addrs [i]; i++)
    {
        <span class="enscript-keyword">if</span> (memcmp (result-&gt;header-&gt;addrs [i], data, len) == 0)
        {
            <span class="enscript-keyword">return</span> result-&gt;header-&gt;addrs [i];
        }
    }

    <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-comment">/*
    Add an alias to the buffer.

    Parameter
        result
            Result structure to write to
        data
            Incoming alias (null terminated)
        len
            Length of data buffer (in bytes), including trailing null

    Result
        Pointer to start of newly written data,
        or NULL on error
        If alias already exists in buffer, returns pointer to that instead.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_alias_to_buffer</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * data, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> new_alias;
    <span class="enscript-type">char</span> * start;
    <span class="enscript-type">char</span> * temp;

    <span class="enscript-keyword">if</span> ((temp = contains_alias (result, data)))
    {
        <span class="enscript-keyword">return</span> temp;
    }

    <span class="enscript-keyword">if</span> (result-&gt;aliases_count &gt;= k_aliases_max)
    {
        <span class="enscript-comment">// Not enough alias slots
</span>        set_err_internal_resource_full (result);
        syslog (LOG_ERR,
                <span class="enscript-string">&quot;mdns: Internal alias buffer full; increase size&quot;</span>
                );
        <span class="enscript-keyword">return</span> NULL;
    }

    new_alias = result-&gt;alias_idx - len;

    <span class="enscript-keyword">if</span> (new_alias &lt; result-&gt;addr_idx)
    {
        <span class="enscript-comment">// Not enough room
</span>        set_err_buf_too_small (result);
        <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
            syslog (LOG_DEBUG,
                    <span class="enscript-string">&quot;mdns: Ran out of buffer when adding alias %d&quot;</span>,
                    result-&gt;aliases_count + 1
                    );
        <span class="enscript-keyword">return</span> NULL;
    }

    start = result-&gt;buffer + new_alias;
    memcpy (start, data, len);
    result-&gt;alias_idx = new_alias;
    result-&gt;header-&gt;aliases [result-&gt;aliases_count] = start;
    result-&gt;aliases_count++;
    result-&gt;header-&gt;aliases [result-&gt;aliases_count] = NULL;

    <span class="enscript-keyword">return</span> start;
}


<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">contains_alias</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * alias)
{
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">for</span> (i = 0; result-&gt;header-&gt;aliases [i]; i++)
    {
        <span class="enscript-keyword">if</span> (strcmp (result-&gt;header-&gt;aliases [i], alias) == 0)
        {
            <span class="enscript-keyword">return</span> result-&gt;header-&gt;aliases [i];
        }
    }

    <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-comment">/*
    Add fully qualified hostname to result.

    Parameter
        result
            Result structure to write to
        fullname
            Fully qualified hostname

    Result
        Pointer to start of hostname buffer,
        or NULL on error (usually hostname too long)
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_hostname_len</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fullname, <span class="enscript-type">int</span> len)
{
    <span class="enscript-keyword">if</span> (len &gt;= k_hostname_maxlen)
    {
        set_err_bad_hostname (result);
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;mdns: Hostname too long '%.*s': len %d, max %d&quot;</span>,
                len,
                fullname,
                len,
                k_hostname_maxlen
                );
        <span class="enscript-keyword">return</span> NULL;
    }

    result-&gt;hostent-&gt;h_name =
        strcpy (result-&gt;header-&gt;hostname, fullname);

    <span class="enscript-keyword">return</span> result-&gt;header-&gt;hostname;
}


<span class="enscript-comment">/*
    Add fully qualified name as hostname or alias.

    If hostname is not fully qualified this is not an error, but the data
    returned may be not what the application wanted.

    Parameter
        result
            Result structure to write to
        data
            Incoming alias (null terminated)
        len
            Length of data buffer (in bytes), including trailing null

    Result
        Pointer to start of newly written data,
        or NULL on error
        If alias or hostname already exists, returns pointer to that instead.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_hostname_or_alias</span> (result_map_t * result, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * data, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">char</span> * hostname = result-&gt;hostent-&gt;h_name;

    <span class="enscript-keyword">if</span> (*hostname)
    {
        <span class="enscript-keyword">if</span> (strcmp (hostname, data) == 0)
        {
            <span class="enscript-keyword">return</span> hostname;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> add_alias_to_buffer (result, data, len);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span> add_hostname_len (result, data, len);
    }
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">init_result</span> (
    result_map_t * result,
    hostent * result_buf,
    <span class="enscript-type">char</span> * buf,
    size_t buflen
    )
{
    <span class="enscript-keyword">if</span> (buflen &lt; <span class="enscript-keyword">sizeof</span> (buf_header_t))
    {
        <span class="enscript-keyword">return</span> ERANGE;
    }

    result-&gt;hostent = result_buf;
    result-&gt;header = (buf_header_t *) buf;
    result-&gt;header-&gt;hostname[0] = 0;
    result-&gt;aliases_count = 0;
    result-&gt;header-&gt;aliases[0] = NULL;
    result-&gt;addrs_count = 0;
    result-&gt;header-&gt;addrs[0] = NULL;
    result-&gt;buffer = buf + <span class="enscript-keyword">sizeof</span> (buf_header_t);
    result-&gt;addr_idx = 0;
    result-&gt;alias_idx = buflen - <span class="enscript-keyword">sizeof</span> (buf_header_t);
    result-&gt;done = 0;
    set_err_notfound (result);

    <span class="enscript-comment">// Point hostent to the right buffers
</span>    result-&gt;hostent-&gt;h_name = result-&gt;header-&gt;hostname;
    result-&gt;hostent-&gt;h_aliases = result-&gt;header-&gt;aliases;
    result-&gt;hostent-&gt;h_addr_list = result-&gt;header-&gt;addrs;

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
    Set the status in the result.

    Parameters
        result
            Result structure to update
        status
            New nss_status value
        err
            New errno value
        herr
            New h_errno value

    Returns
        New status value
 */</span>
<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err</span> (result_map_t * result, nss_status status, <span class="enscript-type">int</span> err, <span class="enscript-type">int</span> herr)
{
    result-&gt;status = status;
    result-&gt;r_errno = err;
    result-&gt;r_h_errno = herr;

    <span class="enscript-keyword">return</span> status;
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_notfound</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_NOTFOUND, ENOENT, HOST_NOT_FOUND);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_bad_hostname</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_TRYAGAIN, ENOENT, NO_RECOVERY);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_buf_too_small</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_TRYAGAIN, ERANGE, NETDB_INTERNAL);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_internal_resource_full</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_RETURN, ERANGE, NO_RECOVERY);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_system</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_UNAVAIL, errno, NETDB_INTERNAL);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_mdns_failed</span> (result_map_t * result)
{
    <span class="enscript-keyword">return</span> set_err (result, NSS_STATUS_TRYAGAIN, EAGAIN, TRY_AGAIN);
}

<span class="enscript-type">static</span> nss_status
<span class="enscript-function-name">set_err_success</span> (result_map_t * result)
{
    result-&gt;status = NSS_STATUS_SUCCESS;
    <span class="enscript-keyword">return</span> result-&gt;status;
}


<span class="enscript-comment">/*
    Test whether name is applicable for mdns to process, and if so copy into
    lookup_name buffer (if non-NULL).

    Returns
        Pointer to name to lookup up, if applicable, or NULL otherwise.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">is_applicable_name</span> (
    result_map_t * result,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
    <span class="enscript-type">char</span> * lookup_name
    )
{
    <span class="enscript-type">int</span> match = config_is_mdns_suffix (name);
    <span class="enscript-keyword">if</span> (match &gt; 0)
    {
        <span class="enscript-keyword">if</span> (lookup_name)
        {
            strncpy (lookup_name, name, k_hostname_maxlen + 1);
            <span class="enscript-keyword">return</span> lookup_name;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> name;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (match &lt; 0)
        {
            set_err_system (result);
        }
        <span class="enscript-keyword">return</span> NULL;
    }
}

<span class="enscript-comment">/*
    Test whether address is applicable for mdns to process, and if so copy into
    addr_str buffer as an address suitable for ptr lookup.

    Returns
        Pointer to name to lookup up, if applicable, or NULL otherwise.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">is_applicable_addr</span> (
    result_map_t * result,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr,
    <span class="enscript-type">int</span> af,
    <span class="enscript-type">char</span> * addr_str
    )
{
    <span class="enscript-type">int</span> match;

    <span class="enscript-keyword">if</span> (!format_reverse_addr (af, addr, -1, addr_str))
    {
        <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
            syslog (LOG_DEBUG,
                    <span class="enscript-string">&quot;mdns: Failed to create reverse address&quot;</span>
                    );
        <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">if</span> (MDNS_VERBOSE)
        syslog (LOG_DEBUG,
                <span class="enscript-string">&quot;mdns: Reverse address: %s&quot;</span>,
                addr_str
                );

    match = config_is_mdns_suffix (addr_str);
    <span class="enscript-keyword">if</span> (match &gt; 0)
    {
        <span class="enscript-keyword">return</span> addr_str;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (match &lt; 0)
        {
            set_err_system (result);
        }
        <span class="enscript-keyword">return</span> NULL;
    }
}

<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Types and Constants
</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_conf_file = <span class="enscript-string">&quot;/etc/nss_mdns.conf&quot;</span>;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONF_LINE_SIZE</span> 1024

<span class="enscript-type">const</span> <span class="enscript-type">char</span> k_comment_char = <span class="enscript-string">'#'</span>;

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_keyword_domain = <span class="enscript-string">&quot;domain&quot;</span>;

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_default_domains [] =
{
    <span class="enscript-string">&quot;local&quot;</span>,
    <span class="enscript-string">&quot;254.169.in-addr.arpa&quot;</span>,
    <span class="enscript-string">&quot;8.e.f.ip6.int&quot;</span>,
    <span class="enscript-string">&quot;8.e.f.ip6.arpa&quot;</span>,
    <span class="enscript-string">&quot;9.e.f.ip6.int&quot;</span>,
    <span class="enscript-string">&quot;9.e.f.ip6.arpa&quot;</span>,
    <span class="enscript-string">&quot;a.e.f.ip6.int&quot;</span>,
    <span class="enscript-string">&quot;a.e.f.ip6.arpa&quot;</span>,
    <span class="enscript-string">&quot;b.e.f.ip6.int&quot;</span>,
    <span class="enscript-string">&quot;b.e.f.ip6.arpa&quot;</span>,
    NULL
    <span class="enscript-comment">// Always null terminated
</span>};

<span class="enscript-comment">// Linked list of domains
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> domain_entry
{
    <span class="enscript-type">char</span> * domain;
    <span class="enscript-type">struct</span> domain_entry * next;
} domain_entry_t;


<span class="enscript-comment">// Config
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    domain_entry_t * domains;
} config_t;

<span class="enscript-type">const</span> config_t k_empty_config =
{
    NULL
};


<span class="enscript-comment">// Context - tracks position in config file, used for error reporting
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * filename;
    <span class="enscript-type">int</span> linenum;
} config_file_context_t;


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local prototypes
</span>
<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">load_config</span> (config_t * conf);

<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">process_config_line</span> (
    config_t * conf,
    <span class="enscript-type">char</span> * line,
    config_file_context_t * context
    );

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">get_next_word</span> (<span class="enscript-type">char</span> * input, <span class="enscript-type">char</span> **next);

<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">default_config</span> (config_t * conf);

<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">add_domain</span> (config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">contains_domain</span> (<span class="enscript-type">const</span> config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">contains_domain_suffix</span> (<span class="enscript-type">const</span> config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * addr);


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Global variables
</span>
<span class="enscript-type">static</span> config_t * g_config = NULL;
<span class="enscript-comment">// Configuration info
</span>
pthread_mutex_t g_config_mutex =
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP</span>
    PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
#<span class="enscript-reference">else</span>
    PTHREAD_MUTEX_INITIALIZER;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Configuration functions
</span>

<span class="enscript-comment">/*
    Initialise the configuration from the config file.

    Returns
        0 success
        non-zero error code on failure
 */</span>
errcode_t
<span class="enscript-function-name">init_config</span> ()
{
    <span class="enscript-keyword">if</span> (g_config)
    {
        <span class="enscript-comment">/*
            Safe to test outside mutex.
            If non-zero, initialisation is complete and g_config can be
            safely used read-only.  If zero, then we do proper mutex
            testing before initialisation.
         */</span>
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">int</span> errcode = -1;
        <span class="enscript-type">int</span> presult;
        config_t * temp_config;

        <span class="enscript-comment">// Acquire mutex
</span>        presult = pthread_mutex_lock (&amp;g_config_mutex);
        <span class="enscript-keyword">if</span> (presult)
        {
            syslog (LOG_ERR,
                    <span class="enscript-string">&quot;mdns: Fatal mutex lock error in nss_mdns:init_config, %s:%d: %d: %s&quot;</span>,
                    __FILE__, __LINE__, presult, strerror (presult)
                    );
            <span class="enscript-keyword">return</span> presult;
        }

        <span class="enscript-comment">// Test again now we have mutex, in case initialisation occurred while
</span>        <span class="enscript-comment">// we were waiting
</span>        <span class="enscript-keyword">if</span> (!g_config)
        {
            temp_config = (config_t *) malloc (<span class="enscript-keyword">sizeof</span> (config_t));
            <span class="enscript-keyword">if</span> (temp_config)
            {
                <span class="enscript-comment">// Note: This code will leak memory if initialisation fails
</span>                <span class="enscript-comment">// repeatedly.  This should only happen in the case of a memory
</span>                <span class="enscript-comment">// error, so I'm not sure if it's a meaningful problem. - AW
</span>                *temp_config = k_empty_config;
                errcode = load_config (temp_config);

                <span class="enscript-keyword">if</span> (!errcode)
                {
                    g_config = temp_config;
                }
            }
            <span class="enscript-keyword">else</span>
            {
                syslog (LOG_ERR,
                        <span class="enscript-string">&quot;mdns: Can't allocate memory in nss_mdns:init_config, %s:%d&quot;</span>,
                        __FILE__, __LINE__
                        );
                errcode = errno;
            }
        }

        presult = pthread_mutex_unlock (&amp;g_config_mutex);
        <span class="enscript-keyword">if</span> (presult)
        {
            syslog (LOG_ERR,
                    <span class="enscript-string">&quot;mdns: Fatal mutex unlock error in nss_mdns:init_config, %s:%d: %d: %s&quot;</span>,
                    __FILE__, __LINE__, presult, strerror (presult)
                    );
            errcode = presult;
        }

        <span class="enscript-keyword">return</span> errcode;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">config_is_mdns_suffix</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name)
{
    <span class="enscript-type">int</span> errcode = init_config ();
    <span class="enscript-keyword">if</span> (!errcode)
    {
        <span class="enscript-keyword">return</span> contains_domain_suffix (g_config, name);
    }
    <span class="enscript-keyword">else</span>
    {
        errno = errcode;
        <span class="enscript-keyword">return</span> -1;
    }
}


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local functions
</span>
<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">load_config</span> (config_t * conf)
{
    FILE * cf;
    <span class="enscript-type">char</span> line [CONF_LINE_SIZE];
    config_file_context_t context;

    context.filename = k_conf_file;
    context.linenum = 0;


    cf = fopen (context.filename, <span class="enscript-string">&quot;r&quot;</span>);
    <span class="enscript-keyword">if</span> (!cf)
    {
        syslog (LOG_INFO,
                <span class="enscript-string">&quot;mdns: Couldn't open nss_mdns configuration file %s, using default.&quot;</span>,
                context.filename
                );
        <span class="enscript-keyword">return</span> default_config (conf);
    }

    <span class="enscript-keyword">while</span> (fgets (line, CONF_LINE_SIZE, cf))
    {
        <span class="enscript-type">int</span> errcode;
        context.linenum++;
        errcode = process_config_line (conf, line, &amp;context);
        <span class="enscript-keyword">if</span> (errcode)
        {
            <span class="enscript-comment">// Critical error, give up
</span>            fclose(cf);
            <span class="enscript-keyword">return</span> errcode;
        }
    }

    fclose (cf);

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
    Parse a line of the configuration file.
    For each keyword recognised, perform appropriate handling.
    If the keyword is not recognised, print a message to syslog
    and continue.

    Returns
        0 success, or recoverable config file error
        non-zero serious system error, processing aborted
 */</span>
<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">process_config_line</span> (
    config_t * conf,
    <span class="enscript-type">char</span> * line,
    config_file_context_t * context
    )
{
    <span class="enscript-type">char</span> * curr = line;
    <span class="enscript-type">char</span> * word;

    word = get_next_word (curr, &amp;curr);
    <span class="enscript-keyword">if</span> (!word || word [0] == k_comment_char)
    {
        <span class="enscript-comment">// Nothing interesting on this line
</span>        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> (strcmp (word, k_keyword_domain) == 0)
    {
        word = get_next_word (curr, &amp;curr);
        <span class="enscript-keyword">if</span> (word)
        {
            <span class="enscript-type">int</span> errcode = add_domain (conf, word);
            <span class="enscript-keyword">if</span> (errcode)
            {
                <span class="enscript-comment">// something badly wrong, bail
</span>                <span class="enscript-keyword">return</span> errcode;
            }

            <span class="enscript-keyword">if</span> (get_next_word (curr, NULL))
            {
                syslog (LOG_WARNING,
                        <span class="enscript-string">&quot;%s, line %d: ignored extra text found after domain&quot;</span>,
                        context-&gt;filename,
                        context-&gt;linenum
                        );
            }
        }
        <span class="enscript-keyword">else</span>
        {
            syslog (LOG_WARNING,
                    <span class="enscript-string">&quot;%s, line %d: no domain specified&quot;</span>,
                    context-&gt;filename,
                    context-&gt;linenum
                    );
        }
    }
    <span class="enscript-keyword">else</span>
    {
        syslog (LOG_WARNING,
                <span class="enscript-string">&quot;%s, line %d: unknown keyword %s - skipping&quot;</span>,
                context-&gt;filename,
                context-&gt;linenum,
                word
                );
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
    Get next word (whitespace separated) from input string.
    A null character is written into the first whitespace character following
    the word.

    Parameters
        input
            Input string.  This string is modified by get_next_word.
        next
            If non-NULL and the result is non-NULL, a pointer to the
            character following the end of the word (after the null)
            is written to 'next'.
            If no word is found, the original value is unchanged.
            If the word extended to the end of the string, 'next' points
            to the trailling NULL.
            It is safe to pass 'str' as 'input' and '&amp;str' as 'next'.
    Returns
        Pointer to the first non-whitespace character (and thus word) found.
        if no word is found, returns NULL.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">get_next_word</span> (<span class="enscript-type">char</span> * input, <span class="enscript-type">char</span> **next)
{
    <span class="enscript-type">char</span> * curr = input;
    <span class="enscript-type">char</span> * result;

    <span class="enscript-keyword">while</span> (isspace (*curr))
    {
        curr++;
    }

    <span class="enscript-keyword">if</span> (*curr == 0)
    {
        <span class="enscript-keyword">return</span> NULL;
    }

    result = curr;
    <span class="enscript-keyword">while</span> (*curr &amp;&amp; !isspace (*curr))
    {
        curr++;
    }
    <span class="enscript-keyword">if</span> (*curr)
    {
        *curr = 0;
        <span class="enscript-keyword">if</span> (next)
        {
            *next = curr+1;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (next)
        {
            *next = curr;
        }
    }

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">default_config</span> (config_t * conf)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; k_default_domains [i]; i++)
    {
        <span class="enscript-type">int</span> errcode =
            add_domain (conf, k_default_domains [i]);
        <span class="enscript-keyword">if</span> (errcode)
        {
            <span class="enscript-comment">// Something has gone (badly) wrong - let's bail
</span>            <span class="enscript-keyword">return</span> errcode;
        }
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> errcode_t
<span class="enscript-function-name">add_domain</span> (config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain)
{
    <span class="enscript-keyword">if</span> (!contains_domain (conf, domain))
    {
        domain_entry_t * d =
            (domain_entry_t *) malloc (<span class="enscript-keyword">sizeof</span> (domain_entry_t));
        <span class="enscript-keyword">if</span> (!d)
        {
            syslog (LOG_ERR,
                    <span class="enscript-string">&quot;mdns: Can't allocate memory in nss_mdns:init_config, %s:%d&quot;</span>,
                    __FILE__, __LINE__
                    );
            <span class="enscript-keyword">return</span> ENOMEM;
        }

        d-&gt;domain = strdup (domain);
        <span class="enscript-keyword">if</span> (!d-&gt;domain)
        {
            syslog (LOG_ERR,
                    <span class="enscript-string">&quot;mdns: Can't allocate memory in nss_mdns:init_config, %s:%d&quot;</span>,
                    __FILE__, __LINE__
                    );
            free (d);
            <span class="enscript-keyword">return</span> ENOMEM;
        }
        d-&gt;next = conf-&gt;domains;
        conf-&gt;domains = d;
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">contains_domain</span> (<span class="enscript-type">const</span> config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain)
{
    <span class="enscript-type">const</span> domain_entry_t * curr = conf-&gt;domains;

    <span class="enscript-keyword">while</span> (curr != NULL)
    {
        <span class="enscript-keyword">if</span> (strcasecmp (curr-&gt;domain, domain) == 0)
        {
            <span class="enscript-keyword">return</span> 1;
        }

        curr = curr-&gt;next;
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">contains_domain_suffix</span> (<span class="enscript-type">const</span> config_t * conf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * addr)
{
    <span class="enscript-type">const</span> domain_entry_t * curr = conf-&gt;domains;

    <span class="enscript-keyword">while</span> (curr != NULL)
    {
        <span class="enscript-keyword">if</span> (cmp_dns_suffix (addr, curr-&gt;domain) &gt; 0)
        {
            <span class="enscript-keyword">return</span> 1;
        }

        curr = curr-&gt;next;
    }

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Types and Constants
</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_local_suffix = <span class="enscript-string">&quot;local&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> k_dns_separator = <span class="enscript-string">'.'</span>;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> k_label_maxlen = DNS_LABEL_MAXLEN;
<span class="enscript-comment">// Label entries longer than this are actually pointers.
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    <span class="enscript-type">int</span> value;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * comment;
} table_entry_t;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> table_entry_t k_table_af [] =
{
    { AF_UNSPEC, NULL, NULL },
    { AF_LOCAL, <span class="enscript-string">&quot;LOCAL&quot;</span>, NULL },
    { AF_UNIX, <span class="enscript-string">&quot;UNIX&quot;</span>, NULL },
    { AF_INET, <span class="enscript-string">&quot;INET&quot;</span>, NULL },
    { AF_INET6, <span class="enscript-string">&quot;INET6&quot;</span>, NULL }
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> k_table_af_size =
    <span class="enscript-keyword">sizeof</span> (k_table_af) / <span class="enscript-keyword">sizeof</span> (*k_table_af);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_table_ns_class [] =
{
    NULL,
    <span class="enscript-string">&quot;IN&quot;</span>
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> k_table_ns_class_size =
    <span class="enscript-keyword">sizeof</span> (k_table_ns_class) / <span class="enscript-keyword">sizeof</span> (*k_table_ns_class);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * k_table_ns_type [] =
{
    NULL,
    <span class="enscript-string">&quot;A&quot;</span>,
    <span class="enscript-string">&quot;NS&quot;</span>,
    <span class="enscript-string">&quot;MD&quot;</span>,
    <span class="enscript-string">&quot;MF&quot;</span>,
    <span class="enscript-string">&quot;CNAME&quot;</span>,
    <span class="enscript-string">&quot;SOA&quot;</span>,
    <span class="enscript-string">&quot;MB&quot;</span>,
    <span class="enscript-string">&quot;MG&quot;</span>,
    <span class="enscript-string">&quot;MR&quot;</span>,
    <span class="enscript-string">&quot;NULL&quot;</span>,
    <span class="enscript-string">&quot;WKS&quot;</span>,
    <span class="enscript-string">&quot;PTR&quot;</span>,
    <span class="enscript-string">&quot;HINFO&quot;</span>,
    <span class="enscript-string">&quot;MINFO&quot;</span>,
    <span class="enscript-string">&quot;MX&quot;</span>,
    <span class="enscript-string">&quot;TXT&quot;</span>,
    <span class="enscript-string">&quot;RP&quot;</span>,
    <span class="enscript-string">&quot;AFSDB&quot;</span>,
    <span class="enscript-string">&quot;X25&quot;</span>,
    <span class="enscript-string">&quot;ISDN&quot;</span>,
    <span class="enscript-string">&quot;RT&quot;</span>,
    <span class="enscript-string">&quot;NSAP&quot;</span>,
    NULL,
    <span class="enscript-string">&quot;SIG&quot;</span>,
    <span class="enscript-string">&quot;KEY&quot;</span>,
    <span class="enscript-string">&quot;PX&quot;</span>,
    <span class="enscript-string">&quot;GPOS&quot;</span>,
    <span class="enscript-string">&quot;AAAA&quot;</span>,
    <span class="enscript-string">&quot;LOC&quot;</span>,
    <span class="enscript-string">&quot;NXT&quot;</span>,
    <span class="enscript-string">&quot;EID&quot;</span>,
    <span class="enscript-string">&quot;NIMLOC&quot;</span>,
    <span class="enscript-string">&quot;SRV&quot;</span>,
    <span class="enscript-string">&quot;ATMA&quot;</span>,
    <span class="enscript-string">&quot;NAPTR&quot;</span>,
    <span class="enscript-string">&quot;KX&quot;</span>,
    <span class="enscript-string">&quot;CERT&quot;</span>,
    <span class="enscript-string">&quot;A6&quot;</span>,
    <span class="enscript-string">&quot;DNAME&quot;</span>,
    <span class="enscript-string">&quot;SINK&quot;</span>,
    <span class="enscript-string">&quot;OPT&quot;</span>
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> k_table_ns_type_size =
    <span class="enscript-keyword">sizeof</span> (k_table_ns_type) / <span class="enscript-keyword">sizeof</span> (*k_table_ns_type);


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local prototypes
</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">simple_table_index</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * table [], <span class="enscript-type">int</span> size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">table_index_name</span> (<span class="enscript-type">const</span> table_entry_t table [], <span class="enscript-type">int</span> size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">table_index_value</span> (<span class="enscript-type">const</span> table_entry_t table [], <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> n);


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Global variables
</span>

<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Util functions
</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">count_dots</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name)
{
    <span class="enscript-type">int</span> count = 0;
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; name[i]; i++)
    {
        <span class="enscript-keyword">if</span> (name [i] == k_dns_separator)
            count++;
    }

    <span class="enscript-keyword">return</span> count;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">islocal</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name)
{
    <span class="enscript-keyword">return</span> cmp_dns_suffix (name, k_local_suffix) &gt; 0;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">rr_to_af</span> (ns_type_t rrtype)
{
    <span class="enscript-keyword">switch</span> (rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceType_A</span>:
        <span class="enscript-keyword">return</span> AF_INET;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSServiceType_AAAA</span>:
        <span class="enscript-keyword">return</span> AF_INET6;

    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> AF_UNSPEC;
    }
}


ns_type_t
<span class="enscript-function-name">af_to_rr</span> (<span class="enscript-type">int</span> af)
{
    <span class="enscript-keyword">switch</span> (af)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
        <span class="enscript-keyword">return</span> kDNSServiceType_A;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
        <span class="enscript-keyword">return</span> kDNSServiceType_AAAA;

    <span class="enscript-reference">default</span>:
        <span class="enscript-comment">//return ns_t_invalid;
</span>        <span class="enscript-keyword">return</span> 0;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">str_to_af</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-type">int</span> result =
        table_index_name (k_table_af, k_table_af_size, str);
    <span class="enscript-keyword">if</span> (result &lt; 0)
        result = 0;

    <span class="enscript-keyword">return</span> k_table_af [result].value;
}


ns_class_t
<span class="enscript-function-name">str_to_ns_class</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-keyword">return</span> (ns_class_t)
           simple_table_index (k_table_ns_class, k_table_ns_class_size, str);
}


ns_type_t
<span class="enscript-function-name">str_to_ns_type</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-keyword">return</span> (ns_type_t)
           simple_table_index (k_table_ns_type, k_table_ns_type_size, str);
}


<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">af_to_str</span> (<span class="enscript-type">int</span> in)
{
    <span class="enscript-type">int</span> result =
        table_index_value (k_table_af, k_table_af_size, in);
    <span class="enscript-keyword">if</span> (result &lt; 0)
        result = 0;

    <span class="enscript-keyword">return</span> k_table_af [result].name;
}


<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ns_class_to_str</span> (ns_class_t in)
{
    <span class="enscript-keyword">if</span> (in &lt; k_table_ns_class_size)
        <span class="enscript-keyword">return</span> k_table_ns_class [in];
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ns_type_to_str</span> (ns_type_t in)
{
    <span class="enscript-keyword">if</span> (in &lt; k_table_ns_type_size)
        <span class="enscript-keyword">return</span> k_table_ns_type [in];
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr_in</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr * addr,
    <span class="enscript-type">int</span> prefixlen,
    <span class="enscript-type">char</span> * buf
    )
{
    <span class="enscript-type">char</span> * curr = buf;
    <span class="enscript-type">int</span> i;

    <span class="enscript-type">const</span> uint8_t * in_addr_a = (uint8_t *) addr;

    <span class="enscript-keyword">if</span> (prefixlen &gt; 32)
        <span class="enscript-keyword">return</span> NULL;
    <span class="enscript-keyword">if</span> (prefixlen &lt; 0)
        prefixlen = 32;

    i = (prefixlen + 7) / 8;
    <span class="enscript-comment">// divide prefixlen into bytes, rounding up
</span>
    <span class="enscript-keyword">while</span> (i &gt; 0)
    {
        i--;
        curr += sprintf (curr, <span class="enscript-string">&quot;%d.&quot;</span>, in_addr_a [i]);
    }
    sprintf (curr, <span class="enscript-string">&quot;in-addr.arpa&quot;</span>);

    <span class="enscript-keyword">return</span> buf;
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr_in6</span> (
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr * addr,
    <span class="enscript-type">int</span> prefixlen,
    <span class="enscript-type">char</span> * buf
    )
{
    <span class="enscript-type">char</span> * curr = buf;
    <span class="enscript-type">int</span> i;

    <span class="enscript-type">const</span> uint8_t * in_addr_a = (uint8_t *) addr;

    <span class="enscript-keyword">if</span> (prefixlen &gt; 128)
        <span class="enscript-keyword">return</span> NULL;
    <span class="enscript-keyword">if</span> (prefixlen &lt; 0)
        prefixlen = 128;

    i = (prefixlen + 3) / 4;
    <span class="enscript-comment">// divide prefixlen into nibbles, rounding up
</span>
    <span class="enscript-comment">// Special handling for first
</span>    <span class="enscript-keyword">if</span> (i % 2)
    {
        curr += sprintf (curr, <span class="enscript-string">&quot;%d.&quot;</span>, (in_addr_a [i/2] &gt;&gt; 4) &amp; 0x0F);
    }
    i &gt;&gt;= 1;
    <span class="enscript-comment">// Convert i to bytes (divide by 2)
</span>
    <span class="enscript-keyword">while</span> (i &gt; 0)
    {
        uint8_t val;

        i--;
        val = in_addr_a [i];
        curr += sprintf (curr, <span class="enscript-string">&quot;%x.%x.&quot;</span>, val &amp; 0x0F, (val &gt;&gt; 4) &amp; 0x0F);
    }
    sprintf (curr, <span class="enscript-string">&quot;ip6.arpa&quot;</span>);

    <span class="enscript-keyword">return</span> buf;
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">format_reverse_addr</span> (
    <span class="enscript-type">int</span> af,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> * addr,
    <span class="enscript-type">int</span> prefixlen,
    <span class="enscript-type">char</span> * buf
    )
{
    <span class="enscript-keyword">switch</span> (af)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
        <span class="enscript-keyword">return</span>
            format_reverse_addr_in (
                (<span class="enscript-type">struct</span> in_addr *) addr, prefixlen, buf
                );
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
        <span class="enscript-keyword">return</span>
            format_reverse_addr_in6 (
                (<span class="enscript-type">struct</span> in6_addr *) addr, prefixlen, buf
                );
        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> NULL;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cmp_dns_suffix</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domain)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * nametail;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * domaintail;

    <span class="enscript-comment">// Idiot checks
</span>    <span class="enscript-keyword">if</span> (*name == 0 || *name == k_dns_separator)
    {
        <span class="enscript-comment">// Name can't be empty or start with separator
</span>        <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_BAD_NAME;
    }

    <span class="enscript-keyword">if</span> (*domain == 0)
    {
        <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_SUCCESS;
        <span class="enscript-comment">// trivially true
</span>    }

    <span class="enscript-keyword">if</span> (*domain == k_dns_separator)
    {
        <span class="enscript-comment">// drop leading separator from domain
</span>        domain++;
        <span class="enscript-keyword">if</span> (*domain == k_dns_separator)
        {
            <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_BAD_DOMAIN;
        }
    }

    <span class="enscript-comment">// Find ends of strings
</span>    <span class="enscript-keyword">for</span> (nametail = name; *nametail; nametail++)
        ;
    <span class="enscript-keyword">for</span> (domaintail = domain; *domaintail; domaintail++)
        ;

    <span class="enscript-comment">// Shuffle back to last real character, and drop any trailing '.'
</span>    <span class="enscript-comment">// while we're at it.
</span>    nametail--;
    <span class="enscript-keyword">if</span> (*nametail == k_dns_separator)
    {
        nametail--;
        <span class="enscript-keyword">if</span> (*nametail == k_dns_separator)
        {
            <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_BAD_NAME;
        }
    }
    domaintail--;
    <span class="enscript-keyword">if</span> (*domaintail == k_dns_separator)
    {
        domaintail--;
        <span class="enscript-keyword">if</span> (*domaintail == k_dns_separator)
        {
            <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_BAD_DOMAIN;
        }
    }

    <span class="enscript-comment">// Compare.
</span>    <span class="enscript-keyword">while</span> (
        nametail &gt;= name
        &amp;&amp; domaintail &gt;= domain
        &amp;&amp; tolower(*nametail) == tolower(*domaintail))
    {
        nametail--;
        domaintail--;
    }

    <span class="enscript-comment">/* A successful finish will be one of the following:
        (leading and trailing . ignored)

        name  :  domain2.domain1
        domain:  domain2.domain1
                ^

        name  : domain3.domain2.domain1
        domain:         domain2.domain1
                       ^
     */</span>
    <span class="enscript-keyword">if</span> (
        domaintail &lt; domain
        &amp;&amp; (nametail &lt; name || *nametail == k_dns_separator)
        )
    {
        <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_SUCCESS;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span> CMP_DNS_SUFFIX_FAILURE;
    }
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dns_rdata_to_name</span> (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * rdata, <span class="enscript-type">int</span> rdlen, <span class="enscript-type">char</span> * name, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> name_len)
{
    <span class="enscript-type">int</span> i = 0;
    <span class="enscript-comment">// Index into 'name'
</span>    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * rdata_curr = rdata;

    <span class="enscript-keyword">if</span> (rdlen == 0) <span class="enscript-keyword">return</span> DNS_RDATA_TO_NAME_BAD_FORMAT;

    <span class="enscript-comment">/*
        In RDATA, a DNS name is stored as a series of labels.
        Each label consists of a length octet (max value 63)
        followed by the data for that label.
        The series is terminated with a length 0 octet.
        A length octet beginning with bits 11 is a pointer to
        somewhere else in the payload, but we don't support these
        since we don't have access to the entire payload.

        See RFC1034 section 3.1 and RFC1035 section 3.1.
     */</span>
    <span class="enscript-keyword">while</span> (1)
    {
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> term_len = *rdata_curr;
        rdata_curr++;

        <span class="enscript-keyword">if</span> (term_len == 0)
        {
            <span class="enscript-keyword">break</span>;
            <span class="enscript-comment">// 0 length record terminates label
</span>        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (term_len &gt; k_label_maxlen)
        {
            name [i] = 0;
            <span class="enscript-keyword">return</span> DNS_RDATA_TO_NAME_PTR;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rdata_curr + term_len &gt; rdata + rdlen)
        {
            name [i] = 0;
            <span class="enscript-keyword">return</span> DNS_RDATA_TO_NAME_BAD_FORMAT;
        }

        <span class="enscript-keyword">if</span> (name_len &lt; i + term_len + 1)
        <span class="enscript-comment">// +1 is separator
</span>        {
            name [i] = 0;
            <span class="enscript-keyword">return</span> DNS_RDATA_TO_NAME_TOO_LONG;
        }

        memcpy (name + i, rdata_curr, term_len);

        i += term_len;
        rdata_curr += term_len;

        name [i] = k_dns_separator;
        i++;
    }

    name [i] = 0;
    <span class="enscript-keyword">return</span> i;
}


<span class="enscript-comment">//----------
</span><span class="enscript-comment">// Local functions
</span>
<span class="enscript-comment">/*
    Find the index of an string entry in a table.  A case insenitive match
    is performed.  If no entry is found, 0 is returned.

    Parameters
        table
            Lookup table
            Table entries may be NULL.  NULL entries will never match.
        size
            number of entries in table
        str
            lookup string

    Result
        index of first matching entry, or 0 if no matches
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">simple_table_index</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> * table [], <span class="enscript-type">int</span> size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++)
    {
        <span class="enscript-keyword">if</span> (
            table [i]
            &amp;&amp; (strcasecmp (table [i], str) == 0)
            )
        {
            <span class="enscript-keyword">return</span> i;
        }
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
    Find the index of a name in a table.

    Parameters
        table
            array of table_entry_t records.  The name field is compared
            (ignoring case) to the input string.
        size
            number of entries in table
        str
            lookup string

    Result
        index of first matching entry, or -1 if no matches
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">table_index_name</span> (<span class="enscript-type">const</span> table_entry_t table [], <span class="enscript-type">int</span> size, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * str)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++)
    {
        <span class="enscript-keyword">if</span> (
            table [i].name
            &amp;&amp; (strcasecmp (table [i].name, str) == 0)
            )
        {
            <span class="enscript-keyword">return</span> i;
        }
    }

    <span class="enscript-keyword">return</span> -1;
}


<span class="enscript-comment">/*
    Find the index of a value a table.

    Parameters
        table
            array of table_entry_t records.  The value field is compared to
            the input value
        size
            number of entries in table
        n
            lookup value

    Result
        index of first matching entry, or -1 if no matches
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">table_index_value</span> (<span class="enscript-type">const</span> table_entry_t table [], <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> n)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++)
    {
        <span class="enscript-keyword">if</span> (table [i].value == n)
        {
            <span class="enscript-keyword">return</span> i;
        }
    }

    <span class="enscript-keyword">return</span> -1;
}
</pre>
<hr />
</body></html>