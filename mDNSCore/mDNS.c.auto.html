<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mDNS.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mDNS.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="mDNS.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4; c-file-style: &quot;bsd&quot;; c-basic-offset: 4; fill-column: 108; indent-tabs-mode: nil; -*-
 *
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This code is completely 100% portable C. It does not depend on any external header files
 * from outside the mDNS project -- all the types it expects to find are defined right here.
 *
 * The previous point is very important: This file does not depend on any external
 * header files. It should compile on *any* platform that has a C compiler, without
 * making *any* assumptions about availability of so-called &quot;standard&quot; C functions,
 * routines, or types (which may or may not be present on any given platform).
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>                  // Defines general DNS utility routines
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uDNS.h&quot;</span>                       // Defines entry points into unicast-specific routines
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nsec.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssec.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;D2D.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SymptomReporter.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Disable certain benign warnings with Microsoft compilers
</span>#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>))
<span class="enscript-comment">// Disable &quot;conditional expression is constant&quot; warning for debug macros.
</span><span class="enscript-comment">// Otherwise, this generates warnings for the perfectly natural construct &quot;while(1)&quot;
</span><span class="enscript-comment">// If someone knows a variant way of writing &quot;while(1)&quot; that doesn't generate warning messages, please let us know
</span>    #pragma warning(disable:4127)

<span class="enscript-comment">// Disable &quot;assignment within conditional expression&quot;.
</span><span class="enscript-comment">// Other compilers understand the convention that if you place the assignment expression within an extra pair
</span><span class="enscript-comment">// of parentheses, this signals to the compiler that you really intended an assignment and no warning is necessary.
</span><span class="enscript-comment">// The Microsoft compiler doesn't understand this convention, so in the absense of any other way to signal
</span><span class="enscript-comment">// to the compiler that the assignment is intentional, we have to just turn this warning off completely.
</span>    #pragma warning(disable:4706)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd.h&quot;</span> // for kDNSServiceFlags* definitions
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dns_sd_internal.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-comment">// Delay in seconds before disabling multicast after there are no active queries or registrations.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONJOUR_DISABLE_DELAY</span> 60
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">WEB_CONTENT_FILTER</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;WebFilterDNS/WebFilterDNS.h&gt;</span>

WCFConnection *<span class="enscript-function-name">WCFConnectionNew</span>(<span class="enscript-type">void</span>) __attribute__((weak_import));
<span class="enscript-type">void</span> <span class="enscript-function-name">WCFConnectionDealloc</span>(WCFConnection* c) __attribute__((weak_import));
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Metrics.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNS64.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Forward declarations
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">BeginSleepProcessing</span>(mDNS *<span class="enscript-type">const</span> m);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RetrySPSRegistrations</span>(mDNS *<span class="enscript-type">const</span> m);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendWakeup</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID InterfaceID, mDNSEthAddr *EthAddr, mDNSOpaque48 *password, mDNSBool unicastOnly);
mDNSlocal mDNSBool <span class="enscript-function-name">LocalRecordRmvEventsForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_PurgeBeforeResolve</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckForDNSSECRecords</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SendKeepalives</span>(mDNS *<span class="enscript-type">const</span> m);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ExtractKeepaliveInfo</span>(AuthRecord *ar, mDNSu32 *timeout, mDNSAddr *laddr, mDNSAddr *raddr, mDNSEthAddr *eth,
                                         mDNSu32 *seq, mDNSu32 *ack, mDNSIPPort *lport, mDNSIPPort *rport, mDNSu16 *win);

<span class="enscript-type">typedef</span> mDNSu32 DeadvertiseFlags;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDeadvertiseFlag_NormalHostname</span> (1U &lt;&lt; 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDeadvertiseFlag_RandHostname</span>   (1U &lt;&lt; 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDeadvertiseFlag_All</span>            (kDeadvertiseFlag_NormalHostname | kDeadvertiseFlag_RandHostname)

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeadvertiseInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, DeadvertiseFlags flags);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseInterfaceIfNeeded</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeNSECRecords</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *NSECRecords);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSParseNSEC3Records</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, <span class="enscript-type">const</span> mDNSu8 *end,
                                        <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, CacheRecord **NSEC3Records);
mDNSlocal mDNSu8 *<span class="enscript-function-name">GetValueForMACAddr</span>(mDNSu8 *ptr, mDNSu8 *limit, mDNSEthAddr *eth);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Program</span> <span class="enscript-variable-name">Constants</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// To Turn OFF mDNS_Tracer set MDNS_TRACER to 0 or undef it
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MDNS_TRACER</span> 1

<span class="enscript-comment">// Any records bigger than this are considered 'large' records
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SmallRecordLimit</span> 1024

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMaxUpdateCredits</span> 10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kUpdateCreditRefreshInterval</span> (mDNSPlatformOneSecond * 6)

<span class="enscript-comment">// define special NR_AnswerTo values
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NR_AnswerMulticast</span>  (mDNSu8*)~0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NR_AnswerUnicast</span>    (mDNSu8*)~1

<span class="enscript-comment">// Question default timeout values
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MCAST_TIMEOUT</span>       5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_LO_OR_P2P_TIMEOUT</span>   5

<span class="enscript-comment">// The code (see SendQueries() and BuildQuestion()) needs to have the
</span><span class="enscript-comment">// RequestUnicast value set to a value one greater than the number of times you want the query
</span><span class="enscript-comment">// sent with the &quot;request unicast response&quot; (QU) bit set.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SET_QU_IN_FIRST_QUERY</span>   2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultRequestUnicastCount</span> SET_QU_IN_FIRST_QUERY

<span class="enscript-comment">// The time needed to offload records to a sleep proxy after powerd sends the kIOMessageSystemWillSleep notification
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DARK_WAKE_DELAY_SLEEP</span>  5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDarkWakeDelaySleep</span>    (mDNSPlatformOneSecond * DARK_WAKE_DELAY_SLEEP)

<span class="enscript-comment">// The maximum number of times we delay probing to prevent spurious conflicts due to stale packets
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CONFLICT_PROCESSING_DELAYS</span> 3

<span class="enscript-comment">// RFC 6762 defines Passive Observation Of Failures (POOF)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//    A host observes the multicast queries issued by the other hosts on
</span><span class="enscript-comment">//    the network.  One of the major benefits of also sending responses
</span><span class="enscript-comment">//    using multicast is that it allows all hosts to see the responses
</span><span class="enscript-comment">//    (or lack thereof) to those queries.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//    If a host sees queries, for which a record in its cache would be
</span><span class="enscript-comment">//    expected to be given as an answer in a multicast response, but no
</span><span class="enscript-comment">//    such answer is seen, then the host may take this as an indication
</span><span class="enscript-comment">//    that the record may no longer be valid.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//    After seeing two or more of these queries, and seeing no multicast
</span><span class="enscript-comment">//    response containing the expected answer within ten seconds, then even
</span><span class="enscript-comment">//    though its TTL may indicate that it is not yet due to expire, that
</span><span class="enscript-comment">//    record SHOULD be flushed from the cache.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &lt;<a href="https://tools.ietf.org/html/rfc6762#section-10.5">https://tools.ietf.org/html/rfc6762#section-10.5</a>&gt;
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">POOF_ENABLED</span> 1

mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> mDNS_DomainTypeNames[] =
{
    <span class="enscript-string">&quot;b._dns-sd._udp.&quot;</span>,      <span class="enscript-comment">// Browse
</span>    <span class="enscript-string">&quot;db._dns-sd._udp.&quot;</span>,     <span class="enscript-comment">// Default Browse
</span>    <span class="enscript-string">&quot;lb._dns-sd._udp.&quot;</span>,     <span class="enscript-comment">// Automatic Browse
</span>    <span class="enscript-string">&quot;r._dns-sd._udp.&quot;</span>,      <span class="enscript-comment">// Registration
</span>    <span class="enscript-string">&quot;dr._dns-sd._udp.&quot;</span>      <span class="enscript-comment">// Default Registration
</span>};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">uDNS_IsActiveQuery</span>(q, u) mDNSfalse
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
<span class="enscript-comment">// When doing memory allocation debugging, this function traverses all lists in the mDNS query
</span><span class="enscript-comment">// structures and caches and checks each entry in the list to make sure it's still good.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ValidateLists</span>(<span class="enscript-type">void</span> *context)
{
    mDNS *m = context;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    mDNSu32 NumAllInterfaceRecords   = 0;
    mDNSu32 NumAllInterfaceQuestions = 0;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Check core mDNS lists
</span>    AuthRecord                  *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;next == (AuthRecord *)~0 || rr-&gt;resrec.RecordType == 0 || rr-&gt;resrec.RecordType == 0xFF)
            LogMemCorruption(<span class="enscript-string">&quot;ResourceRecords list: %p is garbage (%X)&quot;</span>, rr, rr-&gt;resrec.RecordType);
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.name != &amp;rr-&gt;namestorage)
            LogMemCorruption(<span class="enscript-string">&quot;ResourceRecords list: %p name %p does not point to namestorage %p %##s&quot;</span>,
                             rr, rr-&gt;resrec.name-&gt;c, rr-&gt;namestorage.c, rr-&gt;namestorage.c);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; !RRLocalOnly(rr)) NumAllInterfaceRecords++;
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">for</span> (rr = m-&gt;DuplicateRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;next == (AuthRecord *)~0 || rr-&gt;resrec.RecordType == 0 || rr-&gt;resrec.RecordType == 0xFF)
            LogMemCorruption(<span class="enscript-string">&quot;DuplicateRecords list: %p is garbage (%X)&quot;</span>, rr, rr-&gt;resrec.RecordType);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; !RRLocalOnly(rr)) NumAllInterfaceRecords++;
#<span class="enscript-reference">endif</span>
    }

    rr = m-&gt;NewLocalRecords;
    <span class="enscript-keyword">if</span> (rr)
        <span class="enscript-keyword">if</span> (rr-&gt;next == (AuthRecord *)~0 || rr-&gt;resrec.RecordType == 0 || rr-&gt;resrec.RecordType == 0xFF)
            LogMemCorruption(<span class="enscript-string">&quot;NewLocalRecords: %p is garbage (%X)&quot;</span>, rr, rr-&gt;resrec.RecordType);

    rr = m-&gt;CurrentRecord;
    <span class="enscript-keyword">if</span> (rr)
        <span class="enscript-keyword">if</span> (rr-&gt;next == (AuthRecord *)~0 || rr-&gt;resrec.RecordType == 0 || rr-&gt;resrec.RecordType == 0xFF)
            LogMemCorruption(<span class="enscript-string">&quot;CurrentRecord: %p is garbage (%X)&quot;</span>, rr, rr-&gt;resrec.RecordType);

    DNSQuestion                 *q;
    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (q-&gt;next == (DNSQuestion*)~0 || q-&gt;ThisQInterval == (mDNSs32) ~0)
            LogMemCorruption(<span class="enscript-string">&quot;Questions list: %p is garbage (%lX %p)&quot;</span>, q, q-&gt;ThisQInterval, q-&gt;next);
        <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf &amp;&amp; q-&gt;LocalSocket)
            LogMemCorruption(<span class="enscript-string">&quot;Questions list: Duplicate Question %p should not have LocalSocket set %##s (%s)&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
        <span class="enscript-keyword">if</span> (!LocalOnlyOrP2PInterface(q-&gt;InterfaceID) &amp;&amp; mDNSOpaque16IsZero(q-&gt;TargetQID))
            NumAllInterfaceQuestions++;
#<span class="enscript-reference">endif</span>
    }

    CacheGroup                  *cg;
    CacheRecord                 *cr;
    mDNSu32 slot;
    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == 0 || cr-&gt;resrec.RecordType == 0xFF)
            LogMemCorruption(<span class="enscript-string">&quot;Cache slot %lu: %p is garbage (%X)&quot;</span>, slot, cr, cr-&gt;resrec.RecordType);
        <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion)
        {
            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next) <span class="enscript-keyword">if</span> (q == cr-&gt;CRActiveQuestion) <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (!q) LogMemCorruption(<span class="enscript-string">&quot;Cache slot %lu: CRActiveQuestion %p not in m-&gt;Questions list %s&quot;</span>, slot, cr-&gt;CRActiveQuestion, CRDisplayString(m, cr));
        }
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceRecords != NumAllInterfaceRecords)
    	LogMemCorruption(<span class="enscript-string">&quot;NumAllInterfaceRecords is %d should be %d&quot;</span>, m-&gt;NumAllInterfaceRecords, NumAllInterfaceRecords);
    
    <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceQuestions != NumAllInterfaceQuestions)
    	LogMemCorruption(<span class="enscript-string">&quot;NumAllInterfaceQuestions is %d should be %d&quot;</span>, m-&gt;NumAllInterfaceQuestions, NumAllInterfaceQuestions);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>

<span class="enscript-comment">// Returns true if this is a  unique, authoritative LocalOnly record that answers questions of type 
</span><span class="enscript-comment">// A, AAAA , CNAME, or PTR.  The caller should answer the question with this record and not send out 
</span><span class="enscript-comment">// the question on the wire if LocalOnlyRecordAnswersQuestion() also returns true.
</span><span class="enscript-comment">// Main use is to handle /etc/hosts records and the LocalOnly PTR records created for localhost.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">UniqueLocalOnlyRecord</span>(rr) ((rr)-&gt;ARType == AuthRecordLocalOnly &amp;&amp; \
                                        (rr)-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask &amp;&amp; \
                                        ((rr)-&gt;resrec.rrtype == kDNSType_A || (rr)-&gt;resrec.rrtype == kDNSType_AAAA || \
                                         (rr)-&gt;resrec.rrtype == kDNSType_CNAME || \
                                         (rr)-&gt;resrec.rrtype == kDNSType_PTR))

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetNextQueryStopTime</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    mDNS_CheckLock(m);

    <span class="enscript-keyword">if</span> (m-&gt;NextScheduledStopTime - q-&gt;StopTime &gt; 0)
        m-&gt;NextScheduledStopTime = q-&gt;StopTime;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SetNextQueryTime</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    mDNS_CheckLock(m);

    <span class="enscript-keyword">if</span> (ActiveQuestion(q))
    {
        <span class="enscript-comment">// Depending on whether this is a multicast or unicast question we want to set either:
</span>        <span class="enscript-comment">// m-&gt;NextScheduledQuery = NextQSendTime(q) or
</span>        <span class="enscript-comment">// m-&gt;NextuDNSEvent      = NextQSendTime(q)
</span>        mDNSs32 *<span class="enscript-type">const</span> timer = mDNSOpaque16IsZero(q-&gt;TargetQID) ? &amp;m-&gt;NextScheduledQuery : &amp;m-&gt;NextuDNSEvent;
        <span class="enscript-keyword">if</span> (*timer - NextQSendTime(q) &gt; 0)
            *timer = NextQSendTime(q);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseAuthEntity</span>(AuthHash *r, AuthEntity *e)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span> &gt;= 1
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=0; i&lt;<span class="enscript-keyword">sizeof</span>(*e); i++) ((<span class="enscript-type">char</span>*)e)[i] = 0xFF;
#<span class="enscript-reference">endif</span>
    e-&gt;next = r-&gt;rrauth_free;
    r-&gt;rrauth_free = e;
    r-&gt;rrauth_totalused--;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseAuthGroup</span>(AuthHash *r, AuthGroup **cp)
{
    AuthEntity *e = (AuthEntity *)(*cp);
    LogMsg(<span class="enscript-string">&quot;ReleaseAuthGroup:  Releasing AuthGroup %##s&quot;</span>, (*cp)-&gt;name-&gt;c);
    <span class="enscript-keyword">if</span> ((*cp)-&gt;rrauth_tail != &amp;(*cp)-&gt;members)
        LogMsg(<span class="enscript-string">&quot;ERROR: (*cp)-&gt;members == mDNSNULL but (*cp)-&gt;rrauth_tail != &amp;(*cp)-&gt;members)&quot;</span>);
    <span class="enscript-keyword">if</span> ((*cp)-&gt;name != (domainname*)((*cp)-&gt;namestorage)) mDNSPlatformMemFree((*cp)-&gt;name);
    (*cp)-&gt;name = mDNSNULL;
    *cp = (*cp)-&gt;next;          <span class="enscript-comment">// Cut record from list
</span>    ReleaseAuthEntity(r, e);
}

mDNSlocal AuthEntity *<span class="enscript-function-name">GetAuthEntity</span>(AuthHash *r, <span class="enscript-type">const</span> AuthGroup *<span class="enscript-type">const</span> PreserveAG)
{
    AuthEntity *e = mDNSNULL;

    <span class="enscript-keyword">if</span> (r-&gt;rrauth_lock) { LogMsg(<span class="enscript-string">&quot;GetFreeCacheRR ERROR! Cache already locked!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    r-&gt;rrauth_lock = 1;

    <span class="enscript-keyword">if</span> (!r-&gt;rrauth_free)
    {
        <span class="enscript-comment">// We allocate just one AuthEntity at a time because we need to be able
</span>        <span class="enscript-comment">// free them all individually which normally happens when we parse /etc/hosts into
</span>        <span class="enscript-comment">// AuthHash where we add the &quot;new&quot; entries and discard (free) the already added
</span>        <span class="enscript-comment">// entries. If we allocate as chunks, we can't free them individually.
</span>        AuthEntity *storage = (AuthEntity *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*storage));
        storage-&gt;next = mDNSNULL;
        r-&gt;rrauth_free = storage;
    }

    <span class="enscript-comment">// If we still have no free records, recycle all the records we can.
</span>    <span class="enscript-comment">// Enumerating the entire auth is moderately expensive, so when we do it, we reclaim all the records we can in one pass.
</span>    <span class="enscript-keyword">if</span> (!r-&gt;rrauth_free)
    {
        mDNSu32 oldtotalused = r-&gt;rrauth_totalused;
        mDNSu32 slot;
        <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
        {
            AuthGroup **cp = &amp;r-&gt;rrauth_hash[slot];
            <span class="enscript-keyword">while</span> (*cp)
            {
                <span class="enscript-keyword">if</span> ((*cp)-&gt;members || (*cp)==PreserveAG) cp=&amp;(*cp)-&gt;next;
                <span class="enscript-keyword">else</span> ReleaseAuthGroup(r, cp);
            }
        }
        LogInfo(<span class="enscript-string">&quot;GetAuthEntity: Recycled %d records to reduce auth cache from %d to %d&quot;</span>,
                oldtotalused - r-&gt;rrauth_totalused, oldtotalused, r-&gt;rrauth_totalused);
    }

    <span class="enscript-keyword">if</span> (r-&gt;rrauth_free) <span class="enscript-comment">// If there are records in the free list, take one
</span>    {
        e = r-&gt;rrauth_free;
        r-&gt;rrauth_free = e-&gt;next;
        <span class="enscript-keyword">if</span> (++r-&gt;rrauth_totalused &gt;= r-&gt;rrauth_report)
        {
            LogInfo(<span class="enscript-string">&quot;RR Auth now using %ld objects&quot;</span>, r-&gt;rrauth_totalused);
            <span class="enscript-keyword">if</span>      (r-&gt;rrauth_report &lt;  100) r-&gt;rrauth_report += 10;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rrauth_report &lt; 1000) r-&gt;rrauth_report += 100;
            <span class="enscript-keyword">else</span> r-&gt;rrauth_report += 1000;
        }
        mDNSPlatformMemZero(e, <span class="enscript-keyword">sizeof</span>(*e));
    }

    r-&gt;rrauth_lock = 0;

    <span class="enscript-keyword">return</span>(e);
}

mDNSexport AuthGroup *<span class="enscript-function-name">AuthGroupForName</span>(AuthHash *r, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    AuthGroup *ag;
    <span class="enscript-type">const</span> mDNSu32 slot = namehash % AUTH_HASH_SLOTS;

    <span class="enscript-keyword">for</span> (ag = r-&gt;rrauth_hash[slot]; ag; ag=ag-&gt;next)
        <span class="enscript-keyword">if</span> (ag-&gt;namehash == namehash &amp;&amp; SameDomainName(ag-&gt;name, name))
            <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">return</span>(ag);
}

mDNSexport AuthGroup *<span class="enscript-function-name">AuthGroupForRecord</span>(AuthHash *r, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">return</span>(AuthGroupForName(r, rr-&gt;namehash, rr-&gt;name));
}

mDNSlocal AuthGroup *<span class="enscript-function-name">GetAuthGroup</span>(AuthHash *r, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    mDNSu16 namelen = DomainNameLength(rr-&gt;name);
    AuthGroup *ag = (AuthGroup*)GetAuthEntity(r, mDNSNULL);
    <span class="enscript-type">const</span> mDNSu32 slot = rr-&gt;namehash % AUTH_HASH_SLOTS;
    <span class="enscript-keyword">if</span> (!ag) { LogMsg(<span class="enscript-string">&quot;GetAuthGroup: Failed to allocate memory for %##s&quot;</span>, rr-&gt;name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }
    ag-&gt;next         = r-&gt;rrauth_hash[slot];
    ag-&gt;namehash     = rr-&gt;namehash;
    ag-&gt;members      = mDNSNULL;
    ag-&gt;rrauth_tail  = &amp;ag-&gt;members;
    ag-&gt;NewLocalOnlyRecords = mDNSNULL;
    <span class="enscript-keyword">if</span> (namelen &gt; <span class="enscript-keyword">sizeof</span>(ag-&gt;namestorage))
        ag-&gt;name = (domainname *) mDNSPlatformMemAllocate(namelen);
    <span class="enscript-keyword">else</span>
        ag-&gt;name = (domainname*)ag-&gt;namestorage;
    <span class="enscript-keyword">if</span> (!ag-&gt;name)
    {
        LogMsg(<span class="enscript-string">&quot;GetAuthGroup: Failed to allocate name storage for %##s&quot;</span>, rr-&gt;name-&gt;c);
        ReleaseAuthEntity(r, (AuthEntity*)ag);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }
    AssignDomainName(ag-&gt;name, rr-&gt;name);

    <span class="enscript-keyword">if</span> (AuthGroupForRecord(r, rr)) LogMsg(<span class="enscript-string">&quot;GetAuthGroup: Already have AuthGroup for %##s&quot;</span>, rr-&gt;name-&gt;c);
    r-&gt;rrauth_hash[slot] = ag;
    <span class="enscript-keyword">if</span> (AuthGroupForRecord(r, rr) != ag) LogMsg(<span class="enscript-string">&quot;GetAuthGroup: Not finding AuthGroup for %##s&quot;</span>, rr-&gt;name-&gt;c);

    <span class="enscript-keyword">return</span>(ag);
}

<span class="enscript-comment">// Returns the AuthGroup in which the AuthRecord was inserted
</span>mDNSexport AuthGroup *<span class="enscript-function-name">InsertAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthHash *r, AuthRecord *rr)
{
    AuthGroup *ag;

    (<span class="enscript-type">void</span>)m;
    ag = AuthGroupForRecord(r, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!ag) ag = GetAuthGroup(r, &amp;rr-&gt;resrec);   <span class="enscript-comment">// If we don't have a AuthGroup for this name, make one now
</span>    <span class="enscript-keyword">if</span> (ag)
    {
        *(ag-&gt;rrauth_tail) = rr;                <span class="enscript-comment">// Append this record to tail of cache slot list
</span>        ag-&gt;rrauth_tail = &amp;(rr-&gt;next);          <span class="enscript-comment">// Advance tail pointer
</span>    }
    <span class="enscript-keyword">return</span> ag;
}

mDNSexport AuthGroup *<span class="enscript-function-name">RemoveAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthHash *r, AuthRecord *rr)
{
    AuthGroup *a;
    AuthRecord **rp;

    a = AuthGroupForRecord(r, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!a) { LogMsg(<span class="enscript-string">&quot;RemoveAuthRecord: ERROR!! AuthGroup not found for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span> mDNSNULL; }
    rp = &amp;a-&gt;members;
    <span class="enscript-keyword">while</span> (*rp)
    {
        <span class="enscript-keyword">if</span> (*rp != rr)
            rp=&amp;(*rp)-&gt;next;
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// We don't break here, so that we can set the tail below without tracking &quot;prev&quot; pointers
</span>
            LogInfo(<span class="enscript-string">&quot;RemoveAuthRecord: removing auth record %s from table&quot;</span>, ARDisplayString(m, rr));
            *rp = (*rp)-&gt;next;          <span class="enscript-comment">// Cut record from list
</span>        }
    }
    <span class="enscript-comment">// TBD: If there are no more members, release authgroup ?
</span>    a-&gt;rrauth_tail = rp;
    <span class="enscript-keyword">return</span> a;
}

mDNSexport CacheGroup *<span class="enscript-function-name">CacheGroupForName</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    CacheGroup *cg;
    mDNSu32    slot = HashSlotFromNameHash(namehash);
    <span class="enscript-keyword">for</span> (cg = m-&gt;rrcache_hash[slot]; cg; cg=cg-&gt;next)
        <span class="enscript-keyword">if</span> (cg-&gt;namehash == namehash &amp;&amp; SameDomainName(cg-&gt;name, name))
            <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">return</span>(cg);
}

mDNSlocal CacheGroup *<span class="enscript-function-name">CacheGroupForRecord</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">return</span>(CacheGroupForName(m, rr-&gt;namehash, rr-&gt;name));
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNS_AddressIsLocalSubnet</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> mDNSAddr *addr)
{
    NetworkInterfaceInfo *intf;

    <span class="enscript-keyword">if</span> (addr-&gt;type == mDNSAddrType_IPv4)
    {
        <span class="enscript-comment">// Normally we resist touching the NotAnInteger fields, but here we're doing tricky bitwise masking so we make an exception
</span>        <span class="enscript-keyword">if</span> (mDNSv4AddressIsLinkLocal(&amp;addr-&gt;ip.v4)) <span class="enscript-keyword">return</span>(mDNStrue);
        <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == addr-&gt;type &amp;&amp; intf-&gt;InterfaceID == InterfaceID &amp;&amp; intf-&gt;McastTxRx)
                <span class="enscript-keyword">if</span> (((intf-&gt;ip.ip.v4.NotAnInteger ^ addr-&gt;ip.v4.NotAnInteger) &amp; intf-&gt;mask.ip.v4.NotAnInteger) == 0)
                    <span class="enscript-keyword">return</span>(mDNStrue);
    }

    <span class="enscript-keyword">if</span> (addr-&gt;type == mDNSAddrType_IPv6)
    {
        <span class="enscript-keyword">if</span> (mDNSv6AddressIsLinkLocal(&amp;addr-&gt;ip.v6)) <span class="enscript-keyword">return</span>(mDNStrue);
        <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == addr-&gt;type &amp;&amp; intf-&gt;InterfaceID == InterfaceID &amp;&amp; intf-&gt;McastTxRx)
                <span class="enscript-keyword">if</span> ((((intf-&gt;ip.ip.v6.l[0] ^ addr-&gt;ip.v6.l[0]) &amp; intf-&gt;mask.ip.v6.l[0]) == 0) &amp;&amp;
                    (((intf-&gt;ip.ip.v6.l[1] ^ addr-&gt;ip.v6.l[1]) &amp; intf-&gt;mask.ip.v6.l[1]) == 0) &amp;&amp;
                    (((intf-&gt;ip.ip.v6.l[2] ^ addr-&gt;ip.v6.l[2]) &amp; intf-&gt;mask.ip.v6.l[2]) == 0) &amp;&amp;
                    (((intf-&gt;ip.ip.v6.l[3] ^ addr-&gt;ip.v6.l[3]) &amp; intf-&gt;mask.ip.v6.l[3]) == 0))
                        <span class="enscript-keyword">return</span>(mDNStrue);
    }

    <span class="enscript-keyword">return</span>(mDNSfalse);
}

mDNSlocal NetworkInterfaceInfo *<span class="enscript-function-name">FirstInterfaceForID</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    NetworkInterfaceInfo *intf = m-&gt;HostInterfaces;
    <span class="enscript-keyword">while</span> (intf &amp;&amp; intf-&gt;InterfaceID != InterfaceID) intf = intf-&gt;next;
    <span class="enscript-keyword">return</span>(intf);
}

mDNSlocal NetworkInterfaceInfo *<span class="enscript-function-name">FirstIPv4LLInterfaceForID</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    NetworkInterfaceInfo *intf;

    <span class="enscript-keyword">if</span> (!InterfaceID)
        <span class="enscript-keyword">return</span> mDNSNULL;

    <span class="enscript-comment">// Note: We don't check for InterfaceActive, as the active interface could be IPv6 and 
</span>    <span class="enscript-comment">// we still want to find the first IPv4 Link-Local interface
</span>    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
    {
        <span class="enscript-keyword">if</span> (intf-&gt;InterfaceID == InterfaceID &amp;&amp;
            intf-&gt;ip.type == mDNSAddrType_IPv4 &amp;&amp; mDNSv4AddressIsLinkLocal(&amp;intf-&gt;ip.ip.v4))
        {
            debugf(<span class="enscript-string">&quot;FirstIPv4LLInterfaceForID: found LL interface with address %.4a&quot;</span>, &amp;intf-&gt;ip.ip.v4);
            <span class="enscript-keyword">return</span> intf;
        }
    }
    <span class="enscript-keyword">return</span> (mDNSNULL);
}

mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">InterfaceNameForID</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, InterfaceID);
    <span class="enscript-keyword">return</span>(intf ? intf-&gt;ifname : mDNSNULL);
}

<span class="enscript-comment">// Caller should hold the lock
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GenerateNegativeResponseEx</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID InterfaceID, QC_result qc, mDNSBool noData)
{
    DNSQuestion *q;
    <span class="enscript-keyword">if</span> (!m-&gt;CurrentQuestion) { LogMsg(<span class="enscript-string">&quot;GenerateNegativeResponse: ERROR!! CurrentQuestion not set&quot;</span>); <span class="enscript-keyword">return</span>; }
    q = m-&gt;CurrentQuestion;
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
           <span class="enscript-string">&quot;[R%d-&gt;Q%d] GenerateNegativeResponse: Generating negative response for question &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
           q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));

    MakeNegativeCacheRecord(m, &amp;m-&gt;rec.r, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;qtype, q-&gt;qclass, 60, InterfaceID, mDNSNULL);
    m-&gt;rec.r.resrec.negativeRecordType = noData ? kNegativeRecordType_NoData : kNegativeRecordType_Unspecified;

    <span class="enscript-comment">// We need to force the response through in the following cases
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">//  a) SuppressUnusable questions that are suppressed
</span>    <span class="enscript-comment">//  b) Append search domains and retry the question
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// The question may not have set Intermediates in which case we don't deliver negative responses. So, to force
</span>    <span class="enscript-comment">// through we use &quot;QC_forceresponse&quot;.
</span>    AnswerCurrentQuestionWithResourceRecord(m, &amp;m-&gt;rec.r, qc);
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q) { q-&gt;ThisQInterval = 0; }              <span class="enscript-comment">// Deactivate this question
</span>    <span class="enscript-comment">// Don't touch the question after this
</span>    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GenerateNegativeResponse</span>(M, INTERFACE_ID, QC) GenerateNegativeResponseEx(M, INTERFACE_ID, QC, mDNSfalse)

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerQuestionByFollowingCNAME</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, ResourceRecord *rr)
{
    <span class="enscript-type">const</span> mDNSBool selfref = SameDomainName(&amp;q-&gt;qname, &amp;rr-&gt;rdata-&gt;u.name);
    <span class="enscript-keyword">if</span> (q-&gt;CNAMEReferrals &gt;= 10 || selfref)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerQuestionByFollowingCNAME: %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)  NOT following CNAME referral %d&quot;</span> PUB_S <span class="enscript-string">&quot; for &quot;</span> PRI_S,
               q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype),
               q-&gt;CNAMEReferrals, selfref ? <span class="enscript-string">&quot; (Self-Referential)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, RRDisplayString(m, rr));

    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">const</span> mDNSu32 c = q-&gt;CNAMEReferrals + 1;        <span class="enscript-comment">// Stash a copy of the new q-&gt;CNAMEReferrals value
</span>        UDPSocket *sock = q-&gt;LocalSocket;
        mDNSOpaque16 id = q-&gt;TargetQID;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
        uDNSMetrics metrics;
#<span class="enscript-reference">endif</span>

        q-&gt;LocalSocket = mDNSNULL;

        <span class="enscript-comment">// The SameDomainName check above is to ignore bogus CNAME records that point right back at
</span>        <span class="enscript-comment">// themselves. Without that check we can get into a case where we have two duplicate questions,
</span>        <span class="enscript-comment">// A and B, and when we stop question A, UpdateQuestionDuplicates copies the value of CNAMEReferrals
</span>        <span class="enscript-comment">// from A to B, and then A is re-appended to the end of the list as a duplicate of B (because
</span>        <span class="enscript-comment">// the target name is still the same), and then when we stop question B, UpdateQuestionDuplicates
</span>        <span class="enscript-comment">// copies the B's value of CNAMEReferrals back to A, and we end up not incrementing CNAMEReferrals
</span>        <span class="enscript-comment">// for either of them. This is not a problem for CNAME loops of two or more records because in
</span>        <span class="enscript-comment">// those cases the newly re-appended question A has a different target name and therefore cannot be
</span>        <span class="enscript-comment">// a duplicate of any other question ('B') which was itself a duplicate of the previous question A.
</span>
        <span class="enscript-comment">// Right now we just stop and re-use the existing query. If we really wanted to be 100% perfect,
</span>        <span class="enscript-comment">// and track CNAMEs coming and going, we should really create a subordinate query here,
</span>        <span class="enscript-comment">// which we would subsequently cancel and retract if the CNAME referral record were removed.
</span>        <span class="enscript-comment">// In reality this is such a corner case we'll ignore it until someone actually needs it.
</span>
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerQuestionByFollowingCNAME: %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) following CNAME referral %d for &quot;</span> PRI_S,
               q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype),
               q-&gt;CNAMEReferrals, RRDisplayString(m, rr));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
        <span class="enscript-keyword">if</span> ((q-&gt;CNAMEReferrals == 0) &amp;&amp; !q-&gt;metrics.originalQName)
        {
            domainname *    qName;
            mDNSu16         qNameLen;

            qNameLen = DomainNameLength(&amp;q-&gt;qname);
            <span class="enscript-keyword">if</span> ((qNameLen &gt; 0) &amp;&amp; (qNameLen &lt;= MAX_DOMAIN_NAME))
            {
                qName = (domainname *) mDNSPlatformMemAllocate(qNameLen);
                <span class="enscript-keyword">if</span> (qName)
                {
                    mDNSPlatformMemCopy(qName-&gt;c, q-&gt;qname.c, qNameLen);
                    q-&gt;metrics.originalQName = qName;
                }
            }
        }
        metrics = q-&gt;metrics;
        mDNSPlatformMemZero(&amp;q-&gt;metrics, <span class="enscript-keyword">sizeof</span>(q-&gt;metrics));
#<span class="enscript-reference">endif</span>
        mDNS_StopQuery_internal(m, q);                              <span class="enscript-comment">// Stop old query
</span>        AssignDomainName(&amp;q-&gt;qname, &amp;rr-&gt;rdata-&gt;u.name);            <span class="enscript-comment">// Update qname
</span>        q-&gt;qnamehash = DomainNameHashValue(&amp;q-&gt;qname);              <span class="enscript-comment">// and namehash
</span>        <span class="enscript-comment">// If a unicast query results in a CNAME that points to a .local, we need to re-try
</span>        <span class="enscript-comment">// this as unicast. Setting the mDNSInterface_Unicast tells mDNS_StartQuery_internal
</span>        <span class="enscript-comment">// to try this as unicast query even though it is a .local name
</span>        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; IsLocalDomain(&amp;q-&gt;qname))
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                   <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerQuestionByFollowingCNAME: Resolving a .local CNAME %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) Record &quot;</span> PRI_S,
                   q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), RRDisplayString(m, rr));
            q-&gt;IsUnicastDotLocal = mDNStrue;
        }
        mDNS_StartQuery_internal(m, q);                             <span class="enscript-comment">// start new query
</span>        <span class="enscript-comment">// Record how many times we've done this. We need to do this *after* mDNS_StartQuery_internal,
</span>        <span class="enscript-comment">// because mDNS_StartQuery_internal re-initializes CNAMEReferrals to zero
</span>        q-&gt;CNAMEReferrals = c;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
        metrics.expiredAnswerState  = q-&gt;metrics.expiredAnswerState; <span class="enscript-comment">//  We want the newly initialized state for this value
</span>        metrics.dnsOverTCPState     = q-&gt;metrics.dnsOverTCPState;    <span class="enscript-comment">//  We want the newly initialized state for this value
</span>        q-&gt;metrics = metrics;
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (sock)
        {
            <span class="enscript-comment">// If our new query is a duplicate, then it can't have a socket of its own, so we have to close the one we saved.
</span>            <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf) mDNSPlatformUDPClose(sock);
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Transplant the old socket into the new question, and copy the query ID across too.
</span>                <span class="enscript-comment">// No need to close the old q-&gt;LocalSocket value because it won't have been created yet (they're made lazily on-demand).
</span>                q-&gt;LocalSocket = sock;
                q-&gt;TargetQID = id;
            }
        }
    }
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_LIBIDN</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unicode/uidna.h&gt;</span>

<span class="enscript-comment">// #define DEBUG_PUNYCODE 1
</span>
mDNSlocal mDNSu8 *<span class="enscript-function-name">PunycodeConvert</span>(<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> src, mDNSu8 *<span class="enscript-type">const</span> dst, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    UErrorCode errorCode = U_ZERO_ERROR;
    UIDNAInfo info = UIDNA_INFO_INITIALIZER;
    UIDNA *uts46 = uidna_openUTS46(UIDNA_USE_STD3_RULES|UIDNA_NONTRANSITIONAL_TO_UNICODE, &amp;errorCode);
    int32_t len = uidna_nameToASCII_UTF8(uts46, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)src+1, src[0], (<span class="enscript-type">char</span> *)dst+1, end-(dst+1), &amp;info, &amp;errorCode);
    uidna_close(uts46);
    #<span class="enscript-keyword">if</span> DEBUG_PUNYCODE
    <span class="enscript-keyword">if</span> (errorCode) LogMsg(<span class="enscript-string">&quot;uidna_nameToASCII_UTF8(%##s) failed errorCode %d&quot;</span>, src, errorCode);
    <span class="enscript-keyword">if</span> (info.errors) LogMsg(<span class="enscript-string">&quot;uidna_nameToASCII_UTF8(%##s) failed info.errors 0x%08X&quot;</span>, src, info.errors);
    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL) LogMsg(<span class="enscript-string">&quot;uidna_nameToASCII_UTF8(%##s) result too long %d&quot;</span>, src, len);
    #endif
    <span class="enscript-keyword">if</span> (errorCode || info.errors || len &gt; MAX_DOMAIN_LABEL) <span class="enscript-keyword">return</span> mDNSNULL;
    *dst = len;
    <span class="enscript-keyword">return</span>(dst + 1 + len);
}

mDNSlocal mDNSBool <span class="enscript-function-name">IsHighASCIILabel</span>(<span class="enscript-type">const</span> mDNSu8 *d)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=1; i&lt;=d[0]; i++) <span class="enscript-keyword">if</span> (d[i] &amp; 0x80) <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">FindLastHighASCIILabel</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = d-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *ans = mDNSNULL;
    <span class="enscript-keyword">while</span> (ptr[0])
    {
        <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> next = ptr + 1 + ptr[0];
        <span class="enscript-keyword">if</span> (ptr[0] &gt; MAX_DOMAIN_LABEL || next &gt;= d-&gt;c + MAX_DOMAIN_NAME) <span class="enscript-keyword">return</span> mDNSNULL;
        <span class="enscript-keyword">if</span> (IsHighASCIILabel(ptr)) ans = ptr;
        ptr = next;
    }
    <span class="enscript-keyword">return</span> ans;
}

mDNSlocal mDNSBool <span class="enscript-function-name">PerformNextPunycodeConversion</span>(<span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, domainname *<span class="enscript-type">const</span> newname)
{
    <span class="enscript-type">const</span> mDNSu8 *h = FindLastHighASCIILabel(&amp;q-&gt;qname);
    #<span class="enscript-keyword">if</span> DEBUG_PUNYCODE
    LogMsg(<span class="enscript-string">&quot;PerformNextPunycodeConversion: %##s (%s) Last High-ASCII Label %##s&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), h);
    #endif
    <span class="enscript-keyword">if</span> (!h) <span class="enscript-keyword">return</span> mDNSfalse;  <span class="enscript-comment">// There are no high-ascii labels to convert
</span>
    mDNSu8 *<span class="enscript-type">const</span> dst = PunycodeConvert(h, newname-&gt;c + (h - q-&gt;qname.c), newname-&gt;c + MAX_DOMAIN_NAME);
    <span class="enscript-keyword">if</span> (!dst)
        <span class="enscript-keyword">return</span> mDNSfalse;  <span class="enscript-comment">// The label was not convertible to Punycode
</span>    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// If Punycode conversion of final eligible label was successful, copy the rest of the domainname
</span>        <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> src = h + 1 + h[0];
        <span class="enscript-type">const</span> mDNSu8 remainder  = DomainNameLength((domainname*)src);
        <span class="enscript-keyword">if</span> (dst + remainder &gt; newname-&gt;c + MAX_DOMAIN_NAME) <span class="enscript-keyword">return</span> mDNSfalse;  <span class="enscript-comment">// Name too long -- cannot be converted to Punycode
</span>
        mDNSPlatformMemCopy(newname-&gt;c, q-&gt;qname.c, h - q-&gt;qname.c);  <span class="enscript-comment">// Fill in the leading part
</span>        mDNSPlatformMemCopy(dst, src, remainder);                     <span class="enscript-comment">// Fill in the trailing part
</span>        #<span class="enscript-keyword">if</span> DEBUG_PUNYCODE
        LogMsg(<span class="enscript-string">&quot;PerformNextPunycodeConversion: %##s converted to %##s&quot;</span>, q-&gt;qname.c, newname-&gt;c);
        #endif
        <span class="enscript-keyword">return</span> mDNStrue;
    }
}

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">USE_LIBIDN</span>

<span class="enscript-comment">// For a single given DNSQuestion pointed to by CurrentQuestion, deliver an add/remove result for the single given AuthRecord
</span><span class="enscript-comment">// Note: All the callers should use the m-&gt;CurrentQuestion to see if the question is still valid or not
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerLocalQuestionWithLocalAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, QC_result AddRecord)
{
    DNSQuestion *q = m-&gt;CurrentQuestion;
    mDNSBool followcname;

    <span class="enscript-keyword">if</span> (!q)
    {
        LogMsg(<span class="enscript-string">&quot;AnswerLocalQuestionWithLocalAuthRecord: ERROR!! CurrentQuestion NULL while answering with %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

    followcname = FollowCNAME(q, &amp;rr-&gt;resrec, AddRecord);

    <span class="enscript-comment">// We should not be delivering results for record types Unregistered, Deregistering, and (unverified) Unique
</span>    <span class="enscript-keyword">if</span> (!(rr-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveMask))
    {
        LogMsg(<span class="enscript-string">&quot;AnswerLocalQuestionWithLocalAuthRecord: *NOT* delivering %s event for local record type %X %s&quot;</span>,
               AddRecord ? <span class="enscript-string">&quot;Add&quot;</span> : <span class="enscript-string">&quot;Rmv&quot;</span>, rr-&gt;resrec.RecordType, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Indicate that we've given at least one positive answer for this record, so we should be prepared to send a goodbye for it
</span>    <span class="enscript-keyword">if</span> (AddRecord) rr-&gt;AnsweredLocalQ = mDNStrue;
    mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>    <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback &amp;&amp; !q-&gt;NoAnswer)
    {
        q-&gt;CurrentAnswers += AddRecord ? 1 : -1;
        <span class="enscript-keyword">if</span> (UniqueLocalOnlyRecord(rr))
        {
            <span class="enscript-keyword">if</span> (!followcname || q-&gt;ReturnIntermed)
            {
                <span class="enscript-comment">// Don't send this packet on the wire as we answered from /etc/hosts
</span>                q-&gt;ThisQInterval = 0;
                q-&gt;LOAddressAnswers += AddRecord ? 1 : -1;
                q-&gt;QuestionCallback(m, q, &amp;rr-&gt;resrec, AddRecord);
            }
            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>            <span class="enscript-comment">// The callback above could have caused the question to stop. Detect that
</span>            <span class="enscript-comment">// using m-&gt;CurrentQuestion
</span>            <span class="enscript-keyword">if</span> (followcname &amp;&amp; m-&gt;CurrentQuestion == q)
                AnswerQuestionByFollowingCNAME(m, q, &amp;rr-&gt;resrec);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span>
        {
            q-&gt;QuestionCallback(m, q, &amp;rr-&gt;resrec, AddRecord);
        }
    }
    mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerInterfaceAnyQuestionsWithLocalAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *ar, QC_result AddRecord)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;AnswerInterfaceAnyQuestionsWithLocalAuthRecord: ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
    {
        mDNSBool answered;
        DNSQuestion *q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (RRAny(ar))
            answered = AuthRecordAnswersQuestion(ar, q);
        <span class="enscript-keyword">else</span>
            answered = LocalOnlyRecordAnswersQuestion(ar, q);
        <span class="enscript-keyword">if</span> (answered)
            AnswerLocalQuestionWithLocalAuthRecord(m, ar, AddRecord);       <span class="enscript-comment">// MUST NOT dereference q again
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

<span class="enscript-comment">// When a new local AuthRecord is created or deleted, AnswerAllLocalQuestionsWithLocalAuthRecord()
</span><span class="enscript-comment">// delivers the appropriate add/remove events to listening questions:
</span><span class="enscript-comment">// 1. It runs though all our LocalOnlyQuestions delivering answers as appropriate,
</span><span class="enscript-comment">//    stopping if it reaches a NewLocalOnlyQuestion -- brand-new questions are handled by AnswerNewLocalOnlyQuestion().
</span><span class="enscript-comment">// 2. If the AuthRecord is marked mDNSInterface_LocalOnly or mDNSInterface_P2P, then it also runs though
</span><span class="enscript-comment">//    our main question list, delivering answers to mDNSInterface_Any questions as appropriate,
</span><span class="enscript-comment">//    stopping if it reaches a NewQuestion -- brand-new questions are handled by AnswerNewQuestion().
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// AnswerAllLocalQuestionsWithLocalAuthRecord is used by the m-&gt;NewLocalRecords loop in mDNS_Execute(),
</span><span class="enscript-comment">// and by mDNS_Deregister_internal()
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerAllLocalQuestionsWithLocalAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *ar, QC_result AddRecord)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;AnswerAllLocalQuestionsWithLocalAuthRecord ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));

    m-&gt;CurrentQuestion = m-&gt;LocalOnlyQuestions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewLocalOnlyQuestions)
    {
        mDNSBool answered;
        DNSQuestion *q = m-&gt;CurrentQuestion;
        <span class="enscript-comment">// We are called with both LocalOnly/P2P record or a regular AuthRecord
</span>        <span class="enscript-keyword">if</span> (RRAny(ar))
            answered = AuthRecordAnswersQuestion(ar, q);
        <span class="enscript-keyword">else</span>
            answered = LocalOnlyRecordAnswersQuestion(ar, q);
        <span class="enscript-keyword">if</span> (answered)
            AnswerLocalQuestionWithLocalAuthRecord(m, ar, AddRecord);           <span class="enscript-comment">// MUST NOT dereference q again
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentQuestion = q-&gt;next;
    }

    m-&gt;CurrentQuestion = mDNSNULL;

    <span class="enscript-comment">// If this AuthRecord is marked LocalOnly or P2P, then we want to deliver it to all local 'mDNSInterface_Any' questions
</span>    <span class="enscript-keyword">if</span> (ar-&gt;ARType == AuthRecordLocalOnly || ar-&gt;ARType == AuthRecordP2P)
        AnswerInterfaceAnyQuestionsWithLocalAuthRecord(m, ar, AddRecord);

}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Resource</span> <span class="enscript-variable-name">Record</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRTypeIsAddressType</span>(T) ((T) == kDNSType_A || (T) == kDNSType_AAAA)

mDNSlocal mDNSBool <span class="enscript-function-name">ResourceRecordIsValidAnswer</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">if</span> ((rr-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveMask) &amp;&amp;
        ((rr-&gt;Additional1 == mDNSNULL) || (rr-&gt;Additional1-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveMask)) &amp;&amp;
        ((rr-&gt;Additional2 == mDNSNULL) || (rr-&gt;Additional2-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveMask)) &amp;&amp;
        ((rr-&gt;DependentOn == mDNSNULL) || (rr-&gt;DependentOn-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveMask)))
    {
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">IsInterfaceValidForAuthRecord</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == mDNSInterface_Any)
    {
        <span class="enscript-keyword">return</span> mDNSPlatformValidRecordForInterface(rr, InterfaceID);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span> ((rr-&gt;resrec.InterfaceID == InterfaceID) ? mDNStrue : mDNSfalse);
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">ResourceRecordIsValidInterfaceAnswer</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> mDNSInterfaceID interfaceID)
{
    <span class="enscript-keyword">return</span> ((IsInterfaceValidForAuthRecord(rr, interfaceID) &amp;&amp; ResourceRecordIsValidAnswer(rr)) ? mDNStrue : mDNSfalse);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DefaultProbeCountForTypeUnique</span> ((mDNSu8)3)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DefaultProbeCountForRecordType</span>(X)      ((X) == kDNSRecordTypeUnique ? DefaultProbeCountForTypeUnique : (mDNSu8)0)

<span class="enscript-comment">// Parameters for handling probing conflicts
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMaxAllowedMCastProbingConflicts</span> 1                     // Maximum number of conflicts to allow from mcast messages.
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kProbingConflictPauseDuration</span>    mDNSPlatformOneSecond // Duration of probing pause after an allowed mcast conflict.

<span class="enscript-comment">// See RFC 6762: &quot;8.3 Announcing&quot;
</span><span class="enscript-comment">// &quot;The Multicast DNS responder MUST send at least two unsolicited responses, one second apart.&quot;
</span><span class="enscript-comment">// Send 4, which is really 8 since we send on both IPv4 and IPv6.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">InitialAnnounceCount</span> ((mDNSu8)4)

<span class="enscript-comment">// For goodbye packets we set the count to 3, and for wakeups we set it to 18
</span><span class="enscript-comment">// (which will be up to 15 wakeup attempts over the course of 30 seconds,
</span><span class="enscript-comment">// and then if the machine fails to wake, 3 goodbye packets).
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GoodbyeCount</span> ((mDNSu8)3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WakeupCount</span> ((mDNSu8)18)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_PROBE_RESTARTS</span> ((mDNSu8)20)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_GHOST_TIME</span> ((mDNSs32)((60*60*24*7)*mDNSPlatformOneSecond))  //  One week

<span class="enscript-comment">// Number of wakeups we send if WakeOnResolve is set in the question
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">InitialWakeOnResolveCount</span> ((mDNSu8)3)

<span class="enscript-comment">// Note that the announce intervals use exponential backoff, doubling each time. The probe intervals do not.
</span><span class="enscript-comment">// This means that because the announce interval is doubled after sending the first packet, the first
</span><span class="enscript-comment">// observed on-the-wire inter-packet interval between announcements is actually one second.
</span><span class="enscript-comment">// The half-second value here may be thought of as a conceptual (non-existent) half-second delay *before* the first packet is sent.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DefaultProbeIntervalForTypeUnique</span> (mDNSPlatformOneSecond/4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DefaultAnnounceIntervalForTypeShared</span> (mDNSPlatformOneSecond/2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DefaultAnnounceIntervalForTypeUnique</span> (mDNSPlatformOneSecond/2)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DefaultAPIntervalForRecordType</span>(X)  ((X) &amp;kDNSRecordTypeActiveSharedMask ? DefaultAnnounceIntervalForTypeShared : \
                                            (X) &amp;kDNSRecordTypeUnique           ? DefaultProbeIntervalForTypeUnique    : \
                                            (X) &amp;kDNSRecordTypeActiveUniqueMask ? DefaultAnnounceIntervalForTypeUnique : 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TimeToAnnounceThisRecord</span>(RR,time) ((RR)-&gt;AnnounceCount &amp;&amp; (time) - ((RR)-&gt;LastAPTime + (RR)-&gt;ThisAPInterval) &gt;= 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TicksTTL</span>(RR) ((mDNSs32)(RR)-&gt;resrec.rroriginalttl * mDNSPlatformOneSecond)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRExpireTime</span>(RR) ((RR)-&gt;TimeRcvd + TicksTTL(RR))

<span class="enscript-comment">// Adjustment factor to avoid race condition (used for unicast cache entries) :
</span><span class="enscript-comment">// Suppose real record has TTL of 3600, and our local caching server has held it for 3500 seconds, so it returns an aged TTL of 100.
</span><span class="enscript-comment">// If we do our normal refresh at 80% of the TTL, our local caching server will return 20 seconds, so we'll do another
</span><span class="enscript-comment">// 80% refresh after 16 seconds, and then the server will return 4 seconds, and so on, in the fashion of Zeno's paradox.
</span><span class="enscript-comment">// To avoid this, we extend the record's effective TTL to give it a little extra grace period.
</span><span class="enscript-comment">// We adjust the 100 second TTL to 127. This means that when we do our 80% query after 102 seconds,
</span><span class="enscript-comment">// the cached copy at our local caching server will already have expired, so the server will be forced
</span><span class="enscript-comment">// to fetch a fresh copy from the authoritative server, and then return a fresh record with the full TTL of 3600 seconds.
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRAdjustTTL</span>(ttl) ((ttl) + ((ttl)/4) + 2)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRUnadjustedTTL</span>(ttl) ((((ttl) - 2) * 4) / 5)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MaxUnansweredQueries</span> 4

<span class="enscript-comment">// SameResourceRecordSignature returns true if two resources records have the same name, type, and class, and may be sent
</span><span class="enscript-comment">// (or were received) on the same interface (i.e. if *both* records specify an interface, then it has to match).
</span><span class="enscript-comment">// TTL and rdata may differ.
</span><span class="enscript-comment">// This is used for cache flush management:
</span><span class="enscript-comment">// When sending a unique record, all other records matching &quot;SameResourceRecordSignature&quot; must also be sent
</span><span class="enscript-comment">// When receiving a unique record, all old cache records matching &quot;SameResourceRecordSignature&quot; are flushed
</span>
<span class="enscript-comment">// SameResourceRecordNameClassInterface is functionally the same as SameResourceRecordSignature, except rrtype does not have to match
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SameResourceRecordSignature</span>(A,B) (A)-&gt;resrec.rrtype == (B)-&gt;resrec.rrtype &amp;&amp; SameResourceRecordNameClassInterface((A),(B))

mDNSlocal mDNSBool <span class="enscript-function-name">SameResourceRecordNameClassInterface</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> r1, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> r2)
{
    <span class="enscript-keyword">if</span> (!r1) { LogMsg(<span class="enscript-string">&quot;SameResourceRecordSignature ERROR: r1 is NULL&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (!r2) { LogMsg(<span class="enscript-string">&quot;SameResourceRecordSignature ERROR: r2 is NULL&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (r1-&gt;resrec.InterfaceID &amp;&amp;
        r2-&gt;resrec.InterfaceID &amp;&amp;
        r1-&gt;resrec.InterfaceID != r2-&gt;resrec.InterfaceID) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">return</span> (mDNSBool)(
               r1-&gt;resrec.rrclass  == r2-&gt;resrec.rrclass &amp;&amp;
               r1-&gt;resrec.namehash == r2-&gt;resrec.namehash &amp;&amp;
               SameDomainName(r1-&gt;resrec.name, r2-&gt;resrec.name));
}

<span class="enscript-comment">// PacketRRMatchesSignature behaves as SameResourceRecordSignature, except that types may differ if our
</span><span class="enscript-comment">// authoratative record is unique (as opposed to shared). For unique records, we are supposed to have
</span><span class="enscript-comment">// complete ownership of *all* types for this name, so *any* record type with the same name is a conflict.
</span><span class="enscript-comment">// In addition, when probing we send our questions with the wildcard type kDNSQType_ANY,
</span><span class="enscript-comment">// so a response of any type should match, even if it is not actually the type the client plans to use.
</span>
<span class="enscript-comment">// For now, to make it easier to avoid false conflicts, we treat SPS Proxy records like shared records,
</span><span class="enscript-comment">// and require the rrtypes to match for the rdata to be considered potentially conflicting
</span>mDNSlocal mDNSBool <span class="enscript-function-name">PacketRRMatchesSignature</span>(<span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pktrr, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> authrr)
{
    <span class="enscript-keyword">if</span> (!pktrr)  { LogMsg(<span class="enscript-string">&quot;PacketRRMatchesSignature ERROR: pktrr is NULL&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (!authrr) { LogMsg(<span class="enscript-string">&quot;PacketRRMatchesSignature ERROR: authrr is NULL&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (pktrr-&gt;resrec.InterfaceID &amp;&amp;
        authrr-&gt;resrec.InterfaceID &amp;&amp;
        pktrr-&gt;resrec.InterfaceID != authrr-&gt;resrec.InterfaceID) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">if</span> (!(authrr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) || authrr-&gt;WakeUp.HMAC.l[0])
        <span class="enscript-keyword">if</span> (pktrr-&gt;resrec.rrtype != authrr-&gt;resrec.rrtype) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">if</span> ((authrr-&gt;resrec.InterfaceID == mDNSInterface_Any) &amp;&amp;
        !mDNSPlatformValidRecordForInterface(authrr, pktrr-&gt;resrec.InterfaceID)) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">return</span> (mDNSBool)(
               pktrr-&gt;resrec.rrclass == authrr-&gt;resrec.rrclass &amp;&amp;
               pktrr-&gt;resrec.namehash == authrr-&gt;resrec.namehash &amp;&amp;
               SameDomainName(pktrr-&gt;resrec.name, authrr-&gt;resrec.name));
}

<span class="enscript-comment">// CacheRecord *ka is the CacheRecord from the known answer list in the query.
</span><span class="enscript-comment">// This is the information that the requester believes to be correct.
</span><span class="enscript-comment">// AuthRecord *rr is the answer we are proposing to give, if not suppressed.
</span><span class="enscript-comment">// This is the information that we believe to be correct.
</span><span class="enscript-comment">// We've already determined that we plan to give this answer on this interface
</span><span class="enscript-comment">// (either the record is non-specific, or it is specific to this interface)
</span><span class="enscript-comment">// so now we just need to check the name, type, class, rdata and TTL.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">ShouldSuppressKnownAnswer</span>(<span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> ka, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-comment">// If RR signature is different, or data is different, then don't suppress our answer
</span>    <span class="enscript-keyword">if</span> (!IdenticalResourceRecord(&amp;ka-&gt;resrec, &amp;rr-&gt;resrec)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// If the requester's indicated TTL is less than half the real TTL,
</span>    <span class="enscript-comment">// we need to give our answer before the requester's copy expires.
</span>    <span class="enscript-comment">// If the requester's indicated TTL is at least half the real TTL,
</span>    <span class="enscript-comment">// then we can suppress our answer this time.
</span>    <span class="enscript-comment">// If the requester's indicated TTL is greater than the TTL we believe,
</span>    <span class="enscript-comment">// then that's okay, and we don't need to do anything about it.
</span>    <span class="enscript-comment">// (If two responders on the network are offering the same information,
</span>    <span class="enscript-comment">// that's okay, and if they are offering the information with different TTLs,
</span>    <span class="enscript-comment">// the one offering the lower TTL should defer to the one offering the higher TTL.)
</span>    <span class="enscript-keyword">return</span> (mDNSBool)(ka-&gt;resrec.rroriginalttl &gt;= rr-&gt;resrec.rroriginalttl / 2);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetNextAnnounceProbeTime</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique)
    {
        <span class="enscript-keyword">if</span> ((rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) - m-&gt;timenow &gt; mDNSPlatformOneSecond * 10)
        {
            LogMsg(<span class="enscript-string">&quot;SetNextAnnounceProbeTime: ProbeCount %d Next in %d %s&quot;</span>, rr-&gt;ProbeCount, (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) - m-&gt;timenow, ARDisplayString(m, rr));
            LogMsg(<span class="enscript-string">&quot;SetNextAnnounceProbeTime: m-&gt;SuppressProbes %d m-&gt;timenow %d diff %d&quot;</span>, m-&gt;SuppressProbes, m-&gt;timenow, m-&gt;SuppressProbes - m-&gt;timenow);
        }
        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledProbe - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
            m-&gt;NextScheduledProbe = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);
        <span class="enscript-comment">// Some defensive code:
</span>        <span class="enscript-comment">// If (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) happens to be far in the past, we don't want to allow
</span>        <span class="enscript-comment">// NextScheduledProbe to be set excessively in the past, because that can cause bad things to happen.
</span>        <span class="enscript-comment">// See: &lt;rdar://problem/7795434&gt; mDNS: Sometimes advertising stops working and record interval is set to zero
</span>        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledProbe - m-&gt;timenow &lt; 0)
            m-&gt;NextScheduledProbe = m-&gt;timenow;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount &amp;&amp; (ResourceRecordIsValidAnswer(rr) || rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering))
    {
        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledResponse - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
            m-&gt;NextScheduledResponse = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitializeLastAPTime</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-comment">// For reverse-mapping Sleep Proxy PTR records, probe interval is one second
</span>    rr-&gt;ThisAPInterval = rr-&gt;AddressProxy.type ? mDNSPlatformOneSecond : DefaultAPIntervalForRecordType(rr-&gt;resrec.RecordType);

    <span class="enscript-comment">// * If this is a record type that's going to probe, then we use the m-&gt;SuppressProbes time.
</span>    <span class="enscript-comment">// * Otherwise, if it's not going to probe, but m-&gt;SuppressProbes is set because we have other
</span>    <span class="enscript-comment">//   records that are going to probe, then we delay its first announcement so that it will
</span>    <span class="enscript-comment">//   go out synchronized with the first announcement for the other records that *are* probing.
</span>    <span class="enscript-comment">//   This is a minor performance tweak that helps keep groups of related records synchronized together.
</span>    <span class="enscript-comment">//   The addition of &quot;interval / 2&quot; is to make sure that, in the event that any of the probes are
</span>    <span class="enscript-comment">//   delayed by a few milliseconds, this announcement does not inadvertently go out *before* the probing is complete.
</span>    <span class="enscript-comment">//   When the probing is complete and those records begin to announce, these records will also be picked up and accelerated,
</span>    <span class="enscript-comment">//   because they will meet the criterion of being at least half-way to their scheduled announcement time.
</span>    <span class="enscript-comment">// * If it's not going to probe and m-&gt;SuppressProbes is not already set then we should announce immediately.
</span>
    <span class="enscript-keyword">if</span> (rr-&gt;ProbeCount)
    {
        rr-&gt;ProbingConflictCount = 0;
        <span class="enscript-comment">// If we have no probe suppression time set, or it is in the past, set it now
</span>        <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes == 0 || m-&gt;SuppressProbes - m-&gt;timenow &lt; 0)
        {
            <span class="enscript-comment">// To allow us to aggregate probes when a group of services are registered together,
</span>            <span class="enscript-comment">// the first probe is delayed by a random delay in the range 1/8 to 1/4 second.
</span>            <span class="enscript-comment">// This means the common-case behaviour is:
</span>            <span class="enscript-comment">// randomized wait; probe
</span>            <span class="enscript-comment">// 1/4 second wait; probe
</span>            <span class="enscript-comment">// 1/4 second wait; probe
</span>            <span class="enscript-comment">// 1/4 second wait; announce (i.e. service is normally announced 7/8 to 1 second after being registered)
</span>            m-&gt;SuppressProbes = NonZeroTime(m-&gt;timenow + DefaultProbeIntervalForTypeUnique/2 + mDNSRandom(DefaultProbeIntervalForTypeUnique/2));

            <span class="enscript-comment">// If we already have a *probe* scheduled to go out sooner, then use that time to get better aggregation
</span>            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes - m-&gt;NextScheduledProbe &gt;= 0)
                m-&gt;SuppressProbes = NonZeroTime(m-&gt;NextScheduledProbe);
            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes - m-&gt;timenow &lt; 0)     <span class="enscript-comment">// Make sure we don't set m-&gt;SuppressProbes excessively in the past
</span>                m-&gt;SuppressProbes = m-&gt;timenow;

            <span class="enscript-comment">// If we already have a *query* scheduled to go out sooner, then use that time to get better aggregation
</span>            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes - m-&gt;NextScheduledQuery &gt;= 0)
                m-&gt;SuppressProbes = NonZeroTime(m-&gt;NextScheduledQuery);
            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes - m-&gt;timenow &lt; 0)     <span class="enscript-comment">// Make sure we don't set m-&gt;SuppressProbes excessively in the past
</span>                m-&gt;SuppressProbes = m-&gt;timenow;

            <span class="enscript-comment">// except... don't expect to be able to send before the m-&gt;SuppressSending timer fires
</span>            <span class="enscript-keyword">if</span> (m-&gt;SuppressSending &amp;&amp; m-&gt;SuppressProbes - m-&gt;SuppressSending &lt; 0)
                m-&gt;SuppressProbes = NonZeroTime(m-&gt;SuppressSending);

            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes - m-&gt;timenow &gt; mDNSPlatformOneSecond * 8)
            {
                LogMsg(<span class="enscript-string">&quot;InitializeLastAPTime ERROR m-&gt;SuppressProbes %d m-&gt;NextScheduledProbe %d m-&gt;NextScheduledQuery %d m-&gt;SuppressSending %d %d&quot;</span>,
                       m-&gt;SuppressProbes     - m-&gt;timenow,
                       m-&gt;NextScheduledProbe - m-&gt;timenow,
                       m-&gt;NextScheduledQuery - m-&gt;timenow,
                       m-&gt;SuppressSending,
                       m-&gt;SuppressSending    - m-&gt;timenow);
                m-&gt;SuppressProbes = NonZeroTime(m-&gt;timenow + DefaultProbeIntervalForTypeUnique/2 + mDNSRandom(DefaultProbeIntervalForTypeUnique/2));
            }
        }
        rr-&gt;LastAPTime = m-&gt;SuppressProbes - rr-&gt;ThisAPInterval;
    }
    <span class="enscript-comment">// Skip kDNSRecordTypeKnownUnique and kDNSRecordTypeShared records here and set their LastAPTime in the &quot;else&quot; block below so 
</span>    <span class="enscript-comment">// that they get announced immediately, otherwise, their announcement would be delayed until the based on the SuppressProbes value.
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rr-&gt;resrec.RecordType != kDNSRecordTypeKnownUnique) &amp;&amp; (rr-&gt;resrec.RecordType != kDNSRecordTypeShared) &amp;&amp; m-&gt;SuppressProbes &amp;&amp; (m-&gt;SuppressProbes - m-&gt;timenow &gt;= 0))
        rr-&gt;LastAPTime = m-&gt;SuppressProbes - rr-&gt;ThisAPInterval + DefaultProbeIntervalForTypeUnique * DefaultProbeCountForTypeUnique + rr-&gt;ThisAPInterval / 2;
    <span class="enscript-keyword">else</span>
        rr-&gt;LastAPTime = m-&gt;timenow - rr-&gt;ThisAPInterval;

    <span class="enscript-comment">// For reverse-mapping Sleep Proxy PTR records we don't want to start probing instantly -- we
</span>    <span class="enscript-comment">// wait one second to give the client a chance to go to sleep, and then start our ARP/NDP probing.
</span>    <span class="enscript-comment">// After three probes one second apart with no answer, we conclude the client is now sleeping
</span>    <span class="enscript-comment">// and we can begin broadcasting our announcements to take over ownership of that IP address.
</span>    <span class="enscript-comment">// If we don't wait for the client to go to sleep, then when the client sees our ARP Announcements there's a risk
</span>    <span class="enscript-comment">// (depending on the OS and networking stack it's using) that it might interpret it as a conflict and change its IP address.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;AddressProxy.type)
        rr-&gt;LastAPTime = m-&gt;timenow;

    <span class="enscript-comment">// Set LastMCTime to now, to inhibit multicast responses
</span>    <span class="enscript-comment">// (no need to send additional multicast responses when we're announcing anyway)
</span>    rr-&gt;LastMCTime      = m-&gt;timenow;
    rr-&gt;LastMCInterface = mDNSInterfaceMark;

    SetNextAnnounceProbeTime(m, rr);
}

mDNSlocal <span class="enscript-type">const</span> domainname *<span class="enscript-function-name">SetUnicastTargetToHostName</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    <span class="enscript-type">const</span> domainname *target;
    <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget)
    {
        rr-&gt;AutoTarget = Target_AutoHostAndNATMAP;
    }

    target = GetServiceTarget(m, rr);
    <span class="enscript-keyword">if</span> (!target || target-&gt;c[0] == 0)
    {
        <span class="enscript-comment">// defer registration until we've got a target
</span>        LogInfo(<span class="enscript-string">&quot;SetUnicastTargetToHostName No target for %s&quot;</span>, ARDisplayString(m, rr));
        rr-&gt;state = regState_NoTarget;
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;SetUnicastTargetToHostName target %##s for resource record %s&quot;</span>, target-&gt;c, ARDisplayString(m,rr));
        <span class="enscript-keyword">return</span> target;
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSlocal mDNSBool <span class="enscript-function-name">AuthRecordIncludesOrIsAWDL</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> ar)
{
    <span class="enscript-keyword">return</span> ((AuthRecordIncludesAWDL(ar) || mDNSPlatformInterfaceIsAWDL(ar-&gt;resrec.InterfaceID)) ? mDNStrue : mDNSfalse);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Right now this only applies to mDNS (.local) services where the target host is always m-&gt;MulticastHostname
</span><span class="enscript-comment">// Eventually we should unify this with GetServiceTarget() in uDNS.c
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetTargetToHostName</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    domainname *<span class="enscript-type">const</span> target = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
    <span class="enscript-type">const</span> domainname *newname;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (AuthRecordIncludesOrIsAWDL(rr))
    {
        newname = &amp;m-&gt;RandomizedHostname;
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
        newname = &amp;m-&gt;MulticastHostname;
    }
    <span class="enscript-keyword">if</span> (!target) LogInfo(<span class="enscript-string">&quot;SetTargetToHostName: Don't know how to set the target of rrtype %s&quot;</span>, DNSTypeName(rr-&gt;resrec.rrtype));

    <span class="enscript-keyword">if</span> (!(rr-&gt;ForceMCast || rr-&gt;ARType == AuthRecordLocalOnly || rr-&gt;ARType == AuthRecordP2P || IsLocalDomain(&amp;rr-&gt;namestorage)))
    {
        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> n = SetUnicastTargetToHostName(m, rr);
        <span class="enscript-keyword">if</span> (n) newname = n;
        <span class="enscript-keyword">else</span> { <span class="enscript-keyword">if</span> (target) target-&gt;c[0] = 0; SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0); <span class="enscript-keyword">return</span>; }
    }

    <span class="enscript-keyword">if</span> (target &amp;&amp; SameDomainName(target, newname))
        debugf(<span class="enscript-string">&quot;SetTargetToHostName: Target of %##s is already %##s&quot;</span>, rr-&gt;resrec.name-&gt;c, target-&gt;c);

    <span class="enscript-keyword">if</span> (target &amp;&amp; !SameDomainName(target, newname))
    {
        AssignDomainName(target, newname);
        SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);      <span class="enscript-comment">// Update rdlength, rdestimate, rdatahash
</span>
        <span class="enscript-comment">// If we're in the middle of probing this record, we need to start again,
</span>        <span class="enscript-comment">// because changing its rdata may change the outcome of the tie-breaker.
</span>        <span class="enscript-comment">// (If the record type is kDNSRecordTypeUnique (unconfirmed unique) then DefaultProbeCountForRecordType is non-zero.)
</span>        rr-&gt;ProbeCount     = DefaultProbeCountForRecordType(rr-&gt;resrec.RecordType);

        <span class="enscript-comment">// If we've announced this record, we really should send a goodbye packet for the old rdata before
</span>        <span class="enscript-comment">// changing to the new rdata. However, in practice, we only do SetTargetToHostName for unique records,
</span>        <span class="enscript-comment">// so when we announce them we'll set the kDNSClass_UniqueRRSet and clear any stale data that way.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;RequireGoodbye &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeShared)
            debugf(<span class="enscript-string">&quot;Have announced shared record %##s (%s) at least once: should have sent a goodbye packet before updating&quot;</span>,
                   rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));

        rr-&gt;AnnounceCount  = InitialAnnounceCount;
        rr-&gt;RequireGoodbye = mDNSfalse;
        rr-&gt;ProbeRestartCount = 0;
        InitializeLastAPTime(m, rr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AcknowledgeRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">if</span> (rr-&gt;RecordCallback)
    {
        <span class="enscript-comment">// CAUTION: MUST NOT do anything more with rr after calling rr-&gt;Callback(), because the client's callback function
</span>        <span class="enscript-comment">// is allowed to do anything, including starting/stopping queries, registering/deregistering records, etc.
</span>        rr-&gt;Acknowledged = mDNStrue;
        mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>        rr-&gt;RecordCallback(m, rr, mStatus_NoError);
        mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ActivateUnicastRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-comment">// Make sure that we don't activate the SRV record and associated service records, if it is in
</span>    <span class="enscript-comment">// NoTarget state. First time when a service is being instantiated, SRV record may be in NoTarget state.
</span>    <span class="enscript-comment">// We should not activate any of the other reords (PTR, TXT) that are part of the service. When
</span>    <span class="enscript-comment">// the target becomes available, the records will be reregistered.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype != kDNSType_SRV)
    {
        AuthRecord *srvRR = mDNSNULL;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_PTR)
            srvRR = rr-&gt;Additional1;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_TXT)
            srvRR = rr-&gt;DependentOn;
        <span class="enscript-keyword">if</span> (srvRR)
        {
            <span class="enscript-keyword">if</span> (srvRR-&gt;resrec.rrtype != kDNSType_SRV)
            {
                LogMsg(<span class="enscript-string">&quot;ActivateUnicastRegistration: ERROR!! Resource record %s wrong, expecting SRV type&quot;</span>, ARDisplayString(m, srvRR));
            }
            <span class="enscript-keyword">else</span>
            {
                LogInfo(<span class="enscript-string">&quot;ActivateUnicastRegistration: Found Service Record %s in state %d for %##s (%s)&quot;</span>,
                        ARDisplayString(m, srvRR), srvRR-&gt;state, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
                rr-&gt;state = srvRR-&gt;state;
            }
        }
    }

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_NoTarget)
    {
        LogInfo(<span class="enscript-string">&quot;ActivateUnicastRegistration record %s in regState_NoTarget, not activating&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">// When we wake up from sleep, we call ActivateUnicastRegistration. It is possible that just before we went to sleep,
</span>    <span class="enscript-comment">// the service/record was being deregistered. In that case, we should not try to register again. For the cases where
</span>    <span class="enscript-comment">// the records are deregistered due to e.g., no target for the SRV record, we would have returned from above if it
</span>    <span class="enscript-comment">// was already in NoTarget state. If it was in the process of deregistration but did not complete fully before we went
</span>    <span class="enscript-comment">// to sleep, then it is okay to start in Pending state as we will go back to NoTarget state if we don't have a target.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
    {
        LogInfo(<span class="enscript-string">&quot;ActivateUnicastRegistration: Resource record %s, current state %d, moving to DeregPending&quot;</span>, ARDisplayString(m, rr), rr-&gt;state);
        rr-&gt;state = regState_DeregPending;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;ActivateUnicastRegistration: Resource record %s, current state %d, moving to Pending&quot;</span>, ARDisplayString(m, rr), rr-&gt;state);
        rr-&gt;state = regState_Pending;
    }
    rr-&gt;ProbingConflictCount = 0;
    rr-&gt;LastConflictPktNum   = 0;
    rr-&gt;ProbeRestartCount    = 0;
    rr-&gt;ProbeCount           = 0;
    rr-&gt;AnnounceCount        = 0;
    rr-&gt;ThisAPInterval       = INIT_RECORD_REG_INTERVAL;
    rr-&gt;LastAPTime           = m-&gt;timenow - rr-&gt;ThisAPInterval;
    rr-&gt;expire               = 0; <span class="enscript-comment">// Forget about all the leases, start fresh
</span>    rr-&gt;uselease             = mDNStrue;
    rr-&gt;updateid             = zeroID;
    rr-&gt;SRVChanged           = mDNSfalse;
    rr-&gt;updateError          = mStatus_NoError;
    <span class="enscript-comment">// RestartRecordGetZoneData calls this function whenever a new interface gets registered with core.
</span>    <span class="enscript-comment">// The records might already be registered with the server and hence could have NAT state.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext)
    {
        mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
        rr-&gt;NATinfo.clientContext = mDNSNULL;
    }
    <span class="enscript-keyword">if</span> (rr-&gt;nta) { CancelGetZoneData(m, rr-&gt;nta); rr-&gt;nta = mDNSNULL; }
    <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp);       rr-&gt;tcp = mDNSNULL; }
    <span class="enscript-keyword">if</span> (m-&gt;NextuDNSEvent - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
        m-&gt;NextuDNSEvent = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);
}

<span class="enscript-comment">// Two records qualify to be local duplicates if:
</span><span class="enscript-comment">// (a) the RecordTypes are the same, or
</span><span class="enscript-comment">// (b) one is Unique and the other Verified
</span><span class="enscript-comment">// (c) either is in the process of deregistering
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">RecordLDT</span>(A,B) ((A)-&gt;resrec.RecordType == (B)-&gt;resrec.RecordType || \
                        ((A)-&gt;resrec.RecordType | (B)-&gt;resrec.RecordType) == (kDNSRecordTypeUnique | kDNSRecordTypeVerified) || \
                        ((A)-&gt;resrec.RecordType == kDNSRecordTypeDeregistering || (B)-&gt;resrec.RecordType == kDNSRecordTypeDeregistering))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RecordIsLocalDuplicate</span>(A,B) \
    ((A)-&gt;resrec.InterfaceID == (B)-&gt;resrec.InterfaceID &amp;&amp; RecordLDT((A),(B)) &amp;&amp; IdenticalResourceRecord(&amp; (A)-&gt;resrec, &amp; (B)-&gt;resrec))

mDNSlocal AuthRecord *<span class="enscript-function-name">CheckAuthIdenticalRecord</span>(AuthHash *r, AuthRecord *rr)
{
    <span class="enscript-type">const</span> AuthGroup *a;
    AuthRecord *rp;

    a = AuthGroupForRecord(r, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!a) <span class="enscript-keyword">return</span> mDNSNULL;
    rp = a-&gt;members;
    <span class="enscript-keyword">while</span> (rp)
    {
        <span class="enscript-keyword">if</span> (!RecordIsLocalDuplicate(rp, rr))
            rp = rp-&gt;next;
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (rp-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
            {
                rp-&gt;AnnounceCount = 0;
                rp = rp-&gt;next;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> rp;
        }
    }
    <span class="enscript-keyword">return</span> (mDNSNULL);
}

mDNSlocal mDNSBool <span class="enscript-function-name">CheckAuthRecordConflict</span>(AuthHash *r, AuthRecord *rr)
{
    <span class="enscript-type">const</span> AuthGroup *a;
    <span class="enscript-type">const</span> AuthRecord *rp;

    a = AuthGroupForRecord(r, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!a) <span class="enscript-keyword">return</span> mDNSfalse;
    rp = a-&gt;members;
    <span class="enscript-keyword">while</span> (rp)
    {
        <span class="enscript-type">const</span> AuthRecord *s1 = rr-&gt;RRSet ? rr-&gt;RRSet : rr;
        <span class="enscript-type">const</span> AuthRecord *s2 = rp-&gt;RRSet ? rp-&gt;RRSet : rp;
        <span class="enscript-keyword">if</span> (s1 != s2 &amp;&amp; SameResourceRecordSignature(rp, rr) &amp;&amp; !IdenticalSameNameRecord(&amp;rp-&gt;resrec, &amp;rr-&gt;resrec))
            <span class="enscript-keyword">return</span> mDNStrue;
        <span class="enscript-keyword">else</span>
            rp = rp-&gt;next;
    }
    <span class="enscript-keyword">return</span> (mDNSfalse);
}

<span class="enscript-comment">// checks to see if &quot;rr&quot; is already present
</span>mDNSlocal AuthRecord *<span class="enscript-function-name">CheckAuthSameRecord</span>(AuthHash *r, AuthRecord *rr)
{
    <span class="enscript-type">const</span> AuthGroup *a;
    AuthRecord *rp;

    a = AuthGroupForRecord(r, &amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!a) <span class="enscript-keyword">return</span> mDNSNULL;
    rp = a-&gt;members;
    <span class="enscript-keyword">while</span> (rp)
    {
        <span class="enscript-keyword">if</span> (rp != rr)
            rp = rp-&gt;next;
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> rp;
        }
    }
    <span class="enscript-keyword">return</span> (mDNSNULL);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DecrementAutoTargetServices</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        <span class="enscript-comment">// A sanity check, this should be prevented in calling code.
</span>        LogInfo(<span class="enscript-string">&quot;DecrementAutoTargetServices: called for RRLocalOnly() record: %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; (rr-&gt;resrec.rrtype == kDNSType_SRV) &amp;&amp; (rr-&gt;AutoTarget == Target_AutoHost))
    {
        NetworkInterfaceInfo *intf;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        DeadvertiseFlags flags     = 0; <span class="enscript-comment">// DeadvertiseFlags for non-AWDL interfaces.
</span>        DeadvertiseFlags flagsAWDL = 0; <span class="enscript-comment">// DeadvertiseFlags for AWDL interfaces.
</span>        <span class="enscript-keyword">if</span> (AuthRecordIncludesOrIsAWDL(rr))
        {
            <span class="enscript-keyword">if</span> (AuthRecordIncludesAWDL(rr))
            {
                m-&gt;AutoTargetAWDLIncludedCount--;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                    <span class="enscript-string">&quot;DecrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record &quot;</span> PRI_S,
                    m-&gt;AutoTargetAWDLIncludedCount, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (m-&gt;AutoTargetAWDLIncludedCount == 0)
                {
                    flags |= kDeadvertiseFlag_RandHostname;
                    <span class="enscript-keyword">if</span> (m-&gt;AutoTargetAWDLOnlyCount == 0) flagsAWDL |= kDeadvertiseFlag_RandHostname;
                }
            }
            <span class="enscript-keyword">else</span>
            {
                m-&gt;AutoTargetAWDLOnlyCount--;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                    <span class="enscript-string">&quot;DecrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record &quot;</span> PRI_S,
                    m-&gt;AutoTargetAWDLOnlyCount, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> ((m-&gt;AutoTargetAWDLIncludedCount == 0) &amp;&amp; (m-&gt;AutoTargetAWDLOnlyCount == 0))
                {
                    flagsAWDL |= kDeadvertiseFlag_RandHostname;
                }
            }
            <span class="enscript-keyword">if</span> (flags || flagsAWDL)
            {
                <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
                {
                    <span class="enscript-keyword">if</span> (!intf-&gt;Advertise) <span class="enscript-keyword">continue</span>;
                    <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(intf-&gt;InterfaceID))
                    {
                        <span class="enscript-keyword">if</span> (flagsAWDL) DeadvertiseInterface(m, intf, flagsAWDL);
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        <span class="enscript-keyword">if</span> (flags) DeadvertiseInterface(m, intf, flags);
                    }
                }
            }
            <span class="enscript-keyword">if</span> ((m-&gt;AutoTargetAWDLIncludedCount == 0) &amp;&amp; (m-&gt;AutoTargetAWDLOnlyCount == 0))
            {
                GetRandomUUIDLocalHostname(&amp;m-&gt;RandomizedHostname);
            }
        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        {
            m-&gt;AutoTargetServices--;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;DecrementAutoTargetServices: AutoTargetServices %u Record &quot;</span> PRI_S,
                m-&gt;AutoTargetServices, ARDisplayString(m, rr));
            <span class="enscript-keyword">if</span> (m-&gt;AutoTargetServices == 0)
            {
                <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
                {
                    <span class="enscript-keyword">if</span> (intf-&gt;Advertise) DeadvertiseInterface(m, intf, kDeadvertiseFlag_NormalHostname);
                }
            }
        }
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))
    {
        <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceRecords + m-&gt;NumAllInterfaceQuestions == 1)
            m-&gt;NextBonjourDisableTime = NonZeroTime(m-&gt;timenow + (BONJOUR_DISABLE_DELAY * mDNSPlatformOneSecond));
        m-&gt;NumAllInterfaceRecords--;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;DecrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u &quot;</span> PRI_S,
            m-&gt;NumAllInterfaceRecords, m-&gt;NumAllInterfaceQuestions, ARDisplayString(m, rr));
    }
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseNecessaryInterfaceRecords</span>(mDNS *<span class="enscript-type">const</span> m)
{
    NetworkInterfaceInfo *intf;
    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
    {
        <span class="enscript-keyword">if</span> (intf-&gt;Advertise) AdvertiseInterfaceIfNeeded(m, intf);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">IncrementAutoTargetServices</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    mDNSBool enablingBonjour = mDNSfalse;

    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        <span class="enscript-comment">// A sanity check, this should be prevented in calling code.
</span>        LogInfo(<span class="enscript-string">&quot;IncrementAutoTargetServices: called for RRLocalOnly() record: %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))
    {
        m-&gt;NumAllInterfaceRecords++;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;IncrementAutoTargetServices: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u &quot;</span> PRI_S,
            m-&gt;NumAllInterfaceRecords, m-&gt;NumAllInterfaceQuestions, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceRecords + m-&gt;NumAllInterfaceQuestions == 1)
        {
            m-&gt;NextBonjourDisableTime = 0;
            <span class="enscript-keyword">if</span> (m-&gt;BonjourEnabled == 0)
            {
                <span class="enscript-comment">// Enable Bonjour immediately by scheduling network changed processing where
</span>                <span class="enscript-comment">// we will join the multicast group on each active interface.
</span>                m-&gt;BonjourEnabled = 1;
                enablingBonjour = mDNStrue;
                m-&gt;NetworkChanged = m-&gt;timenow;
            }
        }
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; (rr-&gt;resrec.rrtype == kDNSType_SRV) &amp;&amp; (rr-&gt;AutoTarget == Target_AutoHost))
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        <span class="enscript-keyword">if</span> (AuthRecordIncludesAWDL(rr))
        {
            m-&gt;AutoTargetAWDLIncludedCount++;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;IncrementAutoTargetServices: AutoTargetAWDLIncludedCount %u Record &quot;</span> PRI_S,
                m-&gt;AutoTargetAWDLIncludedCount, ARDisplayString(m, rr));
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(rr-&gt;resrec.InterfaceID))
        {
            m-&gt;AutoTargetAWDLOnlyCount++;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;IncrementAutoTargetServices: AutoTargetAWDLOnlyCount %u Record &quot;</span> PRI_S,
                m-&gt;AutoTargetAWDLOnlyCount, ARDisplayString(m, rr));
        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        {
            m-&gt;AutoTargetServices++;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;IncrementAutoTargetServices: AutoTargetServices %u Record &quot;</span> PRI_S,
                m-&gt;AutoTargetServices, ARDisplayString(m, rr));
        }
        <span class="enscript-comment">// If this is the first advertised service and we did not just enable Bonjour above, then
</span>        <span class="enscript-comment">// advertise all the interface records.  If we did enable Bonjour above, the interface records will
</span>        <span class="enscript-comment">// be advertised during the network changed processing scheduled above, so no need 
</span>        <span class="enscript-comment">// to do it here.
</span>        <span class="enscript-keyword">if</span> (!enablingBonjour) AdvertiseNecessaryInterfaceRecords(m);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">getKeepaliveRaddr</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNSAddr *raddr)
{
    mDNSAddr     laddr = zeroAddr;
    mDNSEthAddr  eth = zeroEthAddr;
    mDNSIPPort   lport = zeroIPPort;
    mDNSIPPort   rport = zeroIPPort;
    mDNSu32      timeout = 0;
    mDNSu32      seq = 0;
    mDNSu32      ack = 0;
    mDNSu16      win = 0;

    <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;rr-&gt;resrec))
    {
        mDNS_ExtractKeepaliveInfo(rr, &amp;timeout, &amp;laddr, raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);
        <span class="enscript-keyword">if</span> (!timeout || mDNSAddressIsZero(&amp;laddr) || mDNSAddressIsZero(raddr) || mDNSIPPortIsZero(lport) || mDNSIPPortIsZero(rport))
        {
            LogMsg(<span class="enscript-string">&quot;getKeepaliveRaddr: not a valid record %s for keepalive %#a:%d %#a:%d&quot;</span>, ARDisplayString(m, rr), &amp;laddr, lport.NotAnInteger, raddr, rport.NotAnInteger);
            <span class="enscript-keyword">return</span>;
        }
    }
}

<span class="enscript-comment">// Exported so uDNS.c can call this
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_Register_internal</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    domainname *target = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
    AuthRecord *r;
    AuthRecord **p = &amp;m-&gt;ResourceRecords;
    AuthRecord **d = &amp;m-&gt;DuplicateRecords;

    <span class="enscript-keyword">if</span> ((mDNSs32)rr-&gt;resrec.rroriginalttl &lt;= 0)
    { LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: TTL %X should be 1 - 0x7FFFFFFF %s&quot;</span>, rr-&gt;resrec.rroriginalttl, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    <span class="enscript-keyword">if</span> (!rr-&gt;resrec.RecordType)
    { LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: RecordType must be non-zero %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    <span class="enscript-keyword">if</span> (m-&gt;ShutdownTime)
    { LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: Shutting down, can't register %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>(mStatus_ServiceNotRunning); }

    <span class="enscript-keyword">if</span> (m-&gt;DivertMulticastAdvertisements &amp;&amp; !AuthRecord_uDNS(rr))
    {
        mDNSInterfaceID previousID = rr-&gt;resrec.InterfaceID;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == mDNSInterface_Any || rr-&gt;resrec.InterfaceID == mDNSInterface_P2P)
        {
            rr-&gt;resrec.InterfaceID = mDNSInterface_LocalOnly;
            rr-&gt;ARType = AuthRecordLocalOnly;
        }
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID != mDNSInterface_LocalOnly)
        {
            NetworkInterfaceInfo *intf = FirstInterfaceForID(m, rr-&gt;resrec.InterfaceID);
            <span class="enscript-keyword">if</span> (intf &amp;&amp; !intf-&gt;Advertise) { rr-&gt;resrec.InterfaceID = mDNSInterface_LocalOnly; rr-&gt;ARType = AuthRecordLocalOnly; }
        }
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID != previousID)
            LogInfo(<span class="enscript-string">&quot;mDNS_Register_internal: Diverting record to local-only %s&quot;</span>, ARDisplayString(m, rr));
    }

    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        <span class="enscript-keyword">if</span> (CheckAuthSameRecord(&amp;m-&gt;rrauth, rr))
        {
            LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: ERROR!! Tried to register LocalOnly AuthRecord %p %##s (%s) that's already in the list&quot;</span>,
                   rr, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
            <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != rr) p=&amp;(*p)-&gt;next;
        <span class="enscript-keyword">if</span> (*p)
        {
            LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %##s (%s) that's already in the list&quot;</span>,
                   rr, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
            <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
        }
    }

    <span class="enscript-keyword">while</span> (*d &amp;&amp; *d != rr) d=&amp;(*d)-&gt;next;
    <span class="enscript-keyword">if</span> (*d)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: ERROR!! Tried to register AuthRecord %p %##s (%s) that's already in the Duplicate list&quot;</span>,
               rr, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
        <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
    }

    <span class="enscript-keyword">if</span> (rr-&gt;DependentOn)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique)
            rr-&gt;resrec.RecordType =  kDNSRecordTypeVerified;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeKnownUnique)
        {
            LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: ERROR! %##s (%s): rr-&gt;DependentOn &amp;&amp; RecordType != kDNSRecordTypeUnique or kDNSRecordTypeKnownUnique&quot;</span>,
                   rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
            <span class="enscript-keyword">return</span>(mStatus_Invalid);
        }
        <span class="enscript-keyword">if</span> (!(rr-&gt;DependentOn-&gt;resrec.RecordType &amp; (kDNSRecordTypeUnique | kDNSRecordTypeVerified | kDNSRecordTypeKnownUnique)))
        {
            LogMsg(<span class="enscript-string">&quot;mDNS_Register_internal: ERROR! %##s (%s): rr-&gt;DependentOn-&gt;RecordType bad type %X&quot;</span>,
                   rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), rr-&gt;DependentOn-&gt;resrec.RecordType);
            <span class="enscript-keyword">return</span>(mStatus_Invalid);
        }
    }

    rr-&gt;next = mDNSNULL;

    <span class="enscript-comment">// Field Group 1: The actual information pertaining to this resource record
</span>    <span class="enscript-comment">// Set up by client prior to call
</span>
    <span class="enscript-comment">// Field Group 2: Persistent metadata for Authoritative Records
</span><span class="enscript-comment">//  rr-&gt;Additional1       = set to mDNSNULL  in mDNS_SetupResourceRecord; may be overridden by client
</span><span class="enscript-comment">//  rr-&gt;Additional2       = set to mDNSNULL  in mDNS_SetupResourceRecord; may be overridden by client
</span><span class="enscript-comment">//  rr-&gt;DependentOn       = set to mDNSNULL  in mDNS_SetupResourceRecord; may be overridden by client
</span><span class="enscript-comment">//  rr-&gt;RRSet             = set to mDNSNULL  in mDNS_SetupResourceRecord; may be overridden by client
</span><span class="enscript-comment">//  rr-&gt;Callback          = already set      in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;Context           = already set      in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;RecordType        = already set      in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;HostTarget        = set to mDNSfalse in mDNS_SetupResourceRecord; may be overridden by client
</span><span class="enscript-comment">//  rr-&gt;AllowRemoteQuery  = set to mDNSfalse in mDNS_SetupResourceRecord; may be overridden by client
</span>    <span class="enscript-comment">// Make sure target is not uninitialized data, or we may crash writing debugging log messages
</span>    <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget &amp;&amp; target) target-&gt;c[0] = 0;

    <span class="enscript-comment">// Field Group 3: Transient state for Authoritative Records
</span>    rr-&gt;Acknowledged      = mDNSfalse;
    rr-&gt;ProbeCount        = DefaultProbeCountForRecordType(rr-&gt;resrec.RecordType);
    rr-&gt;ProbeRestartCount = 0;
    rr-&gt;AnnounceCount     = InitialAnnounceCount;
    rr-&gt;RequireGoodbye    = mDNSfalse;
    rr-&gt;AnsweredLocalQ    = mDNSfalse;
    rr-&gt;IncludeInProbe    = mDNSfalse;
    rr-&gt;ImmedUnicast      = mDNSfalse;
    rr-&gt;SendNSECNow       = mDNSNULL;
    rr-&gt;ImmedAnswer       = mDNSNULL;
    rr-&gt;ImmedAdditional   = mDNSNULL;
    rr-&gt;SendRNow          = mDNSNULL;
    rr-&gt;v4Requester       = zerov4Addr;
    rr-&gt;v6Requester       = zerov6Addr;
    rr-&gt;NextResponse      = mDNSNULL;
    rr-&gt;NR_AnswerTo       = mDNSNULL;
    rr-&gt;NR_AdditionalTo   = mDNSNULL;
    <span class="enscript-keyword">if</span> (!rr-&gt;AutoTarget) InitializeLastAPTime(m, rr);
<span class="enscript-comment">//  rr-&gt;LastAPTime        = Set for us in InitializeLastAPTime()
</span><span class="enscript-comment">//  rr-&gt;LastMCTime        = Set for us in InitializeLastAPTime()
</span><span class="enscript-comment">//  rr-&gt;LastMCInterface   = Set for us in InitializeLastAPTime()
</span>    rr-&gt;NewRData          = mDNSNULL;
    rr-&gt;newrdlength       = 0;
    rr-&gt;UpdateCallback    = mDNSNULL;
    rr-&gt;UpdateCredits     = kMaxUpdateCredits;
    rr-&gt;NextUpdateCredit  = 0;
    rr-&gt;UpdateBlocked     = 0;

    <span class="enscript-comment">// For records we're holding as proxy (except reverse-mapping PTR records) two announcements is sufficient
</span>    <span class="enscript-keyword">if</span> (rr-&gt;WakeUp.HMAC.l[0] &amp;&amp; !rr-&gt;AddressProxy.type) rr-&gt;AnnounceCount = 2;

    <span class="enscript-comment">// Field Group 4: Transient uDNS state for Authoritative Records
</span>    rr-&gt;state             = regState_Zero;
    rr-&gt;uselease          = 0;
    rr-&gt;expire            = 0;
    rr-&gt;Private           = 0;
    rr-&gt;updateid          = zeroID;
    rr-&gt;updateIntID       = zeroOpaque64;
    rr-&gt;zone              = rr-&gt;resrec.name;
    rr-&gt;nta               = mDNSNULL;
    rr-&gt;tcp               = mDNSNULL;
    rr-&gt;OrigRData         = 0;
    rr-&gt;OrigRDLen         = 0;
    rr-&gt;InFlightRData     = 0;
    rr-&gt;InFlightRDLen     = 0;
    rr-&gt;QueuedRData       = 0;
    rr-&gt;QueuedRDLen       = 0;
    <span class="enscript-comment">//mDNSPlatformMemZero(&amp;rr-&gt;NATinfo, sizeof(rr-&gt;NATinfo));
</span>    <span class="enscript-comment">// We should be recording the actual internal port for this service record here. Once we initiate our NAT mapping
</span>    <span class="enscript-comment">// request we'll subsequently overwrite srv.port with the allocated external NAT port -- potentially multiple
</span>    <span class="enscript-comment">// times with different values if the external NAT port changes during the lifetime of the service registration.
</span>    <span class="enscript-comment">//if (rr-&gt;resrec.rrtype == kDNSType_SRV) rr-&gt;NATinfo.IntPort = rr-&gt;resrec.rdata-&gt;u.srv.port;
</span>
<span class="enscript-comment">//  rr-&gt;resrec.interface         = already set in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;resrec.name-&gt;c           = MUST be set by client
</span><span class="enscript-comment">//  rr-&gt;resrec.rrtype            = already set in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;resrec.rrclass           = already set in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;resrec.rroriginalttl     = already set in mDNS_SetupResourceRecord
</span><span class="enscript-comment">//  rr-&gt;resrec.rdata             = MUST be set by client, unless record type is CNAME or PTR and rr-&gt;HostTarget is set
</span>
    <span class="enscript-comment">// BIND named (name daemon) doesn't allow TXT records with zero-length rdata. This is strictly speaking correct,
</span>    <span class="enscript-comment">// since RFC 1035 specifies a TXT record as &quot;One or more &lt;character-string&gt;s&quot;, not &quot;Zero or more &lt;character-string&gt;s&quot;.
</span>    <span class="enscript-comment">// Since some legacy apps try to create zero-length TXT records, we'll silently correct it here.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_TXT &amp;&amp; rr-&gt;resrec.rdlength == 0) { rr-&gt;resrec.rdlength = 1; rr-&gt;resrec.rdata-&gt;u.txt.c[0] = 0; }

    <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget)
    {
        SetTargetToHostName(m, rr); <span class="enscript-comment">// Also sets rdlength and rdestimate for us, and calls InitializeLastAPTime();
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
        <span class="enscript-comment">// If we have no target record yet, SetTargetToHostName will set rr-&gt;state == regState_NoTarget
</span>        <span class="enscript-comment">// In this case we leave the record half-formed in the list, and later we'll remove it from the list and re-add it properly.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_NoTarget)
        {
            <span class="enscript-comment">// Initialize the target so that we don't crash while logging etc.
</span>            domainname *tar = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
            <span class="enscript-keyword">if</span> (tar) tar-&gt;c[0] = 0;
            LogInfo(<span class="enscript-string">&quot;mDNS_Register_internal: record %s in NoTarget state&quot;</span>, ARDisplayString(m, rr));
        }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">else</span>
    {
        rr-&gt;resrec.rdlength   = GetRDLength(&amp;rr-&gt;resrec, mDNSfalse);
        rr-&gt;resrec.rdestimate = GetRDLength(&amp;rr-&gt;resrec, mDNStrue);
    }

    <span class="enscript-keyword">if</span> (!ValidateDomainName(rr-&gt;resrec.name))
    { LogMsg(<span class="enscript-string">&quot;Attempt to register record with invalid name: %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>(mStatus_Invalid); }

    <span class="enscript-comment">// Don't do this until *after* we've set rr-&gt;resrec.rdlength
</span>    <span class="enscript-keyword">if</span> (!ValidateRData(rr-&gt;resrec.rrtype, rr-&gt;resrec.rdlength, rr-&gt;resrec.rdata))
    { LogMsg(<span class="enscript-string">&quot;Attempt to register record with invalid rdata: %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>(mStatus_Invalid); }

    rr-&gt;resrec.namehash   = DomainNameHashValue(rr-&gt;resrec.name);
    rr-&gt;resrec.rdatahash  = target ? DomainNameHashValue(target) : RDataHashValue(&amp;rr-&gt;resrec);

    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        <span class="enscript-comment">// If this is supposed to be unique, make sure we don't have any name conflicts.
</span>        <span class="enscript-comment">// If we found a conflict, we may still want to insert the record in the list but mark it appropriately
</span>        <span class="enscript-comment">// (kDNSRecordTypeDeregistering) so that we deliver RMV events to the application. But this causes more
</span>        <span class="enscript-comment">// complications and not clear whether there are any benefits. See rdar:9304275 for details.
</span>        <span class="enscript-comment">// Hence, just bail out.
</span>        <span class="enscript-comment">// This comment is doesnt make any sense. -- SC
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
        {
            <span class="enscript-keyword">if</span> (CheckAuthRecordConflict(&amp;m-&gt;rrauth, rr))
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_Register_internal: Name conflict %s (%p), InterfaceID %p&quot;</span>, ARDisplayString(m, rr), rr, rr-&gt;resrec.InterfaceID);
                <span class="enscript-keyword">return</span> mStatus_NameConflict;
            }
        }
    }

    <span class="enscript-comment">// For uDNS records, we don't support duplicate checks at this time.
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr))
    {
        <span class="enscript-keyword">if</span> (!m-&gt;NewLocalRecords) m-&gt;NewLocalRecords = rr;
        <span class="enscript-comment">// When we called SetTargetToHostName, it may have caused mDNS_Register_internal to be re-entered, appending new
</span>        <span class="enscript-comment">// records to the list, so we now need to update p to advance to the new end to the list before appending our new record.
</span>        <span class="enscript-keyword">while</span> (*p) p=&amp;(*p)-&gt;next;
        *p = rr;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique) rr-&gt;resrec.RecordType = kDNSRecordTypeVerified;
        rr-&gt;ProbeCount    = 0;
        rr-&gt;ProbeRestartCount = 0;
        rr-&gt;AnnounceCount = 0;
        <span class="enscript-keyword">if</span> (rr-&gt;state != regState_NoTarget) ActivateUnicastRegistration(m, rr);
        <span class="enscript-keyword">return</span>(mStatus_NoError);            <span class="enscript-comment">// &lt;--- Note: For unicast records, code currently bails out at this point
</span>    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Now that we've finished building our new record, make sure it's not identical to one we already have
</span>    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        rr-&gt;ProbeCount    = 0;
        rr-&gt;ProbeRestartCount = 0;
        rr-&gt;AnnounceCount = 0;
        r = CheckAuthIdenticalRecord(&amp;m-&gt;rrauth, rr);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">for</span> (r = m-&gt;ResourceRecords; r; r=r-&gt;next)
            <span class="enscript-keyword">if</span> (RecordIsLocalDuplicate(r, rr))
            {
                <span class="enscript-keyword">if</span> (r-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) r-&gt;AnnounceCount = 0;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            }
    }

    <span class="enscript-keyword">if</span> (r)
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_Register_internal: Adding to duplicate list %s&quot;</span>, ARDisplayString(m,rr));
        *d = rr;
        <span class="enscript-comment">// If the previous copy of this record is already verified unique,
</span>        <span class="enscript-comment">// then indicate that we should move this record promptly to kDNSRecordTypeUnique state.
</span>        <span class="enscript-comment">// Setting ProbeCount to zero will cause SendQueries() to advance this record to
</span>        <span class="enscript-comment">// kDNSRecordTypeVerified state and call the client callback at the next appropriate time.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique &amp;&amp; r-&gt;resrec.RecordType == kDNSRecordTypeVerified)
            rr-&gt;ProbeCount = 0;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_Register_internal: Adding to active record list %s&quot;</span>, ARDisplayString(m,rr));
        <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
        {
            AuthGroup *ag;
            ag = InsertAuthRecord(m, &amp;m-&gt;rrauth, rr);
            <span class="enscript-keyword">if</span> (ag &amp;&amp; !ag-&gt;NewLocalOnlyRecords)
            {
                m-&gt;NewLocalOnlyRecords = mDNStrue;
                ag-&gt;NewLocalOnlyRecords = rr;
            }
            <span class="enscript-comment">// No probing for LocalOnly records; acknowledge them right away
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique) rr-&gt;resrec.RecordType = kDNSRecordTypeVerified;
            AcknowledgeRecord(m, rr);
            <span class="enscript-keyword">return</span>(mStatus_NoError);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (!m-&gt;NewLocalRecords) m-&gt;NewLocalRecords = rr;
            *p = rr;
        }
    }

    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))   <span class="enscript-comment">// This check is superfluous, given that for unicast records we (currently) bail out above
</span>    {
        <span class="enscript-comment">// We have inserted the record in the list. See if we have to advertise the A/AAAA, HINFO, PTR records.
</span>        IncrementAutoTargetServices(m, rr);

        <span class="enscript-comment">// For records that are not going to probe, acknowledge them right away
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeUnique &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering)
            AcknowledgeRecord(m, rr);

        <span class="enscript-comment">// Adding a record may affect whether or not we should sleep
</span>        mDNS_UpdateAllowSleep(m);
    }

    <span class="enscript-comment">// If this is a non-sleep proxy keepalive record, fetch the MAC address of the remote host.
</span>    <span class="enscript-comment">// This is used by the in-NIC proxy to send the keepalive packets.
</span>    <span class="enscript-keyword">if</span> (!rr-&gt;WakeUp.HMAC.l[0] &amp;&amp; mDNS_KeepaliveRecord(&amp;rr-&gt;resrec))
    {
        mDNSAddr raddr;
        <span class="enscript-comment">// Set the record type to known unique to prevent probing keep alive records.
</span>        <span class="enscript-comment">// Also make sure we do not announce the keepalive records.
</span>       rr-&gt;resrec.RecordType = kDNSRecordTypeKnownUnique;
       rr-&gt;AnnounceCount     = 0;
       getKeepaliveRaddr(m, rr, &amp;raddr);
       <span class="enscript-comment">// This is an asynchronous call. Once the remote MAC address is available, helper will schedule an
</span>       <span class="enscript-comment">// asynchronous task to update the resource record
</span>       mDNSPlatformGetRemoteMacAddr(&amp;raddr);
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RecordProbeFailure</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr)
{
    m-&gt;ProbeFailTime = m-&gt;timenow;
    m-&gt;NumFailedProbes++;
    <span class="enscript-comment">// If we've had fifteen or more probe failures, rate-limit to one every five seconds.
</span>    <span class="enscript-comment">// If a bunch of hosts have all been configured with the same name, then they'll all
</span>    <span class="enscript-comment">// conflict and run through the same series of names: name-2, name-3, name-4, etc.,
</span>    <span class="enscript-comment">// up to name-10. After that they'll start adding random increments in the range 1-100,
</span>    <span class="enscript-comment">// so they're more likely to branch out in the available namespace and settle on a set of
</span>    <span class="enscript-comment">// unique names quickly. If after five more tries the host is still conflicting, then we
</span>    <span class="enscript-comment">// may have a serious problem, so we start rate-limiting so we don't melt down the network.
</span>    <span class="enscript-keyword">if</span> (m-&gt;NumFailedProbes &gt;= 15)
    {
        m-&gt;SuppressProbes = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond * 5);
        LogMsg(<span class="enscript-string">&quot;Excessive name conflicts (%lu) for %##s (%s); rate limiting in effect&quot;</span>,
               m-&gt;NumFailedProbes, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CompleteRDataUpdate</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    RData *OldRData = rr-&gt;resrec.rdata;
    mDNSu16 OldRDLen = rr-&gt;resrec.rdlength;
    SetNewRData(&amp;rr-&gt;resrec, rr-&gt;NewRData, rr-&gt;newrdlength);    <span class="enscript-comment">// Update our rdata
</span>    rr-&gt;NewRData = mDNSNULL;                                    <span class="enscript-comment">// Clear the NewRData pointer ...
</span>    <span class="enscript-keyword">if</span> (rr-&gt;UpdateCallback)
        rr-&gt;UpdateCallback(m, rr, OldRData, OldRDLen);          <span class="enscript-comment">// ... and let the client know
</span>}

<span class="enscript-comment">// Note: mDNS_Deregister_internal can call a user callback, which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span><span class="enscript-comment">// Exported so uDNS.c can call this
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_Deregister_internal</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mDNS_Dereg_type drt)
{
    AuthRecord *r2;
    mDNSu8 RecordType = rr-&gt;resrec.RecordType;
    AuthRecord **p = &amp;m-&gt;ResourceRecords;   <span class="enscript-comment">// Find this record in our list of active records
</span>    mDNSBool dupList = mDNSfalse;

    <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
    {
        AuthGroup *a;
        AuthRecord **rp;

        a = AuthGroupForRecord(&amp;m-&gt;rrauth, &amp;rr-&gt;resrec);
        <span class="enscript-keyword">if</span> (!a) <span class="enscript-keyword">return</span> mDNSfalse;
        rp = &amp;a-&gt;members;
        <span class="enscript-keyword">while</span> (*rp &amp;&amp; *rp != rr) rp=&amp;(*rp)-&gt;next;
        p = rp;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != rr) p=&amp;(*p)-&gt;next;
    }

    <span class="enscript-keyword">if</span> (*p)
    {
        <span class="enscript-comment">// We found our record on the main list. See if there are any duplicates that need special handling.
</span>        <span class="enscript-keyword">if</span> (drt == mDNS_Dereg_conflict)     <span class="enscript-comment">// If this was a conflict, see that all duplicates get the same treatment
</span>        {
            <span class="enscript-comment">// Scan for duplicates of rr, and mark them for deregistration at the end of this routine, after we've finished
</span>            <span class="enscript-comment">// deregistering rr. We need to do this scan *before* we give the client the chance to free and reuse the rr memory.
</span>            <span class="enscript-keyword">for</span> (r2 = m-&gt;DuplicateRecords; r2; r2=r2-&gt;next) <span class="enscript-keyword">if</span> (RecordIsLocalDuplicate(r2, rr)) r2-&gt;ProbeCount = 0xFF;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Before we delete the record (and potentially send a goodbye packet)
</span>            <span class="enscript-comment">// first see if we have a record on the duplicate list ready to take over from it.
</span>            AuthRecord **d = &amp;m-&gt;DuplicateRecords;
            <span class="enscript-keyword">while</span> (*d &amp;&amp; !RecordIsLocalDuplicate(*d, rr)) d=&amp;(*d)-&gt;next;
            <span class="enscript-keyword">if</span> (*d)
            {
                AuthRecord *dup = *d;
                debugf(<span class="enscript-string">&quot;mDNS_Register_internal: Duplicate record %p taking over from %p %##s (%s)&quot;</span>,
                       dup, rr, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
                *d        = dup-&gt;next;      <span class="enscript-comment">// Cut replacement record from DuplicateRecords list
</span>                <span class="enscript-keyword">if</span> (RRLocalOnly(rr))
                {
                    dup-&gt;next = mDNSNULL;
                    <span class="enscript-keyword">if</span> (!InsertAuthRecord(m, &amp;m-&gt;rrauth, dup)) LogMsg(<span class="enscript-string">&quot;mDNS_Deregister_internal: ERROR!! cannot insert %s&quot;</span>, ARDisplayString(m, dup));
                }
                <span class="enscript-keyword">else</span>
                {
                    dup-&gt;next = rr-&gt;next;       <span class="enscript-comment">// And then...
</span>                    rr-&gt;next  = dup;            <span class="enscript-comment">// ... splice it in right after the record we're about to delete
</span>                }
                dup-&gt;resrec.RecordType        = rr-&gt;resrec.RecordType;
                dup-&gt;ProbeCount      = rr-&gt;ProbeCount;
                dup-&gt;ProbeRestartCount = rr-&gt;ProbeRestartCount;
                dup-&gt;AnnounceCount   = rr-&gt;AnnounceCount;
                dup-&gt;RequireGoodbye  = rr-&gt;RequireGoodbye;
                dup-&gt;AnsweredLocalQ  = rr-&gt;AnsweredLocalQ;
                dup-&gt;ImmedAnswer     = rr-&gt;ImmedAnswer;
                dup-&gt;ImmedUnicast    = rr-&gt;ImmedUnicast;
                dup-&gt;ImmedAdditional = rr-&gt;ImmedAdditional;
                dup-&gt;v4Requester     = rr-&gt;v4Requester;
                dup-&gt;v6Requester     = rr-&gt;v6Requester;
                dup-&gt;ThisAPInterval  = rr-&gt;ThisAPInterval;
                dup-&gt;LastAPTime      = rr-&gt;LastAPTime;
                dup-&gt;LastMCTime      = rr-&gt;LastMCTime;
                dup-&gt;LastMCInterface = rr-&gt;LastMCInterface;
                dup-&gt;Private         = rr-&gt;Private;
                dup-&gt;state           = rr-&gt;state;
                rr-&gt;RequireGoodbye = mDNSfalse;
                rr-&gt;AnsweredLocalQ = mDNSfalse;
            }
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// We didn't find our record on the main list; try the DuplicateRecords list instead.
</span>        p = &amp;m-&gt;DuplicateRecords;
        <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != rr) p=&amp;(*p)-&gt;next;
        <span class="enscript-comment">// If we found our record on the duplicate list, then make sure we don't send a goodbye for it
</span>        <span class="enscript-keyword">if</span> (*p)
        {
            <span class="enscript-comment">// Duplicate records are not used for sending wakeups or goodbyes. Hence, deregister them
</span>            <span class="enscript-comment">// immediately. When there is a conflict, we deregister all the conflicting duplicate records
</span>            <span class="enscript-comment">// also that have been marked above in this function. In that case, we come here and if we don't
</span>            <span class="enscript-comment">// deregister (unilink from the DuplicateRecords list), we will be recursing infinitely. Hence,
</span>            <span class="enscript-comment">// clear the HMAC which will cause it to deregister. See &lt;rdar://problem/10380988&gt; for
</span>            <span class="enscript-comment">// details.
</span>            rr-&gt;WakeUp.HMAC    = zeroEthAddr;
            rr-&gt;RequireGoodbye = mDNSfalse;
            rr-&gt;resrec.RecordType = kDNSRecordTypeDeregistering;
            dupList = mDNStrue;
        }
        <span class="enscript-keyword">if</span> (*p) debugf(<span class="enscript-string">&quot;mDNS_Deregister_internal: Deleting DuplicateRecord %p %##s (%s)&quot;</span>,
                       rr, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
    }

    <span class="enscript-keyword">if</span> (!*p)
    {
        <span class="enscript-comment">// No need to log an error message if we already know this is a potentially repeated deregistration
</span>        <span class="enscript-keyword">if</span> (drt != mDNS_Dereg_repeat)
            LogMsg(<span class="enscript-string">&quot;mDNS_Deregister_internal: Record %p not found in list %s&quot;</span>, rr, ARDisplayString(m,rr));
        <span class="enscript-keyword">return</span>(mStatus_BadReferenceErr);
    }

    <span class="enscript-comment">// If this is a shared record and we've announced it at least once,
</span>    <span class="enscript-comment">// we need to retract that announcement before we delete the record
</span>
    <span class="enscript-comment">// If this is a record (including mDNSInterface_LocalOnly records) for which we've given local-only answers then
</span>    <span class="enscript-comment">// it's tempting to just do &quot;AnswerAllLocalQuestionsWithLocalAuthRecord(m, rr, QC_rmv)&quot; here, but that would not not be safe.
</span>    <span class="enscript-comment">// The AnswerAllLocalQuestionsWithLocalAuthRecord routine walks the question list invoking client callbacks, using the &quot;m-&gt;CurrentQuestion&quot;
</span>    <span class="enscript-comment">// mechanism to cope with the client callback modifying the question list while that's happening.
</span>    <span class="enscript-comment">// However, mDNS_Deregister could have been called from a client callback (e.g. from the domain enumeration callback FoundDomain)
</span>    <span class="enscript-comment">// which means that the &quot;m-&gt;CurrentQuestion&quot; mechanism is already in use to protect that list, so we can't use it twice.
</span>    <span class="enscript-comment">// More generally, if we invoke callbacks from within a client callback, then those callbacks could deregister other
</span>    <span class="enscript-comment">// records, thereby invoking yet more callbacks, without limit.
</span>    <span class="enscript-comment">// The solution is to defer delivering the &quot;Remove&quot; events until mDNS_Execute time, just like we do for sending
</span>    <span class="enscript-comment">// actual goodbye packets.
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr))
    {
        <span class="enscript-keyword">if</span> (rr-&gt;RequireGoodbye)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp); rr-&gt;tcp = mDNSNULL; }
            rr-&gt;resrec.RecordType    = kDNSRecordTypeDeregistering;
            m-&gt;LocalRemoveEvents     = mDNStrue;
            uDNS_DeregisterRecord(m, rr);
            <span class="enscript-comment">// At this point unconditionally we bail out
</span>            <span class="enscript-comment">// Either uDNS_DeregisterRecord will have completed synchronously, and called CompleteDeregistration,
</span>            <span class="enscript-comment">// which calls us back here with RequireGoodbye set to false, or it will have initiated the deregistration
</span>            <span class="enscript-comment">// process and will complete asynchronously. Either way we don't need to do anything more here.
</span>            <span class="enscript-keyword">return</span>(mStatus_NoError);
        }
        <span class="enscript-comment">// Sometimes the records don't complete proper deregistration i.e., don't wait for a response
</span>        <span class="enscript-comment">// from the server. In that case, if the records have been part of a group update, clear the
</span>        <span class="enscript-comment">// state here.
</span>        rr-&gt;updateid = zeroID;

        <span class="enscript-comment">// We defer cleaning up NAT state only after sending goodbyes. This is important because
</span>        <span class="enscript-comment">// RecordRegistrationGotZoneData guards against creating NAT state if clientContext is non-NULL.
</span>        <span class="enscript-comment">// This happens today when we turn on/off interface where we get multiple network transitions
</span>        <span class="enscript-comment">// and RestartRecordGetZoneData triggers re-registration of the resource records even though
</span>        <span class="enscript-comment">// they may be in Registered state which causes NAT information to be setup multiple times. Defering
</span>        <span class="enscript-comment">// the cleanup here keeps clientContext non-NULL and hence prevents that. Note that cleaning up
</span>        <span class="enscript-comment">// NAT state here takes care of the case where we did not send goodbyes at all.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext)
        {
            mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
            rr-&gt;NATinfo.clientContext = mDNSNULL;
        }
        <span class="enscript-keyword">if</span> (rr-&gt;nta) { CancelGetZoneData(m, rr-&gt;nta); rr-&gt;nta = mDNSNULL; }
        <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp);       rr-&gt;tcp = mDNSNULL; }
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">UNICAST_DISABLED</span>

    <span class="enscript-keyword">if</span>      (RecordType == kDNSRecordTypeUnregistered)
        LogMsg(<span class="enscript-string">&quot;mDNS_Deregister_internal: %s already marked kDNSRecordTypeUnregistered&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (RecordType == kDNSRecordTypeDeregistering)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_Deregister_internal: %s already marked kDNSRecordTypeDeregistering&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>(mStatus_BadReferenceErr);
    }

    <span class="enscript-keyword">if</span> (rr-&gt;WakeUp.HMAC.l[0] ||
        (((RecordType == kDNSRecordTypeShared) || (rr-&gt;ARType == AuthRecordLocalOnly)) &amp;&amp;
        (rr-&gt;RequireGoodbye || rr-&gt;AnsweredLocalQ)))
    {
        verbosedebugf(<span class="enscript-string">&quot;mDNS_Deregister_internal: Starting deregistration for %s&quot;</span>, ARDisplayString(m, rr));
        rr-&gt;resrec.RecordType    = kDNSRecordTypeDeregistering;
        rr-&gt;resrec.rroriginalttl = 0;
        rr-&gt;AnnounceCount        = rr-&gt;WakeUp.HMAC.l[0] ? WakeupCount : (drt == mDNS_Dereg_rapid) ? 1 : GoodbyeCount;
        rr-&gt;ThisAPInterval       = mDNSPlatformOneSecond * 2;
        rr-&gt;LastAPTime           = m-&gt;timenow - rr-&gt;ThisAPInterval;
        m-&gt;LocalRemoveEvents     = mDNStrue;
        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledResponse - (m-&gt;timenow + mDNSPlatformOneSecond/10) &gt;= 0)
            m-&gt;NextScheduledResponse = (m-&gt;timenow + mDNSPlatformOneSecond/10);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (!dupList &amp;&amp; RRLocalOnly(rr))
        {
            AuthGroup *ag = RemoveAuthRecord(m, &amp;m-&gt;rrauth, rr);
            <span class="enscript-keyword">if</span> (ag-&gt;NewLocalOnlyRecords == rr) ag-&gt;NewLocalOnlyRecords = rr-&gt;next;
        }
        <span class="enscript-keyword">else</span>
        {
            *p = rr-&gt;next;                  <span class="enscript-comment">// Cut this record from the list
</span>            <span class="enscript-keyword">if</span> (m-&gt;NewLocalRecords == rr) m-&gt;NewLocalRecords = rr-&gt;next;
            DecrementAutoTargetServices(m, rr);
        }
        <span class="enscript-comment">// If someone is about to look at this, bump the pointer forward
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord   == rr) m-&gt;CurrentRecord   = rr-&gt;next;
        rr-&gt;next = mDNSNULL;

        verbosedebugf(<span class="enscript-string">&quot;mDNS_Deregister_internal: Deleting record for %s&quot;</span>, ARDisplayString(m, rr));
        rr-&gt;resrec.RecordType = kDNSRecordTypeUnregistered;

        <span class="enscript-keyword">if</span> ((drt == mDNS_Dereg_conflict || drt == mDNS_Dereg_repeat) &amp;&amp; RecordType == kDNSRecordTypeShared)
            debugf(<span class="enscript-string">&quot;mDNS_Deregister_internal: Cannot have a conflict on a shared record! %##s (%s)&quot;</span>,
                   rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));

        <span class="enscript-comment">// If we have an update queued up which never executed, give the client a chance to free that memory
</span>        <span class="enscript-keyword">if</span> (rr-&gt;NewRData) CompleteRDataUpdate(m, rr);   <span class="enscript-comment">// Update our rdata, clear the NewRData pointer, and return memory to the client
</span>

        <span class="enscript-comment">// CAUTION: MUST NOT do anything more with rr after calling rr-&gt;Callback(), because the client's callback function
</span>        <span class="enscript-comment">// is allowed to do anything, including starting/stopping queries, registering/deregistering records, etc.
</span>        <span class="enscript-comment">// In this case the likely client action to the mStatus_MemFree message is to free the memory,
</span>        <span class="enscript-comment">// so any attempt to touch rr after this is likely to lead to a crash.
</span>        <span class="enscript-keyword">if</span> (drt != mDNS_Dereg_conflict)
        {
            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>            LogInfo(<span class="enscript-string">&quot;mDNS_Deregister_internal: callback with mStatus_MemFree for %s&quot;</span>, ARDisplayString(m, rr));
            <span class="enscript-keyword">if</span> (rr-&gt;RecordCallback)
                rr-&gt;RecordCallback(m, rr, mStatus_MemFree);         <span class="enscript-comment">// MUST NOT touch rr after this
</span>            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        }
        <span class="enscript-keyword">else</span>
        {
            RecordProbeFailure(m, rr);
            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>            <span class="enscript-keyword">if</span> (rr-&gt;RecordCallback)
                rr-&gt;RecordCallback(m, rr, mStatus_NameConflict);    <span class="enscript-comment">// MUST NOT touch rr after this
</span>            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>            <span class="enscript-comment">// Now that we've finished deregistering rr, check our DuplicateRecords list for any that we marked previously.
</span>            <span class="enscript-comment">// Note that with all the client callbacks going on, by the time we get here all the
</span>            <span class="enscript-comment">// records we marked may have been explicitly deregistered by the client anyway.
</span>            r2 = m-&gt;DuplicateRecords;
            <span class="enscript-keyword">while</span> (r2)
            {
                <span class="enscript-keyword">if</span> (r2-&gt;ProbeCount != 0xFF)
                {
                    r2 = r2-&gt;next;
                }
                <span class="enscript-keyword">else</span>
                {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
                    <span class="enscript-comment">// See if this record was also registered with any D2D plugins.
</span>                    D2D_stop_advertising_record(r2);
#<span class="enscript-reference">endif</span>
                    mDNS_Deregister_internal(m, r2, mDNS_Dereg_conflict);
                    <span class="enscript-comment">// As this is a duplicate record, it will be unlinked from the list
</span>                    <span class="enscript-comment">// immediately
</span>                    r2 = m-&gt;DuplicateRecords;
                }
            }
        }
    }
    mDNS_UpdateAllowSleep(m);
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Packet</span> <span class="enscript-variable-name">Sending</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AddRecordToResponseList</span>(AuthRecord ***nrpp, AuthRecord *rr, AuthRecord *add)
{
    <span class="enscript-keyword">if</span> (rr-&gt;NextResponse == mDNSNULL &amp;&amp; *nrpp != &amp;rr-&gt;NextResponse)
    {
        **nrpp = rr;
        <span class="enscript-comment">// NR_AdditionalTo must point to a record with NR_AnswerTo set (and not NR_AdditionalTo)
</span>        <span class="enscript-comment">// If 'add' does not meet this requirement, then follow its NR_AdditionalTo pointer to a record that does
</span>        <span class="enscript-comment">// The referenced record will definitely be acceptable (by recursive application of this rule)
</span>        <span class="enscript-keyword">if</span> (add &amp;&amp; add-&gt;NR_AdditionalTo) add = add-&gt;NR_AdditionalTo;
        rr-&gt;NR_AdditionalTo = add;
        *nrpp = &amp;rr-&gt;NextResponse;
    }
    debugf(<span class="enscript-string">&quot;AddRecordToResponseList: %##s (%s) already in list&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AddRRSetAdditionalsToResponseList</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord ***nrpp, AuthRecord *rr, AuthRecord *additional, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    AuthRecord *rr2;
    <span class="enscript-keyword">if</span> (additional-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
    {
        <span class="enscript-keyword">for</span> (rr2 = m-&gt;ResourceRecords; rr2; rr2 = rr2-&gt;next)
        {
            <span class="enscript-keyword">if</span> ((rr2-&gt;resrec.namehash == additional-&gt;resrec.namehash) &amp;&amp;
                (rr2-&gt;resrec.rrtype   == additional-&gt;resrec.rrtype) &amp;&amp;
                (rr2 != additional) &amp;&amp;
                (rr2-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) &amp;&amp;
                (rr2-&gt;resrec.rrclass  == additional-&gt;resrec.rrclass) &amp;&amp;
                ResourceRecordIsValidInterfaceAnswer(rr2, InterfaceID) &amp;&amp;
                SameDomainName(rr2-&gt;resrec.name, additional-&gt;resrec.name))
            {
                AddRecordToResponseList(nrpp, rr2, rr);
            }
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AddAdditionalsToResponseList</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *ResponseRecords, AuthRecord ***nrpp, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    AuthRecord  *rr, *rr2;
    <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)           <span class="enscript-comment">// For each record we plan to put
</span>    {
        <span class="enscript-comment">// (Note: This is an &quot;if&quot;, not a &quot;while&quot;. If we add a record, we'll find it again
</span>        <span class="enscript-comment">// later in the &quot;for&quot; loop, and we will follow further &quot;additional&quot; links then.)
</span>        <span class="enscript-keyword">if</span> (rr-&gt;Additional1 &amp;&amp; ResourceRecordIsValidInterfaceAnswer(rr-&gt;Additional1, InterfaceID))
        {
            AddRecordToResponseList(nrpp, rr-&gt;Additional1, rr);
            AddRRSetAdditionalsToResponseList(m, nrpp, rr, rr-&gt;Additional1, InterfaceID);
        }

        <span class="enscript-keyword">if</span> (rr-&gt;Additional2 &amp;&amp; ResourceRecordIsValidInterfaceAnswer(rr-&gt;Additional2, InterfaceID))
        {
            AddRecordToResponseList(nrpp, rr-&gt;Additional2, rr);
            AddRRSetAdditionalsToResponseList(m, nrpp, rr, rr-&gt;Additional2, InterfaceID);
        }

        <span class="enscript-comment">// For SRV records, automatically add the Address record(s) for the target host
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV)
        {
            <span class="enscript-keyword">for</span> (rr2=m-&gt;ResourceRecords; rr2; rr2=rr2-&gt;next)                    <span class="enscript-comment">// Scan list of resource records
</span>                <span class="enscript-keyword">if</span> (RRTypeIsAddressType(rr2-&gt;resrec.rrtype) &amp;&amp;                  <span class="enscript-comment">// For all address records (A/AAAA) ...
</span>                    ResourceRecordIsValidInterfaceAnswer(rr2, InterfaceID) &amp;&amp;   <span class="enscript-comment">// ... which are valid for answer ...
</span>                    rr-&gt;resrec.rdatahash == rr2-&gt;resrec.namehash &amp;&amp;         <span class="enscript-comment">// ... whose name is the name of the SRV target
</span>                    SameDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.srv.target, rr2-&gt;resrec.name))
                    AddRecordToResponseList(nrpp, rr2, rr);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (RRTypeIsAddressType(rr-&gt;resrec.rrtype))    <span class="enscript-comment">// For A or AAAA, put counterpart as additional
</span>        {
            <span class="enscript-keyword">for</span> (rr2=m-&gt;ResourceRecords; rr2; rr2=rr2-&gt;next)                    <span class="enscript-comment">// Scan list of resource records
</span>                <span class="enscript-keyword">if</span> (RRTypeIsAddressType(rr2-&gt;resrec.rrtype) &amp;&amp;                  <span class="enscript-comment">// For all address records (A/AAAA) ...
</span>                    ResourceRecordIsValidInterfaceAnswer(rr2, InterfaceID) &amp;&amp;   <span class="enscript-comment">// ... which are valid for answer ...
</span>                    rr-&gt;resrec.namehash == rr2-&gt;resrec.namehash &amp;&amp;              <span class="enscript-comment">// ... and have the same name
</span>                    SameDomainName(rr-&gt;resrec.name, rr2-&gt;resrec.name))
                    AddRecordToResponseList(nrpp, rr2, rr);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_PTR)         <span class="enscript-comment">// For service PTR, see if we want to add DeviceInfo record
</span>        {
            <span class="enscript-keyword">if</span> (ResourceRecordIsValidInterfaceAnswer(&amp;m-&gt;DeviceInfo, InterfaceID) &amp;&amp;
                SameDomainLabel(rr-&gt;resrec.rdata-&gt;u.name.c, m-&gt;DeviceInfo.resrec.name-&gt;c))
                AddRecordToResponseList(nrpp, &amp;m-&gt;DeviceInfo, rr);
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendDelayedUnicastResponse</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dest, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    AuthRecord *rr;
    AuthRecord  *ResponseRecords = mDNSNULL;
    AuthRecord **nrp             = &amp;ResponseRecords;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, InterfaceID);

    <span class="enscript-comment">// Make a list of all our records that need to be unicast to this destination
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-comment">// If we find we can no longer unicast this answer, clear ImmedUnicast
</span>        <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer == mDNSInterfaceMark               ||
            mDNSSameIPv4Address(rr-&gt;v4Requester, onesIPv4Addr) ||
            mDNSSameIPv6Address(rr-&gt;v6Requester, onesIPv6Addr)  )
            rr-&gt;ImmedUnicast = mDNSfalse;

        <span class="enscript-keyword">if</span> (rr-&gt;ImmedUnicast &amp;&amp; rr-&gt;ImmedAnswer == InterfaceID)
        {
            <span class="enscript-keyword">if</span> ((dest-&gt;type == mDNSAddrType_IPv4 &amp;&amp; mDNSSameIPv4Address(rr-&gt;v4Requester, dest-&gt;ip.v4)) ||
                (dest-&gt;type == mDNSAddrType_IPv6 &amp;&amp; mDNSSameIPv6Address(rr-&gt;v6Requester, dest-&gt;ip.v6)))
            {
                rr-&gt;ImmedAnswer  = mDNSNULL;                <span class="enscript-comment">// Clear the state fields
</span>                rr-&gt;ImmedUnicast = mDNSfalse;
                rr-&gt;v4Requester  = zerov4Addr;
                rr-&gt;v6Requester  = zerov6Addr;

                <span class="enscript-comment">// Only sent records registered for P2P over P2P interfaces
</span>                <span class="enscript-keyword">if</span> (intf &amp;&amp; !mDNSPlatformValidRecordForInterface(rr, intf-&gt;InterfaceID))
                {
                    <span class="enscript-keyword">continue</span>;
                }

                <span class="enscript-keyword">if</span> (rr-&gt;NextResponse == mDNSNULL &amp;&amp; nrp != &amp;rr-&gt;NextResponse)   <span class="enscript-comment">// rr-&gt;NR_AnswerTo
</span>                {
                    rr-&gt;NR_AnswerTo = NR_AnswerMulticast;
                    *nrp = rr;
                    nrp = &amp;rr-&gt;NextResponse;
                }
            }
        }
    }

    AddAdditionalsToResponseList(m, ResponseRecords, &amp;nrp, InterfaceID);

    <span class="enscript-keyword">while</span> (ResponseRecords)
    {
        mDNSu8 *responseptr = m-&gt;omsg.data;
        mDNSu8 *newptr;
        InitializeDNSMessage(&amp;m-&gt;omsg.h, zeroID, ResponseFlags);

        <span class="enscript-comment">// Put answers in the packet
</span>        <span class="enscript-keyword">while</span> (ResponseRecords &amp;&amp; ResponseRecords-&gt;NR_AnswerTo)
        {
            rr = ResponseRecords;
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;        <span class="enscript-comment">// Temporarily set the cache flush bit so PutResourceRecord will set it
</span>
            newptr = PutResourceRecord(&amp;m-&gt;omsg, responseptr, &amp;m-&gt;omsg.h.numAnswers, &amp;rr-&gt;resrec);

            rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;           <span class="enscript-comment">// Make sure to clear cache flush bit back to normal state
</span>            <span class="enscript-keyword">if</span> (!newptr &amp;&amp; m-&gt;omsg.h.numAnswers)
            {
                <span class="enscript-keyword">break</span>; <span class="enscript-comment">// If packet full, send it now
</span>            }
            <span class="enscript-keyword">if</span> (newptr) responseptr = newptr;
            ResponseRecords = rr-&gt;NextResponse;
            rr-&gt;NextResponse    = mDNSNULL;
            rr-&gt;NR_AnswerTo     = mDNSNULL;
            rr-&gt;NR_AdditionalTo = mDNSNULL;
            rr-&gt;RequireGoodbye  = mDNStrue;
        }

        <span class="enscript-comment">// Add additionals, if there's space
</span>        <span class="enscript-keyword">while</span> (ResponseRecords &amp;&amp; !ResponseRecords-&gt;NR_AnswerTo)
        {
            rr = ResponseRecords;
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;        <span class="enscript-comment">// Temporarily set the cache flush bit so PutResourceRecord will set it
</span>            newptr = PutResourceRecord(&amp;m-&gt;omsg, responseptr, &amp;m-&gt;omsg.h.numAdditionals, &amp;rr-&gt;resrec);
            rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;           <span class="enscript-comment">// Make sure to clear cache flush bit back to normal state
</span>
            <span class="enscript-keyword">if</span> (newptr) responseptr = newptr;
            <span class="enscript-keyword">if</span> (newptr &amp;&amp; m-&gt;omsg.h.numAnswers) rr-&gt;RequireGoodbye = mDNStrue;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) rr-&gt;ImmedAnswer = mDNSInterfaceMark;
            ResponseRecords = rr-&gt;NextResponse;
            rr-&gt;NextResponse    = mDNSNULL;
            rr-&gt;NR_AnswerTo     = mDNSNULL;
            rr-&gt;NR_AdditionalTo = mDNSNULL;
        }

        <span class="enscript-keyword">if</span> (m-&gt;omsg.h.numAnswers)
            mDNSSendDNSMessage(m, &amp;m-&gt;omsg, responseptr, InterfaceID, mDNSNULL, mDNSNULL, dest, MulticastDNSPort, mDNSNULL, mDNSfalse);
    }
}

<span class="enscript-comment">// CompleteDeregistration guarantees that on exit the record will have been cut from the m-&gt;ResourceRecords list
</span><span class="enscript-comment">// and the client's mStatus_MemFree callback will have been invoked
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">CompleteDeregistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    LogInfo(<span class="enscript-string">&quot;CompleteDeregistration: called for Resource record %s&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-comment">// Clearing rr-&gt;RequireGoodbye signals mDNS_Deregister_internal() that
</span>    <span class="enscript-comment">// it should go ahead and immediately dispose of this registration
</span>    rr-&gt;resrec.RecordType = kDNSRecordTypeShared;
    rr-&gt;RequireGoodbye    = mDNSfalse;
    rr-&gt;WakeUp.HMAC       = zeroEthAddr;
    <span class="enscript-keyword">if</span> (rr-&gt;AnsweredLocalQ) { AnswerAllLocalQuestionsWithLocalAuthRecord(m, rr, QC_rmv); rr-&gt;AnsweredLocalQ = mDNSfalse; }
    mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);     <span class="enscript-comment">// Don't touch rr after this
</span>}

<span class="enscript-comment">// DiscardDeregistrations is used on shutdown and sleep to discard (forcibly and immediately)
</span><span class="enscript-comment">// any deregistering records that remain in the m-&gt;ResourceRecords list.
</span><span class="enscript-comment">// DiscardDeregistrations calls mDNS_Deregister_internal which can call a user callback,
</span><span class="enscript-comment">// which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DiscardDeregistrations</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;DiscardDeregistrations ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = m-&gt;ResourceRecords;

    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
            CompleteDeregistration(m, rr);      <span class="enscript-comment">// Don't touch rr after this
</span>        <span class="enscript-keyword">else</span>
            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">GetLabelDecimalValue</span>(<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> src, mDNSu8 *dst)
{
    <span class="enscript-type">int</span> i, val = 0;
    <span class="enscript-keyword">if</span> (src[0] &lt; 1 || src[0] &gt; 3) <span class="enscript-keyword">return</span>(mStatus_Invalid);
    <span class="enscript-keyword">for</span> (i=1; i&lt;=src[0]; i++)
    {
        <span class="enscript-keyword">if</span> (src[i] &lt; <span class="enscript-string">'0'</span> || src[i] &gt; <span class="enscript-string">'9'</span>) <span class="enscript-keyword">return</span>(mStatus_Invalid);
        val = val * 10 + src[i] - <span class="enscript-string">'0'</span>;
    }
    <span class="enscript-keyword">if</span> (val &gt; 255) <span class="enscript-keyword">return</span>(mStatus_Invalid);
    *dst = (mDNSu8)val;
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSlocal mStatus <span class="enscript-function-name">GetIPv4FromName</span>(mDNSAddr *<span class="enscript-type">const</span> a, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">int</span> skip = CountLabels(name) - 6;
    <span class="enscript-keyword">if</span> (skip &lt; 0) { LogMsg(<span class="enscript-string">&quot;GetIPFromName: Need six labels in IPv4 reverse mapping name %##s&quot;</span>, name); <span class="enscript-keyword">return</span> mStatus_Invalid; }
    <span class="enscript-keyword">if</span> (GetLabelDecimalValue(SkipLeadingLabels(name, skip+3)-&gt;c, &amp;a-&gt;ip.v4.b[0]) ||
        GetLabelDecimalValue(SkipLeadingLabels(name, skip+2)-&gt;c, &amp;a-&gt;ip.v4.b[1]) ||
        GetLabelDecimalValue(SkipLeadingLabels(name, skip+1)-&gt;c, &amp;a-&gt;ip.v4.b[2]) ||
        GetLabelDecimalValue(SkipLeadingLabels(name, skip+0)-&gt;c, &amp;a-&gt;ip.v4.b[3])) <span class="enscript-keyword">return</span> mStatus_Invalid;
    a-&gt;type = mDNSAddrType_IPv4;
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">HexVal</span>(X) ( ((X) &gt;= <span class="enscript-string">'0'</span> &amp;&amp; (X) &lt;= <span class="enscript-string">'9'</span>) ? ((X) - <span class="enscript-string">'0'</span>     ) :   \
                    ((X) &gt;= <span class="enscript-string">'A'</span> &amp;&amp; (X) &lt;= <span class="enscript-string">'F'</span>) ? ((X) - <span class="enscript-string">'A'</span> + 10) :   \
                    ((X) &gt;= <span class="enscript-string">'a'</span> &amp;&amp; (X) &lt;= <span class="enscript-string">'f'</span>) ? ((X) - <span class="enscript-string">'a'</span> + 10) : -1)

mDNSlocal mStatus <span class="enscript-function-name">GetIPv6FromName</span>(mDNSAddr *<span class="enscript-type">const</span> a, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">int</span> i, h, l;
    <span class="enscript-type">const</span> domainname *n;

    <span class="enscript-type">int</span> skip = CountLabels(name) - 34;
    <span class="enscript-keyword">if</span> (skip &lt; 0) { LogMsg(<span class="enscript-string">&quot;GetIPFromName: Need 34 labels in IPv6 reverse mapping name %##s&quot;</span>, name); <span class="enscript-keyword">return</span> mStatus_Invalid; }

    n = SkipLeadingLabels(name, skip);
    <span class="enscript-keyword">for</span> (i=0; i&lt;16; i++)
    {
        <span class="enscript-keyword">if</span> (n-&gt;c[0] != 1) <span class="enscript-keyword">return</span> mStatus_Invalid;
        l = HexVal(n-&gt;c[1]);
        n = (<span class="enscript-type">const</span> domainname *)(n-&gt;c + 2);

        <span class="enscript-keyword">if</span> (n-&gt;c[0] != 1) <span class="enscript-keyword">return</span> mStatus_Invalid;
        h = HexVal(n-&gt;c[1]);
        n = (<span class="enscript-type">const</span> domainname *)(n-&gt;c + 2);

        <span class="enscript-keyword">if</span> (l&lt;0 || h&lt;0) <span class="enscript-keyword">return</span> mStatus_Invalid;
        a-&gt;ip.v6.b[15-i] = (mDNSu8)((h &lt;&lt; 4) | l);
    }

    a-&gt;type = mDNSAddrType_IPv6;
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSlocal mDNSs32 <span class="enscript-function-name">ReverseMapDomainType</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">int</span> skip = CountLabels(name) - 2;
    <span class="enscript-keyword">if</span> (skip &gt;= 0)
    {
        <span class="enscript-type">const</span> domainname *suffix = SkipLeadingLabels(name, skip);
        <span class="enscript-keyword">if</span> (SameDomainName(suffix, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x7&quot;</span> <span class="enscript-string">&quot;in-addr&quot;</span> <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>)) <span class="enscript-keyword">return</span> mDNSAddrType_IPv4;
        <span class="enscript-keyword">if</span> (SameDomainName(suffix, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;ip6&quot;</span>     <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>)) <span class="enscript-keyword">return</span> mDNSAddrType_IPv6;
    }
    <span class="enscript-keyword">return</span>(mDNSAddrType_None);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendARP</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu8 op, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr,
                       <span class="enscript-type">const</span> mDNSv4Addr *<span class="enscript-type">const</span> spa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> tha, <span class="enscript-type">const</span> mDNSv4Addr *<span class="enscript-type">const</span> tpa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> dst)
{
    <span class="enscript-type">int</span> i;
    mDNSu8 *ptr = m-&gt;omsg.data;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, rr-&gt;resrec.InterfaceID);
    <span class="enscript-keyword">if</span> (!intf) { LogMsg(<span class="enscript-string">&quot;SendARP: No interface with InterfaceID %p found %s&quot;</span>, rr-&gt;resrec.InterfaceID, ARDisplayString(m,rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// 0x00 Destination address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = dst-&gt;b[i];

    <span class="enscript-comment">// 0x06 Source address (Note: Since we don't currently set the BIOCSHDRCMPLT option, BPF will fill in the real interface address for us)
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = intf-&gt;MAC.b[0];

    <span class="enscript-comment">// 0x0C ARP Ethertype (0x0806)
</span>    *ptr++ = 0x08; *ptr++ = 0x06;

    <span class="enscript-comment">// 0x0E ARP header
</span>    *ptr++ = 0x00; *ptr++ = 0x01;   <span class="enscript-comment">// Hardware address space; Ethernet = 1
</span>    *ptr++ = 0x08; *ptr++ = 0x00;   <span class="enscript-comment">// Protocol address space; IP = 0x0800
</span>    *ptr++ = 6;                     <span class="enscript-comment">// Hardware address length
</span>    *ptr++ = 4;                     <span class="enscript-comment">// Protocol address length
</span>    *ptr++ = 0x00; *ptr++ = op;     <span class="enscript-comment">// opcode; Request = 1, Response = 2
</span>
    <span class="enscript-comment">// 0x16 Sender hardware address (our MAC address)
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = intf-&gt;MAC.b[i];

    <span class="enscript-comment">// 0x1C Sender protocol address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;4; i++) *ptr++ = spa-&gt;b[i];

    <span class="enscript-comment">// 0x20 Target hardware address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = tha-&gt;b[i];

    <span class="enscript-comment">// 0x26 Target protocol address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;4; i++) *ptr++ = tpa-&gt;b[i];

    <span class="enscript-comment">// 0x2A Total ARP Packet length 42 bytes
</span>    mDNSPlatformSendRawPacket(m-&gt;omsg.data, ptr, rr-&gt;resrec.InterfaceID);
}

mDNSlocal mDNSu16 <span class="enscript-function-name">CheckSum</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> data, mDNSs32 length, mDNSu32 sum)
{
    <span class="enscript-type">const</span> mDNSu16 *ptr = data;
    <span class="enscript-keyword">while</span> (length &gt; 0) { length -= 2; sum += *ptr++; }
    sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16);
    sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16);
    <span class="enscript-keyword">return</span>(sum != 0xFFFF ? sum : 0);
}

mDNSlocal mDNSu16 <span class="enscript-function-name">IPv6CheckSum</span>(<span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> src, <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> dst, <span class="enscript-type">const</span> mDNSu8 protocol, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> data, <span class="enscript-type">const</span> mDNSu32 length)
{
    IPv6PseudoHeader ph;
    ph.src = *src;
    ph.dst = *dst;
    ph.len.b[0] = length &gt;&gt; 24;
    ph.len.b[1] = length &gt;&gt; 16;
    ph.len.b[2] = length &gt;&gt; 8;
    ph.len.b[3] = length;
    ph.pro.b[0] = 0;
    ph.pro.b[1] = 0;
    ph.pro.b[2] = 0;
    ph.pro.b[3] = protocol;
    <span class="enscript-keyword">return</span> CheckSum(&amp;ph, <span class="enscript-keyword">sizeof</span>(ph), CheckSum(data, length, 0));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendNDP</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu8 op, <span class="enscript-type">const</span> mDNSu8 flags, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr,
                       <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> spa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> tha, <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> tpa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> dst)
{
    <span class="enscript-type">int</span> i;
    mDNSOpaque16 checksum;
    mDNSu8 *ptr = m-&gt;omsg.data;
    <span class="enscript-comment">// Some recipient hosts seem to ignore Neighbor Solicitations if the IPv6-layer destination address is not the
</span>    <span class="enscript-comment">// appropriate IPv6 solicited node multicast address, so we use that IPv6-layer destination address, even though
</span>    <span class="enscript-comment">// at the Ethernet-layer we unicast the packet to the intended target, to avoid wasting network bandwidth.
</span>    <span class="enscript-type">const</span> mDNSv6Addr mc = { { 0xFF,0x02,0x00,0x00, 0,0,0,0, 0,0,0,1, 0xFF,tpa-&gt;b[0xD],tpa-&gt;b[0xE],tpa-&gt;b[0xF] } };
    <span class="enscript-type">const</span> mDNSv6Addr *<span class="enscript-type">const</span> v6dst = (op == NDP_Sol) ? &amp;mc : tpa;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, rr-&gt;resrec.InterfaceID);
    <span class="enscript-keyword">if</span> (!intf) { LogMsg(<span class="enscript-string">&quot;SendNDP: No interface with InterfaceID %p found %s&quot;</span>, rr-&gt;resrec.InterfaceID, ARDisplayString(m,rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// 0x00 Destination address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = dst-&gt;b[i];
    <span class="enscript-comment">// Right now we only send Neighbor Solicitations to verify whether the host we're proxying for has gone to sleep yet.
</span>    <span class="enscript-comment">// Since we know who we're looking for, we send it via Ethernet-layer unicast, rather than bothering every host on the
</span>    <span class="enscript-comment">// link with a pointless link-layer multicast.
</span>    <span class="enscript-comment">// Should we want to send traditional Neighbor Solicitations in the future, where we really don't know in advance what
</span>    <span class="enscript-comment">// Ethernet-layer address we're looking for, we'll need to send to the appropriate Ethernet-layer multicast address:
</span>    <span class="enscript-comment">// *ptr++ = 0x33;
</span>    <span class="enscript-comment">// *ptr++ = 0x33;
</span>    <span class="enscript-comment">// *ptr++ = 0xFF;
</span>    <span class="enscript-comment">// *ptr++ = tpa-&gt;b[0xD];
</span>    <span class="enscript-comment">// *ptr++ = tpa-&gt;b[0xE];
</span>    <span class="enscript-comment">// *ptr++ = tpa-&gt;b[0xF];
</span>
    <span class="enscript-comment">// 0x06 Source address (Note: Since we don't currently set the BIOCSHDRCMPLT option, BPF will fill in the real interface address for us)
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = (tha ? *tha : intf-&gt;MAC).b[i];

    <span class="enscript-comment">// 0x0C IPv6 Ethertype (0x86DD)
</span>    *ptr++ = 0x86; *ptr++ = 0xDD;

    <span class="enscript-comment">// 0x0E IPv6 header
</span>    *ptr++ = 0x60; *ptr++ = 0x00; *ptr++ = 0x00; *ptr++ = 0x00;     <span class="enscript-comment">// Version, Traffic Class, Flow Label
</span>    *ptr++ = 0x00; *ptr++ = 0x20;                                   <span class="enscript-comment">// Length
</span>    *ptr++ = 0x3A;                                                  <span class="enscript-comment">// Protocol == ICMPv6
</span>    *ptr++ = 0xFF;                                                  <span class="enscript-comment">// Hop Limit
</span>
    <span class="enscript-comment">// 0x16 Sender IPv6 address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;16; i++) *ptr++ = spa-&gt;b[i];

    <span class="enscript-comment">// 0x26 Destination IPv6 address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;16; i++) *ptr++ = v6dst-&gt;b[i];

    <span class="enscript-comment">// 0x36 NDP header
</span>    *ptr++ = op;                    <span class="enscript-comment">// 0x87 == Neighbor Solicitation, 0x88 == Neighbor Advertisement
</span>    *ptr++ = 0x00;                  <span class="enscript-comment">// Code
</span>    *ptr++ = 0x00; *ptr++ = 0x00;   <span class="enscript-comment">// Checksum placeholder (0x38, 0x39)
</span>    *ptr++ = flags;
    *ptr++ = 0x00; *ptr++ = 0x00; *ptr++ = 0x00;

    <span class="enscript-keyword">if</span> (op == NDP_Sol)  <span class="enscript-comment">// Neighbor Solicitation. The NDP &quot;target&quot; is the address we seek.
</span>    {
        <span class="enscript-comment">// 0x3E NDP target.
</span>        <span class="enscript-keyword">for</span> (i=0; i&lt;16; i++) *ptr++ = tpa-&gt;b[i];
        <span class="enscript-comment">// 0x4E Source Link-layer Address
</span>        <span class="enscript-comment">// &lt;<a href="http://www.ietf.org/rfc/rfc2461.txt">http://www.ietf.org/rfc/rfc2461.txt</a>&gt;
</span>        <span class="enscript-comment">// MUST NOT be included when the source IP address is the unspecified address.
</span>        <span class="enscript-comment">// Otherwise, on link layers that have addresses this option MUST be included
</span>        <span class="enscript-comment">// in multicast solicitations and SHOULD be included in unicast solicitations.
</span>        <span class="enscript-keyword">if</span> (!mDNSIPv6AddressIsZero(*spa))
        {
            *ptr++ = NDP_SrcLL; <span class="enscript-comment">// Option Type 1 == Source Link-layer Address
</span>            *ptr++ = 0x01;      <span class="enscript-comment">// Option length 1 (in units of 8 octets)
</span>            <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = (tha ? *tha : intf-&gt;MAC).b[i];
        }
    }
    <span class="enscript-keyword">else</span>            <span class="enscript-comment">// Neighbor Advertisement. The NDP &quot;target&quot; is the address we're giving information about.
</span>    {
        <span class="enscript-comment">// 0x3E NDP target.
</span>        <span class="enscript-keyword">for</span> (i=0; i&lt;16; i++) *ptr++ = spa-&gt;b[i];
        <span class="enscript-comment">// 0x4E Target Link-layer Address
</span>        *ptr++ = NDP_TgtLL; <span class="enscript-comment">// Option Type 2 == Target Link-layer Address
</span>        *ptr++ = 0x01;      <span class="enscript-comment">// Option length 1 (in units of 8 octets)
</span>        <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = (tha ? *tha : intf-&gt;MAC).b[i];
    }

    <span class="enscript-comment">// 0x4E or 0x56 Total NDP Packet length 78 or 86 bytes
</span>    m-&gt;omsg.data[0x13] = ptr - &amp;m-&gt;omsg.data[0x36];     <span class="enscript-comment">// Compute actual length
</span>    checksum.NotAnInteger = ~IPv6CheckSum(spa, v6dst, 0x3A, &amp;m-&gt;omsg.data[0x36], m-&gt;omsg.data[0x13]);
    m-&gt;omsg.data[0x38] = checksum.b[0];
    m-&gt;omsg.data[0x39] = checksum.b[1];

    mDNSPlatformSendRawPacket(m-&gt;omsg.data, ptr, rr-&gt;resrec.InterfaceID);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetupTracerOpt</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, rdataOPT *<span class="enscript-type">const</span> Trace)
{
    mDNSu32 DNS_VERS = _DNS_SD_H;
    Trace-&gt;u.tracer.platf    = m-&gt;mDNS_plat;
    Trace-&gt;u.tracer.mDNSv    = DNS_VERS;

    Trace-&gt;opt              = kDNSOpt_Trace;
    Trace-&gt;optlen           = DNSOpt_TraceData_Space - 4;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetupOwnerOpt</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, rdataOPT *<span class="enscript-type">const</span> owner)
{
    owner-&gt;u.owner.vers     = 0;
    owner-&gt;u.owner.seq      = m-&gt;SleepSeqNum;
    owner-&gt;u.owner.HMAC     = m-&gt;PrimaryMAC;
    owner-&gt;u.owner.IMAC     = intf-&gt;MAC;
    owner-&gt;u.owner.password = zeroEthAddr;

    <span class="enscript-comment">// Don't try to compute the optlen until *after* we've set up the data fields
</span>    <span class="enscript-comment">// Right now the DNSOpt_Owner_Space macro does not depend on the owner-&gt;u.owner being set up correctly, but in the future it might
</span>    owner-&gt;opt              = kDNSOpt_Owner;
    owner-&gt;optlen           = DNSOpt_Owner_Space(&amp;m-&gt;PrimaryMAC, &amp;intf-&gt;MAC) - 4;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GrantUpdateCredit</span>(AuthRecord *rr)
{
    <span class="enscript-keyword">if</span> (++rr-&gt;UpdateCredits &gt;= kMaxUpdateCredits) rr-&gt;NextUpdateCredit = 0;
    <span class="enscript-keyword">else</span> rr-&gt;NextUpdateCredit = NonZeroTime(rr-&gt;NextUpdateCredit + kUpdateCreditRefreshInterval);
}

mDNSlocal mDNSBool <span class="enscript-function-name">ShouldSendGoodbyesBeforeSleep</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> NetworkInterfaceInfo *intf, AuthRecord *rr)
{
    <span class="enscript-comment">// If there are no sleep proxies, we set the state to SleepState_Sleeping explicitly
</span>    <span class="enscript-comment">// and hence there is no need to check for Transfering state. But if we have sleep
</span>    <span class="enscript-comment">// proxies and partially sending goodbyes for some records, we will be in Transfering
</span>    <span class="enscript-comment">// state and hence need to make sure that we send goodbyes in that case too. Checking whether
</span>    <span class="enscript-comment">// we are not awake handles both cases.
</span>    <span class="enscript-keyword">if</span> ((rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) &amp;&amp; (m-&gt;SleepState != SleepState_Awake))
    {
        debugf(<span class="enscript-string">&quot;ShouldSendGoodbyesBeforeSleep: marking for goodbye&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-keyword">if</span> (m-&gt;SleepState != SleepState_Sleeping)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// If we are going to sleep and in SleepState_Sleeping, SendGoodbyes on the interface tell you
</span>    <span class="enscript-comment">// whether you can send goodbyes or not.
</span>    <span class="enscript-keyword">if</span> (!intf-&gt;SendGoodbyes)
    {
        debugf(<span class="enscript-string">&quot;ShouldSendGoodbyesBeforeSleep: not sending goodbye %s, int %p&quot;</span>, ARDisplayString(m, rr), intf-&gt;InterfaceID);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">else</span>
    {
        debugf(<span class="enscript-string">&quot;ShouldSendGoodbyesBeforeSleep: sending goodbye %s, int %p&quot;</span>, ARDisplayString(m, rr), intf-&gt;InterfaceID);
        <span class="enscript-keyword">return</span> mDNStrue;
    }
}

<span class="enscript-comment">// Note about acceleration of announcements to facilitate automatic coalescing of
</span><span class="enscript-comment">// multiple independent threads of announcements into a single synchronized thread:
</span><span class="enscript-comment">// The announcements in the packet may be at different stages of maturity;
</span><span class="enscript-comment">// One-second interval, two-second interval, four-second interval, and so on.
</span><span class="enscript-comment">// After we've put in all the announcements that are due, we then consider
</span><span class="enscript-comment">// whether there are other nearly-due announcements that are worth accelerating.
</span><span class="enscript-comment">// To be eligible for acceleration, a record MUST NOT be older (further along
</span><span class="enscript-comment">// its timeline) than the most mature record we've already put in the packet.
</span><span class="enscript-comment">// In other words, younger records can have their timelines accelerated to catch up
</span><span class="enscript-comment">// with their elder bretheren; this narrows the age gap and helps them eventually get in sync.
</span><span class="enscript-comment">// Older records cannot have their timelines accelerated; this would just widen
</span><span class="enscript-comment">// the gap between them and their younger bretheren and get them even more out of sync.
</span>
<span class="enscript-comment">// Note: SendResponses calls mDNS_Deregister_internal which can call a user callback, which may change
</span><span class="enscript-comment">// the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendResponses</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-type">int</span> pktcount = 0;
    AuthRecord *rr, *r2;
    mDNSs32 maxExistingAnnounceInterval = 0;
    <span class="enscript-type">const</span> NetworkInterfaceInfo *intf = GetFirstActiveInterface(m-&gt;HostInterfaces);

    m-&gt;NextScheduledResponse = m-&gt;timenow + FutureTime;

    <span class="enscript-keyword">if</span> (m-&gt;SleepState == SleepState_Transferring) RetrySPSRegistrations(m);

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;ImmedUnicast)
        {
            mDNSAddr v4 = { mDNSAddrType_IPv4, {{{0}}} };
            mDNSAddr v6 = { mDNSAddrType_IPv6, {{{0}}} };
            v4.ip.v4 = rr-&gt;v4Requester;
            v6.ip.v6 = rr-&gt;v6Requester;
            <span class="enscript-keyword">if</span> (!mDNSIPv4AddressIsZero(rr-&gt;v4Requester)) SendDelayedUnicastResponse(m, &amp;v4, rr-&gt;ImmedAnswer);
            <span class="enscript-keyword">if</span> (!mDNSIPv6AddressIsZero(rr-&gt;v6Requester)) SendDelayedUnicastResponse(m, &amp;v6, rr-&gt;ImmedAnswer);
            <span class="enscript-keyword">if</span> (rr-&gt;ImmedUnicast)
            {
                LogMsg(<span class="enscript-string">&quot;SendResponses: ERROR: rr-&gt;ImmedUnicast still set: %s&quot;</span>, ARDisplayString(m, rr));
                rr-&gt;ImmedUnicast = mDNSfalse;
            }
        }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 1. Setup: Set the SendRNow and ImmedAnswer fields to indicate which interface(s) the records need to be sent on
</span>    <span class="enscript-comment">// ***
</span>
    <span class="enscript-comment">// Run through our list of records, and decide which ones we're going to announce on all interfaces
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">while</span> (rr-&gt;NextUpdateCredit &amp;&amp; m-&gt;timenow - rr-&gt;NextUpdateCredit &gt;= 0) GrantUpdateCredit(rr);
        <span class="enscript-keyword">if</span> (TimeToAnnounceThisRecord(rr, m-&gt;timenow))
        {
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
            {
                <span class="enscript-keyword">if</span> (!rr-&gt;WakeUp.HMAC.l[0])
                {
                    <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount) rr-&gt;ImmedAnswer = mDNSInterfaceMark;     <span class="enscript-comment">// Send goodbye packet on all interfaces
</span>                }
                <span class="enscript-keyword">else</span>
                {
                    mDNSBool unicastOnly;
                    LogSPS(<span class="enscript-string">&quot;SendResponses: Sending wakeup %2d for %.6a %s&quot;</span>, rr-&gt;AnnounceCount-3, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                    unicastOnly = ((rr-&gt;AnnounceCount == WakeupCount) || (rr-&gt;AnnounceCount == WakeupCount - 1)) ? mDNStrue : mDNSfalse;
                    SendWakeup(m, rr-&gt;resrec.InterfaceID, &amp;rr-&gt;WakeUp.IMAC, &amp;rr-&gt;WakeUp.password, unicastOnly);
                    <span class="enscript-keyword">for</span> (r2 = rr; r2; r2=r2-&gt;next)
                        <span class="enscript-keyword">if</span> ((r2-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) &amp;&amp; r2-&gt;AnnounceCount &amp;&amp; (r2-&gt;resrec.InterfaceID == rr-&gt;resrec.InterfaceID) &amp;&amp;
                            mDNSSameEthAddress(&amp;r2-&gt;WakeUp.IMAC, &amp;rr-&gt;WakeUp.IMAC) &amp;&amp; !mDNSSameEthAddress(&amp;zeroEthAddr, &amp;r2-&gt;WakeUp.HMAC))
                        {
                            <span class="enscript-comment">// For now we only want to send a single Unsolicited Neighbor Advertisement restoring the address to the original
</span>                            <span class="enscript-comment">// owner, because these packets can cause some IPv6 stacks to falsely conclude that there's an address conflict.
</span>                            <span class="enscript-keyword">if</span> (r2-&gt;AddressProxy.type == mDNSAddrType_IPv6 &amp;&amp; r2-&gt;AnnounceCount == WakeupCount)
                            {
                                LogSPS(<span class="enscript-string">&quot;NDP Announcement %2d Releasing traffic for H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                                       r2-&gt;AnnounceCount-3, &amp;r2-&gt;WakeUp.HMAC, &amp;r2-&gt;WakeUp.IMAC, ARDisplayString(m,r2));
                                SendNDP(m, NDP_Adv, NDP_Override, r2, &amp;r2-&gt;AddressProxy.ip.v6, &amp;r2-&gt;WakeUp.IMAC, &amp;AllHosts_v6, &amp;AllHosts_v6_Eth);
                            }
                            r2-&gt;LastAPTime = m-&gt;timenow;
                            <span class="enscript-comment">// After 15 wakeups without success (maybe host has left the network) send three goodbyes instead
</span>                            <span class="enscript-keyword">if</span> (--r2-&gt;AnnounceCount &lt;= GoodbyeCount) r2-&gt;WakeUp.HMAC = zeroEthAddr;
                        }
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(rr))
            {
                <span class="enscript-keyword">if</span> (rr-&gt;AddressProxy.type)
                {
                    <span class="enscript-keyword">if</span> (!mDNSSameEthAddress(&amp;zeroEthAddr, &amp;rr-&gt;WakeUp.HMAC))
                    {
                        rr-&gt;AnnounceCount--;
                        rr-&gt;ThisAPInterval *= 2;
                        rr-&gt;LastAPTime = m-&gt;timenow;
                        <span class="enscript-keyword">if</span> (rr-&gt;AddressProxy.type == mDNSAddrType_IPv4)
                        {
                            LogSPS(<span class="enscript-string">&quot;ARP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                                    rr-&gt;AnnounceCount, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m,rr));
                            SendARP(m, 1, rr, &amp;rr-&gt;AddressProxy.ip.v4, &amp;zeroEthAddr, &amp;rr-&gt;AddressProxy.ip.v4, &amp;onesEthAddr);
                        }
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;AddressProxy.type == mDNSAddrType_IPv6)
                        {
                            LogSPS(<span class="enscript-string">&quot;NDP Announcement %2d Capturing traffic for H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                                    rr-&gt;AnnounceCount, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m,rr));
                            SendNDP(m, NDP_Adv, NDP_Override, rr, &amp;rr-&gt;AddressProxy.ip.v6, mDNSNULL, &amp;AllHosts_v6, &amp;AllHosts_v6_Eth);
                        }
                    }
                }
                <span class="enscript-keyword">else</span>
                {
                    rr-&gt;ImmedAnswer = mDNSInterfaceMark;        <span class="enscript-comment">// Send on all interfaces
</span>                    <span class="enscript-keyword">if</span> (maxExistingAnnounceInterval &lt; rr-&gt;ThisAPInterval)
                        maxExistingAnnounceInterval = rr-&gt;ThisAPInterval;
                    <span class="enscript-keyword">if</span> (rr-&gt;UpdateBlocked) rr-&gt;UpdateBlocked = 0;
                }
            }
        }
    }

    <span class="enscript-comment">// Any interface-specific records we're going to send are marked as being sent on all appropriate interfaces (which is just one)
</span>    <span class="enscript-comment">// Eligible records that are more than half-way to their announcement time are accelerated
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> ((rr-&gt;resrec.InterfaceID &amp;&amp; rr-&gt;ImmedAnswer) ||
            (rr-&gt;ThisAPInterval &lt;= maxExistingAnnounceInterval &amp;&amp;
             TimeToAnnounceThisRecord(rr, m-&gt;timenow + rr-&gt;ThisAPInterval/2) &amp;&amp;
             !rr-&gt;AddressProxy.type &amp;&amp;                  <span class="enscript-comment">// Don't include ARP Annoucements when considering which records to accelerate
</span>             ResourceRecordIsValidAnswer(rr)))
            rr-&gt;ImmedAnswer = mDNSInterfaceMark;        <span class="enscript-comment">// Send on all interfaces
</span>
    <span class="enscript-comment">// When sending SRV records (particularly when announcing a new service) automatically add related Address record(s) as additionals
</span>    <span class="enscript-comment">// Note: Currently all address records are interface-specific, so it's safe to set ImmedAdditional to their InterfaceID,
</span>    <span class="enscript-comment">// which will be non-null. If by some chance there is an address record that's not interface-specific (should never happen)
</span>    <span class="enscript-comment">// then all that means is that it won't get sent -- which would not be the end of the world.
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer &amp;&amp; rr-&gt;resrec.rrtype == kDNSType_SRV)
            <span class="enscript-keyword">for</span> (r2=m-&gt;ResourceRecords; r2; r2=r2-&gt;next)                <span class="enscript-comment">// Scan list of resource records
</span>                <span class="enscript-keyword">if</span> (RRTypeIsAddressType(r2-&gt;resrec.rrtype) &amp;&amp;           <span class="enscript-comment">// For all address records (A/AAAA) ...
</span>                    ResourceRecordIsValidAnswer(r2) &amp;&amp;                  <span class="enscript-comment">// ... which are valid for answer ...
</span>                    rr-&gt;LastMCTime - r2-&gt;LastMCTime &gt;= 0 &amp;&amp;             <span class="enscript-comment">// ... which we have not sent recently ...
</span>                    rr-&gt;resrec.rdatahash == r2-&gt;resrec.namehash &amp;&amp;      <span class="enscript-comment">// ... whose name is the name of the SRV target
</span>                    SameDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.srv.target, r2-&gt;resrec.name) &amp;&amp;
                    (rr-&gt;ImmedAnswer == mDNSInterfaceMark || rr-&gt;ImmedAnswer == r2-&gt;resrec.InterfaceID))
                    r2-&gt;ImmedAdditional = r2-&gt;resrec.InterfaceID;       <span class="enscript-comment">// ... then mark this address record for sending too
</span>        <span class="enscript-comment">// We also make sure we send the DeviceInfo TXT record too, if necessary
</span>        <span class="enscript-comment">// We check for RecordType == kDNSRecordTypeShared because we don't want to tag the
</span>        <span class="enscript-comment">// DeviceInfo TXT record onto a goodbye packet (RecordType == kDNSRecordTypeDeregistering).
</span>        <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeShared &amp;&amp; rr-&gt;resrec.rrtype == kDNSType_PTR)
            <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(&amp;m-&gt;DeviceInfo) &amp;&amp; SameDomainLabel(rr-&gt;resrec.rdata-&gt;u.name.c, m-&gt;DeviceInfo.resrec.name-&gt;c))
            {
                <span class="enscript-keyword">if</span> (!m-&gt;DeviceInfo.ImmedAnswer) m-&gt;DeviceInfo.ImmedAnswer = rr-&gt;ImmedAnswer;
                <span class="enscript-keyword">else</span> m-&gt;DeviceInfo.ImmedAnswer = mDNSInterfaceMark;
            }
    }

    <span class="enscript-comment">// If there's a record which is supposed to be unique that we're going to send, then make sure that we give
</span>    <span class="enscript-comment">// the whole RRSet as an atomic unit. That means that if we have any other records with the same name/type/class
</span>    <span class="enscript-comment">// then we need to mark them for sending too. Otherwise, if we set the kDNSClass_UniqueRRSet bit on a
</span>    <span class="enscript-comment">// record, then other RRSet members that have not been sent recently will get flushed out of client caches.
</span>    <span class="enscript-comment">// -- If a record is marked to be sent on a certain interface, make sure the whole set is marked to be sent on that interface
</span>    <span class="enscript-comment">// -- If any record is marked to be sent on all interfaces, make sure the whole set is marked to be sent on all interfaces
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer)            <span class="enscript-comment">// If we're sending this as answer, see that its whole RRSet is similarly marked
</span>            {
                <span class="enscript-keyword">for</span> (r2 = m-&gt;ResourceRecords; r2; r2=r2-&gt;next)
                {
                    <span class="enscript-keyword">if</span> ((r2-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) &amp;&amp; ResourceRecordIsValidAnswer(r2) &amp;&amp;
                        (r2-&gt;ImmedAnswer != mDNSInterfaceMark) &amp;&amp; (r2-&gt;ImmedAnswer != rr-&gt;ImmedAnswer) &amp;&amp;
                        SameResourceRecordSignature(r2, rr) &amp;&amp;
                        ((rr-&gt;ImmedAnswer == mDNSInterfaceMark) || IsInterfaceValidForAuthRecord(r2, rr-&gt;ImmedAnswer)))
                    {
                        r2-&gt;ImmedAnswer = !r2-&gt;ImmedAnswer ? rr-&gt;ImmedAnswer : mDNSInterfaceMark;
                    }
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;ImmedAdditional)   <span class="enscript-comment">// If we're sending this as additional, see that its whole RRSet is similarly marked
</span>            {
                <span class="enscript-keyword">for</span> (r2 = m-&gt;ResourceRecords; r2; r2=r2-&gt;next)
                {
                    <span class="enscript-keyword">if</span> ((r2-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) &amp;&amp; ResourceRecordIsValidAnswer(r2) &amp;&amp;
                        (r2-&gt;ImmedAdditional != rr-&gt;ImmedAdditional) &amp;&amp;
                        SameResourceRecordSignature(r2, rr) &amp;&amp;
                        IsInterfaceValidForAuthRecord(r2, rr-&gt;ImmedAdditional))
                    {
                        r2-&gt;ImmedAdditional = rr-&gt;ImmedAdditional;
                    }
                }
            }
        }

    <span class="enscript-comment">// Now set SendRNow state appropriately
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer == mDNSInterfaceMark)       <span class="enscript-comment">// Sending this record on all appropriate interfaces
</span>        {
            rr-&gt;SendRNow = !intf ? mDNSNULL : (rr-&gt;resrec.InterfaceID) ? rr-&gt;resrec.InterfaceID : intf-&gt;InterfaceID;
            rr-&gt;ImmedAdditional = mDNSNULL;             <span class="enscript-comment">// No need to send as additional if sending as answer
</span>            rr-&gt;LastMCTime      = m-&gt;timenow;
            rr-&gt;LastMCInterface = rr-&gt;ImmedAnswer;
            rr-&gt;ProbeRestartCount = 0;                  <span class="enscript-comment">// Reset the probe restart count
</span>            <span class="enscript-comment">// If we're announcing this record, and it's at least half-way to its ordained time, then consider this announcement done
</span>            <span class="enscript-keyword">if</span> (TimeToAnnounceThisRecord(rr, m-&gt;timenow + rr-&gt;ThisAPInterval/2))
            {
                rr-&gt;AnnounceCount--;
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering)
                    rr-&gt;ThisAPInterval *= 2;
                rr-&gt;LastAPTime = m-&gt;timenow;
                debugf(<span class="enscript-string">&quot;Announcing %##s (%s) %d&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), rr-&gt;AnnounceCount);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer)                       <span class="enscript-comment">// Else, just respond to a single query on single interface:
</span>        {
            rr-&gt;SendRNow        = rr-&gt;ImmedAnswer;      <span class="enscript-comment">// Just respond on that interface
</span>            rr-&gt;ImmedAdditional = mDNSNULL;             <span class="enscript-comment">// No need to send as additional too
</span>            rr-&gt;LastMCTime      = m-&gt;timenow;
            rr-&gt;LastMCInterface = rr-&gt;ImmedAnswer;
        }
        SetNextAnnounceProbeTime(m, rr);
        <span class="enscript-comment">//if (rr-&gt;SendRNow) LogMsg(&quot;%-15.4a %s&quot;, &amp;rr-&gt;v4Requester, ARDisplayString(m, rr));
</span>    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 2. Loop through interface list, sending records as appropriate
</span>    <span class="enscript-comment">// ***
</span>
    <span class="enscript-keyword">while</span> (intf)
    {
        <span class="enscript-type">int</span> OwnerRecordSpace = (m-&gt;AnnounceOwner &amp;&amp; intf-&gt;MAC.l[0]) ? DNSOpt_Header_Space + DNSOpt_Owner_Space(&amp;m-&gt;PrimaryMAC, &amp;intf-&gt;MAC) : 0;
        <span class="enscript-type">int</span> TraceRecordSpace = (mDNS_McastTracingEnabled &amp;&amp; MDNS_TRACER) ? DNSOpt_Header_Space + DNSOpt_TraceData_Space : 0;
        <span class="enscript-type">int</span> numDereg    = 0;
        <span class="enscript-type">int</span> numAnnounce = 0;
        <span class="enscript-type">int</span> numAnswer   = 0;
        mDNSu8 *responseptr = m-&gt;omsg.data;
        mDNSu8 *newptr;
        InitializeDNSMessage(&amp;m-&gt;omsg.h, zeroID, ResponseFlags);

        <span class="enscript-comment">// First Pass. Look for:
</span>        <span class="enscript-comment">// 1. Deregistering records that need to send their goodbye packet
</span>        <span class="enscript-comment">// 2. Updated records that need to retract their old data
</span>        <span class="enscript-comment">// 3. Answers and announcements we need to send
</span>        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        {

            <span class="enscript-comment">// Skip this interface if the record InterfaceID is *Any and the record is not
</span>            <span class="enscript-comment">// appropriate for the interface type.
</span>            <span class="enscript-keyword">if</span> ((rr-&gt;SendRNow == intf-&gt;InterfaceID) &amp;&amp;
                ((rr-&gt;resrec.InterfaceID == mDNSInterface_Any) &amp;&amp; !mDNSPlatformValidRecordForInterface(rr, intf-&gt;InterfaceID)))
            {
                rr-&gt;SendRNow = GetNextActiveInterfaceID(intf);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;SendRNow == intf-&gt;InterfaceID)
            {
                RData  *OldRData    = rr-&gt;resrec.rdata;
                mDNSu16 oldrdlength = rr-&gt;resrec.rdlength;
                mDNSu8 active = (mDNSu8)
                                (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp; !ShouldSendGoodbyesBeforeSleep(m, intf, rr));
                newptr = mDNSNULL;
                <span class="enscript-keyword">if</span> (rr-&gt;NewRData &amp;&amp; active)
                {
                    <span class="enscript-comment">// See if we should send a courtesy &quot;goodbye&quot; for the old data before we replace it.
</span>                    <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(rr) &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeShared &amp;&amp; rr-&gt;RequireGoodbye)
                    {
                        newptr = PutRR_OS_TTL(responseptr, &amp;m-&gt;omsg.h.numAnswers, &amp;rr-&gt;resrec, 0);
                        <span class="enscript-keyword">if</span> (newptr) { responseptr = newptr; numDereg++; rr-&gt;RequireGoodbye = mDNSfalse; }
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">continue</span>; <span class="enscript-comment">// If this packet is already too full to hold the goodbye for this record, skip it for now and we'll retry later
</span>                    }
                    SetNewRData(&amp;rr-&gt;resrec, rr-&gt;NewRData, rr-&gt;newrdlength);
                }

                <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                    rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;        <span class="enscript-comment">// Temporarily set the cache flush bit so PutResourceRecord will set it
</span>                newptr = PutRR_OS_TTL(responseptr, &amp;m-&gt;omsg.h.numAnswers, &amp;rr-&gt;resrec, active ? rr-&gt;resrec.rroriginalttl : 0);
                rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;           <span class="enscript-comment">// Make sure to clear cache flush bit back to normal state
</span>                <span class="enscript-keyword">if</span> (newptr)
                {
                    responseptr = newptr;
                    rr-&gt;RequireGoodbye = active;
                    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) numDereg++;
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;LastAPTime == m-&gt;timenow) numAnnounce++;<span class="enscript-keyword">else</span> numAnswer++;
                }

                <span class="enscript-keyword">if</span> (rr-&gt;NewRData &amp;&amp; active)
                    SetNewRData(&amp;rr-&gt;resrec, OldRData, oldrdlength);

                <span class="enscript-comment">// The first time through (pktcount==0), if this record is verified unique
</span>                <span class="enscript-comment">// (i.e. typically A, AAAA, SRV, TXT and reverse-mapping PTR), set the flag to add an NSEC too.
</span>                <span class="enscript-keyword">if</span> (!pktcount &amp;&amp; active &amp;&amp; (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveUniqueMask) &amp;&amp; !rr-&gt;SendNSECNow)
                    rr-&gt;SendNSECNow = mDNSInterfaceMark;

                <span class="enscript-keyword">if</span> (newptr)     <span class="enscript-comment">// If succeeded in sending, advance to next interface
</span>                {
                    <span class="enscript-comment">// If sending on all interfaces, go to next interface; else we're finished now
</span>                    <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer == mDNSInterfaceMark &amp;&amp; rr-&gt;resrec.InterfaceID == mDNSInterface_Any)
                        rr-&gt;SendRNow = GetNextActiveInterfaceID(intf);
                    <span class="enscript-keyword">else</span>
                        rr-&gt;SendRNow = mDNSNULL;
                }
            }
        }

        <span class="enscript-comment">// Second Pass. Add additional records, if there's space.
</span>        newptr = responseptr;
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;ImmedAdditional == intf-&gt;InterfaceID)
                <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(rr))
                {
                    <span class="enscript-comment">// If we have at least one answer already in the packet, then plan to add additionals too
</span>                    mDNSBool SendAdditional = (m-&gt;omsg.h.numAnswers &gt; 0);

                    <span class="enscript-comment">// If we're not planning to send any additionals, but this record is a unique one, then
</span>                    <span class="enscript-comment">// make sure we haven't already sent any other members of its RRSet -- if we have, then they
</span>                    <span class="enscript-comment">// will have had the cache flush bit set, so now we need to finish the job and send the rest.
</span>                    <span class="enscript-keyword">if</span> (!SendAdditional &amp;&amp; (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask))
                    {
                        <span class="enscript-type">const</span> AuthRecord *a;
                        <span class="enscript-keyword">for</span> (a = m-&gt;ResourceRecords; a; a=a-&gt;next)
                            <span class="enscript-keyword">if</span> (a-&gt;LastMCTime      == m-&gt;timenow &amp;&amp;
                                a-&gt;LastMCInterface == intf-&gt;InterfaceID &amp;&amp;
                                SameResourceRecordSignature(a, rr)) { SendAdditional = mDNStrue; <span class="enscript-keyword">break</span>; }
                    }
                    <span class="enscript-keyword">if</span> (!SendAdditional)                    <span class="enscript-comment">// If we don't want to send this after all,
</span>                        rr-&gt;ImmedAdditional = mDNSNULL;     <span class="enscript-comment">// then cancel its ImmedAdditional field
</span>                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newptr)                        <span class="enscript-comment">// Else, try to add it if we can
</span>                    {
                        <span class="enscript-comment">// The first time through (pktcount==0), if this record is verified unique
</span>                        <span class="enscript-comment">// (i.e. typically A, AAAA, SRV, TXT and reverse-mapping PTR), set the flag to add an NSEC too.
</span>                        <span class="enscript-keyword">if</span> (!pktcount &amp;&amp; (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveUniqueMask) &amp;&amp; !rr-&gt;SendNSECNow)
                            rr-&gt;SendNSECNow = mDNSInterfaceMark;

                        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                            rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;    <span class="enscript-comment">// Temporarily set the cache flush bit so PutResourceRecord will set it
</span>                        newptr = PutRR_OS(newptr, &amp;m-&gt;omsg.h.numAdditionals, &amp;rr-&gt;resrec);
                        rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;       <span class="enscript-comment">// Make sure to clear cache flush bit back to normal state
</span>                        <span class="enscript-keyword">if</span> (newptr)
                        {
                            responseptr = newptr;
                            rr-&gt;ImmedAdditional = mDNSNULL;
                            rr-&gt;RequireGoodbye = mDNStrue;
                            <span class="enscript-comment">// If we successfully put this additional record in the packet, we record LastMCTime &amp; LastMCInterface.
</span>                            <span class="enscript-comment">// This matters particularly in the case where we have more than one IPv6 (or IPv4) address, because otherwise,
</span>                            <span class="enscript-comment">// when we see our own multicast with the cache flush bit set, if we haven't set LastMCTime, then we'll get
</span>                            <span class="enscript-comment">// all concerned and re-announce our record again to make sure it doesn't get flushed from peer caches.
</span>                            rr-&gt;LastMCTime      = m-&gt;timenow;
                            rr-&gt;LastMCInterface = intf-&gt;InterfaceID;
                        }
                    }
                }

        <span class="enscript-comment">// Third Pass. Add NSEC records, if there's space.
</span>        <span class="enscript-comment">// When we're generating an NSEC record in response to a specify query for that type
</span>        <span class="enscript-comment">// (recognized by rr-&gt;SendNSECNow == intf-&gt;InterfaceID) we should really put the NSEC in the Answer Section,
</span>        <span class="enscript-comment">// not Additional Section, but for now it's easier to handle both cases in this Additional Section loop here.
</span>        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;SendNSECNow == mDNSInterfaceMark || rr-&gt;SendNSECNow == intf-&gt;InterfaceID)
            {
                AuthRecord nsec;
                mDNSu8 *ptr;
                <span class="enscript-type">int</span> len;
                mDNS_SetupResourceRecord(&amp;nsec, mDNSNULL, mDNSInterface_Any, kDNSType_NSEC, rr-&gt;resrec.rroriginalttl, kDNSRecordTypeUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
                nsec.resrec.rrclass |= kDNSClass_UniqueRRSet;
                AssignDomainName(&amp;nsec.namestorage, rr-&gt;resrec.name);
                ptr = nsec.rdatastorage.u.data;
                len = DomainNameLength(rr-&gt;resrec.name);
                <span class="enscript-comment">// We have a nxt name followed by window number, window length and a window bitmap
</span>                nsec.resrec.rdlength = len + 2 + NSEC_MCAST_WINDOW_SIZE;
                <span class="enscript-keyword">if</span> (nsec.resrec.rdlength &lt;= StandardAuthRDSize)
                {
                    mDNSPlatformMemZero(ptr, nsec.resrec.rdlength);
                    AssignDomainName((domainname *)ptr, rr-&gt;resrec.name);
                    ptr += len;
                    *ptr++ = 0; <span class="enscript-comment">// window number
</span>                    *ptr++ = NSEC_MCAST_WINDOW_SIZE; <span class="enscript-comment">// window length
</span>                    <span class="enscript-keyword">for</span> (r2 = m-&gt;ResourceRecords; r2; r2=r2-&gt;next)
                        <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(r2) &amp;&amp; SameResourceRecordNameClassInterface(r2, rr))
                        {
                            <span class="enscript-keyword">if</span> (r2-&gt;resrec.rrtype &gt;= kDNSQType_ANY) { LogMsg(<span class="enscript-string">&quot;SendResponses: Can't create NSEC for record %s&quot;</span>, ARDisplayString(m, r2)); <span class="enscript-keyword">break</span>; }
                            <span class="enscript-keyword">else</span> ptr[r2-&gt;resrec.rrtype &gt;&gt; 3] |= 128 &gt;&gt; (r2-&gt;resrec.rrtype &amp; 7);
                        }
                    newptr = responseptr;
                    <span class="enscript-keyword">if</span> (!r2)    <span class="enscript-comment">// If we successfully built our NSEC record, add it to the packet now
</span>                    {
                        newptr = PutRR_OS(responseptr, &amp;m-&gt;omsg.h.numAdditionals, &amp;nsec.resrec);
                        <span class="enscript-keyword">if</span> (newptr) responseptr = newptr;
                    }
                }
                <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;SendResponses: not enough space (%d)  in authrecord for nsec&quot;</span>, nsec.resrec.rdlength);

                <span class="enscript-comment">// If we successfully put the NSEC record, clear the SendNSECNow flag
</span>                <span class="enscript-comment">// If we consider this NSEC optional, then we unconditionally clear the SendNSECNow flag, even if we fail to put this additional record
</span>                <span class="enscript-keyword">if</span> (newptr || rr-&gt;SendNSECNow == mDNSInterfaceMark)
                {
                    rr-&gt;SendNSECNow = mDNSNULL;
                    <span class="enscript-comment">// Run through remainder of list clearing SendNSECNow flag for all other records which would generate the same NSEC
</span>                    <span class="enscript-keyword">for</span> (r2 = rr-&gt;next; r2; r2=r2-&gt;next)
                        <span class="enscript-keyword">if</span> (SameResourceRecordNameClassInterface(r2, rr))
                            <span class="enscript-keyword">if</span> (r2-&gt;SendNSECNow == mDNSInterfaceMark || r2-&gt;SendNSECNow == intf-&gt;InterfaceID)
                                r2-&gt;SendNSECNow = mDNSNULL;
                }
            }

        <span class="enscript-keyword">if</span> (m-&gt;omsg.h.numAnswers || m-&gt;omsg.h.numAdditionals)
        {
            <span class="enscript-comment">// If we have data to send, add OWNER/TRACER/OWNER+TRACER option if necessary, then send packet
</span>            <span class="enscript-keyword">if</span> (OwnerRecordSpace || TraceRecordSpace)
            {
                AuthRecord opt;
                mDNS_SetupResourceRecord(&amp;opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
                opt.resrec.rrclass    = NormalMaxDNSMessageData;
                opt.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);
                opt.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
                <span class="enscript-keyword">if</span> (OwnerRecordSpace &amp;&amp; TraceRecordSpace)
                {
                    opt.resrec.rdlength   += <span class="enscript-keyword">sizeof</span>(rdataOPT); <span class="enscript-comment">// Two options in this OPT record
</span>                    opt.resrec.rdestimate += <span class="enscript-keyword">sizeof</span>(rdataOPT);
                    SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                    SetupTracerOpt(m, &amp;opt.resrec.rdata-&gt;u.opt[1]);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (OwnerRecordSpace)
                {
                    SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TraceRecordSpace)
                {
                    SetupTracerOpt(m, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                }
                newptr = PutResourceRecord(&amp;m-&gt;omsg, responseptr, &amp;m-&gt;omsg.h.numAdditionals, &amp;opt.resrec);
                <span class="enscript-keyword">if</span> (newptr)
                {
                    responseptr = newptr;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;omsg.h.numAnswers + m-&gt;omsg.h.numAuthorities + m-&gt;omsg.h.numAdditionals == 1)
                {
                    LogInfo(<span class="enscript-string">&quot;SendResponses: No space in packet for %s %s OPT record (%d/%d/%d/%d) %s&quot;</span>, OwnerRecordSpace ? <span class="enscript-string">&quot;OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, TraceRecordSpace ? <span class="enscript-string">&quot;TRACER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                            m-&gt;omsg.h.numQuestions, m-&gt;omsg.h.numAnswers, m-&gt;omsg.h.numAuthorities, m-&gt;omsg.h.numAdditionals, ARDisplayString(m, &amp;opt));
                }
                <span class="enscript-keyword">else</span>
                {
                    LogMsg(<span class="enscript-string">&quot;SendResponses: How did we fail to have space for %s %s OPT record (%d/%d/%d/%d) %s&quot;</span>, OwnerRecordSpace ? <span class="enscript-string">&quot;OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, TraceRecordSpace ? <span class="enscript-string">&quot;TRACER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                           m-&gt;omsg.h.numQuestions, m-&gt;omsg.h.numAnswers, m-&gt;omsg.h.numAuthorities, m-&gt;omsg.h.numAdditionals, ARDisplayString(m, &amp;opt));
                }
            }

            debugf(<span class="enscript-string">&quot;SendResponses: Sending %d Deregistration%s, %d Announcement%s, %d Answer%s, %d Additional%s on %p&quot;</span>,
                   numDereg,                 numDereg                 == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
                   numAnnounce,              numAnnounce              == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
                   numAnswer,                numAnswer                == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
                   m-&gt;omsg.h.numAdditionals, m-&gt;omsg.h.numAdditionals == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>, intf-&gt;InterfaceID);

            <span class="enscript-keyword">if</span> (intf-&gt;IPv4Available) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, responseptr, intf-&gt;InterfaceID, mDNSNULL, mDNSNULL, &amp;AllDNSLinkGroup_v4, MulticastDNSPort, mDNSNULL, mDNSfalse);
            <span class="enscript-keyword">if</span> (intf-&gt;IPv6Available) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, responseptr, intf-&gt;InterfaceID, mDNSNULL, mDNSNULL, &amp;AllDNSLinkGroup_v6, MulticastDNSPort, mDNSNULL, mDNSfalse);
            <span class="enscript-keyword">if</span> (!m-&gt;SuppressSending) m-&gt;SuppressSending = NonZeroTime(m-&gt;timenow + (mDNSPlatformOneSecond+9)/10);
            <span class="enscript-keyword">if</span> (++pktcount &gt;= 1000) { LogMsg(<span class="enscript-string">&quot;SendResponses exceeded loop limit %d: giving up&quot;</span>, pktcount); <span class="enscript-keyword">break</span>; }
            <span class="enscript-comment">// There might be more things to send on this interface, so go around one more time and try again.
</span>        }
        <span class="enscript-keyword">else</span>    <span class="enscript-comment">// Nothing more to send on this interface; go to next
</span>        {
            <span class="enscript-type">const</span> NetworkInterfaceInfo *next = GetFirstActiveInterface(intf-&gt;next);
            #<span class="enscript-keyword">if</span> MDNS_DEBUGMSGS &amp;&amp; 0
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> msg = next ? <span class="enscript-string">&quot;SendResponses: Nothing more on %p; moving to %p&quot;</span> : <span class="enscript-string">&quot;SendResponses: Nothing more on %p&quot;</span>;
            debugf(msg, intf, next);
            #endif
            intf = next;
            pktcount = 0;       <span class="enscript-comment">// When we move to a new interface, reset packet count back to zero -- NSEC generation logic uses it
</span>        }
    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 3. Cleanup: Now that everything is sent, call client callback functions, and reset state variables
</span>    <span class="enscript-comment">// ***
</span>
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;SendResponses ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = m-&gt;ResourceRecords;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        rr = m-&gt;CurrentRecord;
        m-&gt;CurrentRecord = rr-&gt;next;

        <span class="enscript-keyword">if</span> (rr-&gt;SendRNow)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;ARType != AuthRecordLocalOnly &amp;&amp; rr-&gt;ARType != AuthRecordP2P)
                LogInfo(<span class="enscript-string">&quot;SendResponses: No active interface %d to send: %d %02X %s&quot;</span>,
                IIDPrintable(rr-&gt;SendRNow), IIDPrintable(rr-&gt;resrec.InterfaceID), rr-&gt;resrec.RecordType, ARDisplayString(m, rr));
            rr-&gt;SendRNow = mDNSNULL;
        }

        <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer || rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;NewRData) CompleteRDataUpdate(m, rr);   <span class="enscript-comment">// Update our rdata, clear the NewRData pointer, and return memory to the client
</span>
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering &amp;&amp; rr-&gt;AnnounceCount == 0)
            {
                <span class="enscript-comment">// For Unicast, when we get the response from the server, we will call CompleteDeregistration
</span>                <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr)) CompleteDeregistration(m, rr);        <span class="enscript-comment">// Don't touch rr after this
</span>            }
            <span class="enscript-keyword">else</span>
            {
                rr-&gt;ImmedAnswer  = mDNSNULL;
                rr-&gt;ImmedUnicast = mDNSfalse;
                rr-&gt;v4Requester  = zerov4Addr;
                rr-&gt;v6Requester  = zerov6Addr;
            }
        }
    }
    verbosedebugf(<span class="enscript-string">&quot;SendResponses: Next in %ld ticks&quot;</span>, m-&gt;NextScheduledResponse - m-&gt;timenow);
}

<span class="enscript-comment">// Calling CheckCacheExpiration() is an expensive operation because it has to look at the entire cache,
</span><span class="enscript-comment">// so we want to be lazy about how frequently we do it.
</span><span class="enscript-comment">// 1. If a cache record is currently referenced by *no* active questions,
</span><span class="enscript-comment">//    then we don't mind expiring it up to a minute late (who will know?)
</span><span class="enscript-comment">// 2. Else, if a cache record is due for some of its final expiration queries,
</span><span class="enscript-comment">//    we'll allow them to be late by up to 2% of the TTL
</span><span class="enscript-comment">// 3. Else, if a cache record has completed all its final expiration queries without success,
</span><span class="enscript-comment">//    and is expiring, and had an original TTL more than ten seconds, we'll allow it to be one second late
</span><span class="enscript-comment">// 4. Else, it is expiring and had an original TTL of ten seconds or less (includes explicit goodbye packets),
</span><span class="enscript-comment">//    so allow at most 1/10 second lateness
</span><span class="enscript-comment">// 5. For records with rroriginalttl set to zero, that means we really want to delete them immediately
</span><span class="enscript-comment">//    (we have a new record with DelayDelivery set, waiting for the old record to go away before we can notify clients).
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">CacheCheckGracePeriod</span>(CR) (                                                   \
        ((CR)-&gt;CRActiveQuestion == mDNSNULL            ) ? (60 * mDNSPlatformOneSecond) : \
        ((CR)-&gt;UnansweredQueries &lt; MaxUnansweredQueries) ? (TicksTTL(CR)/50)            : \
        ((CR)-&gt;resrec.rroriginalttl &gt; 10               ) ? (mDNSPlatformOneSecond)      : \
        ((CR)-&gt;resrec.rroriginalttl &gt; 0                ) ? (mDNSPlatformOneSecond/10)   : 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NextCacheCheckEvent</span>(CR) ((CR)-&gt;NextRequiredQuery + CacheCheckGracePeriod(CR))

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ScheduleNextCacheCheckTime</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, <span class="enscript-type">const</span> mDNSs32 event)
{
    <span class="enscript-keyword">if</span> (m-&gt;rrcache_nextcheck[slot] - event &gt; 0)
        m-&gt;rrcache_nextcheck[slot] = event;
    <span class="enscript-keyword">if</span> (m-&gt;NextCacheCheck          - event &gt; 0)
        m-&gt;NextCacheCheck          = event;
}

<span class="enscript-comment">// Note: MUST call SetNextCacheCheckTimeForRecord any time we change:
</span><span class="enscript-comment">// rr-&gt;TimeRcvd
</span><span class="enscript-comment">// rr-&gt;resrec.rroriginalttl
</span><span class="enscript-comment">// rr-&gt;UnansweredQueries
</span><span class="enscript-comment">// rr-&gt;CRActiveQuestion
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SetNextCacheCheckTimeForRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr)
{
    rr-&gt;NextRequiredQuery = RRExpireTime(rr);

    <span class="enscript-comment">// If we have an active question, then see if we want to schedule a refresher query for this record.
</span>    <span class="enscript-comment">// Usually we expect to do four queries, at 80-82%, 85-87%, 90-92% and then 95-97% of the TTL.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;CRActiveQuestion &amp;&amp; rr-&gt;UnansweredQueries &lt; MaxUnansweredQueries)
    {
        rr-&gt;NextRequiredQuery -= TicksTTL(rr)/20 * (MaxUnansweredQueries - rr-&gt;UnansweredQueries);
        rr-&gt;NextRequiredQuery += mDNSRandom((mDNSu32)TicksTTL(rr)/50);
        verbosedebugf(<span class="enscript-string">&quot;SetNextCacheCheckTimeForRecord: NextRequiredQuery in %ld sec CacheCheckGracePeriod %d ticks for %s&quot;</span>,
                      (rr-&gt;NextRequiredQuery - m-&gt;timenow) / mDNSPlatformOneSecond, CacheCheckGracePeriod(rr), CRDisplayString(m,rr));
    }
    ScheduleNextCacheCheckTime(m, HashSlotFromNameHash(rr-&gt;resrec.namehash), NextCacheCheckEvent(rr));
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMinimumReconfirmTime</span>                     ((mDNSu32)mDNSPlatformOneSecond *  5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultReconfirmTimeForWake</span>              ((mDNSu32)mDNSPlatformOneSecond *  5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultReconfirmTimeForNoAnswer</span>          ((mDNSu32)mDNSPlatformOneSecond *  5)

<span class="enscript-comment">// Delay before restarting questions on a flapping interface.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultQueryDelayTimeForFlappingInterface</span> ((mDNSu32)mDNSPlatformOneSecond *  3)
<span class="enscript-comment">// After kDefaultQueryDelayTimeForFlappingInterface seconds, allow enough time for up to three queries (0, 1, and 4 seconds)
</span><span class="enscript-comment">// plus three seconds for &quot;response delay&quot; before removing the reconfirmed records from the cache.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultReconfirmTimeForFlappingInterface</span> (kDefaultQueryDelayTimeForFlappingInterface + ((mDNSu32)mDNSPlatformOneSecond *  7))

mDNSexport mStatus <span class="enscript-function-name">mDNS_Reconfirm_internal</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr, mDNSu32 interval)
{
    <span class="enscript-keyword">if</span> (interval &lt; kMinimumReconfirmTime)
        interval = kMinimumReconfirmTime;
    <span class="enscript-keyword">if</span> (interval &gt; 0x10000000)  <span class="enscript-comment">// Make sure interval doesn't overflow when we multiply by four below
</span>        interval = 0x10000000;

    <span class="enscript-comment">// If the expected expiration time for this record is more than interval+33%, then accelerate its expiration
</span>    <span class="enscript-keyword">if</span> (RRExpireTime(rr) - m-&gt;timenow &gt; (mDNSs32)((interval * 4) / 3))
    {
        <span class="enscript-comment">// Add a 33% random amount to the interval, to avoid synchronization between multiple hosts
</span>        <span class="enscript-comment">// For all the reconfirmations in a given batch, we want to use the same random value
</span>        <span class="enscript-comment">// so that the reconfirmation questions can be grouped into a single query packet
</span>        <span class="enscript-keyword">if</span> (!m-&gt;RandomReconfirmDelay) m-&gt;RandomReconfirmDelay = 1 + mDNSRandom(FutureTime);
        interval += m-&gt;RandomReconfirmDelay % ((interval/3) + 1);
        rr-&gt;TimeRcvd          = m-&gt;timenow - (mDNSs32)interval * 3;
        rr-&gt;resrec.rroriginalttl     = (interval * 4 + mDNSPlatformOneSecond - 1) / mDNSPlatformOneSecond;
        SetNextCacheCheckTimeForRecord(m, rr);
    }
    debugf(<span class="enscript-string">&quot;mDNS_Reconfirm_internal:%6ld ticks to go for %s %p&quot;</span>,
           RRExpireTime(rr) - m-&gt;timenow, CRDisplayString(m, rr), rr-&gt;CRActiveQuestion);
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// BuildQuestion puts a question into a DNS Query packet and if successful, updates the value of queryptr.
</span><span class="enscript-comment">// It also appends to the list of known answer records that need to be included,
</span><span class="enscript-comment">// and updates the forcast for the size of the known answer section.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">BuildQuestion</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> NetworkInterfaceInfo *intf, DNSMessage *query, mDNSu8 **queryptr,
                                 DNSQuestion *q, CacheRecord ***kalistptrptr, mDNSu32 *answerforecast)
{
    mDNSBool ucast = (q-&gt;LargeAnswers || q-&gt;RequestUnicast) &amp;&amp; m-&gt;CanReceiveUnicastOn5353 &amp;&amp; intf-&gt;SupportsUnicastMDNSResponse;
    mDNSu16 ucbit = (mDNSu16)(ucast ? kDNSQClass_UnicastResponse : 0);
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = query-&gt;data + NormalMaxDNSMessageData;
    mDNSu8 *newptr = putQuestion(query, *queryptr, limit - *answerforecast, &amp;q-&gt;qname, q-&gt;qtype, (mDNSu16)(q-&gt;qclass | ucbit));
    <span class="enscript-keyword">if</span> (!newptr)
    {
        debugf(<span class="enscript-string">&quot;BuildQuestion: No more space in this packet for question %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    <span class="enscript-keyword">else</span>
    {
        mDNSu32 forecast = *answerforecast;
        <span class="enscript-type">const</span> CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
        CacheRecord *cr;
        CacheRecord **ka = *kalistptrptr;   <span class="enscript-comment">// Make a working copy of the pointer we're going to update
</span>
        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)             <span class="enscript-comment">// If we have a resource record in our cache,
</span>            <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID == q-&gt;SendQNow &amp;&amp;                    <span class="enscript-comment">// received on this interface
</span>                !(cr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask) &amp;&amp;      <span class="enscript-comment">// which is a shared (i.e. not unique) record type
</span>                cr-&gt;NextInKAList == mDNSNULL &amp;&amp; ka != &amp;cr-&gt;NextInKAList &amp;&amp;  <span class="enscript-comment">// which is not already in the known answer list
</span>                cr-&gt;resrec.rdlength &lt;= SmallRecordLimit &amp;&amp;                  <span class="enscript-comment">// which is small enough to sensibly fit in the packet
</span>                SameNameCacheRecordAnswersQuestion(cr, q) &amp;&amp;                <span class="enscript-comment">// which answers our question
</span>                cr-&gt;TimeRcvd + TicksTTL(cr)/2 - m-&gt;timenow &gt;                <span class="enscript-comment">// and its half-way-to-expiry time is at least 1 second away
</span>                mDNSPlatformOneSecond)                                      <span class="enscript-comment">// (also ensures we never include goodbye records with TTL=1)
</span>            {
                <span class="enscript-comment">// We don't want to include unique records in the Known Answer section. The Known Answer section
</span>                <span class="enscript-comment">// is intended to suppress floods of shared-record replies from many other devices on the network.
</span>                <span class="enscript-comment">// That concept really does not apply to unique records, and indeed if we do send a query for
</span>                <span class="enscript-comment">// which we have a unique record already in our cache, then including that unique record as a
</span>                <span class="enscript-comment">// Known Answer, so as to suppress the only answer we were expecting to get, makes little sense.
</span>
                *ka = cr;   <span class="enscript-comment">// Link this record into our known answer chain
</span>                ka = &amp;cr-&gt;NextInKAList;
                <span class="enscript-comment">// We forecast: compressed name (2) type (2) class (2) TTL (4) rdlength (2) rdata (n)
</span>                forecast += 12 + cr-&gt;resrec.rdestimate;
                <span class="enscript-comment">// If we're trying to put more than one question in this packet, and it doesn't fit
</span>                <span class="enscript-comment">// then undo that last question and try again next time
</span>                <span class="enscript-keyword">if</span> (query-&gt;h.numQuestions &gt; 1 &amp;&amp; newptr + forecast &gt;= limit)
                {
                    query-&gt;h.numQuestions--;
                    debugf(<span class="enscript-string">&quot;BuildQuestion: Retracting question %##s (%s) new forecast total %d, total questions %d&quot;</span>,
                           q-&gt;qname.c, DNSTypeName(q-&gt;qtype), newptr + forecast - query-&gt;data, query-&gt;h.numQuestions);
                    ka = *kalistptrptr;     <span class="enscript-comment">// Go back to where we started and retract these answer records
</span>                    <span class="enscript-keyword">while</span> (*ka) { CacheRecord *c = *ka; *ka = mDNSNULL; ka = &amp;c-&gt;NextInKAList; }
                    <span class="enscript-keyword">return</span>(mDNSfalse);      <span class="enscript-comment">// Return false, so we'll try again in the next packet
</span>                }
            }

        <span class="enscript-comment">// Success! Update our state pointers, increment UnansweredQueries as appropriate, and return
</span>        *queryptr        = newptr;              <span class="enscript-comment">// Update the packet pointer
</span>        *answerforecast  = forecast;            <span class="enscript-comment">// Update the forecast
</span>        *kalistptrptr    = ka;                  <span class="enscript-comment">// Update the known answer list pointer
</span>        <span class="enscript-keyword">if</span> (ucast) q-&gt;ExpectUnicastResp = NonZeroTime(m-&gt;timenow);

        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)             <span class="enscript-comment">// For every resource record in our cache,
</span>            <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID == q-&gt;SendQNow &amp;&amp;                    <span class="enscript-comment">// received on this interface
</span>                cr-&gt;NextInKAList == mDNSNULL &amp;&amp; ka != &amp;cr-&gt;NextInKAList &amp;&amp;  <span class="enscript-comment">// which is not in the known answer list
</span>                SameNameCacheRecordAnswersQuestion(cr, q))                  <span class="enscript-comment">// which answers our question
</span>            {
                cr-&gt;UnansweredQueries++;                                    <span class="enscript-comment">// indicate that we're expecting a response
</span>                cr-&gt;LastUnansweredTime = m-&gt;timenow;
                SetNextCacheCheckTimeForRecord(m, cr);
            }

        <span class="enscript-keyword">return</span>(mDNStrue);
    }
}

<span class="enscript-comment">// When we have a query looking for a specified name, but there appear to be no answers with
</span><span class="enscript-comment">// that name, ReconfirmAntecedents() is called with depth=0 to start the reconfirmation process
</span><span class="enscript-comment">// for any records in our cache that reference the given name (e.g. PTR and SRV records).
</span><span class="enscript-comment">// For any such cache record we find, we also recursively call ReconfirmAntecedents() for *its* name.
</span><span class="enscript-comment">// We increment depth each time we recurse, to guard against possible infinite loops, with a limit of 5.
</span><span class="enscript-comment">// A typical reconfirmation scenario might go like this:
</span><span class="enscript-comment">// Depth 0: Name &quot;myhost.local&quot; has no address records
</span><span class="enscript-comment">// Depth 1: SRV &quot;My Service._example._tcp.local.&quot; refers to &quot;myhost.local&quot;; may be stale
</span><span class="enscript-comment">// Depth 2: PTR &quot;_example._tcp.local.&quot; refers to &quot;My Service&quot;; may be stale
</span><span class="enscript-comment">// Depth 3: PTR &quot;_services._dns-sd._udp.local.&quot; refers to &quot;_example._tcp.local.&quot;; may be stale
</span><span class="enscript-comment">// Currently depths 4 and 5 are not expected to occur; if we did get to depth 5 we'd reconfim any records we
</span><span class="enscript-comment">// found referring to the given name, but not recursively descend any further reconfirm *their* antecedents.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReconfirmAntecedents</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> <span class="enscript-type">int</span> depth)
{
    mDNSu32 slot;
    <span class="enscript-type">const</span> CacheGroup *cg;
    CacheRecord *cr;
    debugf(<span class="enscript-string">&quot;ReconfirmAntecedents (depth=%d) for %##s&quot;</span>, depth, name-&gt;c);
    <span class="enscript-keyword">if</span> (!InterfaceID) <span class="enscript-keyword">return</span>; <span class="enscript-comment">// mDNS records have a non-zero InterfaceID. If InterfaceID is 0, then there's nothing to do.
</span>    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-type">const</span> domainname *crtarget;
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID != InterfaceID) <span class="enscript-keyword">continue</span>; <span class="enscript-comment">// Skip non-mDNS records and mDNS records from other interfaces.
</span>        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdatahash != namehash)      <span class="enscript-keyword">continue</span>; <span class="enscript-comment">// Skip records whose rdata hash doesn't match the name hash.
</span>        crtarget = GetRRDomainNameTarget(&amp;cr-&gt;resrec);
        <span class="enscript-keyword">if</span> (crtarget &amp;&amp; SameDomainName(crtarget, name))
        {
            LogInfo(<span class="enscript-string">&quot;ReconfirmAntecedents: Reconfirming (depth=%d, InterfaceID=%p) %s&quot;</span>, depth, InterfaceID, CRDisplayString(m, cr));
            mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForNoAnswer);
            <span class="enscript-keyword">if</span> (depth &lt; 5)
                ReconfirmAntecedents(m, cr-&gt;resrec.name, cr-&gt;resrec.namehash, InterfaceID, depth+1);
        }
    }
}

<span class="enscript-comment">// If we get no answer for a AAAA query, then before doing an automatic implicit ReconfirmAntecedents
</span><span class="enscript-comment">// we check if we have an address record for the same name. If we do have an IPv4 address for a given
</span><span class="enscript-comment">// name but not an IPv6 address, that's okay (it just means the device doesn't do IPv6) so the failure
</span><span class="enscript-comment">// to get a AAAA response is not grounds to doubt the PTR/SRV chain that lead us to that name.
</span>mDNSlocal <span class="enscript-type">const</span> CacheRecord *<span class="enscript-function-name">CacheHasAddressTypeForName</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu32 namehash)
{
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-type">const</span> CacheRecord *cr = cg ? cg-&gt;members : mDNSNULL;
    <span class="enscript-keyword">while</span> (cr &amp;&amp; !RRTypeIsAddressType(cr-&gt;resrec.rrtype)) cr=cr-&gt;next;
    <span class="enscript-keyword">return</span>(cr);
}


mDNSlocal <span class="enscript-type">const</span> CacheRecord *<span class="enscript-function-name">FindSPSInCache1</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> c0, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> c1)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-type">const</span> CacheRecord *cr, *bestcr = mDNSNULL;
    mDNSu32 bestmetric = 1000000;
    <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype == kDNSType_PTR &amp;&amp; cr-&gt;resrec.rdlength &gt;= 6)                      <span class="enscript-comment">// If record is PTR type, with long enough name,
</span>            <span class="enscript-keyword">if</span> (cr != c0 &amp;&amp; cr != c1)                                                           <span class="enscript-comment">// that's not one we've seen before,
</span>                <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, q))                                  <span class="enscript-comment">// and answers our browse query,
</span>                    <span class="enscript-keyword">if</span> (!IdenticalSameNameRecord(&amp;cr-&gt;resrec, &amp;m-&gt;SPSRecords.RR_PTR.resrec))    <span class="enscript-comment">// and is not our own advertised service...
</span>                    {
                        mDNSu32 metric = SPSMetric(cr-&gt;resrec.rdata-&gt;u.name.c);
                        <span class="enscript-keyword">if</span> (bestmetric &gt; metric) { bestmetric = metric; bestcr = cr; }
                    }
    <span class="enscript-keyword">return</span>(bestcr);
#<span class="enscript-reference">else</span> // <span class="enscript-variable-name">SPC_DISABLED</span>
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) q;
    (<span class="enscript-type">void</span>) c0;
    (<span class="enscript-type">void</span>) c1;
    (<span class="enscript-type">void</span>) c1;
    <span class="enscript-keyword">return</span> mDNSNULL;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SPC_DISABLED</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckAndSwapSPS</span>(<span class="enscript-type">const</span> CacheRecord **sps1, <span class="enscript-type">const</span> CacheRecord **sps2)
{
    <span class="enscript-type">const</span> CacheRecord *swap_sps;
    mDNSu32 metric1, metric2;

    <span class="enscript-keyword">if</span> (!(*sps1) || !(*sps2)) <span class="enscript-keyword">return</span>;
    metric1 = SPSMetric((*sps1)-&gt;resrec.rdata-&gt;u.name.c);
    metric2 = SPSMetric((*sps2)-&gt;resrec.rdata-&gt;u.name.c);
    <span class="enscript-keyword">if</span> (!SPSFeatures((*sps1)-&gt;resrec.rdata-&gt;u.name.c) &amp;&amp; SPSFeatures((*sps2)-&gt;resrec.rdata-&gt;u.name.c) &amp;&amp; (metric2 &gt;= metric1))
    {
        swap_sps = *sps1;
        *sps1    = *sps2;
        *sps2    = swap_sps;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReorderSPSByFeature</span>(<span class="enscript-type">const</span> CacheRecord *sps[3])
{
    CheckAndSwapSPS(&amp;sps[0], &amp;sps[1]);
    CheckAndSwapSPS(&amp;sps[0], &amp;sps[2]);
    CheckAndSwapSPS(&amp;sps[1], &amp;sps[2]);
}


<span class="enscript-comment">// Finds the three best Sleep Proxies we currently have in our cache
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">FindSPSInCache</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> CacheRecord *sps[3])
{
    sps[0] =                      FindSPSInCache1(m, q, mDNSNULL, mDNSNULL);
    sps[1] = !sps[0] ? mDNSNULL : FindSPSInCache1(m, q, sps[0],   mDNSNULL);
    sps[2] = !sps[1] ? mDNSNULL : FindSPSInCache1(m, q, sps[0],   sps[1]);

    <span class="enscript-comment">// SPS is already sorted by metric. We want to move the entries to the beginning of the array
</span>    <span class="enscript-comment">// only if they have equally good metric and support features.
</span>    ReorderSPSByFeature(sps);
}

<span class="enscript-comment">// Only DupSuppressInfos newer than the specified 'time' are allowed to remain active
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ExpireDupSuppressInfo</span>(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 time)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=0; i&lt;DupSuppressInfoSize; i++) <span class="enscript-keyword">if</span> (ds[i].Time - time &lt; 0) ds[i].InterfaceID = mDNSNULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ExpireDupSuppressInfoOnInterface</span>(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 time, mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=0; i&lt;DupSuppressInfoSize; i++) <span class="enscript-keyword">if</span> (ds[i].InterfaceID == InterfaceID &amp;&amp; ds[i].Time - time &lt; 0) ds[i].InterfaceID = mDNSNULL;
}

mDNSlocal mDNSBool <span class="enscript-function-name">SuppressOnThisInterface</span>(<span class="enscript-type">const</span> DupSuppressInfo ds[DupSuppressInfoSize], <span class="enscript-type">const</span> NetworkInterfaceInfo * <span class="enscript-type">const</span> intf)
{
    <span class="enscript-type">int</span> i;
    mDNSBool v4 = !intf-&gt;IPv4Available;     <span class="enscript-comment">// If this interface doesn't do v4, we don't need to find a v4 duplicate of this query
</span>    mDNSBool v6 = !intf-&gt;IPv6Available;     <span class="enscript-comment">// If this interface doesn't do v6, we don't need to find a v6 duplicate of this query
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;DupSuppressInfoSize; i++)
        <span class="enscript-keyword">if</span> (ds[i].InterfaceID == intf-&gt;InterfaceID)
        {
            <span class="enscript-keyword">if</span>      (ds[i].Type == mDNSAddrType_IPv4) v4 = mDNStrue;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ds[i].Type == mDNSAddrType_IPv6) v6 = mDNStrue;
            <span class="enscript-keyword">if</span> (v4 &amp;&amp; v6) <span class="enscript-keyword">return</span>(mDNStrue);
        }
    <span class="enscript-keyword">return</span>(mDNSfalse);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RecordDupSuppressInfo</span>(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 Time, mDNSInterfaceID InterfaceID, mDNSs32 Type)
{
    <span class="enscript-type">int</span> i, j;

    <span class="enscript-comment">// See if we have this one in our list somewhere already
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;DupSuppressInfoSize; i++) <span class="enscript-keyword">if</span> (ds[i].InterfaceID == InterfaceID &amp;&amp; ds[i].Type == Type) <span class="enscript-keyword">break</span>;

    <span class="enscript-comment">// If not, find a slot we can re-use
</span>    <span class="enscript-keyword">if</span> (i &gt;= DupSuppressInfoSize)
    {
        i = 0;
        <span class="enscript-keyword">for</span> (j=1; j&lt;DupSuppressInfoSize &amp;&amp; ds[i].InterfaceID; j++)
            <span class="enscript-keyword">if</span> (!ds[j].InterfaceID || ds[j].Time - ds[i].Time &lt; 0)
                i = j;
    }

    <span class="enscript-comment">// Record the info about this query we saw
</span>    ds[i].Time        = Time;
    ds[i].InterfaceID = InterfaceID;
    ds[i].Type        = Type;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSSendWakeOnResolve</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    <span class="enscript-type">int</span> len, i, cnt;
    mDNSInterfaceID InterfaceID = q-&gt;InterfaceID;
    domainname *d = &amp;q-&gt;qname;

    <span class="enscript-comment">// We can't send magic packets without knowing which interface to send it on.
</span>    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_Any || LocalOnlyOrP2PInterface(InterfaceID))
    {
        LogMsg(<span class="enscript-string">&quot;mDNSSendWakeOnResolve: ERROR!! Invalid InterfaceID %p for question %##s&quot;</span>, InterfaceID, q-&gt;qname.c);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Split MAC@IPAddress and pass them separately
</span>    len = d-&gt;c[0];
    cnt = 0;
    <span class="enscript-keyword">for</span> (i = 1; i &lt; len; i++)
    {
        <span class="enscript-keyword">if</span> (d-&gt;c[i] == <span class="enscript-string">'@'</span>)
        {
            <span class="enscript-type">char</span> EthAddr[18];   <span class="enscript-comment">// ethernet adddress : 12 bytes + 5 &quot;:&quot; + 1 NULL byte
</span>            <span class="enscript-type">char</span> IPAddr[47];    <span class="enscript-comment">// Max IP address len: 46 bytes (IPv6) + 1 NULL byte
</span>            <span class="enscript-keyword">if</span> (cnt != 5)
            {
                LogMsg(<span class="enscript-string">&quot;mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, cnt %d&quot;</span>, q-&gt;qname.c, cnt);
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">if</span> ((i - 1) &gt; (<span class="enscript-type">int</span>) (<span class="enscript-keyword">sizeof</span>(EthAddr) - 1))
            {
                LogMsg(<span class="enscript-string">&quot;mDNSSendWakeOnResolve: ERROR!! Malformed Ethernet address %##s, length %d&quot;</span>, q-&gt;qname.c, i - 1);
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">if</span> ((len - i) &gt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(IPAddr) - 1))
            {
                LogMsg(<span class="enscript-string">&quot;mDNSSendWakeOnResolve: ERROR!! Malformed IP address %##s, length %d&quot;</span>, q-&gt;qname.c, len - i);
                <span class="enscript-keyword">return</span>;
            }
            mDNSPlatformMemCopy(EthAddr, &amp;d-&gt;c[1], i - 1);
            EthAddr[i - 1] = 0;
            mDNSPlatformMemCopy(IPAddr, &amp;d-&gt;c[i + 1], len - i);
            IPAddr[len - i] = 0;
            m-&gt;mDNSStats.WakeOnResolves++;
            mDNSPlatformSendWakeupPacket(InterfaceID, EthAddr, IPAddr, InitialWakeOnResolveCount - q-&gt;WakeOnResolveCount);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (d-&gt;c[i] == <span class="enscript-string">':'</span>)
            cnt++;
    }
    LogMsg(<span class="enscript-string">&quot;mDNSSendWakeOnResolve: ERROR!! Malformed WakeOnResolve name %##s&quot;</span>, q-&gt;qname.c);
}


mDNSlocal mDNSBool <span class="enscript-function-name">AccelerateThisQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    <span class="enscript-comment">// If more than 90% of the way to the query time, we should unconditionally accelerate it
</span>    <span class="enscript-keyword">if</span> (TimeToSendThisQuestion(q, m-&gt;timenow + q-&gt;ThisQInterval/10))
        <span class="enscript-keyword">return</span>(mDNStrue);

    <span class="enscript-comment">// If half-way to next scheduled query time, only accelerate if it will add less than 512 bytes to the packet
</span>    <span class="enscript-keyword">if</span> (TimeToSendThisQuestion(q, m-&gt;timenow + q-&gt;ThisQInterval/2))
    {
        <span class="enscript-comment">// We forecast: qname (n) type (2) class (2)
</span>        mDNSu32 forecast = (mDNSu32)DomainNameLength(&amp;q-&gt;qname) + 4;
        <span class="enscript-type">const</span> CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
        <span class="enscript-type">const</span> CacheRecord *cr;
        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)              <span class="enscript-comment">// If we have a resource record in our cache,
</span>            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdlength &lt;= SmallRecordLimit &amp;&amp;                   <span class="enscript-comment">// which is small enough to sensibly fit in the packet
</span>                SameNameCacheRecordAnswersQuestion(cr, q) &amp;&amp;                 <span class="enscript-comment">// which answers our question
</span>                cr-&gt;TimeRcvd + TicksTTL(cr)/2 - m-&gt;timenow &gt;= 0 &amp;&amp;           <span class="enscript-comment">// and it is less than half-way to expiry
</span>                cr-&gt;NextRequiredQuery - (m-&gt;timenow + q-&gt;ThisQInterval) &gt; 0) <span class="enscript-comment">// and we'll ask at least once again before NextRequiredQuery
</span>            {
                <span class="enscript-comment">// We forecast: compressed name (2) type (2) class (2) TTL (4) rdlength (2) rdata (n)
</span>                forecast += 12 + cr-&gt;resrec.rdestimate;
                <span class="enscript-keyword">if</span> (forecast &gt;= 512) <span class="enscript-keyword">return</span>(mDNSfalse); <span class="enscript-comment">// If this would add 512 bytes or more to the packet, don't accelerate
</span>            }
        <span class="enscript-keyword">return</span>(mDNStrue);
    }

    <span class="enscript-keyword">return</span>(mDNSfalse);
}

<span class="enscript-comment">// How Standard Queries are generated:
</span><span class="enscript-comment">// 1. The Question Section contains the question
</span><span class="enscript-comment">// 2. The Additional Section contains answers we already know, to suppress duplicate responses
</span>
<span class="enscript-comment">// How Probe Queries are generated:
</span><span class="enscript-comment">// 1. The Question Section contains queries for the name we intend to use, with QType=ANY because
</span><span class="enscript-comment">// if some other host is already using *any* records with this name, we want to know about it.
</span><span class="enscript-comment">// 2. The Authority Section contains the proposed values we intend to use for one or more
</span><span class="enscript-comment">// of our records with that name (analogous to the Update section of DNS Update packets)
</span><span class="enscript-comment">// because if some other host is probing at the same time, we each want to know what the other is
</span><span class="enscript-comment">// planning, in order to apply the tie-breaking rule to see who gets to use the name and who doesn't.
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendQueries</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSu32 slot;
    CacheGroup *cg;
    CacheRecord *cr;
    AuthRecord *ar;
    <span class="enscript-type">int</span> pktcount = 0;
    DNSQuestion *q;
    <span class="enscript-comment">// For explanation of maxExistingQuestionInterval logic, see comments for maxExistingAnnounceInterval
</span>    mDNSs32 maxExistingQuestionInterval = 0;
    <span class="enscript-type">const</span> NetworkInterfaceInfo *intf = GetFirstActiveInterface(m-&gt;HostInterfaces);
    CacheRecord *KnownAnswerList = mDNSNULL;

    <span class="enscript-comment">// 1. If time for a query, work out what we need to do
</span>
    <span class="enscript-comment">// We're expecting to send a query anyway, so see if any expiring cache records are close enough
</span>    <span class="enscript-comment">// to their NextRequiredQuery to be worth batching them together with this one
</span>    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion &amp;&amp; cr-&gt;UnansweredQueries &lt; MaxUnansweredQueries)
        {
            <span class="enscript-keyword">if</span> (m-&gt;timenow + TicksTTL(cr)/50 - cr-&gt;NextRequiredQuery &gt;= 0)
            {
                debugf(<span class="enscript-string">&quot;Sending %d%% cache expiration query for %s&quot;</span>, 80 + 5 * cr-&gt;UnansweredQueries, CRDisplayString(m, cr));
                q = cr-&gt;CRActiveQuestion;
                ExpireDupSuppressInfoOnInterface(q-&gt;DupSuppress, m-&gt;timenow - TicksTTL(cr)/20, cr-&gt;resrec.InterfaceID);
                <span class="enscript-comment">// For uDNS queries (TargetQID non-zero) we adjust LastQTime,
</span>                <span class="enscript-comment">// and bump UnansweredQueries so that we don't spin trying to send the same cache expiration query repeatedly
</span>                <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID))
                {
                    q-&gt;LastQTime = m-&gt;timenow - q-&gt;ThisQInterval;
                    cr-&gt;UnansweredQueries++;
                    m-&gt;mDNSStats.CacheRefreshQueries++;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;SendQNow == mDNSNULL)
                {
                    q-&gt;SendQNow = cr-&gt;resrec.InterfaceID;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;SendQNow != cr-&gt;resrec.InterfaceID)
                {
                    q-&gt;SendQNow = mDNSInterfaceMark;
                }

                <span class="enscript-comment">// Indicate that this question was marked for sending
</span>                <span class="enscript-comment">// to update an existing cached answer record.
</span>                <span class="enscript-comment">// The browse throttling logic below uses this to determine
</span>                <span class="enscript-comment">// if the query should be sent.
</span>                <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))
                    q-&gt;CachedAnswerNeedsUpdate = mDNStrue;
            }
        }
    }

    <span class="enscript-comment">// Scan our list of questions to see which:
</span>    <span class="enscript-comment">//     *WideArea*  queries need to be sent
</span>    <span class="enscript-comment">//     *unicast*   queries need to be sent
</span>    <span class="enscript-comment">//     *multicast* queries we're definitely going to send
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;SendQueries ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>, m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
    {
        q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; TimeToSendThisQuestion(q, m-&gt;timenow))
        {
            <span class="enscript-comment">//LogInfo(&quot;Time to send %##s (%s) %d&quot;, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), m-&gt;timenow - NextQSendTime(q));
</span>            q-&gt;SendQNow = mDNSInterfaceMark;        <span class="enscript-comment">// Mark this question for sending on all interfaces
</span>            <span class="enscript-keyword">if</span> (maxExistingQuestionInterval &lt; q-&gt;ThisQInterval)
                maxExistingQuestionInterval = q-&gt;ThisQInterval;
        }
        <span class="enscript-comment">// If m-&gt;CurrentQuestion wasn't modified out from under us, advance it now
</span>        <span class="enscript-comment">// We can't do this at the start of the loop because uDNS_CheckCurrentQuestion() depends on having
</span>        <span class="enscript-comment">// m-&gt;CurrentQuestion point to the right question
</span>        <span class="enscript-keyword">if</span> (q == m-&gt;CurrentQuestion) m-&gt;CurrentQuestion = m-&gt;CurrentQuestion-&gt;next;
    }
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion)
    {
        LogInfo(<span class="enscript-string">&quot;SendQueries question loop 1: Skipping NewQuestion %##s (%s)&quot;</span>, m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
        m-&gt;CurrentQuestion = m-&gt;CurrentQuestion-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;

    <span class="enscript-comment">// Scan our list of questions
</span>    <span class="enscript-comment">// (a) to see if there are any more that are worth accelerating, and
</span>    <span class="enscript-comment">// (b) to update the state variables for *all* the questions we're going to send
</span>    <span class="enscript-comment">// Note: Don't set NextScheduledQuery until here, because uDNS_CheckCurrentQuestion in the loop above can add new questions to the list,
</span>    <span class="enscript-comment">// which causes NextScheduledQuery to get (incorrectly) set to m-&gt;timenow. Setting it here is the right place, because the very
</span>    <span class="enscript-comment">// next thing we do is scan the list and call SetNextQueryTime() for every question we find, so we know we end up with the right value.
</span>    m-&gt;NextScheduledQuery = m-&gt;timenow + FutureTime;
    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; q != m-&gt;NewQuestions; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID)
            &amp;&amp; (q-&gt;SendQNow || (ActiveQuestion(q) &amp;&amp; q-&gt;ThisQInterval &lt;= maxExistingQuestionInterval &amp;&amp; AccelerateThisQuery(m,q))))
        {
            <span class="enscript-comment">// If at least halfway to next query time, advance to next interval
</span>            <span class="enscript-comment">// If less than halfway to next query time, then
</span>            <span class="enscript-comment">// treat this as logically a repeat of the last transmission, without advancing the interval
</span>            <span class="enscript-keyword">if</span> (m-&gt;timenow - (q-&gt;LastQTime + (q-&gt;ThisQInterval/2)) &gt;= 0)
            {
                <span class="enscript-comment">// If we have reached the answer threshold for this question, 
</span>                <span class="enscript-comment">// don't send it again until MaxQuestionInterval unless:
</span>                <span class="enscript-comment">//  one of its cached answers needs to be refreshed,
</span>                <span class="enscript-comment">//  or it's the initial query for a kDNSServiceFlagsThresholdFinder mode browse.
</span>                <span class="enscript-keyword">if</span> (q-&gt;BrowseThreshold
                    &amp;&amp; (q-&gt;CurrentAnswers &gt;= q-&gt;BrowseThreshold)
                    &amp;&amp; (q-&gt;CachedAnswerNeedsUpdate == mDNSfalse)
                    &amp;&amp; !((q-&gt;flags &amp; kDNSServiceFlagsThresholdFinder) &amp;&amp; (q-&gt;ThisQInterval == InitialQuestionInterval)))
                {
                    q-&gt;SendQNow = mDNSNULL;
                    q-&gt;ThisQInterval = MaxQuestionInterval;
                    q-&gt;LastQTime = m-&gt;timenow;
                    q-&gt;RequestUnicast = 0;
                    LogInfo(<span class="enscript-string">&quot;SendQueries: (%s) %##s reached threshold of %d answers&quot;</span>,
                         DNSTypeName(q-&gt;qtype), q-&gt;qname.c, q-&gt;BrowseThreshold);
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Mark this question for sending on all interfaces
</span>                    q-&gt;SendQNow = mDNSInterfaceMark;
                    q-&gt;ThisQInterval *= QuestionIntervalStep;
                }

                debugf(<span class="enscript-string">&quot;SendQueries: %##s (%s) next interval %d seconds RequestUnicast = %d&quot;</span>,
                       q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;ThisQInterval / InitialQuestionInterval, q-&gt;RequestUnicast);

                <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &gt; MaxQuestionInterval)
                {
                    q-&gt;ThisQInterval = MaxQuestionInterval;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;InterfaceID &amp;&amp;
                         q-&gt;CurrentAnswers == 0 &amp;&amp; q-&gt;ThisQInterval == InitialQuestionInterval * QuestionIntervalStep3 &amp;&amp; !q-&gt;RequestUnicast &amp;&amp;
                         !(RRTypeIsAddressType(q-&gt;qtype) &amp;&amp; CacheHasAddressTypeForName(m, &amp;q-&gt;qname, q-&gt;qnamehash)))
                {
                    <span class="enscript-comment">// Generally don't need to log this.
</span>                    <span class="enscript-comment">// It's not especially noteworthy if a query finds no results -- this usually happens for domain
</span>                    <span class="enscript-comment">// enumeration queries in the LL subdomain (e.g. &quot;db._dns-sd._udp.0.0.254.169.in-addr.arpa&quot;)
</span>                    <span class="enscript-comment">// and when there simply happen to be no instances of the service the client is looking
</span>                    <span class="enscript-comment">// for (e.g. iTunes is set to look for RAOP devices, and the current network has none).
</span>                    debugf(<span class="enscript-string">&quot;SendQueries: Zero current answers for %##s (%s); will reconfirm antecedents&quot;</span>,
                           q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    <span class="enscript-comment">// Sending third query, and no answers yet; time to begin doubting the source
</span>                    ReconfirmAntecedents(m, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;InterfaceID, 0);
                }
            }

            <span class="enscript-comment">// Mark for sending. (If no active interfaces, then don't even try.)
</span>            q-&gt;SendOnAll = (q-&gt;SendQNow == mDNSInterfaceMark);
            <span class="enscript-keyword">if</span> (q-&gt;SendOnAll)
            {
                q-&gt;SendQNow  = !intf ? mDNSNULL : (q-&gt;InterfaceID) ? q-&gt;InterfaceID : intf-&gt;InterfaceID;
                q-&gt;LastQTime = m-&gt;timenow;
            }

            <span class="enscript-comment">// If we recorded a duplicate suppression for this question less than half an interval ago,
</span>            <span class="enscript-comment">// then we consider it recent enough that we don't need to do an identical query ourselves.
</span>            ExpireDupSuppressInfo(q-&gt;DupSuppress, m-&gt;timenow - q-&gt;ThisQInterval/2);

            q-&gt;LastQTxTime      = m-&gt;timenow;
            q-&gt;RecentAnswerPkts = 0;
            <span class="enscript-keyword">if</span> (q-&gt;RequestUnicast) q-&gt;RequestUnicast--;
        }
        <span class="enscript-comment">// For all questions (not just the ones we're sending) check what the next scheduled event will be
</span>        <span class="enscript-comment">// We don't need to consider NewQuestions here because for those we'll set m-&gt;NextScheduledQuery in AnswerNewQuestion
</span>        SetNextQueryTime(m,q);
    }

    <span class="enscript-comment">// 2. Scan our authoritative RR list to see what probes we might need to send
</span>
    m-&gt;NextScheduledProbe = m-&gt;timenow + FutureTime;

    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;SendQueries ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = m-&gt;ResourceRecords;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        ar = m-&gt;CurrentRecord;
        m-&gt;CurrentRecord = ar-&gt;next;
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(ar) &amp;&amp; ar-&gt;resrec.RecordType == kDNSRecordTypeUnique)  <span class="enscript-comment">// For all records that are still probing...
</span>        {
            <span class="enscript-comment">// 1. If it's not reached its probe time, just make sure we update m-&gt;NextScheduledProbe correctly
</span>            <span class="enscript-keyword">if</span> (m-&gt;timenow - (ar-&gt;LastAPTime + ar-&gt;ThisAPInterval) &lt; 0)
            {
                SetNextAnnounceProbeTime(m, ar);
            }
            <span class="enscript-comment">// 2. else, if it has reached its probe time, mark it for sending and then update m-&gt;NextScheduledProbe correctly
</span>            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ar-&gt;ProbeCount)
            {
                <span class="enscript-keyword">if</span> (ar-&gt;AddressProxy.type == mDNSAddrType_IPv4)
                {
                    <span class="enscript-comment">// There's a problem here. If a host is waking up, and we probe to see if it responds, then
</span>                    <span class="enscript-comment">// it will see those ARP probes as signalling intent to use the address, so it picks a different one.
</span>                    <span class="enscript-comment">// A more benign way to find out if a host is responding to ARPs might be send a standard ARP *request*
</span>                    <span class="enscript-comment">// (using our sender IP address) instead of an ARP *probe* (using all-zero sender IP address).
</span>                    <span class="enscript-comment">// A similar concern may apply to the NDP Probe too. -- SC
</span>                    LogSPS(<span class="enscript-string">&quot;SendQueries ARP Probe %d %s %s&quot;</span>, ar-&gt;ProbeCount, InterfaceNameForID(m, ar-&gt;resrec.InterfaceID), ARDisplayString(m,ar));
                    SendARP(m, 1, ar, &amp;zerov4Addr, &amp;zeroEthAddr, &amp;ar-&gt;AddressProxy.ip.v4, &amp;ar-&gt;WakeUp.IMAC);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ar-&gt;AddressProxy.type == mDNSAddrType_IPv6)
                {
                    LogSPS(<span class="enscript-string">&quot;SendQueries NDP Probe %d %s %s&quot;</span>, ar-&gt;ProbeCount, InterfaceNameForID(m, ar-&gt;resrec.InterfaceID), ARDisplayString(m,ar));
                    <span class="enscript-comment">// IPv6 source = zero
</span>                    <span class="enscript-comment">// No target hardware address
</span>                    <span class="enscript-comment">// IPv6 target address is address we're probing
</span>                    <span class="enscript-comment">// Ethernet destination address is Ethernet interface address of the Sleep Proxy client we're probing
</span>                    SendNDP(m, NDP_Sol, 0, ar, &amp;zerov6Addr, mDNSNULL, &amp;ar-&gt;AddressProxy.ip.v6, &amp;ar-&gt;WakeUp.IMAC);
                }
                <span class="enscript-comment">// Mark for sending. (If no active interfaces, then don't even try.)
</span>                ar-&gt;SendRNow   = (!intf || ar-&gt;WakeUp.HMAC.l[0]) ? mDNSNULL : ar-&gt;resrec.InterfaceID ? ar-&gt;resrec.InterfaceID : intf-&gt;InterfaceID;
                ar-&gt;LastAPTime = m-&gt;timenow;
                <span class="enscript-comment">// When we have a late conflict that resets a record to probing state we use a special marker value greater
</span>                <span class="enscript-comment">// than DefaultProbeCountForTypeUnique. Here we detect that state and reset ar-&gt;ProbeCount back to the right value.
</span>                <span class="enscript-keyword">if</span> (ar-&gt;ProbeCount &gt; DefaultProbeCountForTypeUnique)
                    ar-&gt;ProbeCount = DefaultProbeCountForTypeUnique;
                ar-&gt;ProbeCount--;
                SetNextAnnounceProbeTime(m, ar);
                <span class="enscript-keyword">if</span> (ar-&gt;ProbeCount == 0)
                {
                    <span class="enscript-comment">// If this is the last probe for this record, then see if we have any matching records
</span>                    <span class="enscript-comment">// on our duplicate list which should similarly have their ProbeCount cleared to zero...
</span>                    AuthRecord *r2;
                    <span class="enscript-keyword">for</span> (r2 = m-&gt;DuplicateRecords; r2; r2=r2-&gt;next)
                        <span class="enscript-keyword">if</span> (r2-&gt;resrec.RecordType == kDNSRecordTypeUnique &amp;&amp; RecordIsLocalDuplicate(r2, ar))
                            r2-&gt;ProbeCount = 0;
                    <span class="enscript-comment">// ... then acknowledge this record to the client.
</span>                    <span class="enscript-comment">// We do this optimistically, just as we're about to send the third probe.
</span>                    <span class="enscript-comment">// This helps clients that both advertise and browse, and want to filter themselves
</span>                    <span class="enscript-comment">// from the browse results list, because it helps ensure that the registration
</span>                    <span class="enscript-comment">// confirmation will be delivered 1/4 second *before* the browse &quot;add&quot; event.
</span>                    <span class="enscript-comment">// A potential downside is that we could deliver a registration confirmation and then find out
</span>                    <span class="enscript-comment">// moments later that there's a name conflict, but applications have to be prepared to handle
</span>                    <span class="enscript-comment">// late conflicts anyway (e.g. on connection of network cable, etc.), so this is nothing new.
</span>                    <span class="enscript-keyword">if</span> (!ar-&gt;Acknowledged) AcknowledgeRecord(m, ar);
                }
            }
            <span class="enscript-comment">// else, if it has now finished probing, move it to state Verified,
</span>            <span class="enscript-comment">// and update m-&gt;NextScheduledResponse so it will be announced
</span>            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (!ar-&gt;Acknowledged) AcknowledgeRecord(m, ar);    <span class="enscript-comment">// Defensive, just in case it got missed somehow
</span>                ar-&gt;resrec.RecordType     = kDNSRecordTypeVerified;
                ar-&gt;ThisAPInterval = DefaultAnnounceIntervalForTypeUnique;
                ar-&gt;LastAPTime     = m-&gt;timenow - DefaultAnnounceIntervalForTypeUnique;
                SetNextAnnounceProbeTime(m, ar);
            }
        }
    }
    m-&gt;CurrentRecord = m-&gt;DuplicateRecords;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        ar = m-&gt;CurrentRecord;
        m-&gt;CurrentRecord = ar-&gt;next;
        <span class="enscript-keyword">if</span> (ar-&gt;resrec.RecordType == kDNSRecordTypeUnique &amp;&amp; ar-&gt;ProbeCount == 0 &amp;&amp; !ar-&gt;Acknowledged)
            AcknowledgeRecord(m, ar);
    }

    <span class="enscript-comment">// 3. Now we know which queries and probes we're sending,
</span>    <span class="enscript-comment">// go through our interface list sending the appropriate queries on each interface
</span>    <span class="enscript-keyword">while</span> (intf)
    {
        <span class="enscript-type">int</span> OwnerRecordSpace = (m-&gt;AnnounceOwner &amp;&amp; intf-&gt;MAC.l[0]) ? DNSOpt_Header_Space + DNSOpt_Owner_Space(&amp;m-&gt;PrimaryMAC, &amp;intf-&gt;MAC) : 0;
        <span class="enscript-type">int</span> TraceRecordSpace = (mDNS_McastTracingEnabled &amp;&amp; MDNS_TRACER) ? DNSOpt_Header_Space + DNSOpt_TraceData_Space : 0;
        mDNSu8 *queryptr = m-&gt;omsg.data;
        mDNSBool useBackgroundTrafficClass = mDNSfalse;    <span class="enscript-comment">// set if we should use background traffic class
</span>
        InitializeDNSMessage(&amp;m-&gt;omsg.h, zeroID, QueryFlags);
        <span class="enscript-keyword">if</span> (KnownAnswerList) verbosedebugf(<span class="enscript-string">&quot;SendQueries:   KnownAnswerList set... Will continue from previous packet&quot;</span>);
        <span class="enscript-keyword">if</span> (!KnownAnswerList)
        {
            <span class="enscript-comment">// Start a new known-answer list
</span>            CacheRecord **kalistptr = &amp;KnownAnswerList;
            mDNSu32 answerforecast = OwnerRecordSpace + TraceRecordSpace;  <span class="enscript-comment">// Start by assuming we'll need at least enough space to put the Owner+Tracer Option
</span>
            <span class="enscript-comment">// Put query questions in this packet
</span>            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; q != m-&gt;NewQuestions; q=q-&gt;next)
            {
                <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; (q-&gt;SendQNow == intf-&gt;InterfaceID))
                {
                    mDNSBool Suppress = mDNSfalse;
                    debugf(<span class="enscript-string">&quot;SendQueries: %s question for %##s (%s) at %d forecast total %d&quot;</span>,
                           SuppressOnThisInterface(q-&gt;DupSuppress, intf) ? <span class="enscript-string">&quot;Suppressing&quot;</span> : <span class="enscript-string">&quot;Putting    &quot;</span>,
                           q-&gt;qname.c, DNSTypeName(q-&gt;qtype), queryptr - m-&gt;omsg.data, queryptr + answerforecast - m-&gt;omsg.data);

                    <span class="enscript-comment">// If interface is P2P type, verify that query should be sent over it.
</span>                    <span class="enscript-keyword">if</span> (!mDNSPlatformValidQuestionForInterface(q, intf))
                    {
                        q-&gt;SendQNow = (q-&gt;InterfaceID || !q-&gt;SendOnAll) ? mDNSNULL : GetNextActiveInterfaceID(intf);
                    }
                    <span class="enscript-comment">// If we're suppressing this question, or we successfully put it, update its SendQNow state
</span>                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((Suppress = SuppressOnThisInterface(q-&gt;DupSuppress, intf)) ||
                        BuildQuestion(m, intf, &amp;m-&gt;omsg, &amp;queryptr, q, &amp;kalistptr, &amp;answerforecast))
                    {
                        <span class="enscript-keyword">if</span> (Suppress)
                            m-&gt;mDNSStats.DupQuerySuppressions++;

                        q-&gt;SendQNow = (q-&gt;InterfaceID || !q-&gt;SendOnAll) ? mDNSNULL : GetNextActiveInterfaceID(intf);
                        <span class="enscript-keyword">if</span> (q-&gt;WakeOnResolveCount)
                        {
                            mDNSSendWakeOnResolve(m, q);
                            q-&gt;WakeOnResolveCount--;
                        }

                        <span class="enscript-comment">// use background traffic class if any included question requires it
</span>                        <span class="enscript-keyword">if</span> (q-&gt;UseBackgroundTraffic)
                        {
                            useBackgroundTrafficClass = mDNStrue;
                        }
                    }
                }
            }

            <span class="enscript-comment">// Put probe questions in this packet
</span>            <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
            {
                <span class="enscript-keyword">if</span> (ar-&gt;SendRNow != intf-&gt;InterfaceID)
                    <span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">// If interface is a P2P variant, verify that the probe should be sent over it.
</span>                <span class="enscript-keyword">if</span> (!mDNSPlatformValidRecordForInterface(ar, intf-&gt;InterfaceID))
                {
                    ar-&gt;SendRNow = (ar-&gt;resrec.InterfaceID) ? mDNSNULL : GetNextActiveInterfaceID(intf);
                    ar-&gt;IncludeInProbe = mDNSfalse;
                }
                <span class="enscript-keyword">else</span>
                {
                    mDNSBool ucast = (ar-&gt;ProbeCount &gt;= DefaultProbeCountForTypeUnique-1) &amp;&amp; m-&gt;CanReceiveUnicastOn5353 &amp;&amp; intf-&gt;SupportsUnicastMDNSResponse;
                    mDNSu16 ucbit = (mDNSu16)(ucast ? kDNSQClass_UnicastResponse : 0);
                    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = m-&gt;omsg.data + (m-&gt;omsg.h.numQuestions ? NormalMaxDNSMessageData : AbsoluteMaxDNSMessageData);
                    <span class="enscript-comment">// We forecast: compressed name (2) type (2) class (2) TTL (4) rdlength (2) rdata (n)
</span>                    mDNSu32 forecast = answerforecast + 12 + ar-&gt;resrec.rdestimate;
                    mDNSBool putProbe = mDNStrue;
                    mDNSu16 qclass = ar-&gt;resrec.rrclass | ucbit;

                    {<span class="enscript-comment">// Determine if this probe question is already in packet's dns message
</span>                        <span class="enscript-type">const</span> mDNSu8 *questionptr = m-&gt;omsg.data;
                        DNSQuestion question;
                        mDNSu16 n;
                        <span class="enscript-keyword">for</span> (n = 0; n &lt; m-&gt;omsg.h.numQuestions &amp;&amp; questionptr; n++)
                        {
                            questionptr = getQuestion(&amp;m-&gt;omsg, questionptr, limit, mDNSInterface_Any, &amp;question);
                            <span class="enscript-keyword">if</span> (questionptr &amp;&amp; (question.qtype == kDNSQType_ANY) &amp;&amp; (question.qclass == qclass) &amp;&amp;
                                (question.qnamehash == ar-&gt;resrec.namehash) &amp;&amp; SameDomainName(&amp;question.qname, ar-&gt;resrec.name))
                            {
                                putProbe = mDNSfalse;  <span class="enscript-comment">// set to false if already in message
</span>                                <span class="enscript-keyword">break</span>;
                            }
                        }
                    }

                    <span class="enscript-keyword">if</span> (putProbe)
                    {
                        mDNSu8 *newptr = putQuestion(&amp;m-&gt;omsg, queryptr, limit - forecast, ar-&gt;resrec.name, kDNSQType_ANY, qclass);
                        <span class="enscript-keyword">if</span> (newptr)
                        {
                            queryptr       = newptr;
                            answerforecast = forecast;
                            ar-&gt;SendRNow = (ar-&gt;resrec.InterfaceID) ? mDNSNULL : GetNextActiveInterfaceID(intf);
                            ar-&gt;IncludeInProbe = mDNStrue;
                            verbosedebugf(<span class="enscript-string">&quot;SendQueries:   Put Question %##s (%s) probecount %d InterfaceID= %d %d %d&quot;</span>,
                                      ar-&gt;resrec.name-&gt;c, DNSTypeName(ar-&gt;resrec.rrtype), ar-&gt;ProbeCount, ar-&gt;resrec.InterfaceID, ar-&gt;resrec.rdestimate, answerforecast);
                        }
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        ar-&gt;SendRNow = (ar-&gt;resrec.InterfaceID) ? mDNSNULL : GetNextActiveInterfaceID(intf);
                        ar-&gt;IncludeInProbe = mDNStrue;
                    }
                }
            }
        }

        <span class="enscript-comment">// Put our known answer list (either new one from this question or questions, or remainder of old one from last time)
</span>        <span class="enscript-keyword">while</span> (KnownAnswerList)
        {
            CacheRecord *ka = KnownAnswerList;
            mDNSu32 SecsSinceRcvd = ((mDNSu32)(m-&gt;timenow - ka-&gt;TimeRcvd)) / mDNSPlatformOneSecond;
            mDNSu8 *newptr = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, queryptr, &amp;m-&gt;omsg.h.numAnswers, &amp;ka-&gt;resrec, ka-&gt;resrec.rroriginalttl - SecsSinceRcvd,
                                                           m-&gt;omsg.data + NormalMaxDNSMessageData - OwnerRecordSpace - TraceRecordSpace);
            <span class="enscript-keyword">if</span> (newptr)
            {
                verbosedebugf(<span class="enscript-string">&quot;SendQueries:   Put %##s (%s) at %d - %d&quot;</span>,
                              ka-&gt;resrec.name-&gt;c, DNSTypeName(ka-&gt;resrec.rrtype), queryptr - m-&gt;omsg.data, newptr - m-&gt;omsg.data);
                queryptr = newptr;
                KnownAnswerList = ka-&gt;NextInKAList;
                ka-&gt;NextInKAList = mDNSNULL;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// If we ran out of space and we have more than one question in the packet, that's an error --
</span>                <span class="enscript-comment">// we shouldn't have put more than one question if there was a risk of us running out of space.
</span>                <span class="enscript-keyword">if</span> (m-&gt;omsg.h.numQuestions &gt; 1)
                    LogMsg(<span class="enscript-string">&quot;SendQueries:   Put %d answers; No more space for known answers&quot;</span>, m-&gt;omsg.h.numAnswers);
                m-&gt;omsg.h.flags.b[0] |= kDNSFlag0_TC;
                <span class="enscript-keyword">break</span>;
            }
        }

        <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
        {
            <span class="enscript-keyword">if</span> (ar-&gt;IncludeInProbe)
            {
                mDNSu8 *newptr = PutResourceRecord(&amp;m-&gt;omsg, queryptr, &amp;m-&gt;omsg.h.numAuthorities, &amp;ar-&gt;resrec);
                ar-&gt;IncludeInProbe = mDNSfalse;
                <span class="enscript-keyword">if</span> (newptr) queryptr = newptr;
                <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;SendQueries:   How did we fail to have space for the Update record %s&quot;</span>, ARDisplayString(m,ar));
            }
        }

        <span class="enscript-keyword">if</span> (queryptr &gt; m-&gt;omsg.data)
        {
            <span class="enscript-comment">// If we have data to send, add OWNER/TRACER/OWNER+TRACER option if necessary, then send packet
</span>            <span class="enscript-keyword">if</span> (OwnerRecordSpace || TraceRecordSpace)
            {
                AuthRecord opt;
                mDNS_SetupResourceRecord(&amp;opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
                opt.resrec.rrclass    = NormalMaxDNSMessageData;
                opt.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);
                opt.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
                <span class="enscript-keyword">if</span> (OwnerRecordSpace &amp;&amp; TraceRecordSpace)
                {
                    opt.resrec.rdlength   += <span class="enscript-keyword">sizeof</span>(rdataOPT);  <span class="enscript-comment">// Two options in this OPT record
</span>                    opt.resrec.rdestimate += <span class="enscript-keyword">sizeof</span>(rdataOPT);
                    SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                    SetupTracerOpt(m, &amp;opt.resrec.rdata-&gt;u.opt[1]);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (OwnerRecordSpace)
                {
                    SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TraceRecordSpace)
                {
                    SetupTracerOpt(m, &amp;opt.resrec.rdata-&gt;u.opt[0]);
                }
                queryptr = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, queryptr, &amp;m-&gt;omsg.h.numAdditionals,
                                                         &amp;opt.resrec, opt.resrec.rroriginalttl, m-&gt;omsg.data + AbsoluteMaxDNSMessageData);
                <span class="enscript-keyword">if</span> (!queryptr)
                {
                    LogMsg(<span class="enscript-string">&quot;SendQueries: How did we fail to have space for %s %s OPT record (%d/%d/%d/%d) %s&quot;</span>, OwnerRecordSpace ? <span class="enscript-string">&quot;OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, TraceRecordSpace ? <span class="enscript-string">&quot;TRACER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                           m-&gt;omsg.h.numQuestions, m-&gt;omsg.h.numAnswers, m-&gt;omsg.h.numAuthorities, m-&gt;omsg.h.numAdditionals, ARDisplayString(m, &amp;opt));
                }
                <span class="enscript-keyword">if</span> (queryptr &gt; m-&gt;omsg.data + NormalMaxDNSMessageData)
                {
                    <span class="enscript-keyword">if</span> (m-&gt;omsg.h.numQuestions != 1 || m-&gt;omsg.h.numAnswers != 0 || m-&gt;omsg.h.numAuthorities != 1 || m-&gt;omsg.h.numAdditionals != 1)
                        LogMsg(<span class="enscript-string">&quot;SendQueries: Why did we generate oversized packet with %s %s OPT record %p %p %p (%d/%d/%d/%d) %s&quot;</span>, OwnerRecordSpace ? <span class="enscript-string">&quot;OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                                TraceRecordSpace ? <span class="enscript-string">&quot;TRACER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, m-&gt;omsg.data, m-&gt;omsg.data + NormalMaxDNSMessageData, queryptr, m-&gt;omsg.h.numQuestions, m-&gt;omsg.h.numAnswers,
                                m-&gt;omsg.h.numAuthorities, m-&gt;omsg.h.numAdditionals, ARDisplayString(m, &amp;opt));
                }
            }

            <span class="enscript-keyword">if</span> ((m-&gt;omsg.h.flags.b[0] &amp; kDNSFlag0_TC) &amp;&amp; m-&gt;omsg.h.numQuestions &gt; 1)
                LogMsg(<span class="enscript-string">&quot;SendQueries: Should not have more than one question (%d) in a truncated packet&quot;</span>, m-&gt;omsg.h.numQuestions);
            debugf(<span class="enscript-string">&quot;SendQueries:   Sending %d Question%s %d Answer%s %d Update%s on %d (%s)&quot;</span>,
                   m-&gt;omsg.h.numQuestions,   m-&gt;omsg.h.numQuestions   == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
                   m-&gt;omsg.h.numAnswers,     m-&gt;omsg.h.numAnswers     == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
                   m-&gt;omsg.h.numAuthorities, m-&gt;omsg.h.numAuthorities == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>, IIDPrintable(intf-&gt;InterfaceID), intf-&gt;ifname);
            <span class="enscript-keyword">if</span> (intf-&gt;IPv4Available) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, queryptr, intf-&gt;InterfaceID, mDNSNULL, mDNSNULL, &amp;AllDNSLinkGroup_v4, MulticastDNSPort, mDNSNULL, useBackgroundTrafficClass);
            <span class="enscript-keyword">if</span> (intf-&gt;IPv6Available) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, queryptr, intf-&gt;InterfaceID, mDNSNULL, mDNSNULL, &amp;AllDNSLinkGroup_v6, MulticastDNSPort, mDNSNULL, useBackgroundTrafficClass);
            <span class="enscript-keyword">if</span> (!m-&gt;SuppressSending) m-&gt;SuppressSending = NonZeroTime(m-&gt;timenow + (mDNSPlatformOneSecond+9)/10);
            <span class="enscript-keyword">if</span> (++pktcount &gt;= 1000)
            { LogMsg(<span class="enscript-string">&quot;SendQueries exceeded loop limit %d: giving up&quot;</span>, pktcount); <span class="enscript-keyword">break</span>; }
            <span class="enscript-comment">// There might be more records left in the known answer list, or more questions to send
</span>            <span class="enscript-comment">// on this interface, so go around one more time and try again.
</span>        }
        <span class="enscript-keyword">else</span>    <span class="enscript-comment">// Nothing more to send on this interface; go to next
</span>        {
            <span class="enscript-type">const</span> NetworkInterfaceInfo *next = GetFirstActiveInterface(intf-&gt;next);
            #<span class="enscript-keyword">if</span> MDNS_DEBUGMSGS &amp;&amp; 0
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> msg = next ? <span class="enscript-string">&quot;SendQueries:   Nothing more on %p; moving to %p&quot;</span> : <span class="enscript-string">&quot;SendQueries:   Nothing more on %p&quot;</span>;
            debugf(msg, intf, next);
            #endif
            intf = next;
        }
    }

    <span class="enscript-comment">// 4. Final housekeeping
</span>
    <span class="enscript-comment">// 4a. Debugging check: Make sure we announced all our records
</span>    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
        <span class="enscript-keyword">if</span> (ar-&gt;SendRNow)
        {
            <span class="enscript-keyword">if</span> (ar-&gt;ARType != AuthRecordLocalOnly &amp;&amp; ar-&gt;ARType != AuthRecordP2P)
                LogInfo(<span class="enscript-string">&quot;SendQueries: No active interface %d to send probe: %d %s&quot;</span>,
                        IIDPrintable(ar-&gt;SendRNow), IIDPrintable(ar-&gt;resrec.InterfaceID), ARDisplayString(m, ar));
            ar-&gt;SendRNow = mDNSNULL;
        }

    <span class="enscript-comment">// 4b. When we have lingering cache records that we're keeping around for a few seconds in the hope
</span>    <span class="enscript-comment">// that their interface which went away might come back again, the logic will want to send queries
</span>    <span class="enscript-comment">// for those records, but we can't because their interface isn't here any more, so to keep the
</span>    <span class="enscript-comment">// state machine ticking over we just pretend we did so.
</span>    <span class="enscript-comment">// If the interface does not come back in time, the cache record will expire naturally
</span>    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion &amp;&amp; cr-&gt;UnansweredQueries &lt; MaxUnansweredQueries)
        {
            <span class="enscript-keyword">if</span> (m-&gt;timenow + TicksTTL(cr)/50 - cr-&gt;NextRequiredQuery &gt;= 0)
            {
                cr-&gt;UnansweredQueries++;
                cr-&gt;CRActiveQuestion-&gt;SendQNow = mDNSNULL;
                SetNextCacheCheckTimeForRecord(m, cr);
            }
        }
    }

    <span class="enscript-comment">// 4c. Debugging check: Make sure we sent all our planned questions
</span>    <span class="enscript-comment">// Do this AFTER the lingering cache records check above, because that will prevent spurious warnings for questions
</span>    <span class="enscript-comment">// we legitimately couldn't send because the interface is no longer available
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (q-&gt;SendQNow)
        {
            DNSQuestion *x;
            <span class="enscript-keyword">for</span> (x = m-&gt;NewQuestions; x; x=x-&gt;next) <span class="enscript-keyword">if</span> (x == q) <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// Check if this question is a NewQuestion
</span>            <span class="enscript-comment">// There will not be an active interface for questions applied to mDNSInterface_BLE
</span>            <span class="enscript-comment">// so don't log the warning in that case.
</span>            <span class="enscript-keyword">if</span> (q-&gt;InterfaceID != mDNSInterface_BLE)
                LogInfo(<span class="enscript-string">&quot;SendQueries: No active interface %d to send %s question: %d %##s (%s)&quot;</span>,
                        IIDPrintable(q-&gt;SendQNow), x ? <span class="enscript-string">&quot;new&quot;</span> : <span class="enscript-string">&quot;old&quot;</span>, IIDPrintable(q-&gt;InterfaceID), q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            q-&gt;SendQNow = mDNSNULL;
        }
        q-&gt;CachedAnswerNeedsUpdate = mDNSfalse;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendWakeup</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID InterfaceID, mDNSEthAddr *EthAddr, mDNSOpaque48 *password, mDNSBool unicastOnly)
{
    <span class="enscript-type">int</span> i, j;

    mDNSu8 *ptr = m-&gt;omsg.data;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, InterfaceID);
    <span class="enscript-keyword">if</span> (!intf) { LogMsg(<span class="enscript-string">&quot;SendARP: No interface with InterfaceID %p found&quot;</span>, InterfaceID); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// 0x00 Destination address
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = EthAddr-&gt;b[i];

    <span class="enscript-comment">// 0x06 Source address (Note: Since we don't currently set the BIOCSHDRCMPLT option, BPF will fill in the real interface address for us)
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = intf-&gt;MAC.b[0];

    <span class="enscript-comment">// 0x0C Ethertype (0x0842)
</span>    *ptr++ = 0x08;
    *ptr++ = 0x42;

    <span class="enscript-comment">// 0x0E Wakeup sync sequence
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = 0xFF;

    <span class="enscript-comment">// 0x14 Wakeup data
</span>    <span class="enscript-keyword">for</span> (j=0; j&lt;16; j++) <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = EthAddr-&gt;b[i];

    <span class="enscript-comment">// 0x74 Password
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) *ptr++ = password-&gt;b[i];

    mDNSPlatformSendRawPacket(m-&gt;omsg.data, ptr, InterfaceID);

    <span class="enscript-keyword">if</span> (!unicastOnly)
    {
        <span class="enscript-comment">// For Ethernet switches that don't flood-foward packets with unknown unicast destination MAC addresses,
</span>        <span class="enscript-comment">// broadcast is the only reliable way to get a wakeup packet to the intended target machine.
</span>        <span class="enscript-comment">// For 802.11 WPA networks, where a sleeping target machine may have missed a broadcast/multicast
</span>        <span class="enscript-comment">// key rotation, unicast is the only way to get a wakeup packet to the intended target machine.
</span>        <span class="enscript-comment">// So, we send one of each, unicast first, then broadcast second.
</span>        <span class="enscript-keyword">for</span> (i=0; i&lt;6; i++) m-&gt;omsg.data[i] = 0xFF;
        mDNSPlatformSendRawPacket(m-&gt;omsg.data, ptr, InterfaceID);
    }
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">RR</span> <span class="enscript-variable-name">List</span> <span class="enscript-variable-name">Management</span> &amp; <span class="enscript-variable-name">Task</span> <span class="enscript-variable-name">Management</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Whenever a question is answered, reset its state so that we don't query
</span><span class="enscript-comment">// the network repeatedly. This happens first time when we answer the question and
</span><span class="enscript-comment">// and later when we refresh the cache.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ResetQuestionState</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    q-&gt;LastQTime        = m-&gt;timenow;
    q-&gt;LastQTxTime      = m-&gt;timenow;
    q-&gt;RecentAnswerPkts = 0;
    q-&gt;ThisQInterval    = MaxQuestionInterval;
    q-&gt;RequestUnicast   = 0;
    <span class="enscript-comment">// Reset unansweredQueries so that we don't penalize this server later when we
</span>    <span class="enscript-comment">// start sending queries when the cache expires.
</span>    q-&gt;unansweredQueries = 0;
    debugf(<span class="enscript-string">&quot;ResetQuestionState: Set MaxQuestionInterval for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdjustUnansweredQueries</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-type">const</span> mDNSs32 expireTime = RRExpireTime(rr);
    <span class="enscript-type">const</span> mDNSu32 interval = TicksTTL(rr) / 20; <span class="enscript-comment">// Calculate 5% of the cache record's TTL.
</span>    mDNSu32 rem;

    <span class="enscript-comment">// If the record is expired or UnansweredQueries is already at the max, then return early.
</span>    <span class="enscript-keyword">if</span> (((m-&gt;timenow - expireTime) &gt;= 0) || (rr-&gt;UnansweredQueries &gt;= MaxUnansweredQueries)) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (interval == 0)
    {
        LogInfo(<span class="enscript-string">&quot;AdjustUnansweredQueries: WARNING: unusually small TTL (%d ticks) for %s&quot;</span>, TicksTTL(rr), CRDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Calculate the number of whole 5% TTL intervals between now and expiration time.
</span>    rem = ((mDNSu32)(expireTime - m-&gt;timenow)) / interval;

    <span class="enscript-comment">// Calculate the expected number of remaining refresher queries.
</span>    <span class="enscript-comment">// Refresher queries are sent at the start of the last MaxUnansweredQueries intervals.
</span>    <span class="enscript-keyword">if</span> (rem &gt; MaxUnansweredQueries) rem = MaxUnansweredQueries;

    <span class="enscript-comment">// If the current number of remaining refresher queries is greater than expected, then at least one refresher query time
</span>    <span class="enscript-comment">// was missed. This can happen if the cache record didn't have an active question during any of the times at which
</span>    <span class="enscript-comment">// refresher queries would have been sent if the cache record did have an active question. The cache record's
</span>    <span class="enscript-comment">// UnansweredQueries count needs to be adjusted to avoid a burst of refresher queries being sent in an attempt to make up
</span>    <span class="enscript-comment">// for lost time. UnansweredQueries is set to the number of queries that would have been sent had the cache record had an
</span>    <span class="enscript-comment">// active question from the 80% point of its lifetime up to now, with one exception: if the number of expected remaining
</span>    <span class="enscript-comment">// refresher queries is zero (because timenow is beyond the 95% point), then UnansweredQueries is set to
</span>    <span class="enscript-comment">// MaxUnansweredQueries - 1 so that at least one refresher query is sent before the cache record expires.
</span>	<span class="enscript-comment">// Note: The cast is safe because rem is never greater than MaxUnansweredQueries; the comparison has to be signed.
</span>    <span class="enscript-keyword">if</span> ((MaxUnansweredQueries - rr-&gt;UnansweredQueries) &gt; (mDNSs32)rem)
    {
        <span class="enscript-keyword">if</span> (rem == 0) rem++;
        rr-&gt;UnansweredQueries = (mDNSu8)(MaxUnansweredQueries - rem);
    }
}

<span class="enscript-comment">// Note: AnswerCurrentQuestionWithResourceRecord can call a user callback, which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the m-&gt;CurrentQuestion (and possibly m-&gt;CurrentRecord) mechanism to protect against this.
</span><span class="enscript-comment">// In fact, to enforce this, the routine will *only* answer the question currently pointed to by m-&gt;CurrentQuestion,
</span><span class="enscript-comment">// which will be auto-advanced (possibly to NULL) if the client callback cancels the question.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerCurrentQuestionWithResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> QC_result AddRecord)
{
    DNSQuestion *<span class="enscript-type">const</span> q = m-&gt;CurrentQuestion;
    <span class="enscript-type">const</span> mDNSBool followcname = FollowCNAME(q, &amp;rr-&gt;resrec, AddRecord);

    verbosedebugf(<span class="enscript-string">&quot;AnswerCurrentQuestionWithResourceRecord:%4lu %s (%s) TTL %d %s&quot;</span>,
                  q-&gt;CurrentAnswers, AddRecord ? <span class="enscript-string">&quot;Add&quot;</span> : <span class="enscript-string">&quot;Rmv&quot;</span>, MortalityDisplayString(rr-&gt;resrec.mortality),
                  rr-&gt;resrec.rroriginalttl, CRDisplayString(m, rr));

    <span class="enscript-comment">// When the response for the question was validated, the entire rrset was validated. If we deliver
</span>    <span class="enscript-comment">// a RMV for a single record in the rrset, we invalidate the response. If we deliver another add
</span>    <span class="enscript-comment">// in the future, we will do the revalidation again.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Also, if we deliver an ADD for a negative cache record and it has no NSEC/NSEC3, the ValidationStatus needs
</span>    <span class="enscript-comment">// to be reset. This happens normally when we deliver a &quot;secure&quot; negative response followed by an insecure
</span>    <span class="enscript-comment">// negative response which can happen e.g., when disconnecting from network that leads to a negative response
</span>    <span class="enscript-comment">// due to no DNS servers. As we don't deliver RMVs for negative responses that were delivered before, we need
</span>    <span class="enscript-comment">// to do it on the next ADD of a negative cache record. This ADD could be the result of a timeout, no DNS servers
</span>    <span class="enscript-comment">// etc. in which case we need to reset the state to make sure we don't deliver them as secure. If this is
</span>    <span class="enscript-comment">// a real negative response, we would reset the state here and validate the results at the end of this function.
</span>    <span class="enscript-comment">// or the real response again if we purge the cache. 
</span>    <span class="enscript-keyword">if</span> (q-&gt;ValidationRequired &amp;&amp; ((AddRecord == QC_rmv) ||
        (rr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative &amp;&amp; (AddRecord == QC_add))))
    {
        q-&gt;ValidationStatus = 0;
        q-&gt;ValidationState = DNSSECValRequired;
    }

    <span class="enscript-comment">// Normally we don't send out the unicast query if we have answered using our local only auth records e.g., /etc/hosts.
</span>    <span class="enscript-comment">// But if the query for &quot;A&quot; record has a local answer but query for &quot;AAAA&quot; record has no local answer, we might
</span>    <span class="enscript-comment">// send the AAAA query out which will come back with CNAME and will also answer the &quot;A&quot; query. To prevent that,
</span>    <span class="enscript-comment">// we check to see if that query already has a unique local answer.
</span>    <span class="enscript-keyword">if</span> (q-&gt;LOAddressAnswers)
    {
        LogInfo(<span class="enscript-string">&quot;AnswerCurrentQuestionWithResourceRecord: Question %p %##s (%s) not answering with record %s due to &quot;</span>
                <span class="enscript-string">&quot;LOAddressAnswers %d&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), ARDisplayString(m, rr),
                q-&gt;LOAddressAnswers);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (q-&gt;Suppressed &amp;&amp; (AddRecord != QC_suppressed))
    {
        <span class="enscript-comment">// If the query is suppressed, then we don't want to answer from the cache. But if this query is
</span>        <span class="enscript-comment">// supposed to time out, we still want to callback the clients. We do this only for TimeoutQuestions
</span>        <span class="enscript-comment">// that are timing out, which we know are answered with negative cache record when timing out.
</span>        <span class="enscript-keyword">if</span> (!q-&gt;TimeoutQuestion || rr-&gt;resrec.RecordType != kDNSRecordTypePacketNegative || (m-&gt;timenow - q-&gt;StopTime &lt; 0))
            <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">//  Set the record to immortal if appropriate
</span>    <span class="enscript-keyword">if</span> (AddRecord == QC_add &amp;&amp; Question_uDNS(q) &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp;
        q-&gt;allowExpired != AllowExpired_None &amp;&amp; rr-&gt;resrec.mortality == Mortality_Mortal ) rr-&gt;resrec.mortality = Mortality_Immortal; <span class="enscript-comment">// Update a non-expired cache record to immortal if appropriate
</span>    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    <span class="enscript-keyword">if</span> ((AddRecord == QC_add) &amp;&amp; Question_uDNS(q) &amp;&amp; !followcname)
    {
        <span class="enscript-type">const</span> domainname *  queryName;
        mDNSu32             responseLatencyMs;
        mDNSBool            isForCellular;

        queryName = q-&gt;metrics.originalQName ? q-&gt;metrics.originalQName : &amp;q-&gt;qname;
        isForCellular = (q-&gt;qDNSServer &amp;&amp; q-&gt;qDNSServer-&gt;isCell);
        <span class="enscript-keyword">if</span> (!q-&gt;metrics.answered)
        {
            <span class="enscript-keyword">if</span> (q-&gt;metrics.querySendCount &gt; 0)
            {
                responseLatencyMs = ((m-&gt;timenow - q-&gt;metrics.firstQueryTime) * 1000) / mDNSPlatformOneSecond;
            }
            <span class="enscript-keyword">else</span>
            {
                responseLatencyMs = 0;
            }

            MetricsUpdateDNSQueryStats(queryName, q-&gt;qtype, &amp;rr-&gt;resrec, q-&gt;metrics.querySendCount, q-&gt;metrics.expiredAnswerState, q-&gt;metrics.dnsOverTCPState, responseLatencyMs, isForCellular);
            q-&gt;metrics.answered = mDNStrue;
        }
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// Note: Use caution here. In the case of records with rr-&gt;DelayDelivery set, AnswerCurrentQuestionWithResourceRecord(... mDNStrue)
</span>    <span class="enscript-comment">// may be called twice, once when the record is received, and again when it's time to notify local clients.
</span>    <span class="enscript-comment">// If any counters or similar are added here, care must be taken to ensure that they are not double-incremented by this.
</span>
    <span class="enscript-keyword">if</span> (AddRecord == QC_add &amp;&amp; !q-&gt;DuplicateOf &amp;&amp; rr-&gt;CRActiveQuestion != q &amp;&amp; rr-&gt;resrec.mortality != Mortality_Ghost)
    {
        debugf(<span class="enscript-string">&quot;AnswerCurrentQuestionWithResourceRecord: Updating CRActiveQuestion from %p to %p for cache record %s, CurrentAnswer %d&quot;</span>,
               rr-&gt;CRActiveQuestion, q, CRDisplayString(m,rr), q-&gt;CurrentAnswers);
        <span class="enscript-keyword">if</span> (!rr-&gt;CRActiveQuestion)
        {
            m-&gt;rrcache_active++;            <span class="enscript-comment">// If not previously active, increment rrcache_active count
</span>            AdjustUnansweredQueries(m, rr); <span class="enscript-comment">// Adjust UnansweredQueries in case the record missed out on refresher queries
</span>        }
        rr-&gt;CRActiveQuestion = q;           <span class="enscript-comment">// We know q is non-null
</span>        SetNextCacheCheckTimeForRecord(m, rr);
    }

    <span class="enscript-comment">// If this is:
</span>    <span class="enscript-comment">// (a) a no-cache add, where we've already done at least one 'QM' query, or
</span>    <span class="enscript-comment">// (b) a normal add, where we have at least one unique-type answer,
</span>    <span class="enscript-comment">// then there's no need to keep polling the network.
</span>    <span class="enscript-comment">// (If we have an answer in the cache, then we'll automatically ask again in time to stop it expiring.)
</span>    <span class="enscript-comment">// We do this for mDNS questions and uDNS one-shot questions, but not for
</span>    <span class="enscript-comment">// uDNS LongLived questions, because that would mess up our LLQ lease renewal timing.
</span>    <span class="enscript-keyword">if</span> ((AddRecord == QC_addnocache &amp;&amp; !q-&gt;RequestUnicast) ||
        (AddRecord == QC_add &amp;&amp; (q-&gt;ExpectUnique || (rr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask))))
        <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; (mDNSOpaque16IsZero(q-&gt;TargetQID) || !q-&gt;LongLived))
        {
            ResetQuestionState(m, q);
        }

    <span class="enscript-keyword">if</span> (rr-&gt;DelayDelivery) <span class="enscript-keyword">return</span>;      <span class="enscript-comment">// We'll come back later when CacheRecordDeferredAdd() calls us
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    <span class="enscript-comment">// If DNS64StateMachine() returns true, then the question was restarted as a different question, so return.
</span>    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; DNS64StateMachine(m, q, &amp;rr-&gt;resrec, AddRecord)) <span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_LIBIDN</span>
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)  <span class="enscript-comment">// If negative answer, check if we need to try Punycode conversion
</span>    {
        domainname newname;
        <span class="enscript-keyword">if</span> (PerformNextPunycodeConversion(q, &amp;newname))         <span class="enscript-comment">// Itertative Punycode conversion succeeded, so reissue question with new name
</span>        {
            UDPSocket *<span class="enscript-type">const</span> sock = q-&gt;LocalSocket;             <span class="enscript-comment">// Save old socket and transaction ID
</span>            <span class="enscript-type">const</span> mDNSOpaque16 id = q-&gt;TargetQID;
            q-&gt;LocalSocket = mDNSNULL;
            mDNS_StopQuery_internal(m, q);                      <span class="enscript-comment">// Stop old query
</span>            AssignDomainName(&amp;q-&gt;qname, &amp;newname);              <span class="enscript-comment">// Update qname
</span>            q-&gt;qnamehash = DomainNameHashValue(&amp;q-&gt;qname);      <span class="enscript-comment">// and namehash
</span>            mDNS_StartQuery_internal(m, q);                     <span class="enscript-comment">// Start new query
</span>
            <span class="enscript-keyword">if</span> (sock)                                           <span class="enscript-comment">// Transplant saved socket, if appropriate
</span>            {
                <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf) mDNSPlatformUDPClose(sock);
                <span class="enscript-keyword">else</span> { q-&gt;LocalSocket = sock; q-&gt;TargetQID = id; }
            }
            <span class="enscript-keyword">return</span>;                                             <span class="enscript-comment">// All done for now; wait until we get the next answer
</span>        }
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">USE_LIBIDN</span>

    <span class="enscript-comment">// Only deliver negative answers if client has explicitly requested them except when we are forcing a negative response
</span>    <span class="enscript-comment">// for the purpose of retrying search domains/timeout OR the question is suppressed
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative || (q-&gt;qtype != kDNSType_NSEC &amp;&amp; RRAssertsNonexistence(&amp;rr-&gt;resrec, q-&gt;qtype)))
        <span class="enscript-keyword">if</span> (!AddRecord || (AddRecord != QC_suppressed &amp;&amp; AddRecord != QC_forceresponse &amp;&amp; !q-&gt;ReturnIntermed)) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// For CNAME results to non-CNAME questions, only inform the client if they explicitly requested that
</span>    <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback &amp;&amp; !q-&gt;NoAnswer &amp;&amp; (!followcname || q-&gt;ReturnIntermed))
    {
        mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client (and us) to legally make mDNS API calls
</span>        <span class="enscript-keyword">if</span> (q-&gt;qtype != kDNSType_NSEC &amp;&amp; RRAssertsNonexistence(&amp;rr-&gt;resrec, q-&gt;qtype))
        {
            CacheRecord neg;
            MakeNegativeCacheRecord(m, &amp;neg, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;qtype, q-&gt;qclass, 1, rr-&gt;resrec.InterfaceID, q-&gt;qDNSServer);
            q-&gt;QuestionCallback(m, q, &amp;neg.resrec, AddRecord);
        }
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
            <span class="enscript-keyword">if</span> (DNS64ShouldAnswerQuestion(q, &amp;rr-&gt;resrec))
            {
                DNS64AnswerCurrentQuestion(m, &amp;rr-&gt;resrec, AddRecord);
            }
            <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
            {
                q-&gt;QuestionCallback(m, q, &amp;rr-&gt;resrec, AddRecord);
            }
        }
        mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>    }
    <span class="enscript-comment">// Note: Proceed with caution after this point because client callback function
</span>    <span class="enscript-comment">// invoked above is allowed to do anything, such as starting/stopping queries
</span>    <span class="enscript-comment">// (including this one itself, or the next or previous query in the linked list),
</span>    <span class="enscript-comment">// registering/deregistering records, starting/stopping NAT traversals, etc.
</span>
    <span class="enscript-comment">// If this is an &quot;Add&quot; operation and this question needs validation, validate the response.
</span>    <span class="enscript-comment">// In the case of negative responses, extra care should be taken. Negative cache records are
</span>    <span class="enscript-comment">// used for many purposes. For example,
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) Suppressing questions (SuppressUnusable)
</span>    <span class="enscript-comment">// 2) Timeout questions
</span>    <span class="enscript-comment">// 3) The name does not exist
</span>    <span class="enscript-comment">// 4) No DNS servers are available and we need a quick response for the application
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// (1) and (2) are handled by &quot;QC_add&quot; check as AddRecord would be &quot;QC_forceresponse&quot; or &quot;QC_suppressed&quot;
</span>    <span class="enscript-comment">// in that case. For (3), it is possible that we don't get nsecs back but we still need to call
</span>    <span class="enscript-comment">// VerifySignature so that we can deliver the appropriate DNSSEC result. There is no point in verifying
</span>    <span class="enscript-comment">// signature for (4) and hence the explicit check for q-&gt;qDNSServer.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q &amp;&amp; (AddRecord == QC_add) &amp;&amp; !q-&gt;ValidatingResponse &amp;&amp; q-&gt;ValidationRequired &amp;&amp;
        q-&gt;ValidationState == DNSSECValRequired &amp;&amp; q-&gt;qDNSServer)
    {
        q-&gt;ValidationState = DNSSECValInProgress;
        <span class="enscript-comment">// Treat it as callback call as that's what dnssec code expects
</span>        mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client (and us) to legally make mDNS API calls
</span>        VerifySignature(m, mDNSNULL, q);
        mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> ((m-&gt;CurrentQuestion == q) &amp;&amp; !ValidatingQuestion(q))
    {
        <span class="enscript-comment">// If we get a CNAME back while we are validating the response (i.e., CNAME for DS, DNSKEY, RRSIG),
</span>        <span class="enscript-comment">// don't follow them. If it is a ValidationRequired question, wait for the CNAME to be validated
</span>        <span class="enscript-comment">// first before following it
</span>        <span class="enscript-keyword">if</span> (followcname)  AnswerQuestionByFollowingCNAME(m, q, &amp;rr-&gt;resrec);
        
        <span class="enscript-comment">// If we are returning expired RRs, then remember the first expired qname we we can start the query again
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.mortality == Mortality_Ghost &amp;&amp; !q-&gt;firstExpiredQname.c[0] &amp;&amp; (q-&gt;allowExpired == AllowExpired_AllowExpiredAnswers) &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypePacketNegative)
        {
            debugf(<span class="enscript-string">&quot;AnswerCurrentQuestionWithResourceRecord: Keeping track of domain for expired RR %s for question %p&quot;</span>, CRDisplayString(m,rr), q);
            <span class="enscript-comment">// Note: question-&gt;qname is already changed at this point if following a CNAME
</span>            AssignDomainName(&amp;q-&gt;firstExpiredQname, rr-&gt;resrec.name);           <span class="enscript-comment">// Update firstExpiredQname
</span>        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CacheRecordDeferredAdd</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *cr)
{
    cr-&gt;DelayDelivery = 0;
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;CacheRecordDeferredAdd ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
    {
        DNSQuestion *q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(cr, q))
            AnswerCurrentQuestionWithResourceRecord(m, cr, QC_add);
        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

mDNSlocal mDNSs32 <span class="enscript-function-name">CheckForSoonToExpireRecords</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu32 namehash)
{
    <span class="enscript-type">const</span> mDNSs32 threshold = m-&gt;timenow + mDNSPlatformOneSecond;  <span class="enscript-comment">// See if there are any records expiring within one second
</span>    <span class="enscript-type">const</span> mDNSs32 start      = m-&gt;timenow - 0x10000000;
    mDNSs32 delay = start;
    CacheGroup *cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-type">const</span> CacheRecord *rr;

    <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (threshold - RRExpireTime(rr) &gt;= 0)     <span class="enscript-comment">// If we have records about to expire within a second
</span>        {
            <span class="enscript-keyword">if</span> (delay - RRExpireTime(rr) &lt; 0)       <span class="enscript-comment">// then delay until after they've been deleted
</span>                delay = RRExpireTime(rr);
        }
    }
    <span class="enscript-keyword">if</span> (delay - start &gt; 0)
        <span class="enscript-keyword">return</span>(NonZeroTime(delay));
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">// CacheRecordAdd is only called from CreateNewCacheEntry, *never* directly as a result of a client API call.
</span><span class="enscript-comment">// If new questions are created as a result of invoking client callbacks, they will be added to
</span><span class="enscript-comment">// the end of the question list, and m-&gt;NewQuestions will be set to indicate the first new question.
</span><span class="enscript-comment">// rr is a new CacheRecord just received into our cache
</span><span class="enscript-comment">// (kDNSRecordTypePacketAns/PacketAnsUnique/PacketAdd/PacketAddUnique).
</span><span class="enscript-comment">// Note: CacheRecordAdd calls AnswerCurrentQuestionWithResourceRecord which can call a user callback,
</span><span class="enscript-comment">// which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CacheRecordAdd</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *cr)
{
    DNSQuestion *q;

    <span class="enscript-comment">// We stop when we get to NewQuestions -- if we increment their CurrentAnswers/LargeAnswers/UniqueAnswers
</span>    <span class="enscript-comment">// counters here we'll end up double-incrementing them when we do it again in AnswerNewQuestion().
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; q != m-&gt;NewQuestions; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(cr, q))
        {
            <span class="enscript-comment">// If this question is one that's actively sending queries, and it's received ten answers within one
</span>            <span class="enscript-comment">// second of sending the last query packet, then that indicates some radical network topology change,
</span>            <span class="enscript-comment">// so reset its exponential backoff back to the start. We must be at least at the eight-second interval
</span>            <span class="enscript-comment">// to do this. If we're at the four-second interval, or less, there's not much benefit accelerating
</span>            <span class="enscript-comment">// because we will anyway send another query within a few seconds. The first reset query is sent out
</span>            <span class="enscript-comment">// randomized over the next four seconds to reduce possible synchronization between machines.
</span>            <span class="enscript-keyword">if</span> (q-&gt;LastAnswerPktNum != m-&gt;PktNum)
            {
                q-&gt;LastAnswerPktNum = m-&gt;PktNum;
                <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; ActiveQuestion(q) &amp;&amp; ++q-&gt;RecentAnswerPkts &gt;= 10 &amp;&amp;
                    q-&gt;ThisQInterval &gt; InitialQuestionInterval * QuestionIntervalStep3 &amp;&amp; m-&gt;timenow - q-&gt;LastQTxTime &lt; mDNSPlatformOneSecond)
                {
                    LogMsg(<span class="enscript-string">&quot;CacheRecordAdd: %##s (%s) got immediate answer burst (%d); restarting exponential backoff sequence (%d)&quot;</span>,
                           q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;RecentAnswerPkts, q-&gt;ThisQInterval);
                    q-&gt;LastQTime      = m-&gt;timenow - InitialQuestionInterval + (mDNSs32)mDNSRandom((mDNSu32)mDNSPlatformOneSecond*4);
                    q-&gt;ThisQInterval  = InitialQuestionInterval;
                    SetNextQueryTime(m,q);
                }
            }
            verbosedebugf(<span class="enscript-string">&quot;CacheRecordAdd %p %##s (%s) %lu %#a:%d question %p&quot;</span>, cr, cr-&gt;resrec.name-&gt;c,
                          DNSTypeName(cr-&gt;resrec.rrtype), cr-&gt;resrec.rroriginalttl, cr-&gt;resrec.rDNSServer ?
                          &amp;cr-&gt;resrec.rDNSServer-&gt;addr : mDNSNULL, mDNSVal16(cr-&gt;resrec.rDNSServer ?
                                                                             cr-&gt;resrec.rDNSServer-&gt;port : zeroIPPort), q);
            q-&gt;CurrentAnswers++;

            q-&gt;unansweredQueries = 0;
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdlength &gt; SmallRecordLimit) q-&gt;LargeAnswers++;
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) q-&gt;UniqueAnswers++;
            <span class="enscript-keyword">if</span> (q-&gt;CurrentAnswers &gt; 4000)
            {
                <span class="enscript-type">static</span> <span class="enscript-type">int</span> msgcount = 0;
                <span class="enscript-keyword">if</span> (msgcount++ &lt; 10)
                    LogMsg(<span class="enscript-string">&quot;CacheRecordAdd: %##s (%s) has %d answers; shedding records to resist DOS attack&quot;</span>,
                           q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;CurrentAnswers);
                cr-&gt;resrec.rroriginalttl = 0;
                cr-&gt;UnansweredQueries = MaxUnansweredQueries;
            }
        }
    }

    <span class="enscript-keyword">if</span> (!cr-&gt;DelayDelivery)
    {
        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
            LogMsg(<span class="enscript-string">&quot;CacheRecordAdd ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>, m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
        m-&gt;CurrentQuestion = m-&gt;Questions;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
        {
            q = m-&gt;CurrentQuestion;
            <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(cr, q))
                AnswerCurrentQuestionWithResourceRecord(m, cr, QC_add);
            <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>                m-&gt;CurrentQuestion = q-&gt;next;
        }
        m-&gt;CurrentQuestion = mDNSNULL;
    }

    SetNextCacheCheckTimeForRecord(m, cr);
}

<span class="enscript-comment">// NoCacheAnswer is only called from mDNSCoreReceiveResponse, *never* directly as a result of a client API call.
</span><span class="enscript-comment">// If new questions are created as a result of invoking client callbacks, they will be added to
</span><span class="enscript-comment">// the end of the question list, and m-&gt;NewQuestions will be set to indicate the first new question.
</span><span class="enscript-comment">// rr is a new CacheRecord just received from the wire (kDNSRecordTypePacketAns/AnsUnique/Add/AddUnique)
</span><span class="enscript-comment">// but we don't have any place to cache it. We'll deliver question 'add' events now, but we won't have any
</span><span class="enscript-comment">// way to deliver 'remove' events in future, nor will we be able to include this in known-answer lists,
</span><span class="enscript-comment">// so we immediately bump ThisQInterval up to MaxQuestionInterval to avoid pounding the network.
</span><span class="enscript-comment">// Note: NoCacheAnswer calls AnswerCurrentQuestionWithResourceRecord which can call a user callback,
</span><span class="enscript-comment">// which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NoCacheAnswer</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *cr)
{
    LogMsg(<span class="enscript-string">&quot;No cache space: Delivering non-cached result for %##s&quot;</span>, m-&gt;rec.r.resrec.name-&gt;c);
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;NoCacheAnswer ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>, m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-comment">// We do this for *all* questions, not stopping when we get to m-&gt;NewQuestions,
</span>    <span class="enscript-comment">// since we're not caching the record and we'll get no opportunity to do this later
</span>    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion)
    {
        DNSQuestion *q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(cr, q))
            AnswerCurrentQuestionWithResourceRecord(m, cr, QC_addnocache);  <span class="enscript-comment">// QC_addnocache means &quot;don't expect remove events for this&quot;
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

<span class="enscript-comment">// CacheRecordRmv is only called from CheckCacheExpiration, which is called from mDNS_Execute.
</span><span class="enscript-comment">// Note that CacheRecordRmv is *only* called for records that are referenced by at least one active question.
</span><span class="enscript-comment">// If new questions are created as a result of invoking client callbacks, they will be added to
</span><span class="enscript-comment">// the end of the question list, and m-&gt;NewQuestions will be set to indicate the first new question.
</span><span class="enscript-comment">// cr is an existing cache CacheRecord that just expired and is being deleted
</span><span class="enscript-comment">// (kDNSRecordTypePacketAns/PacketAnsUnique/PacketAdd/PacketAddUnique).
</span><span class="enscript-comment">// Note: CacheRecordRmv calls AnswerCurrentQuestionWithResourceRecord which can call a user callback,
</span><span class="enscript-comment">// which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CacheRecordRmv</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *cr)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;CacheRecordRmv ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;

    <span class="enscript-comment">// We stop when we get to NewQuestions -- for new questions their CurrentAnswers/LargeAnswers/UniqueAnswers counters
</span>    <span class="enscript-comment">// will all still be zero because we haven't yet gone through the cache counting how many answers we have for them.
</span>    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
    {
        DNSQuestion *q = m-&gt;CurrentQuestion;
        <span class="enscript-comment">// When a question enters suppressed state, we generate RMV events and generate a negative
</span>        <span class="enscript-comment">// response. A cache may be present that answers this question e.g., cache entry generated
</span>        <span class="enscript-comment">// before the question became suppressed. We need to skip the suppressed questions here as
</span>        <span class="enscript-comment">// the RMV event has already been generated.
</span>        <span class="enscript-keyword">if</span> (!q-&gt;Suppressed &amp;&amp; CacheRecordAnswersQuestion(cr, q) &amp;&amp;
            (q-&gt;allowExpired == AllowExpired_None || cr-&gt;resrec.mortality == Mortality_Mortal))
        {
            verbosedebugf(<span class="enscript-string">&quot;CacheRecordRmv %p %s&quot;</span>, cr, CRDisplayString(m, cr));
            q-&gt;FlappingInterface1 = mDNSNULL;
            q-&gt;FlappingInterface2 = mDNSNULL;

            <span class="enscript-keyword">if</span> (q-&gt;CurrentAnswers == 0)
                LogMsg(<span class="enscript-string">&quot;CacheRecordRmv ERROR!!: How can CurrentAnswers already be zero for %p %##s (%s) DNSServer %#a:%d&quot;</span>,
                       q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;qDNSServer ? &amp;q-&gt;qDNSServer-&gt;addr : mDNSNULL,
                       mDNSVal16(q-&gt;qDNSServer ? q-&gt;qDNSServer-&gt;port : zeroIPPort));
            <span class="enscript-keyword">else</span>
            {
                q-&gt;CurrentAnswers--;
                <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdlength &gt; SmallRecordLimit) q-&gt;LargeAnswers--;
                <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) q-&gt;UniqueAnswers--;
            }

            <span class="enscript-comment">// If we have dropped below the answer threshold for this mDNS question,
</span>            <span class="enscript-comment">// restart the queries at InitialQuestionInterval.
</span>            <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; (q-&gt;BrowseThreshold &gt; 0) &amp;&amp; (q-&gt;CurrentAnswers &lt; q-&gt;BrowseThreshold))
            {
                q-&gt;ThisQInterval = InitialQuestionInterval;
                q-&gt;LastQTime     = m-&gt;timenow - q-&gt;ThisQInterval;
                SetNextQueryTime(m,q);
                LogInfo(<span class="enscript-string">&quot;CacheRecordRmv: (%s) %##s dropped below threshold of %d answers&quot;</span>,
                    DNSTypeName(q-&gt;qtype), q-&gt;qname.c, q-&gt;BrowseThreshold);
            }
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdata-&gt;MaxRDLength) <span class="enscript-comment">// Never generate &quot;remove&quot; events for negative results
</span>            {
                <span class="enscript-keyword">if</span> ((q-&gt;CurrentAnswers == 0) &amp;&amp; mDNSOpaque16IsZero(q-&gt;TargetQID))
                {
                    LogInfo(<span class="enscript-string">&quot;CacheRecordRmv: Last answer for %##s (%s) expired from cache; will reconfirm antecedents&quot;</span>,
                            q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    ReconfirmAntecedents(m, &amp;q-&gt;qname, q-&gt;qnamehash, cr-&gt;resrec.InterfaceID, 0);
                }
                AnswerCurrentQuestionWithResourceRecord(m, cr, QC_rmv);
            }
        }
        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)    <span class="enscript-comment">// If m-&gt;CurrentQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseCacheEntity</span>(mDNS *<span class="enscript-type">const</span> m, CacheEntity *e)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span> &gt;= 1
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i=0; i&lt;<span class="enscript-keyword">sizeof</span>(*e); i++) ((<span class="enscript-type">char</span>*)e)[i] = 0xFF;
#<span class="enscript-reference">endif</span>
    e-&gt;next = m-&gt;rrcache_free;
    m-&gt;rrcache_free = e;
    m-&gt;rrcache_totalused--;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseCacheGroup</span>(mDNS *<span class="enscript-type">const</span> m, CacheGroup **cp)
{
    CacheEntity *e = (CacheEntity *)(*cp);
    <span class="enscript-comment">//LogMsg(&quot;ReleaseCacheGroup:  Releasing CacheGroup for %p, %##s&quot;, (*cp)-&gt;name-&gt;c, (*cp)-&gt;name-&gt;c);
</span>    <span class="enscript-keyword">if</span> ((*cp)-&gt;rrcache_tail != &amp;(*cp)-&gt;members)
        LogMsg(<span class="enscript-string">&quot;ERROR: (*cp)-&gt;members == mDNSNULL but (*cp)-&gt;rrcache_tail != &amp;(*cp)-&gt;members)&quot;</span>);
    <span class="enscript-comment">//if ((*cp)-&gt;name != (domainname*)((*cp)-&gt;namestorage))
</span>    <span class="enscript-comment">//  LogMsg(&quot;ReleaseCacheGroup: %##s, %p %p&quot;, (*cp)-&gt;name-&gt;c, (*cp)-&gt;name, (domainname*)((*cp)-&gt;namestorage));
</span>    <span class="enscript-keyword">if</span> ((*cp)-&gt;name != (domainname*)((*cp)-&gt;namestorage)) mDNSPlatformMemFree((*cp)-&gt;name);
    (*cp)-&gt;name = mDNSNULL;
    *cp = (*cp)-&gt;next;          <span class="enscript-comment">// Cut record from list
</span>    ReleaseCacheEntity(m, e);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseAdditionalCacheRecords</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord **rp)
{
    <span class="enscript-keyword">while</span> (*rp)
    {
        CacheRecord *rr = *rp;
        *rp = (*rp)-&gt;next;          <span class="enscript-comment">// Cut record from list
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdata &amp;&amp; rr-&gt;resrec.rdata != (RData*)&amp;rr-&gt;smallrdatastorage)
        {
            mDNSPlatformMemFree(rr-&gt;resrec.rdata);
            rr-&gt;resrec.rdata = mDNSNULL;
        }
        <span class="enscript-comment">// NSEC or SOA records that are not added to the CacheGroup do not share the name
</span>        <span class="enscript-comment">// of the CacheGroup.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.name)
        {
            debugf(<span class="enscript-string">&quot;ReleaseAdditionalCacheRecords: freeing cached record %##s (%s)&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
            mDNSPlatformMemFree((<span class="enscript-type">void</span> *)rr-&gt;resrec.name);
            rr-&gt;resrec.name = mDNSNULL;
        }
        <span class="enscript-comment">// Don't count the NSEC3 records used by anonymous browse/reg
</span>        <span class="enscript-keyword">if</span> (!rr-&gt;resrec.InterfaceID)
        {
            m-&gt;rrcache_totalused_unicast -= rr-&gt;resrec.rdlength;
            <span class="enscript-keyword">if</span> (DNSSECRecordType(rr-&gt;resrec.rrtype))
                BumpDNSSECStats(m, kStatsActionDecrement, kStatsTypeMemoryUsage, rr-&gt;resrec.rdlength);
        }
        ReleaseCacheEntity(m, (CacheEntity *)rr);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *r)
{
    CacheGroup *cg;

    <span class="enscript-comment">//LogMsg(&quot;ReleaseCacheRecord: Releasing %s&quot;, CRDisplayString(m, r));
</span>    <span class="enscript-keyword">if</span> (r-&gt;resrec.rdata &amp;&amp; r-&gt;resrec.rdata != (RData*)&amp;r-&gt;smallrdatastorage) mDNSPlatformMemFree(r-&gt;resrec.rdata);
    r-&gt;resrec.rdata = mDNSNULL;

    cg = CacheGroupForRecord(m, &amp;r-&gt;resrec);

    <span class="enscript-keyword">if</span> (!cg)
    {
        <span class="enscript-comment">// It is okay to have this printed for NSEC/NSEC3s
</span>        LogInfo(<span class="enscript-string">&quot;ReleaseCacheRecord: ERROR!! cg NULL for %##s (%s)&quot;</span>, r-&gt;resrec.name-&gt;c, DNSTypeName(r-&gt;resrec.rrtype));
    }
    <span class="enscript-comment">// When NSEC records are not added to the cache, it is usually cached at the &quot;nsec&quot; list
</span>    <span class="enscript-comment">// of the CacheRecord. But sometimes they may be freed without adding to the &quot;nsec&quot; list
</span>    <span class="enscript-comment">// (which is handled below) and in that case it should be freed here.
</span>    <span class="enscript-keyword">if</span> (r-&gt;resrec.name &amp;&amp; cg &amp;&amp; r-&gt;resrec.name != cg-&gt;name)
    {
        debugf(<span class="enscript-string">&quot;ReleaseCacheRecord: freeing %##s (%s)&quot;</span>, r-&gt;resrec.name-&gt;c, DNSTypeName(r-&gt;resrec.rrtype));
        mDNSPlatformMemFree((<span class="enscript-type">void</span> *)r-&gt;resrec.name);
    }
    r-&gt;resrec.name = mDNSNULL;

    <span class="enscript-keyword">if</span> (!r-&gt;resrec.InterfaceID)
    {
        m-&gt;rrcache_totalused_unicast -= r-&gt;resrec.rdlength;
        <span class="enscript-keyword">if</span> (DNSSECRecordType(r-&gt;resrec.rrtype))
            BumpDNSSECStats(m, kStatsActionDecrement, kStatsTypeMemoryUsage, r-&gt;resrec.rdlength);
    }

    ReleaseAdditionalCacheRecords(m, &amp;r-&gt;nsec);
    ReleaseAdditionalCacheRecords(m, &amp;r-&gt;soa);

    ReleaseCacheEntity(m, (CacheEntity *)r);
}

<span class="enscript-comment">// Note: We want to be careful that we deliver all the CacheRecordRmv calls before delivering
</span><span class="enscript-comment">// CacheRecordDeferredAdd calls. The in-order nature of the cache lists ensures that all
</span><span class="enscript-comment">// callbacks for old records are delivered before callbacks for newer records.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckCacheExpiration</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, CacheGroup *<span class="enscript-type">const</span> cg)
{
    CacheRecord **rp = &amp;cg-&gt;members;

    <span class="enscript-keyword">if</span> (m-&gt;lock_rrcache) { LogMsg(<span class="enscript-string">&quot;CheckCacheExpiration ERROR! Cache already locked!&quot;</span>); <span class="enscript-keyword">return</span>; }
    m-&gt;lock_rrcache = 1;

    <span class="enscript-keyword">while</span> (*rp)
    {
        CacheRecord *<span class="enscript-type">const</span> rr = *rp;
        mDNSBool recordReleased = mDNSfalse;
        mDNSs32 event = RRExpireTime(rr);
        <span class="enscript-keyword">if</span> (m-&gt;timenow - event &gt;= 0)    <span class="enscript-comment">// If expired, delete it
</span>        {
            <span class="enscript-keyword">if</span> (rr-&gt;CRActiveQuestion)   <span class="enscript-comment">// If this record has one or more active questions, tell them it's going away
</span>            {
                DNSQuestion *q = rr-&gt;CRActiveQuestion;
                verbosedebugf(<span class="enscript-string">&quot;CheckCacheExpiration: Removing%7d %7d %p %s&quot;</span>,
                              m-&gt;timenow - rr-&gt;TimeRcvd, rr-&gt;resrec.rroriginalttl, rr-&gt;CRActiveQuestion, CRDisplayString(m, rr));
                <span class="enscript-comment">// When a cache record is about to expire, we expect to do four queries at 80-82%, 85-87%, 90-92% and
</span>                <span class="enscript-comment">// then 95-97% of the TTL. If the DNS server does not respond, then we will remove the cache entry
</span>                <span class="enscript-comment">// before we pick a new DNS server. As the question interval is set to MaxQuestionInterval, we may
</span>                <span class="enscript-comment">// not send out a query anytime soon. Hence, we need to reset the question interval. If this is
</span>                <span class="enscript-comment">// a normal deferred ADD case, then AnswerCurrentQuestionWithResourceRecord will reset it to
</span>                <span class="enscript-comment">// MaxQuestionInterval. If we have inactive questions referring to negative cache entries,
</span>                <span class="enscript-comment">// don't ressurect them as they will deliver duplicate &quot;No such Record&quot; ADD events
</span>                <span class="enscript-keyword">if</span> (((mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; (rr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask)) ||
                     (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; !q-&gt;LongLived)) &amp;&amp; ActiveQuestion(q))
                {
                    q-&gt;ThisQInterval = InitialQuestionInterval;
                    q-&gt;LastQTime     = m-&gt;timenow - q-&gt;ThisQInterval;
                    SetNextQueryTime(m, q);
                }
                CacheRecordRmv(m, rr);
                m-&gt;rrcache_active--;
            }
            
            event += MAX_GHOST_TIME;                                                    <span class="enscript-comment">// Adjust so we can check for a ghost expiration
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.mortality == Mortality_Mortal ||                             <span class="enscript-comment">// Normal expired mortal record that needs released
</span>                (rr-&gt;resrec.mortality == Mortality_Ghost &amp;&amp; m-&gt;timenow - event &gt;= 0))   <span class="enscript-comment">// A ghost record that expired more than MAX_GHOST_TIME ago
</span>            {   <span class="enscript-comment">//  Release as normal
</span>                *rp = rr-&gt;next;                                     <span class="enscript-comment">// Cut it from the list before ReleaseCacheRecord
</span>                verbosedebugf(<span class="enscript-string">&quot;CheckCacheExpiration: Deleting (%s)%7d %7d %p %s&quot;</span>,
                              MortalityDisplayString(rr-&gt;resrec.mortality),
                              m-&gt;timenow - rr-&gt;TimeRcvd, rr-&gt;resrec.rroriginalttl, rr-&gt;CRActiveQuestion, CRDisplayString(m, rr));
                ReleaseCacheRecord(m, rr);
                recordReleased = mDNStrue;
            }
            <span class="enscript-keyword">else</span>                                                    <span class="enscript-comment">// An immortal record needs to become a ghost when it expires
</span>            {   <span class="enscript-comment">// Don't release this entry
</span>                <span class="enscript-keyword">if</span> (rr-&gt;resrec.mortality == Mortality_Immortal)
                {
                    rr-&gt;resrec.mortality = Mortality_Ghost;         <span class="enscript-comment">// Expired immortal records become ghosts
</span>                    verbosedebugf(<span class="enscript-string">&quot;CheckCacheExpiration: NOT Deleting (%s)%7d %7d %p %s&quot;</span>,
                                  MortalityDisplayString(rr-&gt;resrec.mortality),
                                  m-&gt;timenow - rr-&gt;TimeRcvd, rr-&gt;resrec.rroriginalttl, rr-&gt;CRActiveQuestion, CRDisplayString(m, rr));
                }
            }
        }
        <span class="enscript-keyword">else</span>                                                        <span class="enscript-comment">// else, not expired; see if we need to query
</span>        {
            <span class="enscript-comment">// If waiting to delay delivery, do nothing until then
</span>            <span class="enscript-keyword">if</span> (rr-&gt;DelayDelivery &amp;&amp; rr-&gt;DelayDelivery - m-&gt;timenow &gt; 0)
                event = rr-&gt;DelayDelivery;
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (rr-&gt;DelayDelivery) CacheRecordDeferredAdd(m, rr);
                <span class="enscript-keyword">if</span> (rr-&gt;CRActiveQuestion &amp;&amp; rr-&gt;UnansweredQueries &lt; MaxUnansweredQueries)
                {
                    <span class="enscript-keyword">if</span> (m-&gt;timenow - rr-&gt;NextRequiredQuery &lt; 0)     <span class="enscript-comment">// If not yet time for next query
</span>                        event = NextCacheCheckEvent(rr);            <span class="enscript-comment">// then just record when we want the next query
</span>                    <span class="enscript-keyword">else</span>                                            <span class="enscript-comment">// else trigger our question to go out now
</span>                    {
                        <span class="enscript-comment">// Set NextScheduledQuery to timenow so that SendQueries() will run.
</span>                        <span class="enscript-comment">// SendQueries() will see that we have records close to expiration, and send FEQs for them.
</span>                        m-&gt;NextScheduledQuery = m-&gt;timenow;
                        <span class="enscript-comment">// After sending the query we'll increment UnansweredQueries and call SetNextCacheCheckTimeForRecord(),
</span>                        <span class="enscript-comment">// which will correctly update m-&gt;NextCacheCheck for us.
</span>                        event = m-&gt;timenow + FutureTime;
                    }
                }
            }
        }
        
        <span class="enscript-keyword">if</span> (!recordReleased)  <span class="enscript-comment">//  Schedule if we did not release the record
</span>        {
            verbosedebugf(<span class="enscript-string">&quot;CheckCacheExpiration:%6d %5d %s&quot;</span>,
                          (event - m-&gt;timenow) / mDNSPlatformOneSecond, CacheCheckGracePeriod(rr), CRDisplayString(m, rr));
            <span class="enscript-keyword">if</span> (m-&gt;rrcache_nextcheck[slot] - event &gt; 0)
                m-&gt;rrcache_nextcheck[slot] = event;
            rp = &amp;rr-&gt;next;
        }
    }
    <span class="enscript-keyword">if</span> (cg-&gt;rrcache_tail != rp) verbosedebugf(<span class="enscript-string">&quot;CheckCacheExpiration: Updating CacheGroup tail from %p to %p&quot;</span>, cg-&gt;rrcache_tail, rp);
    cg-&gt;rrcache_tail = rp;
    m-&gt;lock_rrcache = 0;
}

<span class="enscript-comment">// &quot;LORecord&quot; includes both LocalOnly and P2P record. This function assumes m-&gt;CurrentQuestion is pointing to &quot;q&quot;.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If &quot;CheckOnly&quot; is set to &quot;true&quot;, the question won't be answered but just check to see if there is an answer and
</span><span class="enscript-comment">// returns true if there is an answer.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If &quot;CheckOnly&quot; is set to &quot;false&quot;, the question will be answered if there is a LocalOnly/P2P record and 
</span><span class="enscript-comment">// returns true to indicate the same.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">AnswerQuestionWithLORecord</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSBool checkOnly)
{
    AuthRecord *lr;
    AuthGroup *ag;

    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;AnswerQuestionWithLORecord ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));

    ag = AuthGroupForName(&amp;m-&gt;rrauth, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">if</span> (ag)
    {
        m-&gt;CurrentRecord = ag-&gt;members;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord &amp;&amp; m-&gt;CurrentRecord != ag-&gt;NewLocalOnlyRecords)
        {
            AuthRecord *rr = m-&gt;CurrentRecord;
            m-&gt;CurrentRecord = rr-&gt;next;
            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// If the question is mDNSInterface_LocalOnly, all records local to the machine should be used
</span>            <span class="enscript-comment">// to answer the query. This is handled in AnswerNewLocalOnlyQuestion.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// We handle mDNSInterface_Any and scoped questions here. See LocalOnlyRecordAnswersQuestion for more
</span>            <span class="enscript-comment">// details on how we handle this case. For P2P we just handle &quot;Interface_Any&quot; questions. For LocalOnly
</span>            <span class="enscript-comment">// we handle both mDNSInterface_Any and scoped questions.
</span>
            <span class="enscript-keyword">if</span> (rr-&gt;ARType == AuthRecordLocalOnly || (rr-&gt;ARType == AuthRecordP2P &amp;&amp; (q-&gt;InterfaceID == mDNSInterface_Any || q-&gt;InterfaceID == mDNSInterface_BLE)))
                <span class="enscript-keyword">if</span> (LocalOnlyRecordAnswersQuestion(rr, q))
                {
                    <span class="enscript-keyword">if</span> (checkOnly)
                    {
                        LogInfo(<span class="enscript-string">&quot;AnswerQuestionWithLORecord: question %##s (%s) answered by %s&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype),
                            ARDisplayString(m, rr));
                        m-&gt;CurrentRecord = mDNSNULL;
                        <span class="enscript-keyword">return</span> mDNStrue;
                    }
                    AnswerLocalQuestionWithLocalAuthRecord(m, rr, QC_add);
                    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q)
                        <span class="enscript-keyword">break</span>;     <span class="enscript-comment">// If callback deleted q, then we're finished here
</span>                }
        }
    }
    m-&gt;CurrentRecord = mDNSNULL;

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q)
    {
        LogInfo(<span class="enscript-string">&quot;AnswerQuestionWithLORecord: Question deleted while while answering LocalOnly record answers&quot;</span>);
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-keyword">if</span> (q-&gt;LOAddressAnswers)
    {
        LogInfo(<span class="enscript-string">&quot;AnswerQuestionWithLORecord: Question %p %##s (%s) answered using local auth records LOAddressAnswers %d&quot;</span>,
                q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;LOAddressAnswers);
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-comment">// Before we go check the cache and ship this query on the wire, we have to be sure that there are
</span>    <span class="enscript-comment">// no local records that could possibly answer this question. As we did not check the NewLocalRecords, we
</span>    <span class="enscript-comment">// need to just peek at them to see whether it will answer this question. If it would answer, pretend
</span>    <span class="enscript-comment">// that we answered. AnswerAllLocalQuestionsWithLocalAuthRecord will answer shortly. This happens normally
</span>    <span class="enscript-comment">// when we add new /etc/hosts entries and restart the question. It is a new question and also a new record.
</span>    <span class="enscript-keyword">if</span> (ag)
    {
        lr = ag-&gt;NewLocalOnlyRecords;
        <span class="enscript-keyword">while</span> (lr)
        {
            <span class="enscript-keyword">if</span> (UniqueLocalOnlyRecord(lr) &amp;&amp; LocalOnlyRecordAnswersQuestion(lr, q))
            {
                LogInfo(<span class="enscript-string">&quot;AnswerQuestionWithLORecord: Question %p %##s (%s) will be answered using new local auth records &quot;</span>
                        <span class="enscript-string">&quot; LOAddressAnswers %d&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;LOAddressAnswers);
                <span class="enscript-keyword">return</span> mDNStrue;
            }
            lr = lr-&gt;next;
        }
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Today, we suppress questions (not send them on the wire) for several reasons e.g.,
</span><span class="enscript-comment">// AAAA query is suppressed because no IPv6 capability or PID is not allowed to make
</span><span class="enscript-comment">// DNS requests.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerSuppressedQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    <span class="enscript-comment">// If the client did not set the kDNSServiceFlagsReturnIntermediates flag, then don't generate a negative response,
</span>    <span class="enscript-comment">// just deactivate the DNSQuestion.
</span>    <span class="enscript-keyword">if</span> (q-&gt;ReturnIntermed)
    {
        GenerateNegativeResponse(m, mDNSInterface_Any, QC_suppressed);
    }
    <span class="enscript-keyword">else</span>
    {
        q-&gt;ThisQInterval = 0;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerNewQuestion</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSBool ShouldQueryImmediately = mDNStrue;
    DNSQuestion *<span class="enscript-type">const</span> q = m-&gt;NewQuestions;     <span class="enscript-comment">// Grab the question we're going to answer
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID)) DNS64HandleNewQuestion(m, q);
#<span class="enscript-reference">endif</span>
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);

    verbosedebugf(<span class="enscript-string">&quot;AnswerNewQuestion: Answering %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

    <span class="enscript-keyword">if</span> (cg) CheckCacheExpiration(m, HashSlotFromNameHash(q-&gt;qnamehash), cg);
    <span class="enscript-keyword">if</span> (m-&gt;NewQuestions != q) { LogInfo(<span class="enscript-string">&quot;AnswerNewQuestion: Question deleted while doing CheckCacheExpiration&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
    m-&gt;NewQuestions = q-&gt;next;
    <span class="enscript-comment">// Advance NewQuestions to the next *after* calling CheckCacheExpiration, because if we advance it first
</span>    <span class="enscript-comment">// then CheckCacheExpiration may give this question add/remove callbacks, and it's not yet ready for that.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Also, CheckCacheExpiration() calls CacheRecordDeferredAdd() and CacheRecordRmv(), which invoke
</span>    <span class="enscript-comment">// client callbacks, which may delete their own or any other question. Our mechanism for detecting
</span>    <span class="enscript-comment">// whether our current m-&gt;NewQuestions question got deleted by one of these callbacks is to store the
</span>    <span class="enscript-comment">// value of m-&gt;NewQuestions in 'q' before calling CheckCacheExpiration(), and then verify afterwards
</span>    <span class="enscript-comment">// that they're still the same. If m-&gt;NewQuestions has changed (because mDNS_StopQuery_internal
</span>    <span class="enscript-comment">// advanced it), that means the question was deleted, so we no longer need to worry about answering
</span>    <span class="enscript-comment">// it (and indeed 'q' is now a dangling pointer, so dereferencing it at all would be bad, and the
</span>    <span class="enscript-comment">// values we computed for slot and cg are now stale and relate to a question that no longer exists).
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We can't use the usual m-&gt;CurrentQuestion mechanism for this because  CacheRecordDeferredAdd() and
</span>    <span class="enscript-comment">// CacheRecordRmv() both use that themselves when walking the list of (non-new) questions generating callbacks.
</span>    <span class="enscript-comment">// Fortunately mDNS_StopQuery_internal auto-advances both m-&gt;CurrentQuestion *AND* m-&gt;NewQuestions when
</span>    <span class="enscript-comment">// deleting a question, so luckily we have an easy alternative way of detecting if our question got deleted.
</span>
    <span class="enscript-keyword">if</span> (m-&gt;lock_rrcache) LogMsg(<span class="enscript-string">&quot;AnswerNewQuestion ERROR! Cache already locked!&quot;</span>);
    <span class="enscript-comment">// This should be safe, because calling the client's question callback may cause the
</span>    <span class="enscript-comment">// question list to be modified, but should not ever cause the rrcache list to be modified.
</span>    <span class="enscript-comment">// If the client's question callback deletes the question, then m-&gt;CurrentQuestion will
</span>    <span class="enscript-comment">// be advanced, and we'll exit out of the loop
</span>    m-&gt;lock_rrcache = 1;
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion) {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerNewQuestion ERROR m-&gt;CurrentQuestion already set: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;request_id, mDNSVal16(m-&gt;CurrentQuestion-&gt;TargetQID),
               DM_NAME_PARAM(m-&gt;CurrentQuestion-&gt;qname.c), DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    }

    m-&gt;CurrentQuestion = q;     <span class="enscript-comment">// Indicate which question we're answering, so we'll know if it gets deleted
</span>
    <span class="enscript-keyword">if</span> (q-&gt;NoAnswer == NoAnswer_Fail)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerNewQuestion: NoAnswer_Fail &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));

        MakeNegativeCacheRecord(m, &amp;m-&gt;rec.r, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;qtype, q-&gt;qclass, 60, mDNSInterface_Any, q-&gt;qDNSServer);
        q-&gt;NoAnswer = NoAnswer_Normal;      <span class="enscript-comment">// Temporarily turn off answer suppression
</span>        AnswerCurrentQuestionWithResourceRecord(m, &amp;m-&gt;rec.r, QC_addnocache);
        <span class="enscript-comment">// Don't touch the question if it has been stopped already
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q) q-&gt;NoAnswer = NoAnswer_Fail;       <span class="enscript-comment">// Restore NoAnswer state
</span>        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q)
    {
        LogInfo(<span class="enscript-string">&quot;AnswerNewQuestion: Question deleted while generating NoAnswer_Fail response&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// See if we want to tell it about LocalOnly/P2P records. If we answered them using LocalOnly
</span>    <span class="enscript-comment">// or P2P record, then we are done.
</span>    <span class="enscript-keyword">if</span> (AnswerQuestionWithLORecord(m, q, mDNSfalse))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-comment">// If it is a question trying to validate some response, it already checked the cache for a response. If it still
</span>    <span class="enscript-comment">// reissues a question it means it could not find the RRSIGs. So, we need to bypass the cache check and send
</span>    <span class="enscript-comment">// the question out.
</span>    <span class="enscript-keyword">if</span> (q-&gt;Suppressed)
    {
        AnswerSuppressedQuestion(m, q);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!q-&gt;ValidatingResponse)
    {
        CacheRecord *cr;
        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
            <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, q))
            {
                <span class="enscript-comment">// SecsSinceRcvd is whole number of elapsed seconds, rounded down
</span>                mDNSu32 SecsSinceRcvd = ((mDNSu32)(m-&gt;timenow - cr-&gt;TimeRcvd)) / mDNSPlatformOneSecond;
                mDNSBool IsExpired = (cr-&gt;resrec.rroriginalttl &lt;= SecsSinceRcvd);
                <span class="enscript-keyword">if</span> (IsExpired &amp;&amp; q-&gt;allowExpired != AllowExpired_AllowExpiredAnswers) <span class="enscript-keyword">continue</span>;   <span class="enscript-comment">// Go to next one in loop
</span>
                <span class="enscript-comment">// If this record set is marked unique, then that means we can reasonably assume we have the whole set
</span>                <span class="enscript-comment">// -- we don't need to rush out on the network and query immediately to see if there are more answers out there
</span>                <span class="enscript-keyword">if</span> ((cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) || (q-&gt;ExpectUnique))
                    ShouldQueryImmediately = mDNSfalse;
                q-&gt;CurrentAnswers++;
                <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdlength &gt; SmallRecordLimit) q-&gt;LargeAnswers++;
                <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) q-&gt;UniqueAnswers++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                <span class="enscript-keyword">if</span> (q-&gt;metrics.expiredAnswerState == ExpiredAnswer_Allowed) q-&gt;metrics.expiredAnswerState = IsExpired ? ExpiredAnswer_AnsweredWithExpired : ExpiredAnswer_AnsweredWithCache;
#<span class="enscript-reference">endif</span>
                AnswerCurrentQuestionWithResourceRecord(m, cr, QC_add);
                <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) <span class="enscript-keyword">break</span>;     <span class="enscript-comment">// If callback deleted q, then we're finished here
</span>            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; RRTypeIsAddressType(cr-&gt;resrec.rrtype) &amp;&amp; RRTypeIsAddressType(q-&gt;qtype))
                ShouldQueryImmediately = mDNSfalse;
    }
    <span class="enscript-comment">// We don't use LogInfo for this &quot;Question deleted&quot; message because it happens so routinely that
</span>    <span class="enscript-comment">// it's not remotely remarkable, and therefore unlikely to be of much help tracking down bugs.
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) { debugf(<span class="enscript-string">&quot;AnswerNewQuestion: Question deleted while giving cache answers&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

    q-&gt;InitialCacheMiss  = mDNStrue;                                    <span class="enscript-comment">// Initial cache check is done, so mark as a miss from now on
</span>    <span class="enscript-keyword">if</span> (q-&gt;allowExpired == AllowExpired_AllowExpiredAnswers)
    {
        q-&gt;allowExpired = AllowExpired_MakeAnswersImmortal;             <span class="enscript-comment">// After looking through the cache for an answer, demote to make immortal
</span>        <span class="enscript-keyword">if</span> (q-&gt;firstExpiredQname.c[0])                                  <span class="enscript-comment">// If an original query name was saved on an expired answer, start it over in case it is updated
</span>        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                   <span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerNewQuestion: Restarting original question %p firstExpiredQname &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; for allowExpiredAnswers question&quot;</span>,
                   q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(&amp;q-&gt;firstExpiredQname.c));
            mDNS_StopQuery_internal(m, q);                              <span class="enscript-comment">// Stop old query
</span>            AssignDomainName(&amp;q-&gt;qname, &amp;q-&gt;firstExpiredQname);         <span class="enscript-comment">// Update qname
</span>            q-&gt;qnamehash = DomainNameHashValue(&amp;q-&gt;qname);              <span class="enscript-comment">// and namehash
</span>            mDNS_StartQuery_internal(m, q);                             <span class="enscript-comment">// start new query
</span>            q-&gt;CNAMEReferrals = 0;                                      <span class="enscript-comment">// Reset referral count
</span>            q-&gt;firstExpiredQname.c[0] = 0;                              <span class="enscript-comment">// Erase the domain name
</span>        }
    }
    
    <span class="enscript-comment">// Note: When a query gets suppressed or retried with search domains, we de-activate the question.
</span>    <span class="enscript-comment">// Hence we don't execute the following block of code for those cases.
</span>    <span class="enscript-keyword">if</span> (ShouldQueryImmediately &amp;&amp; ActiveQuestion(q))
    {
        debugf(<span class="enscript-string">&quot;[R%d-&gt;Q%d] AnswerNewQuestion: ShouldQueryImmediately %##s (%s)&quot;</span>, q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        q-&gt;ThisQInterval  = InitialQuestionInterval;
        q-&gt;LastQTime      = m-&gt;timenow - q-&gt;ThisQInterval;
        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))       <span class="enscript-comment">// For mDNS, spread packets to avoid a burst of simultaneous queries
</span>        {
            <span class="enscript-comment">// Compute random delay in the range 1-6 seconds, then divide by 50 to get 20-120ms
</span>            <span class="enscript-keyword">if</span> (!m-&gt;RandomQueryDelay)
                m-&gt;RandomQueryDelay = (mDNSPlatformOneSecond + mDNSRandom(mDNSPlatformOneSecond*5) - 1) / 50 + 1;
            q-&gt;LastQTime += m-&gt;RandomQueryDelay;
        }
    }

    <span class="enscript-comment">// IN ALL CASES make sure that m-&gt;NextScheduledQuery is set appropriately.
</span>    <span class="enscript-comment">// In cases where m-&gt;NewQuestions-&gt;DelayAnswering is set, we may have delayed generating our
</span>    <span class="enscript-comment">// answers for this question until *after* its scheduled transmission time, in which case
</span>    <span class="enscript-comment">// m-&gt;NextScheduledQuery may now be set to 'never', and in that case -- even though we're *not* doing
</span>    <span class="enscript-comment">// ShouldQueryImmediately -- we still need to make sure we set m-&gt;NextScheduledQuery correctly.
</span>    SetNextQueryTime(m,q);

<span class="enscript-reference">exit</span>:
    m-&gt;CurrentQuestion = mDNSNULL;
    m-&gt;lock_rrcache = 0;
}

<span class="enscript-comment">// When a NewLocalOnlyQuestion is created, AnswerNewLocalOnlyQuestion runs though our ResourceRecords delivering any
</span><span class="enscript-comment">// appropriate answers, stopping if it reaches a NewLocalOnlyRecord -- these will be handled by AnswerAllLocalQuestionsWithLocalAuthRecord
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerNewLocalOnlyQuestion</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthGroup *ag;
    DNSQuestion *q = m-&gt;NewLocalOnlyQuestions;      <span class="enscript-comment">// Grab the question we're going to answer
</span>    mDNSBool retEv = mDNSfalse;
    m-&gt;NewLocalOnlyQuestions = q-&gt;next;             <span class="enscript-comment">// Advance NewLocalOnlyQuestions to the next (if any)
</span>
    debugf(<span class="enscript-string">&quot;AnswerNewLocalOnlyQuestion: Answering %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;AnswerNewLocalOnlyQuestion ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = q;     <span class="enscript-comment">// Indicate which question we're answering, so we'll know if it gets deleted
</span>
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;AnswerNewLocalOnlyQuestion ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));

    <span class="enscript-comment">// 1. First walk the LocalOnly records answering the LocalOnly question
</span>    <span class="enscript-comment">// 2. As LocalOnly questions should also be answered by any other Auth records local to the machine,
</span>    <span class="enscript-comment">//    walk the ResourceRecords list delivering the answers
</span>    ag = AuthGroupForName(&amp;m-&gt;rrauth, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">if</span> (ag)
    {
        m-&gt;CurrentRecord = ag-&gt;members;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord &amp;&amp; m-&gt;CurrentRecord != ag-&gt;NewLocalOnlyRecords)
        {
            AuthRecord *rr = m-&gt;CurrentRecord;
            m-&gt;CurrentRecord = rr-&gt;next;
            <span class="enscript-keyword">if</span> (LocalOnlyRecordAnswersQuestion(rr, q))
            {
                retEv = mDNStrue;
                AnswerLocalQuestionWithLocalAuthRecord(m, rr, QC_add);
                <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) <span class="enscript-keyword">break</span>;     <span class="enscript-comment">// If callback deleted q, then we're finished here
</span>            }
        }
    }

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)
    {
        m-&gt;CurrentRecord = m-&gt;ResourceRecords;

        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord &amp;&amp; m-&gt;CurrentRecord != m-&gt;NewLocalRecords)
        {
            AuthRecord *ar = m-&gt;CurrentRecord;
            m-&gt;CurrentRecord = ar-&gt;next;
            <span class="enscript-keyword">if</span> (AuthRecordAnswersQuestion(ar, q))
            {
                retEv = mDNStrue;
                AnswerLocalQuestionWithLocalAuthRecord(m, ar, QC_add);
                <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) <span class="enscript-keyword">break</span>;     <span class="enscript-comment">// If callback deleted q, then we're finished here
</span>            }
        }
    }

    <span class="enscript-comment">// The local host is the authoritative source for LocalOnly questions
</span>    <span class="enscript-comment">// so if no records exist and client requested intermediates, then generate a negative response
</span>    <span class="enscript-keyword">if</span> (!retEv &amp;&amp; (m-&gt;CurrentQuestion == q) &amp;&amp; q-&gt;ReturnIntermed)
        GenerateNegativeResponse(m, mDNSInterface_LocalOnly, QC_forceresponse);

    m-&gt;CurrentQuestion = mDNSNULL;
    m-&gt;CurrentRecord   = mDNSNULL;
}

mDNSlocal CacheEntity *<span class="enscript-function-name">GetCacheEntity</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> CacheGroup *<span class="enscript-type">const</span> PreserveCG)
{
    CacheEntity *e = mDNSNULL;

    <span class="enscript-keyword">if</span> (m-&gt;lock_rrcache) { LogMsg(<span class="enscript-string">&quot;GetFreeCacheRR ERROR! Cache already locked!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    m-&gt;lock_rrcache = 1;

    <span class="enscript-comment">// If we have no free records, ask the client layer to give us some more memory
</span>    <span class="enscript-keyword">if</span> (!m-&gt;rrcache_free &amp;&amp; m-&gt;MainCallback)
    {
        <span class="enscript-keyword">if</span> (m-&gt;rrcache_totalused != m-&gt;rrcache_size)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                      <span class="enscript-string">&quot;GetFreeCacheRR: count mismatch: m-&gt;rrcache_totalused %u != m-&gt;rrcache_size %u&quot;</span>,
                      m-&gt;rrcache_totalused, m-&gt;rrcache_size);
        }

        <span class="enscript-comment">// We don't want to be vulnerable to a malicious attacker flooding us with an infinite
</span>        <span class="enscript-comment">// number of bogus records so that we keep growing our cache until the machine runs out of memory.
</span>        <span class="enscript-comment">// To guard against this, if our cache grows above 512kB (approx 3168 records at 164 bytes each),
</span>        <span class="enscript-comment">// and we're actively using less than 1/32 of that cache, then we purge all the unused records
</span>        <span class="enscript-comment">// and recycle them, instead of allocating more memory.
</span>        <span class="enscript-keyword">if</span> (m-&gt;rrcache_size &gt; 5000 &amp;&amp; m-&gt;rrcache_size / 32 &gt; m-&gt;rrcache_active)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                      <span class="enscript-string">&quot;Possible denial-of-service attack in progress: m-&gt;rrcache_size %u; m-&gt;rrcache_active %u&quot;</span>,
                      m-&gt;rrcache_size, m-&gt;rrcache_active);
        }
        <span class="enscript-keyword">else</span>
        {
            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>            m-&gt;MainCallback(m, mStatus_GrowCache);
            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        }
    }

    <span class="enscript-comment">// If we still have no free records, recycle all the records we can.
</span>    <span class="enscript-comment">// Enumerating the entire cache is moderately expensive, so when we do it, we reclaim all the records we can in one pass.
</span>    <span class="enscript-keyword">if</span> (!m-&gt;rrcache_free)
    {
        mDNSu32 oldtotalused = m-&gt;rrcache_totalused;
        mDNSu32 slot;
        <span class="enscript-keyword">for</span> (slot = 0; slot &lt; CACHE_HASH_SLOTS; slot++)
        {
            CacheGroup **cp = &amp;m-&gt;rrcache_hash[slot];
            <span class="enscript-keyword">while</span> (*cp)
            {
                CacheRecord **rp = &amp;(*cp)-&gt;members;
                <span class="enscript-keyword">while</span> (*rp)
                {
                    <span class="enscript-comment">// Records that answer still-active questions are not candidates for recycling
</span>                    <span class="enscript-comment">// Records that are currently linked into the CacheFlushRecords list may not be recycled, or we'll crash
</span>                    <span class="enscript-keyword">if</span> ((*rp)-&gt;CRActiveQuestion || (*rp)-&gt;NextInCFList)
                        rp=&amp;(*rp)-&gt;next;
                    <span class="enscript-keyword">else</span>
                    {
                        CacheRecord *rr = *rp;
                        *rp = (*rp)-&gt;next;          <span class="enscript-comment">// Cut record from list
</span>                        ReleaseCacheRecord(m, rr);
                    }
                }
                <span class="enscript-keyword">if</span> ((*cp)-&gt;rrcache_tail != rp)
                    verbosedebugf(<span class="enscript-string">&quot;GetFreeCacheRR: Updating rrcache_tail[%lu] from %p to %p&quot;</span>, slot, (*cp)-&gt;rrcache_tail, rp);
                (*cp)-&gt;rrcache_tail = rp;
                <span class="enscript-keyword">if</span> ((*cp)-&gt;members || (*cp)==PreserveCG) cp=&amp;(*cp)-&gt;next;
                <span class="enscript-keyword">else</span> ReleaseCacheGroup(m, cp);
            }
        }
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;GetCacheEntity recycled %d records to reduce cache from %d to %d&quot;</span>,
                  oldtotalused - m-&gt;rrcache_totalused, oldtotalused, m-&gt;rrcache_totalused);
    }

    <span class="enscript-keyword">if</span> (m-&gt;rrcache_free)    <span class="enscript-comment">// If there are records in the free list, take one
</span>    {
        e = m-&gt;rrcache_free;
        m-&gt;rrcache_free = e-&gt;next;
        <span class="enscript-keyword">if</span> (++m-&gt;rrcache_totalused &gt;= m-&gt;rrcache_report)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;RR Cache now using %u objects&quot;</span>, m-&gt;rrcache_totalused);
            <span class="enscript-keyword">if</span>      (m-&gt;rrcache_report &lt;  100) m-&gt;rrcache_report += 10;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;rrcache_report &lt; 1000) m-&gt;rrcache_report += 100;
            <span class="enscript-keyword">else</span> m-&gt;rrcache_report += 1000;
        }
        mDNSPlatformMemZero(e, <span class="enscript-keyword">sizeof</span>(*e));
    }

    m-&gt;lock_rrcache = 0;

    <span class="enscript-keyword">return</span>(e);
}

mDNSlocal CacheRecord *<span class="enscript-function-name">GetCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheGroup *cg, mDNSu16 RDLength)
{
    CacheRecord *r = (CacheRecord *)GetCacheEntity(m, cg);
    <span class="enscript-keyword">if</span> (r)
    {
        r-&gt;resrec.rdata = (RData*)&amp;r-&gt;smallrdatastorage;    <span class="enscript-comment">// By default, assume we're usually going to be using local storage
</span>        <span class="enscript-keyword">if</span> (RDLength &gt; InlineCacheRDSize)           <span class="enscript-comment">// If RDLength is too big, allocate extra storage
</span>        {
            r-&gt;resrec.rdata = (RData*) mDNSPlatformMemAllocateClear(sizeofRDataHeader + RDLength);
            <span class="enscript-keyword">if</span> (r-&gt;resrec.rdata) r-&gt;resrec.rdata-&gt;MaxRDLength = r-&gt;resrec.rdlength = RDLength;
            <span class="enscript-keyword">else</span> { ReleaseCacheEntity(m, (CacheEntity*)r); r = mDNSNULL; }
        }
    }
    <span class="enscript-keyword">return</span>(r);
}

mDNSlocal CacheGroup *<span class="enscript-function-name">GetCacheGroup</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    mDNSu16 namelen = DomainNameLength(rr-&gt;name);
    CacheGroup *cg = (CacheGroup*)GetCacheEntity(m, mDNSNULL);
    <span class="enscript-keyword">if</span> (!cg) { LogMsg(<span class="enscript-string">&quot;GetCacheGroup: Failed to allocate memory for %##s&quot;</span>, rr-&gt;name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }
    cg-&gt;next         = m-&gt;rrcache_hash[slot];
    cg-&gt;namehash     = rr-&gt;namehash;
    cg-&gt;members      = mDNSNULL;
    cg-&gt;rrcache_tail = &amp;cg-&gt;members;
    <span class="enscript-keyword">if</span> (namelen &gt; <span class="enscript-keyword">sizeof</span>(cg-&gt;namestorage))
        cg-&gt;name = (domainname *) mDNSPlatformMemAllocate(namelen);
    <span class="enscript-keyword">else</span>
        cg-&gt;name = (domainname*)cg-&gt;namestorage;
    <span class="enscript-keyword">if</span> (!cg-&gt;name)
    {
        LogMsg(<span class="enscript-string">&quot;GetCacheGroup: Failed to allocate name storage for %##s&quot;</span>, rr-&gt;name-&gt;c);
        ReleaseCacheEntity(m, (CacheEntity*)cg);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }
    AssignDomainName(cg-&gt;name, rr-&gt;name);

    <span class="enscript-keyword">if</span> (CacheGroupForRecord(m, rr)) LogMsg(<span class="enscript-string">&quot;GetCacheGroup: Already have CacheGroup for %##s&quot;</span>, rr-&gt;name-&gt;c);
    m-&gt;rrcache_hash[slot] = cg;
    <span class="enscript-keyword">if</span> (CacheGroupForRecord(m, rr) != cg) LogMsg(<span class="enscript-string">&quot;GetCacheGroup: Not finding CacheGroup for %##s&quot;</span>, rr-&gt;name-&gt;c);

    <span class="enscript-keyword">return</span>(cg);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_PurgeCacheResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *rr)
{
    mDNS_CheckLock(m);

    <span class="enscript-comment">// Make sure we mark this record as thoroughly expired -- we don't ever want to give
</span>    <span class="enscript-comment">// a positive answer using an expired record (e.g. from an interface that has gone away).
</span>    <span class="enscript-comment">// We don't want to clear CRActiveQuestion here, because that would leave the record subject to
</span>    <span class="enscript-comment">// summary deletion without giving the proper callback to any questions that are monitoring it.
</span>    <span class="enscript-comment">// By setting UnansweredQueries to MaxUnansweredQueries we ensure it won't trigger any further expiration queries.
</span>    rr-&gt;TimeRcvd          = m-&gt;timenow - mDNSPlatformOneSecond * 60;
    rr-&gt;UnansweredQueries = MaxUnansweredQueries;
    rr-&gt;resrec.rroriginalttl     = 0;
    SetNextCacheCheckTimeForRecord(m, rr);
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNS_TimeNow</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m)
{
    mDNSs32 time;
    mDNSPlatformLock(m);
    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_TimeNow called while holding mDNS lock. This is incorrect. Code protected by lock should just use m-&gt;timenow.&quot;</span>);
        <span class="enscript-keyword">if</span> (!m-&gt;timenow) LogMsg(<span class="enscript-string">&quot;mDNS_TimeNow: m-&gt;mDNS_busy is %ld but m-&gt;timenow not set&quot;</span>, m-&gt;mDNS_busy);
    }

    <span class="enscript-keyword">if</span> (m-&gt;timenow) time = m-&gt;timenow;
    <span class="enscript-keyword">else</span> time = mDNS_TimeNow_NoLock(m);
    mDNSPlatformUnlock(m);
    <span class="enscript-keyword">return</span>(time);
}

<span class="enscript-comment">// To avoid pointless CPU thrash, we use SetSPSProxyListChanged(X) to record the last interface that
</span><span class="enscript-comment">// had its Sleep Proxy client list change, and defer to actual BPF reconfiguration to mDNS_Execute().
</span><span class="enscript-comment">// (GetNextScheduledEvent() returns &quot;now&quot; when m-&gt;SPSProxyListChanged is set)
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">SetSPSProxyListChanged</span>(X) do { \
        if (m-&gt;SPSProxyListChanged &amp;&amp; m-&gt;SPSProxyListChanged != (X)) mDNSPlatformUpdateProxyList(m-&gt;SPSProxyListChanged); \
        m-&gt;SPSProxyListChanged = (X); } while(0)

<span class="enscript-comment">// Called from mDNS_Execute() to expire stale proxy records
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckProxyRecords</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *list)
{
    m-&gt;CurrentRecord = list;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp; rr-&gt;WakeUp.HMAC.l[0])
        {
            <span class="enscript-comment">// If m-&gt;SPSSocket is NULL that means we're not acting as a sleep proxy any more,
</span>            <span class="enscript-comment">// so we need to cease proxying for *all* records we may have, expired or not.
</span>            <span class="enscript-keyword">if</span> (m-&gt;SPSSocket &amp;&amp; m-&gt;timenow - rr-&gt;TimeExpire &lt; 0)    <span class="enscript-comment">// If proxy record not expired yet, update m-&gt;NextScheduledSPS
</span>            {
                <span class="enscript-keyword">if</span> (m-&gt;NextScheduledSPS - rr-&gt;TimeExpire &gt; 0)
                    m-&gt;NextScheduledSPS = rr-&gt;TimeExpire;
            }
            <span class="enscript-keyword">else</span>                                                    <span class="enscript-comment">// else proxy record expired, so remove it
</span>            {
                LogSPS(<span class="enscript-string">&quot;CheckProxyRecords: Removing %d H-MAC %.6a I-MAC %.6a %d %s&quot;</span>,
                       m-&gt;ProxyRecords, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, rr-&gt;WakeUp.seq, ARDisplayString(m, rr));
                SetSPSProxyListChanged(rr-&gt;resrec.InterfaceID);
                mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
                <span class="enscript-comment">// Don't touch rr after this -- memory may have been free'd
</span>            }
        }
        <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>        <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckRmvEventsForLocalRecords</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (rr-&gt;AnsweredLocalQ &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
        {
            debugf(<span class="enscript-string">&quot;CheckRmvEventsForLocalRecords: Generating local RMV events for %s&quot;</span>, ARDisplayString(m, rr));
            rr-&gt;resrec.RecordType = kDNSRecordTypeShared;
            AnswerAllLocalQuestionsWithLocalAuthRecord(m, rr, QC_rmv);
            <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If rr still exists in list, restore its state now
</span>            {
                rr-&gt;resrec.RecordType = kDNSRecordTypeDeregistering;
                rr-&gt;AnsweredLocalQ = mDNSfalse;
                <span class="enscript-comment">// SendResponses normally calls CompleteDeregistration after sending goodbyes.
</span>                <span class="enscript-comment">// For LocalOnly records, we don't do that and hence we need to do that here.
</span>                <span class="enscript-keyword">if</span> (RRLocalOnly(rr)) CompleteDeregistration(m, rr);
            }
        }
        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr)     <span class="enscript-comment">// If m-&gt;CurrentRecord was not auto-advanced, do it ourselves now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">TimeoutQuestions_internal</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion* questions, mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;TimeoutQuestions ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>, m-&gt;CurrentQuestion-&gt;qname.c,
               DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion)
    {
        DNSQuestion *<span class="enscript-type">const</span> q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (q-&gt;StopTime)
        {
            <span class="enscript-keyword">if</span> (!q-&gt;TimeoutQuestion)
                LogMsg(<span class="enscript-string">&quot;TimeoutQuestions: ERROR!! TimeoutQuestion not set, but StopTime set for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

            <span class="enscript-keyword">if</span> (m-&gt;timenow - q-&gt;StopTime &gt;= 0)
            {
                LogInfo(<span class="enscript-string">&quot;TimeoutQuestions: question %p %##s timed out, time %d&quot;</span>, q, q-&gt;qname.c, m-&gt;timenow - q-&gt;StopTime);
                q-&gt;LOAddressAnswers = 0; <span class="enscript-comment">// unset since timing out the question
</span>                GenerateNegativeResponse(m, InterfaceID, QC_forceresponse);
                <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q) q-&gt;StopTime = 0;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (m-&gt;NextScheduledStopTime - q-&gt;StopTime &gt; 0)
                    m-&gt;NextScheduledStopTime = q-&gt;StopTime;
            }
        }
        <span class="enscript-comment">// If m-&gt;CurrentQuestion wasn't modified out from under us, advance it now
</span>        <span class="enscript-comment">// We can't do this at the start of the loop because GenerateNegativeResponse
</span>        <span class="enscript-comment">// depends on having m-&gt;CurrentQuestion point to the right question
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)
            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">TimeoutQuestions</span>(mDNS *<span class="enscript-type">const</span> m)
{
    m-&gt;NextScheduledStopTime = m-&gt;timenow + FutureTime; <span class="enscript-comment">// push reschedule of TimeoutQuestions to way off into the future
</span>    TimeoutQuestions_internal(m, m-&gt;Questions, mDNSInterface_Any);
    TimeoutQuestions_internal(m, m-&gt;LocalOnlyQuestions, mDNSInterface_LocalOnly);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreFreeProxyRR</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rrPtr = m-&gt;SPSRRSet, *rrNext = mDNSNULL;
    LogSPS(<span class="enscript-string">&quot;%s : Freeing stored sleep proxy A/AAAA records&quot;</span>, __func__);
    <span class="enscript-keyword">while</span> (rrPtr)
    {
        rrNext = rrPtr-&gt;next;
        mDNSPlatformMemFree(rrPtr);
        rrPtr  = rrNext;
    }
    m-&gt;SPSRRSet = mDNSNULL;
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNS_Execute</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNS_Lock(m);   <span class="enscript-comment">// Must grab lock before trying to read m-&gt;timenow
</span>
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledEvent &gt;= 0)
    {
        <span class="enscript-type">int</span> i;
        AuthRecord *head, *tail;
        mDNSu32 slot;
        AuthGroup *ag;

        verbosedebugf(<span class="enscript-string">&quot;mDNS_Execute&quot;</span>);

        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
            LogMsg(<span class="enscript-string">&quot;mDNS_Execute: ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
                   m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));

        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
            LogMsg(<span class="enscript-string">&quot;mDNS_Execute: ERROR m-&gt;CurrentRecord already set: %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));

        <span class="enscript-comment">// 1. If we're past the probe suppression time, we can clear it
</span>        <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes &amp;&amp; m-&gt;timenow - m-&gt;SuppressProbes &gt;= 0) m-&gt;SuppressProbes = 0;

        <span class="enscript-comment">// 2. If it's been more than ten seconds since the last probe failure, we can clear the counter
</span>        <span class="enscript-keyword">if</span> (m-&gt;NumFailedProbes &amp;&amp; m-&gt;timenow - m-&gt;ProbeFailTime &gt;= mDNSPlatformOneSecond * 10) m-&gt;NumFailedProbes = 0;

        <span class="enscript-comment">// 3. Purge our cache of stale old records
</span>        <span class="enscript-keyword">if</span> (m-&gt;rrcache_size &amp;&amp; m-&gt;timenow - m-&gt;NextCacheCheck &gt;= 0)
        {
            mDNSu32 numchecked = 0;
            m-&gt;NextCacheCheck = m-&gt;timenow + FutureTime;
            <span class="enscript-keyword">for</span> (slot = 0; slot &lt; CACHE_HASH_SLOTS; slot++)
            {
                <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;rrcache_nextcheck[slot] &gt;= 0)
                {
                    CacheGroup **cp = &amp;m-&gt;rrcache_hash[slot];
                    m-&gt;rrcache_nextcheck[slot] = m-&gt;timenow + FutureTime;
                    <span class="enscript-keyword">while</span> (*cp)
                    {
                        debugf(<span class="enscript-string">&quot;m-&gt;NextCacheCheck %4d Slot %3d %##s&quot;</span>, numchecked, slot, *cp ? (*cp)-&gt;name : (domainname*)<span class="enscript-string">&quot;\x04NULL&quot;</span>);
                        numchecked++;
                        CheckCacheExpiration(m, slot, *cp);
                        <span class="enscript-keyword">if</span> ((*cp)-&gt;members) cp=&amp;(*cp)-&gt;next;
                        <span class="enscript-keyword">else</span> ReleaseCacheGroup(m, cp);
                    }
                }
                <span class="enscript-comment">// Even if we didn't need to actually check this slot yet, still need to
</span>                <span class="enscript-comment">// factor its nextcheck time into our overall NextCacheCheck value
</span>                <span class="enscript-keyword">if</span> (m-&gt;NextCacheCheck - m-&gt;rrcache_nextcheck[slot] &gt; 0)
                    m-&gt;NextCacheCheck = m-&gt;rrcache_nextcheck[slot];
            }
            debugf(<span class="enscript-string">&quot;m-&gt;NextCacheCheck %4d checked, next in %d&quot;</span>, numchecked, m-&gt;NextCacheCheck - m-&gt;timenow);
        }

        <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledSPS &gt;= 0)
        {
            m-&gt;NextScheduledSPS = m-&gt;timenow + FutureTime;
            CheckProxyRecords(m, m-&gt;DuplicateRecords);  <span class="enscript-comment">// Clear m-&gt;DuplicateRecords first, then m-&gt;ResourceRecords
</span>            CheckProxyRecords(m, m-&gt;ResourceRecords);
        }

        SetSPSProxyListChanged(mDNSNULL);       <span class="enscript-comment">// Perform any deferred BPF reconfiguration now
</span>
        <span class="enscript-comment">// Check to see if we need to send any keepalives. Do this after we called CheckProxyRecords above
</span>        <span class="enscript-comment">// as records could have expired during that check
</span>        <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledKA &gt;= 0)
        {
            m-&gt;NextScheduledKA = m-&gt;timenow + FutureTime;
            mDNS_SendKeepalives(m);
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
        <span class="enscript-keyword">if</span> (m-&gt;NextBonjourDisableTime &amp;&amp; (m-&gt;timenow - m-&gt;NextBonjourDisableTime &gt;= 0))
        {
            <span class="enscript-comment">// Schedule immediate network change processing to leave the multicast group
</span>            <span class="enscript-comment">// since the delay time has expired since the previous active registration or query.
</span>            m-&gt;NetworkChanged = m-&gt;timenow;
            m-&gt;NextBonjourDisableTime = 0;
            m-&gt;BonjourEnabled = 0;

            LogInfo(<span class="enscript-string">&quot;mDNS_Execute: Scheduled network changed processing to leave multicast group.&quot;</span>);
        }
#<span class="enscript-reference">endif</span>

        <span class="enscript-comment">// Clear AnnounceOwner if necessary. (Do this *before* SendQueries() and SendResponses().)
</span>        <span class="enscript-keyword">if</span> (m-&gt;AnnounceOwner &amp;&amp; m-&gt;timenow - m-&gt;AnnounceOwner &gt;= 0)
        {
            m-&gt;AnnounceOwner = 0;
        }

        <span class="enscript-keyword">if</span> (m-&gt;DelaySleep &amp;&amp; m-&gt;timenow - m-&gt;DelaySleep &gt;= 0)
        {
            m-&gt;DelaySleep = 0;
            <span class="enscript-keyword">if</span> (m-&gt;SleepState == SleepState_Transferring)
            {
                LogSPS(<span class="enscript-string">&quot;Re-sleep delay passed; now checking for Sleep Proxy Servers&quot;</span>);
                BeginSleepProcessing(m);
            }
        }

        <span class="enscript-comment">// 4. See if we can answer any of our new local questions from the cache
</span>        <span class="enscript-keyword">for</span> (i=0; m-&gt;NewQuestions &amp;&amp; i&lt;1000; i++)
        {
            <span class="enscript-keyword">if</span> (m-&gt;NewQuestions-&gt;DelayAnswering &amp;&amp; m-&gt;timenow - m-&gt;NewQuestions-&gt;DelayAnswering &lt; 0) <span class="enscript-keyword">break</span>;
            AnswerNewQuestion(m);
        }
        <span class="enscript-keyword">if</span> (i &gt;= 1000) LogMsg(<span class="enscript-string">&quot;mDNS_Execute: AnswerNewQuestion exceeded loop limit&quot;</span>);

        <span class="enscript-comment">// Make sure we deliver *all* local RMV events, and clear the corresponding rr-&gt;AnsweredLocalQ flags, *before*
</span>        <span class="enscript-comment">// we begin generating *any* new ADD events in the m-&gt;NewLocalOnlyQuestions and m-&gt;NewLocalRecords loops below.
</span>        <span class="enscript-keyword">for</span> (i=0; i&lt;1000 &amp;&amp; m-&gt;LocalRemoveEvents; i++)
        {
            m-&gt;LocalRemoveEvents = mDNSfalse;
            m-&gt;CurrentRecord = m-&gt;ResourceRecords;
            CheckRmvEventsForLocalRecords(m);
            <span class="enscript-comment">// Walk the LocalOnly records and deliver the RMV events
</span>            <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
                <span class="enscript-keyword">for</span> (ag = m-&gt;rrauth.rrauth_hash[slot]; ag; ag = ag-&gt;next)
                {
                    m-&gt;CurrentRecord = ag-&gt;members;
                    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord) CheckRmvEventsForLocalRecords(m);
                }
        }

        <span class="enscript-keyword">if</span> (i &gt;= 1000) LogMsg(<span class="enscript-string">&quot;mDNS_Execute: m-&gt;LocalRemoveEvents exceeded loop limit&quot;</span>);

        <span class="enscript-keyword">for</span> (i=0; m-&gt;NewLocalOnlyQuestions &amp;&amp; i&lt;1000; i++) AnswerNewLocalOnlyQuestion(m);
        <span class="enscript-keyword">if</span> (i &gt;= 1000) LogMsg(<span class="enscript-string">&quot;mDNS_Execute: AnswerNewLocalOnlyQuestion exceeded loop limit&quot;</span>);

        head = tail = mDNSNULL;
        <span class="enscript-keyword">for</span> (i=0; i&lt;1000 &amp;&amp; m-&gt;NewLocalRecords &amp;&amp; m-&gt;NewLocalRecords != head; i++)
        {
            AuthRecord *rr = m-&gt;NewLocalRecords;
            m-&gt;NewLocalRecords = m-&gt;NewLocalRecords-&gt;next;
            <span class="enscript-keyword">if</span> (LocalRecordReady(rr))
            {
                debugf(<span class="enscript-string">&quot;mDNS_Execute: Delivering Add event with LocalAuthRecord %s&quot;</span>, ARDisplayString(m, rr));
                AnswerAllLocalQuestionsWithLocalAuthRecord(m, rr, QC_add);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!rr-&gt;next)
            {
                <span class="enscript-comment">// If we have just one record that is not ready, we don't have to unlink and
</span>                <span class="enscript-comment">// reinsert. As the NewLocalRecords will be NULL for this case, the loop will
</span>                <span class="enscript-comment">// terminate and set the NewLocalRecords to rr.
</span>                debugf(<span class="enscript-string">&quot;mDNS_Execute: Just one LocalAuthRecord %s, breaking out of the loop early&quot;</span>, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (head != mDNSNULL || m-&gt;NewLocalRecords != mDNSNULL)
                    LogMsg(<span class="enscript-string">&quot;mDNS_Execute: ERROR!!: head %p, NewLocalRecords %p&quot;</span>, head, m-&gt;NewLocalRecords);

                head = rr;
            }
            <span class="enscript-keyword">else</span>
            {
                AuthRecord **p = &amp;m-&gt;ResourceRecords;   <span class="enscript-comment">// Find this record in our list of active records
</span>                debugf(<span class="enscript-string">&quot;mDNS_Execute: Skipping LocalAuthRecord %s&quot;</span>, ARDisplayString(m, rr));
                <span class="enscript-comment">// if this is the first record we are skipping, move to the end of the list.
</span>                <span class="enscript-comment">// if we have already skipped records before, append it at the end.
</span>                <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != rr) p=&amp;(*p)-&gt;next;
                <span class="enscript-keyword">if</span> (*p) *p = rr-&gt;next;                  <span class="enscript-comment">// Cut this record from the list
</span>                <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;mDNS_Execute: ERROR!! Cannot find record %s in ResourceRecords list&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">break</span>; }
                <span class="enscript-keyword">if</span> (!head)
                {
                    <span class="enscript-keyword">while</span> (*p) p=&amp;(*p)-&gt;next;
                    *p = rr;
                    head = tail = rr;
                }
                <span class="enscript-keyword">else</span>
                {
                    tail-&gt;next = rr;
                    tail = rr;
                }
                rr-&gt;next = mDNSNULL;
            }
        }
        m-&gt;NewLocalRecords = head;
        debugf(<span class="enscript-string">&quot;mDNS_Execute: Setting NewLocalRecords to %s&quot;</span>, (head ? ARDisplayString(m, head) : <span class="enscript-string">&quot;NULL&quot;</span>));

        <span class="enscript-keyword">if</span> (i &gt;= 1000) LogMsg(<span class="enscript-string">&quot;mDNS_Execute: m-&gt;NewLocalRecords exceeded loop limit&quot;</span>);

        <span class="enscript-comment">// Check to see if we have any new LocalOnly/P2P records to examine for delivering
</span>        <span class="enscript-comment">// to our local questions
</span>        <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyRecords)
        {
            m-&gt;NewLocalOnlyRecords = mDNSfalse;
            <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
            {
                <span class="enscript-keyword">for</span> (ag = m-&gt;rrauth.rrauth_hash[slot]; ag; ag = ag-&gt;next)
                {
                    <span class="enscript-keyword">for</span> (i=0; i&lt;100 &amp;&amp; ag-&gt;NewLocalOnlyRecords; i++)
                    {
                        AuthRecord *rr = ag-&gt;NewLocalOnlyRecords;
                        ag-&gt;NewLocalOnlyRecords = ag-&gt;NewLocalOnlyRecords-&gt;next;
                        <span class="enscript-comment">// LocalOnly records should always be ready as they never probe
</span>                        <span class="enscript-keyword">if</span> (LocalRecordReady(rr))
                        {
                            debugf(<span class="enscript-string">&quot;mDNS_Execute: Delivering Add event with LocalAuthRecord %s&quot;</span>, ARDisplayString(m, rr));
                            AnswerAllLocalQuestionsWithLocalAuthRecord(m, rr, QC_add);
                        }
                        <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;mDNS_Execute: LocalOnlyRecord %s not ready&quot;</span>, ARDisplayString(m, rr));
                    }
                    <span class="enscript-comment">// We limit about 100 per AuthGroup that can be serviced at a time
</span>                    <span class="enscript-keyword">if</span> (i &gt;= 100) LogMsg(<span class="enscript-string">&quot;mDNS_Execute: ag-&gt;NewLocalOnlyRecords exceeded loop limit&quot;</span>);
                }
            }
        }

        <span class="enscript-comment">// 5. See what packets we need to send
</span>        <span class="enscript-keyword">if</span> (m-&gt;mDNSPlatformStatus != mStatus_NoError || (m-&gt;SleepState == SleepState_Sleeping))
            DiscardDeregistrations(m);
        <span class="enscript-keyword">if</span> (m-&gt;mDNSPlatformStatus == mStatus_NoError &amp;&amp; (m-&gt;SuppressSending == 0 || m-&gt;timenow - m-&gt;SuppressSending &gt;= 0))
        {
            <span class="enscript-comment">// If the platform code is ready, and we're not suppressing packet generation right now
</span>            <span class="enscript-comment">// then send our responses, probes, and questions.
</span>            <span class="enscript-comment">// We check the cache first, because there might be records close to expiring that trigger questions to refresh them.
</span>            <span class="enscript-comment">// We send queries next, because there might be final-stage probes that complete their probing here, causing
</span>            <span class="enscript-comment">// them to advance to announcing state, and we want those to be included in any announcements we send out.
</span>            <span class="enscript-comment">// Finally, we send responses, including the previously mentioned records that just completed probing.
</span>            m-&gt;SuppressSending = 0;

            <span class="enscript-comment">// 6. Send Query packets. This may cause some probing records to advance to announcing state
</span>            <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledQuery &gt;= 0 || m-&gt;timenow - m-&gt;NextScheduledProbe &gt;= 0) SendQueries(m);
            <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledQuery &gt;= 0)
            {
                DNSQuestion *q;
                LogMsg(<span class="enscript-string">&quot;mDNS_Execute: SendQueries didn't send all its queries (%d - %d = %d) will try again in one second&quot;</span>,
                       m-&gt;timenow, m-&gt;NextScheduledQuery, m-&gt;timenow - m-&gt;NextScheduledQuery);
                m-&gt;NextScheduledQuery = m-&gt;timenow + mDNSPlatformOneSecond;
                <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; q != m-&gt;NewQuestions; q=q-&gt;next)
                    <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; m-&gt;timenow - NextQSendTime(q) &gt;= 0)
                        LogMsg(<span class="enscript-string">&quot;mDNS_Execute: SendQueries didn't send %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            }
            <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledProbe &gt;= 0)
            {
                LogMsg(<span class="enscript-string">&quot;mDNS_Execute: SendQueries didn't send all its probes (%d - %d = %d) will try again in one second&quot;</span>,
                       m-&gt;timenow, m-&gt;NextScheduledProbe, m-&gt;timenow - m-&gt;NextScheduledProbe);
                m-&gt;NextScheduledProbe = m-&gt;timenow + mDNSPlatformOneSecond;
            }

            <span class="enscript-comment">// 7. Send Response packets, including probing records just advanced to announcing state
</span>            <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledResponse &gt;= 0) SendResponses(m);
            <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledResponse &gt;= 0)
            {
                LogMsg(<span class="enscript-string">&quot;mDNS_Execute: SendResponses didn't send all its responses; will try again in one second&quot;</span>);
                m-&gt;NextScheduledResponse = m-&gt;timenow + mDNSPlatformOneSecond;
            }
        }

        <span class="enscript-comment">// Clear RandomDelay values, ready to pick a new different value next time
</span>        m-&gt;RandomQueryDelay     = 0;
        m-&gt;RandomReconfirmDelay = 0;

        <span class="enscript-comment">// See if any questions (or local-only questions) have timed out
</span>        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledStopTime &amp;&amp; m-&gt;timenow - m-&gt;NextScheduledStopTime &gt;= 0) TimeoutQuestions(m);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
        <span class="enscript-keyword">if</span> (m-&gt;NextSRVUpdate &amp;&amp; m-&gt;timenow - m-&gt;NextSRVUpdate &gt;= 0) UpdateAllSRVRecords(m);
        <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledNATOp &gt;= 0) CheckNATMappings(m);
        <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextuDNSEvent &gt;= 0) uDNS_Tasks(m);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
        <span class="enscript-type">extern</span> <span class="enscript-type">void</span> serviceBLE();
        <span class="enscript-keyword">if</span> (m-&gt;NextBLEServiceTime &amp;&amp; (m-&gt;timenow - m-&gt;NextBLEServiceTime &gt;= 0)) serviceBLE();
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">ENABLE_BLE_TRIGGERED_BONJOUR</span>
    }

    <span class="enscript-comment">// Note about multi-threaded systems:
</span>    <span class="enscript-comment">// On a multi-threaded system, some other thread could run right after the mDNS_Unlock(),
</span>    <span class="enscript-comment">// performing mDNS API operations that change our next scheduled event time.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// On multi-threaded systems (like the current Windows implementation) that have a single main thread
</span>    <span class="enscript-comment">// calling mDNS_Execute() (and other threads allowed to call mDNS API routines) it is the responsibility
</span>    <span class="enscript-comment">// of the mDNSPlatformUnlock() routine to signal some kind of stateful condition variable that will
</span>    <span class="enscript-comment">// signal whatever blocking primitive the main thread is using, so that it will wake up and execute one
</span>    <span class="enscript-comment">// more iteration of its loop, and immediately call mDNS_Execute() again. The signal has to be stateful
</span>    <span class="enscript-comment">// in the sense that if the main thread has not yet entered its blocking primitive, then as soon as it
</span>    <span class="enscript-comment">// does, the state of the signal will be noticed, causing the blocking primitive to return immediately
</span>    <span class="enscript-comment">// without blocking. This avoids the race condition between the signal from the other thread arriving
</span>    <span class="enscript-comment">// just *before* or just *after* the main thread enters the blocking primitive.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// On multi-threaded systems (like the current Mac OS 9 implementation) that are entirely timer-driven,
</span>    <span class="enscript-comment">// with no main mDNS_Execute() thread, it is the responsibility of the mDNSPlatformUnlock() routine to
</span>    <span class="enscript-comment">// set the timer according to the m-&gt;NextScheduledEvent value, and then when the timer fires, the timer
</span>    <span class="enscript-comment">// callback function should call mDNS_Execute() (and ignore the return value, which may already be stale
</span>    <span class="enscript-comment">// by the time it gets to the timer callback function).
</span>
    mDNS_Unlock(m);     <span class="enscript-comment">// Calling mDNS_Unlock is what gives m-&gt;NextScheduledEvent its new value
</span>    <span class="enscript-keyword">return</span>(m-&gt;NextScheduledEvent);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SuspendLLQs</span>(mDNS *m)
{
    DNSQuestion *q;
    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
        <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;LongLived &amp;&amp; q-&gt;state == LLQ_Established)
        { q-&gt;ReqLease = 0; sendLLQRefresh(m, q); }
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">UNICAST_DISABLED</span>

mDNSlocal mDNSBool <span class="enscript-function-name">QuestionHasLocalAnswers</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    AuthRecord *rr;
    AuthGroup *ag;

    ag = AuthGroupForName(&amp;m-&gt;rrauth, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">if</span> (ag)
    {
        <span class="enscript-keyword">for</span> (rr = ag-&gt;members; rr; rr=rr-&gt;next)
            <span class="enscript-comment">// Filter the /etc/hosts records - LocalOnly, Unique, A/AAAA/CNAME
</span>            <span class="enscript-keyword">if</span> (UniqueLocalOnlyRecord(rr) &amp;&amp; LocalOnlyRecordAnswersQuestion(rr, q))
            {
                LogInfo(<span class="enscript-string">&quot;QuestionHasLocalAnswers: Question %p %##s (%s) has local answer %s&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), ARDisplayString(m, rr));
                <span class="enscript-keyword">return</span> mDNStrue;
            }
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// ActivateUnicastQuery() is called from three places:
</span><span class="enscript-comment">// 1. When a new question is created
</span><span class="enscript-comment">// 2. On wake from sleep
</span><span class="enscript-comment">// 3. When the DNS configuration changes
</span><span class="enscript-comment">// In case 1 we don't want to mess with our established ThisQInterval and LastQTime (ScheduleImmediately is false)
</span><span class="enscript-comment">// In cases 2 and 3 we do want to cause the question to be resent immediately (ScheduleImmediately is true)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ActivateUnicastQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question, mDNSBool ScheduleImmediately)
{
    <span class="enscript-keyword">if</span> (!question-&gt;DuplicateOf)
    {
        debugf(<span class="enscript-string">&quot;ActivateUnicastQuery: %##s %s%s&quot;</span>,
               question-&gt;qname.c, DNSTypeName(question-&gt;qtype), ScheduleImmediately ? <span class="enscript-string">&quot; ScheduleImmediately&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
        question-&gt;CNAMEReferrals = 0;
        <span class="enscript-keyword">if</span> (question-&gt;nta) { CancelGetZoneData(m, question-&gt;nta); question-&gt;nta = mDNSNULL; }
        <span class="enscript-keyword">if</span> (question-&gt;LongLived)
        {
            question-&gt;state = LLQ_Init;
            question-&gt;id = zeroOpaque64;
            question-&gt;servPort = zeroIPPort;
            <span class="enscript-keyword">if</span> (question-&gt;tcp) { DisposeTCPConn(question-&gt;tcp); question-&gt;tcp = mDNSNULL; }
        }
        <span class="enscript-comment">// If the question has local answers, then we don't want answers from outside
</span>        <span class="enscript-keyword">if</span> (ScheduleImmediately &amp;&amp; !QuestionHasLocalAnswers(m, question))
        {
            question-&gt;ThisQInterval = InitialQuestionInterval;
            question-&gt;LastQTime     = m-&gt;timenow - question-&gt;ThisQInterval;
            SetNextQueryTime(m, question);
        }
    }
}

<span class="enscript-comment">// Caller should hold the lock
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreRestartAddressQueries</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool SearchDomainsChanged, FlushCache flushCacheRecords,
                                              CallbackBeforeStartQuery BeforeStartCallback, <span class="enscript-type">void</span> *context)
{
    DNSQuestion *q;
    DNSQuestion *restart = mDNSNULL;

    mDNS_CheckLock(m);

    <span class="enscript-comment">// 1. Flush the cache records
</span>    <span class="enscript-keyword">if</span> (flushCacheRecords) flushCacheRecords(m);

    <span class="enscript-comment">// 2. Even though we may have purged the cache records above, before it can generate RMV event
</span>    <span class="enscript-comment">// we are going to stop the question. Hence we need to deliver the RMV event before we
</span>    <span class="enscript-comment">// stop the question.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// CurrentQuestion is used by RmvEventsForQuestion below. While delivering RMV events, the
</span>    <span class="enscript-comment">// application callback can potentially stop the current question (detected by CurrentQuestion) or
</span>    <span class="enscript-comment">// *any* other question which could be the next one that we may process here. RestartQuestion
</span>    <span class="enscript-comment">// points to the &quot;next&quot; question which will be automatically advanced in mDNS_StopQuery_internal
</span>    <span class="enscript-comment">// if the &quot;next&quot; question is stopped while the CurrentQuestion is stopped
</span>
    <span class="enscript-keyword">if</span> (m-&gt;RestartQuestion)
        LogMsg(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: ERROR!! m-&gt;RestartQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;RestartQuestion-&gt;qname.c, DNSTypeName(m-&gt;RestartQuestion-&gt;qtype));

    m-&gt;RestartQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;RestartQuestion)
    {
        q = m-&gt;RestartQuestion;
        m-&gt;RestartQuestion = q-&gt;next;
        <span class="enscript-comment">// GetZoneData questions are referenced by other questions (original query that started the GetZoneData
</span>        <span class="enscript-comment">// question)  through their &quot;nta&quot; pointer. Normally when the original query stops, it stops the
</span>        <span class="enscript-comment">// GetZoneData question and also frees the memory (See CancelGetZoneData). If we stop the GetZoneData
</span>        <span class="enscript-comment">// question followed by the original query that refers to this GetZoneData question, we will end up
</span>        <span class="enscript-comment">// freeing the GetZoneData question and then start the &quot;freed&quot; question at the end.
</span>
        <span class="enscript-keyword">if</span> (IsGetZoneDataQuestion(q))
        {
            DNSQuestion *refq = q-&gt;next;
            LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Skipping GetZoneDataQuestion %p %##s (%s)&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            <span class="enscript-comment">// debug stuff, we just try to find the referencing question and don't do much with it
</span>            <span class="enscript-keyword">while</span> (refq)
            {
                <span class="enscript-keyword">if</span> (q == &amp;refq-&gt;nta-&gt;question)
                {
                    LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Question %p %##s (%s) referring to GetZoneDataQuestion %p, not stopping&quot;</span>, refq, refq-&gt;qname.c, DNSTypeName(refq-&gt;qtype), q);
                }
                refq = refq-&gt;next;
            }
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// This function is called when /etc/hosts changes and that could affect A, AAAA and CNAME queries
</span>        <span class="enscript-keyword">if</span> (q-&gt;qtype != kDNSType_A &amp;&amp; q-&gt;qtype != kDNSType_AAAA &amp;&amp; q-&gt;qtype != kDNSType_CNAME) <span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">// If the search domains did not change, then we restart all the queries. Otherwise, only
</span>        <span class="enscript-comment">// for queries for which we &quot;might&quot; have appended search domains (&quot;might&quot; because we may
</span>        <span class="enscript-comment">// find results before we apply search domains even though AppendSearchDomains is set to 1)
</span>        <span class="enscript-keyword">if</span> (!SearchDomainsChanged || q-&gt;AppendSearchDomains)
        {
            <span class="enscript-comment">// NOTE: CacheRecordRmvEventsForQuestion will not generate RMV events for queries that have non-zero
</span>            <span class="enscript-comment">// LOAddressAnswers. Hence it is important that we call CacheRecordRmvEventsForQuestion before
</span>            <span class="enscript-comment">// LocalRecordRmvEventsForQuestion (which decrements LOAddressAnswers). Let us say that
</span>            <span class="enscript-comment">// /etc/hosts has an A Record for web.apple.com. Any queries for web.apple.com will be answered locally.
</span>            <span class="enscript-comment">// But this can't prevent a CNAME/AAAA query to not to be sent on the wire. When it is sent on the wire,
</span>            <span class="enscript-comment">// it could create cache entries. When we are restarting queries, we can't deliver the cache RMV events
</span>            <span class="enscript-comment">// for the original query using these cache entries as ADDs were never delivered using these cache
</span>            <span class="enscript-comment">// entries and hence this order is needed.
</span>
            <span class="enscript-comment">// If the query is suppressed, the RMV events won't be delivered
</span>            <span class="enscript-keyword">if</span> (!CacheRecordRmvEventsForQuestion(m, q)) { LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Question deleted while delivering Cache Record RMV events&quot;</span>); <span class="enscript-keyword">continue</span>; }

            <span class="enscript-comment">// Suppressed status does not affect questions that are answered using local records
</span>            <span class="enscript-keyword">if</span> (!LocalRecordRmvEventsForQuestion(m, q)) { LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Question deleted while delivering Local Record RMV events&quot;</span>); <span class="enscript-keyword">continue</span>; }

            LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Stop question %p %##s (%s), AppendSearchDomains %d&quot;</span>, q,
                    q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;AppendSearchDomains);
            mDNS_StopQuery_internal(m, q);
            <span class="enscript-keyword">if</span> (q-&gt;ResetHandler) q-&gt;ResetHandler(q);
            q-&gt;next = restart;
            restart = q;
        }
    }

    <span class="enscript-comment">// 3. Callback before we start the query
</span>    <span class="enscript-keyword">if</span> (BeforeStartCallback) BeforeStartCallback(m, context);

    <span class="enscript-comment">// 4. Restart all the stopped queries
</span>    <span class="enscript-keyword">while</span> (restart)
    {
        q = restart;
        restart = restart-&gt;next;
        q-&gt;next = mDNSNULL;
        LogInfo(<span class="enscript-string">&quot;mDNSCoreRestartAddressQueries: Start question %p %##s (%s)&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        mDNS_StartQuery_internal(m, q);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreRestartQueries</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-comment">// Retrigger all our uDNS questions
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;mDNSCoreRestartQueries: ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion)
    {
        q = m-&gt;CurrentQuestion;
        m-&gt;CurrentQuestion = m-&gt;CurrentQuestion-&gt;next;
        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; ActiveQuestion(q)) ActivateUnicastQuery(m, q, mDNStrue);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Retrigger all our mDNS questions
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)                <span class="enscript-comment">// Scan our list of questions
</span>            mDNSCoreRestartQuestion(m, q);
}

<span class="enscript-comment">// restart question if it's multicast and currently active
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreRestartQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; ActiveQuestion(q))
    {
        q-&gt;ThisQInterval    = InitialQuestionInterval;  <span class="enscript-comment">// MUST be &gt; zero for an active question
</span>        q-&gt;RequestUnicast   = kDefaultRequestUnicastCount;
        q-&gt;LastQTime        = m-&gt;timenow - q-&gt;ThisQInterval;
        q-&gt;RecentAnswerPkts = 0;
        ExpireDupSuppressInfo(q-&gt;DupSuppress, m-&gt;timenow);
        m-&gt;NextScheduledQuery = m-&gt;timenow;
    }
}

<span class="enscript-comment">// restart the probe/announce cycle for multicast record
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreRestartRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, <span class="enscript-type">int</span> announceCount)
{
    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeVerified &amp;&amp; !rr-&gt;DependentOn) rr-&gt;resrec.RecordType = kDNSRecordTypeUnique;
        rr-&gt;ProbeCount     = DefaultProbeCountForRecordType(rr-&gt;resrec.RecordType);

        <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;rr-&gt;resrec))
        {
            rr-&gt;AnnounceCount = 0; <span class="enscript-comment">// Do not announce keepalive records
</span>        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// announceCount &lt; 0 indicates default announce count should be used
</span>            <span class="enscript-keyword">if</span> (announceCount &lt; 0)
                announceCount = InitialAnnounceCount;
            <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount &lt; (mDNSu8)announceCount)
                rr-&gt;AnnounceCount = (mDNSu8)announceCount;
        }

        rr-&gt;SendNSECNow    = mDNSNULL;
        InitializeLastAPTime(m, rr);
    }
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Power</span> <span class="enscript-variable-name">Management</span> (<span class="enscript-variable-name">Sleep</span>/<span class="enscript-variable-name">Wake</span>)
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_UpdateAllowSleep</span>(mDNS *<span class="enscript-type">const</span> m)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IDLESLEEPCONTROL_DISABLED</span>
    mDNSBool allowSleep = mDNStrue;
    <span class="enscript-type">char</span> reason[128];

    reason[0] = 0;

    <span class="enscript-keyword">if</span> (m-&gt;SystemSleepOnlyIfWakeOnLAN)
    {
        <span class="enscript-comment">// Don't sleep if we are a proxy for any services
</span>        <span class="enscript-keyword">if</span> (m-&gt;ProxyRecords)
        {
            allowSleep = mDNSfalse;
            mDNS_snprintf(reason, <span class="enscript-keyword">sizeof</span>(reason), <span class="enscript-string">&quot;sleep proxy for %d records&quot;</span>, m-&gt;ProxyRecords);
            LogInfo(<span class="enscript-string">&quot;mDNS_UpdateAllowSleep: Sleep disabled because we are proxying %d records&quot;</span>, m-&gt;ProxyRecords);
        }

        <span class="enscript-keyword">if</span> (allowSleep &amp;&amp; mDNSCoreHaveAdvertisedMulticastServices(m))
        {
            <span class="enscript-comment">// Scan the list of active interfaces
</span>            NetworkInterfaceInfo *intf;
            <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
            {
                <span class="enscript-keyword">if</span> (intf-&gt;McastTxRx &amp;&amp; !intf-&gt;Loopback &amp;&amp; !mDNSPlatformInterfaceIsD2D(intf-&gt;InterfaceID))
                {
                    <span class="enscript-comment">// Disallow sleep if this interface doesn't support NetWake
</span>                    <span class="enscript-keyword">if</span> (!intf-&gt;NetWake)
                    {
                        allowSleep = mDNSfalse;
                        mDNS_snprintf(reason, <span class="enscript-keyword">sizeof</span>(reason), <span class="enscript-string">&quot;%s does not support NetWake&quot;</span>, intf-&gt;ifname);
                        LogInfo(<span class="enscript-string">&quot;mDNS_UpdateAllowSleep: Sleep disabled because %s does not support NetWake&quot;</span>, intf-&gt;ifname);
                        <span class="enscript-keyword">break</span>;
                    }

                    <span class="enscript-comment">// If the interface can be an in-NIC Proxy, we should check if it can accomodate all the records
</span>                    <span class="enscript-comment">// that will be offloaded. If not, we should prevent sleep.
</span>                    <span class="enscript-comment">// This check will be possible once the lower layers provide an API to query the space available for offloads on the NIC.
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
                    <span class="enscript-keyword">if</span> (!SupportsInNICProxy(intf))
#<span class="enscript-reference">endif</span>
                    {
                        <span class="enscript-comment">// Disallow sleep if there is no sleep proxy server
</span>                        <span class="enscript-type">const</span> CacheRecord *cr = FindSPSInCache1(m, &amp;intf-&gt;NetWakeBrowse, mDNSNULL, mDNSNULL);
                        <span class="enscript-keyword">if</span> ( cr == mDNSNULL)
                        {
                            allowSleep = mDNSfalse;
                            mDNS_snprintf(reason, <span class="enscript-keyword">sizeof</span>(reason), <span class="enscript-string">&quot;No sleep proxy server on %s&quot;</span>, intf-&gt;ifname);
                            LogInfo(<span class="enscript-string">&quot;mDNS_UpdateAllowSleep: Sleep disabled because %s has no sleep proxy server&quot;</span>, intf-&gt;ifname);
                            <span class="enscript-keyword">break</span>;
                        }
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;SPSType != 0)
                        {
                            mDNSu32 mymetric = LocalSPSMetric(m);
                            mDNSu32 metric   = SPSMetric(cr-&gt;resrec.rdata-&gt;u.name.c);
                            <span class="enscript-keyword">if</span> (metric &gt;= mymetric)
                            {
                                allowSleep = mDNSfalse;
                                mDNS_snprintf(reason, <span class="enscript-keyword">sizeof</span>(reason), <span class="enscript-string">&quot;No sleep proxy server with better metric on %s&quot;</span>, intf-&gt;ifname);
                                LogInfo(<span class="enscript-string">&quot;mDNS_UpdateAllowSleep: Sleep disabled because %s has no sleep proxy server with a better metric&quot;</span>, intf-&gt;ifname);
                                <span class="enscript-keyword">break</span>;
                            }
                        }
                    }
                }
            }
        }
    }

    <span class="enscript-comment">// Call the platform code to enable/disable sleep
</span>    mDNSPlatformSetAllowSleep(allowSleep, reason);
#<span class="enscript-reference">else</span>
    (<span class="enscript-type">void</span>) m;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(IDLESLEEPCONTROL_DISABLED) */</span>
}

mDNSlocal mDNSBool <span class="enscript-function-name">mDNSUpdateOkToSend</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSu32 scopeid)
{
    <span class="enscript-comment">// If it is not a uDNS record, check to see if the updateid is zero. &quot;updateid&quot; is cleared when we have
</span>    <span class="enscript-comment">// sent the resource record on all the interfaces. If the update id is not zero, check to see if it is time
</span>    <span class="enscript-comment">// to send.
</span>    <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr) || (rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) || mDNSOpaque16IsZero(rr-&gt;updateid) ||
        m-&gt;timenow - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &lt; 0)
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// If we have a pending registration for &quot;scopeid&quot;, it is ok to send the update on that interface.
</span>    <span class="enscript-comment">// If the scopeid is too big to check for validity, we don't check against updateIntID. When
</span>    <span class="enscript-comment">// we successfully update on all the interfaces (with whatever set in &quot;rr-&gt;updateIntID&quot;), we clear
</span>    <span class="enscript-comment">// updateid and we should have returned from above.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: scopeid is the same as intf-&gt;InterfaceID. It is passed in so that we don't have to call the
</span>    <span class="enscript-comment">// platform function to extract the value from &quot;intf&quot; every time.
</span>
    <span class="enscript-keyword">if</span> ((scopeid &gt;= (<span class="enscript-keyword">sizeof</span>(rr-&gt;updateIntID) * mDNSNBBY) || bit_get_opaque64(rr-&gt;updateIntID, scopeid)) &amp;&amp;
        (!rr-&gt;resrec.InterfaceID || rr-&gt;resrec.InterfaceID == intf-&gt;InterfaceID))
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateRMAC</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context)
{
    IPAddressMACMapping *addrmap = (IPAddressMACMapping *)context ;
    m-&gt;CurrentRecord = m-&gt;ResourceRecords;

    <span class="enscript-keyword">if</span> (!addrmap)
    {
        LogMsg(<span class="enscript-string">&quot;UpdateRMAC: Address mapping is NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rr = m-&gt;CurrentRecord;
        <span class="enscript-comment">// If this is a non-sleep proxy keepalive record and the remote IP address matches, update the RData
</span>        <span class="enscript-keyword">if</span> (!rr-&gt;WakeUp.HMAC.l[0] &amp;&amp; mDNS_KeepaliveRecord(&amp;rr-&gt;resrec))
        {
            mDNSAddr raddr;
            getKeepaliveRaddr(m, rr, &amp;raddr);
            <span class="enscript-keyword">if</span> (mDNSSameAddress(&amp;raddr, &amp;addrmap-&gt;ipaddr))
            {
                <span class="enscript-comment">// Update the MAC address only if it is not a zero MAC address
</span>                mDNSEthAddr macAddr;
                mDNSu8 *ptr = GetValueForMACAddr((mDNSu8 *)(addrmap-&gt;ethaddr), (mDNSu8 *) (addrmap-&gt;ethaddr + <span class="enscript-keyword">sizeof</span>(addrmap-&gt;ethaddr)), &amp;macAddr);
                <span class="enscript-keyword">if</span> (ptr != mDNSNULL &amp;&amp; !mDNSEthAddressIsZero(macAddr))
                {
                    UpdateKeepaliveRData(m, rr, mDNSNULL, mDNStrue, (<span class="enscript-type">char</span> *)(addrmap-&gt;ethaddr));
                }
            }
        }
        m-&gt;CurrentRecord = rr-&gt;next;
    }

    <span class="enscript-keyword">if</span> (addrmap)
        mDNSPlatformMemFree(addrmap);

}

mDNSexport mStatus <span class="enscript-function-name">UpdateKeepaliveRData</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSBool updateMac, <span class="enscript-type">char</span> *ethAddr)
{
    mDNSu16 newrdlength;
    mDNSAddr laddr = zeroAddr;
    mDNSAddr raddr = zeroAddr;
    mDNSEthAddr eth = zeroEthAddr;
    mDNSIPPort lport = zeroIPPort;
    mDNSIPPort rport = zeroIPPort;
    mDNSu32 timeout = 0;
    mDNSu32 seq = 0;
    mDNSu32 ack = 0;
    mDNSu16 win = 0;
    UTF8str255 txt;
    <span class="enscript-type">int</span> rdsize;
    RData *newrd;
    mDNSTCPInfo mti;
    mStatus ret;

    <span class="enscript-comment">// Note: If we fail to update the  DNS NULL  record with additional information in this function, it will be registered
</span>    <span class="enscript-comment">// with the SPS like any other record. SPS will not send keepalives if it does not have additional information.
</span>    mDNS_ExtractKeepaliveInfo(rr, &amp;timeout, &amp;laddr, &amp;raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);
    <span class="enscript-keyword">if</span> (!timeout || mDNSAddressIsZero(&amp;laddr) || mDNSAddressIsZero(&amp;raddr) || mDNSIPPortIsZero(lport) || mDNSIPPortIsZero(rport))
    {
        LogMsg(<span class="enscript-string">&quot;UpdateKeepaliveRData: not a valid record %s for keepalive %#a:%d %#a:%d&quot;</span>, ARDisplayString(m, rr), &amp;laddr, lport.NotAnInteger, &amp;raddr, rport.NotAnInteger);
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }

    <span class="enscript-keyword">if</span> (updateMac)
    {
        <span class="enscript-keyword">if</span> (laddr.type == mDNSAddrType_IPv4)
            newrdlength = mDNS_snprintf((<span class="enscript-type">char</span> *)&amp;txt.c[1], <span class="enscript-keyword">sizeof</span>(txt.c) - 1, <span class="enscript-string">&quot;t=%d i=%d c=%d h=%#a d=%#a l=%u r=%u m=%s&quot;</span>, timeout, kKeepaliveRetryInterval, kKeepaliveRetryCount, &amp;laddr, &amp;raddr, mDNSVal16(lport), mDNSVal16(rport), ethAddr);
        <span class="enscript-keyword">else</span>
            newrdlength = mDNS_snprintf((<span class="enscript-type">char</span> *)&amp;txt.c[1], <span class="enscript-keyword">sizeof</span>(txt.c) - 1, <span class="enscript-string">&quot;t=%d i=%d c=%d H=%#a D=%#a l=%u r=%u m=%s&quot;</span>, timeout, kKeepaliveRetryInterval, kKeepaliveRetryCount, &amp;laddr, &amp;raddr,  mDNSVal16(lport), mDNSVal16(rport), ethAddr);

    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// If this keepalive packet would be sent on a different interface than the current one that we are processing
</span>        <span class="enscript-comment">// now, then we don't update the DNS NULL record. But we do not prevent it from registering with the SPS. When SPS sees
</span>        <span class="enscript-comment">// this DNS NULL record, it does not send any keepalives as it does not have all the information
</span>        mDNSPlatformMemZero(&amp;mti, <span class="enscript-keyword">sizeof</span> (mDNSTCPInfo));
        ret = mDNSPlatformRetrieveTCPInfo(&amp;laddr, &amp;lport, &amp;raddr, &amp;rport, &amp;mti);
        <span class="enscript-keyword">if</span> (ret != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformRetrieveTCPInfo: mDNSPlatformRetrieveTCPInfo failed %d&quot;</span>, ret);
            <span class="enscript-keyword">return</span> ret;
        }
        <span class="enscript-keyword">if</span> ((intf != mDNSNULL) &amp;&amp; (mti.IntfId != intf-&gt;InterfaceID))
        {
            LogInfo(<span class="enscript-string">&quot;mDNSPlatformRetrieveTCPInfo: InterfaceID mismatch mti.IntfId = %p InterfaceID = %p&quot;</span>,  mti.IntfId, intf-&gt;InterfaceID);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }

        <span class="enscript-keyword">if</span> (laddr.type == mDNSAddrType_IPv4)
            newrdlength = mDNS_snprintf((<span class="enscript-type">char</span> *)&amp;txt.c[1], <span class="enscript-keyword">sizeof</span>(txt.c) - 1, <span class="enscript-string">&quot;t=%d i=%d c=%d h=%#a d=%#a l=%u r=%u m=%.6a s=%u a=%u w=%u&quot;</span>, timeout, kKeepaliveRetryInterval, kKeepaliveRetryCount, &amp;laddr, &amp;raddr, mDNSVal16(lport), mDNSVal16(rport), &amp;eth, mti.seq, mti.ack, mti.window);
        <span class="enscript-keyword">else</span>
            newrdlength = mDNS_snprintf((<span class="enscript-type">char</span> *)&amp;txt.c[1], <span class="enscript-keyword">sizeof</span>(txt.c) - 1, <span class="enscript-string">&quot;t=%d i=%d c=%d H=%#a D=%#a l=%u r=%u m=%.6a s=%u a=%u w=%u&quot;</span>, timeout, kKeepaliveRetryInterval, kKeepaliveRetryCount, &amp;laddr, &amp;raddr, mDNSVal16(lport), mDNSVal16(rport), &amp;eth, mti.seq, mti.ack, mti.window);
    }

    <span class="enscript-comment">// Did we insert a null byte at the end ?
</span>    <span class="enscript-keyword">if</span> (newrdlength == (<span class="enscript-keyword">sizeof</span>(txt.c) - 1))
    {
        LogMsg(<span class="enscript-string">&quot;UpdateKeepaliveRData: could not allocate memory %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span> mStatus_NoMemoryErr;
    }

    <span class="enscript-comment">// Include the length for the null byte at the end
</span>    txt.c[0] = newrdlength + 1;
    <span class="enscript-comment">// Account for the first length byte and the null byte at the end
</span>    newrdlength += 2;

    rdsize = newrdlength &gt; <span class="enscript-keyword">sizeof</span>(RDataBody) ? newrdlength : <span class="enscript-keyword">sizeof</span>(RDataBody);
    newrd = (RData *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(RData) - <span class="enscript-keyword">sizeof</span>(RDataBody) + rdsize);
    <span class="enscript-keyword">if</span> (!newrd) { LogMsg(<span class="enscript-string">&quot;UpdateKeepaliveRData: ptr NULL&quot;</span>); <span class="enscript-keyword">return</span> mStatus_NoMemoryErr; }

    newrd-&gt;MaxRDLength = (mDNSu16) rdsize;
    mDNSPlatformMemCopy(&amp;newrd-&gt;u, txt.c, newrdlength);

    <span class="enscript-comment">//  If we are updating the record for the first time, rdata points to rdatastorage as the rdata memory
</span>    <span class="enscript-comment">//  was allocated as part of the AuthRecord itself. We allocate memory when we update the AuthRecord.
</span>    <span class="enscript-comment">//  If the resource record has data that we allocated in a previous pass (to update MAC address),
</span>    <span class="enscript-comment">//  free that memory here before copying in the new data.
</span>    <span class="enscript-keyword">if</span> ( rr-&gt;resrec.rdata != &amp;rr-&gt;rdatastorage)
    {
        LogSPS(<span class="enscript-string">&quot;UpdateKeepaliveRData: Freed allocated memory for keep alive packet: %s &quot;</span>, ARDisplayString(m, rr));
        mDNSPlatformMemFree(rr-&gt;resrec.rdata);
    }
    SetNewRData(&amp;rr-&gt;resrec, newrd, newrdlength);    <span class="enscript-comment">// Update our rdata
</span>
    LogSPS(<span class="enscript-string">&quot;UpdateKeepaliveRData: successfully updated the record %s&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendSPSRegistrationForOwner</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, <span class="enscript-type">const</span> mDNSOpaque16 id, <span class="enscript-type">const</span> OwnerOptData *<span class="enscript-type">const</span> owner)
{
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> optspace = DNSOpt_Header_Space + DNSOpt_LeaseData_Space + DNSOpt_Owner_Space(&amp;m-&gt;PrimaryMAC, &amp;intf-&gt;MAC);
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> sps = intf-&gt;NextSPSAttempt / 3;
    AuthRecord *rr;
    mDNSOpaque16 msgid;
    mDNSu32 scopeid;

    scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, intf-&gt;InterfaceID, mDNStrue);
    <span class="enscript-keyword">if</span> (!intf-&gt;SPSAddr[sps].type)
    {
        intf-&gt;NextSPSAttemptTime = m-&gt;timenow + mDNSPlatformOneSecond;
        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledSPRetry - intf-&gt;NextSPSAttemptTime &gt; 0)
            m-&gt;NextScheduledSPRetry = intf-&gt;NextSPSAttemptTime;
        LogSPS(<span class="enscript-string">&quot;SendSPSRegistration: %s SPS %d (%d) %##s not yet resolved&quot;</span>, intf-&gt;ifname, intf-&gt;NextSPSAttempt, sps, intf-&gt;NetWakeResolve[sps].qname.c);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// Mark our mDNS records (not unicast records) for transfer to SPS
</span>    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(id))
    {
        <span class="enscript-comment">// We may have to register this record over multiple interfaces and we don't want to
</span>        <span class="enscript-comment">// overwrite the id. We send the registration over interface X with id &quot;IDX&quot; and before
</span>        <span class="enscript-comment">// we get a response, we overwrite with id &quot;IDY&quot; for interface Y and we won't accept responses
</span>        <span class="enscript-comment">// for &quot;IDX&quot;. Hence, we want to use the same ID across all interfaces.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// In the case of sleep proxy server transfering its records when it goes to sleep, the owner
</span>        <span class="enscript-comment">// option check below will set the same ID across the records from the same owner. Records
</span>        <span class="enscript-comment">// with different owner option gets different ID.
</span>        msgid = mDNS_NewMessageID(m);
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!(rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) &amp;&amp; rr-&gt;resrec.RecordType &gt; kDNSRecordTypeDeregistering)
            {
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == intf-&gt;InterfaceID || (!rr-&gt;resrec.InterfaceID &amp;&amp; (rr-&gt;ForceMCast || IsLocalDomain(rr-&gt;resrec.name))))
                {
                    <span class="enscript-keyword">if</span> (mDNSPlatformMemSame(owner, &amp;rr-&gt;WakeUp, <span class="enscript-keyword">sizeof</span>(*owner)))
                    {
                        rr-&gt;SendRNow = mDNSInterfaceMark;   <span class="enscript-comment">// mark it now
</span>                        <span class="enscript-comment">// When we are registering on the first interface, rr-&gt;updateid is zero in which case
</span>                        <span class="enscript-comment">// initialize with the new ID. For subsequent interfaces, we want to use the same ID.
</span>                        <span class="enscript-comment">// At the end, all the updates sent across all the interfaces with the same ID.
</span>                        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(rr-&gt;updateid))
                            rr-&gt;updateid = msgid;
                        <span class="enscript-keyword">else</span>
                            msgid = rr-&gt;updateid;
                    }
                }
            }
        }
    }
    <span class="enscript-keyword">else</span>
        msgid = id;

    <span class="enscript-keyword">while</span> (1)
    {
        mDNSu8 *p = m-&gt;omsg.data;
        <span class="enscript-comment">// To comply with RFC 2782, PutResourceRecord suppresses name compression for SRV records in unicast updates.
</span>        <span class="enscript-comment">// For now we follow that same logic for SPS registrations too.
</span>        <span class="enscript-comment">// If we decide to compress SRV records in SPS registrations in the future, we can achieve that by creating our
</span>        <span class="enscript-comment">// initial DNSMessage with h.flags set to zero, and then update it to UpdateReqFlags right before sending the packet.
</span>        InitializeDNSMessage(&amp;m-&gt;omsg.h, msgid, UpdateReqFlags);

        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;SendRNow || mDNSUpdateOkToSend(m, rr, intf, scopeid))
            {
                <span class="enscript-keyword">if</span> (mDNSPlatformMemSame(owner, &amp;rr-&gt;WakeUp, <span class="enscript-keyword">sizeof</span>(*owner)))
                {
                    mDNSu8 *newptr;
                    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = m-&gt;omsg.data + (m-&gt;omsg.h.mDNS_numUpdates ? NormalMaxDNSMessageData : AbsoluteMaxDNSMessageData) - optspace;

                    <span class="enscript-comment">// If we can't update the keepalive record, don't send it
</span>                    <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;rr-&gt;resrec) &amp;&amp; (UpdateKeepaliveRData(m, rr, intf, mDNSfalse, mDNSNULL) != mStatus_NoError))
                    {
                        <span class="enscript-keyword">if</span> (scopeid &lt; (<span class="enscript-keyword">sizeof</span>(rr-&gt;updateIntID) * mDNSNBBY))
                        {
                            bit_clr_opaque64(rr-&gt;updateIntID, scopeid);
                        }
                        rr-&gt;SendRNow = mDNSNULL;
                        <span class="enscript-keyword">continue</span>;
                    }

                    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)
                        rr-&gt;resrec.rrclass |= kDNSClass_UniqueRRSet;    <span class="enscript-comment">// Temporarily set the 'unique' bit so PutResourceRecord will set it
</span>                    newptr = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, p, &amp;m-&gt;omsg.h.mDNS_numUpdates, &amp;rr-&gt;resrec, rr-&gt;resrec.rroriginalttl, limit);
                    rr-&gt;resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;       <span class="enscript-comment">// Make sure to clear 'unique' bit back to normal state
</span>                    <span class="enscript-keyword">if</span> (!newptr)
                        LogSPS(<span class="enscript-string">&quot;SendSPSRegistration put %s FAILED %d/%d %s&quot;</span>, intf-&gt;ifname, p - m-&gt;omsg.data, limit - m-&gt;omsg.data, ARDisplayString(m, rr));
                    <span class="enscript-keyword">else</span>
                    {
                        LogSPS(<span class="enscript-string">&quot;SendSPSRegistration put %s 0x%x 0x%x (updateid %d)  %s&quot;</span>, intf-&gt;ifname, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(m-&gt;omsg.h.id), ARDisplayString(m, rr));
                        rr-&gt;SendRNow       = mDNSNULL;
                        rr-&gt;ThisAPInterval = mDNSPlatformOneSecond;
                        rr-&gt;LastAPTime     = m-&gt;timenow;
                        <span class="enscript-comment">// should be initialized above
</span>                        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(rr-&gt;updateid)) LogMsg(<span class="enscript-string">&quot;SendSPSRegistration: ERROR!! rr %s updateid is zero&quot;</span>, ARDisplayString(m, rr));
                        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledResponse - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
                            m-&gt;NextScheduledResponse = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);
                        p = newptr;
                    }
                }
            }

        <span class="enscript-keyword">if</span> (!m-&gt;omsg.h.mDNS_numUpdates) <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">else</span>
        {
            AuthRecord opt;
            mDNS_SetupResourceRecord(&amp;opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
            opt.resrec.rrclass    = NormalMaxDNSMessageData;
            opt.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT) * 2;   <span class="enscript-comment">// Two options in this OPT record
</span>            opt.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT) * 2;
            opt.resrec.rdata-&gt;u.opt[0].opt           = kDNSOpt_Lease;
            opt.resrec.rdata-&gt;u.opt[0].optlen        = DNSOpt_LeaseData_Space - 4;
            opt.resrec.rdata-&gt;u.opt[0].u.updatelease = DEFAULT_UPDATE_LEASE;
            <span class="enscript-keyword">if</span> (!owner-&gt;HMAC.l[0])                                          <span class="enscript-comment">// If no owner data,
</span>                SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[1]);        <span class="enscript-comment">// use our own interface information
</span>            <span class="enscript-keyword">else</span>                                                            <span class="enscript-comment">// otherwise, use the owner data we were given
</span>            {
                opt.resrec.rdata-&gt;u.opt[1].u.owner = *owner;
                opt.resrec.rdata-&gt;u.opt[1].opt     = kDNSOpt_Owner;
                opt.resrec.rdata-&gt;u.opt[1].optlen  = DNSOpt_Owner_Space(&amp;owner-&gt;HMAC, &amp;owner-&gt;IMAC) - 4;
            }
            LogSPS(<span class="enscript-string">&quot;SendSPSRegistration put %s %s&quot;</span>, intf-&gt;ifname, ARDisplayString(m, &amp;opt));
            p = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, p, &amp;m-&gt;omsg.h.numAdditionals, &amp;opt.resrec, opt.resrec.rroriginalttl, m-&gt;omsg.data + AbsoluteMaxDNSMessageData);
            <span class="enscript-keyword">if</span> (!p)
                LogMsg(<span class="enscript-string">&quot;SendSPSRegistration: Failed to put OPT record (%d updates) %s&quot;</span>, m-&gt;omsg.h.mDNS_numUpdates, ARDisplayString(m, &amp;opt));
            <span class="enscript-keyword">else</span>
            {
                mStatus err;

                LogSPS(<span class="enscript-string">&quot;SendSPSRegistration: Sending Update %s %d (%d) id %5d with %d records %d bytes to %#a:%d&quot;</span>, intf-&gt;ifname, intf-&gt;NextSPSAttempt, sps,
                       mDNSVal16(m-&gt;omsg.h.id), m-&gt;omsg.h.mDNS_numUpdates, p - m-&gt;omsg.data, &amp;intf-&gt;SPSAddr[sps], mDNSVal16(intf-&gt;SPSPort[sps]));
                <span class="enscript-comment">// if (intf-&gt;NextSPSAttempt &lt; 5) m-&gt;omsg.h.flags = zeroID;  // For simulating packet loss
</span>                err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, p, intf-&gt;InterfaceID, mDNSNULL, mDNSNULL, &amp;intf-&gt;SPSAddr[sps], intf-&gt;SPSPort[sps], mDNSNULL, mDNSfalse);
                <span class="enscript-keyword">if</span> (err) LogSPS(<span class="enscript-string">&quot;SendSPSRegistration: mDNSSendDNSMessage err %d&quot;</span>, err);
                <span class="enscript-keyword">if</span> (err &amp;&amp; intf-&gt;SPSAddr[sps].type == mDNSAddrType_IPv4 &amp;&amp; intf-&gt;NetWakeResolve[sps].ThisQInterval == -1)
                {
                    LogSPS(<span class="enscript-string">&quot;SendSPSRegistration %d %##s failed to send to IPv4 address; will try IPv6 instead&quot;</span>, sps, intf-&gt;NetWakeResolve[sps].qname.c);
                    intf-&gt;NetWakeResolve[sps].qtype = kDNSType_AAAA;
                    mDNS_StartQuery_internal(m, &amp;intf-&gt;NetWakeResolve[sps]);
                    <span class="enscript-keyword">return</span>;
                }
            }
        }
    }

    intf-&gt;NextSPSAttemptTime = m-&gt;timenow + mDNSPlatformOneSecond * 10;     <span class="enscript-comment">// If successful, update NextSPSAttemptTime
</span>
<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(id) &amp;&amp; intf-&gt;NextSPSAttempt &lt; 8) intf-&gt;NextSPSAttempt++;
}

mDNSlocal mDNSBool <span class="enscript-function-name">RecordIsFirstOccurrenceOfOwner</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr)
{
    AuthRecord *ar;
    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar &amp;&amp; ar != rr; ar=ar-&gt;next)
        <span class="enscript-keyword">if</span> (mDNSPlatformMemSame(&amp;rr-&gt;WakeUp, &amp;ar-&gt;WakeUp, <span class="enscript-keyword">sizeof</span>(rr-&gt;WakeUp))) <span class="enscript-keyword">return</span> mDNSfalse;
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreStoreProxyRR</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, AuthRecord *<span class="enscript-type">const</span> rr)
{
    AuthRecord *newRR = (AuthRecord *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*newRR));
    <span class="enscript-keyword">if</span> (newRR == mDNSNULL)
    {
        LogSPS(<span class="enscript-string">&quot;%s : could not allocate memory for new resource record&quot;</span>, __func__);
        <span class="enscript-keyword">return</span>;
    }

    mDNS_SetupResourceRecord(newRR, mDNSNULL, InterfaceID, rr-&gt;resrec.rrtype,
                             rr-&gt;resrec.rroriginalttl, rr-&gt;resrec.RecordType,
                             rr-&gt;ARType, mDNSNULL, mDNSNULL);

    AssignDomainName(&amp;newRR-&gt;namestorage, &amp;rr-&gt;namestorage);
    newRR-&gt;resrec.rdlength = DomainNameLength(rr-&gt;resrec.name);
    newRR-&gt;resrec.namehash = DomainNameHashValue(newRR-&gt;resrec.name);
    newRR-&gt;resrec.rrclass  = rr-&gt;resrec.rrclass;

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_A)
    {
        newRR-&gt;resrec.rdata-&gt;u.ipv4 =  rr-&gt;resrec.rdata-&gt;u.ipv4;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_AAAA)
    {
        newRR-&gt;resrec.rdata-&gt;u.ipv6 = rr-&gt;resrec.rdata-&gt;u.ipv6;
    }
    SetNewRData(&amp;newRR-&gt;resrec, mDNSNULL, 0);

    <span class="enscript-comment">// Insert the new node at the head of the list.
</span>    newRR-&gt;next        = m-&gt;SPSRRSet;
    m-&gt;SPSRRSet        = newRR;
    LogSPS(<span class="enscript-string">&quot;%s : Storing proxy record : %s &quot;</span>, __func__, ARDisplayString(m, rr));
}

<span class="enscript-comment">// Some records are interface specific and some are not. The ones that are supposed to be registered
</span><span class="enscript-comment">// on multiple interfaces need to be initialized with all the valid interfaces on which it will be sent.
</span><span class="enscript-comment">// updateIntID bit field tells us on which interfaces we need to register this record. When we get an
</span><span class="enscript-comment">// ack from the sleep proxy server, we clear the interface bit. This way, we know when a record completes
</span><span class="enscript-comment">// registration on all the interfaces
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SPSInitRecordsBeforeUpdate</span>(mDNS *<span class="enscript-type">const</span> m, mDNSOpaque64 updateIntID, mDNSBool *WakeOnlyService)
{
    AuthRecord *ar;
    LogSPS(<span class="enscript-string">&quot;SPSInitRecordsBeforeUpdate: UpdateIntID 0x%x 0x%x&quot;</span>, updateIntID.l[1], updateIntID.l[0]);

    *WakeOnlyService = mDNSfalse;

    <span class="enscript-comment">// Before we store the A and AAAA records that we are going to register with the sleep proxy,
</span>    <span class="enscript-comment">// make sure that the old sleep proxy records are removed.
</span>    mDNSCoreFreeProxyRR(m);

    <span class="enscript-comment">// For records that are registered only on a specific interface, mark only that bit as it will
</span>    <span class="enscript-comment">// never be registered on any other interface. For others, it should be sent on all interfaces.
</span>    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
    {
        ar-&gt;updateIntID = zeroOpaque64;
        ar-&gt;updateid    = zeroID;
        <span class="enscript-keyword">if</span> (AuthRecord_uDNS(ar))
        {
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (ar-&gt;AuthFlags &amp; AuthFlagsWakeOnly)
        {
            <span class="enscript-keyword">if</span> (ar-&gt;resrec.RecordType == kDNSRecordTypeShared &amp;&amp; ar-&gt;RequireGoodbye)
            {
                ar-&gt;ImmedAnswer = mDNSInterfaceMark;
                *WakeOnlyService = mDNStrue;
                <span class="enscript-keyword">continue</span>;
            }
        }
        <span class="enscript-keyword">if</span> (!ar-&gt;resrec.InterfaceID)
        {
            LogSPS(<span class="enscript-string">&quot;Setting scopeid (ALL) 0x%x 0x%x for %s&quot;</span>, updateIntID.l[1], updateIntID.l[0], ARDisplayString(m, ar));
            ar-&gt;updateIntID = updateIntID;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Filter records that belong to interfaces that we won't register the records on. UpdateIntID captures
</span>            <span class="enscript-comment">// exactly this.
</span>            mDNSu32 scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, ar-&gt;resrec.InterfaceID, mDNStrue);
            <span class="enscript-keyword">if</span> ((scopeid &lt; (<span class="enscript-keyword">sizeof</span>(updateIntID) * mDNSNBBY)) &amp;&amp; bit_get_opaque64(updateIntID, scopeid))
            {
                bit_set_opaque64(ar-&gt;updateIntID, scopeid);
                LogSPS(<span class="enscript-string">&quot;SPSInitRecordsBeforeUpdate: Setting scopeid(%d) 0x%x 0x%x for %s&quot;</span>, scopeid, ar-&gt;updateIntID.l[1],
                    ar-&gt;updateIntID.l[0], ARDisplayString(m, ar));
            }
            <span class="enscript-keyword">else</span>
            {
                LogSPS(<span class="enscript-string">&quot;SPSInitRecordsBeforeUpdate: scopeid %d beyond range or not valid for SPS registration&quot;</span>, scopeid);
            }
        }
        <span class="enscript-comment">// Store the A and AAAA records that we registered with the sleep proxy.
</span>        <span class="enscript-comment">// We will use this to prevent spurious name conflicts that may occur when we wake up
</span>        <span class="enscript-keyword">if</span> (ar-&gt;resrec.rrtype == kDNSType_A || ar-&gt;resrec.rrtype == kDNSType_AAAA)
        {
            mDNSCoreStoreProxyRR(m, ar-&gt;resrec.InterfaceID, ar);
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendSPSRegistration</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, <span class="enscript-type">const</span> mDNSOpaque16 id)
{
    AuthRecord *ar;
    OwnerOptData owner = zeroOwner;

    SendSPSRegistrationForOwner(m, intf, id, &amp;owner);

    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!mDNSPlatformMemSame(&amp;owner, &amp;ar-&gt;WakeUp, <span class="enscript-keyword">sizeof</span>(owner)) &amp;&amp; RecordIsFirstOccurrenceOfOwner(m, ar))
        {
            owner = ar-&gt;WakeUp;
            SendSPSRegistrationForOwner(m, intf, id, &amp;owner);
        }
    }
}

<span class="enscript-comment">// RetrySPSRegistrations is called from SendResponses, with the lock held
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RetrySPSRegistrations</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    NetworkInterfaceInfo *intf;

    <span class="enscript-comment">// First make sure none of our interfaces' NextSPSAttemptTimes are inadvertently set to m-&gt;timenow + mDNSPlatformOneSecond * 10
</span>    <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        <span class="enscript-keyword">if</span> (intf-&gt;NextSPSAttempt &amp;&amp; intf-&gt;NextSPSAttemptTime == m-&gt;timenow + mDNSPlatformOneSecond * 10)
            intf-&gt;NextSPSAttemptTime++;

    <span class="enscript-comment">// Retry any record registrations that are due
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr) &amp;&amp; !mDNSOpaque16IsZero(rr-&gt;updateid) &amp;&amp; m-&gt;timenow - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
        {
            <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
            {
                <span class="enscript-comment">// If we still have registrations pending on this interface, send it now
</span>                mDNSu32 scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, intf-&gt;InterfaceID, mDNStrue);
                <span class="enscript-keyword">if</span> ((scopeid &gt;= (<span class="enscript-keyword">sizeof</span>(rr-&gt;updateIntID) * mDNSNBBY) || bit_get_opaque64(rr-&gt;updateIntID, scopeid)) &amp;&amp;
                    (!rr-&gt;resrec.InterfaceID || rr-&gt;resrec.InterfaceID == intf-&gt;InterfaceID))
                {
                    LogSPS(<span class="enscript-string">&quot;RetrySPSRegistrations: 0x%x 0x%x (updateid %d) %s&quot;</span>, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(rr-&gt;updateid), ARDisplayString(m, rr));
                    SendSPSRegistration(m, intf, rr-&gt;updateid);
                }
            }
        }

    <span class="enscript-comment">// For interfaces where we did an SPS registration attempt, increment intf-&gt;NextSPSAttempt
</span>    <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        <span class="enscript-keyword">if</span> (intf-&gt;NextSPSAttempt &amp;&amp; intf-&gt;NextSPSAttemptTime == m-&gt;timenow + mDNSPlatformOneSecond * 10 &amp;&amp; intf-&gt;NextSPSAttempt &lt; 8)
            intf-&gt;NextSPSAttempt++;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NetWakeResolve</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    NetworkInterfaceInfo *intf = (NetworkInterfaceInfo *)question-&gt;QuestionContext;
    <span class="enscript-type">int</span> sps = (<span class="enscript-type">int</span>)(question - intf-&gt;NetWakeResolve);
    (<span class="enscript-type">void</span>)m;            <span class="enscript-comment">// Unused
</span>    LogSPS(<span class="enscript-string">&quot;NetWakeResolve: SPS: %d Add: %d %s&quot;</span>, sps, AddRecord, RRDisplayString(m, answer));

    <span class="enscript-keyword">if</span> (!AddRecord) <span class="enscript-keyword">return</span>;                                             <span class="enscript-comment">// Don't care about REMOVE events
</span>    <span class="enscript-keyword">if</span> (answer-&gt;rrtype != question-&gt;qtype) <span class="enscript-keyword">return</span>;                      <span class="enscript-comment">// Don't care about CNAMEs
</span>
    <span class="enscript-comment">// if (answer-&gt;rrtype == kDNSType_AAAA &amp;&amp; sps == 0) return; // To test failing to resolve sleep proxy's address
</span>
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_SRV)
    {
        <span class="enscript-comment">// 1. Got the SRV record; now look up the target host's IP address
</span>        mDNS_StopQuery(m, question);
        intf-&gt;SPSPort[sps] = answer-&gt;rdata-&gt;u.srv.port;
        AssignDomainName(&amp;question-&gt;qname, &amp;answer-&gt;rdata-&gt;u.srv.target);
        question-&gt;qtype = kDNSType_A;
        mDNS_StartQuery(m, question);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_A &amp;&amp; answer-&gt;rdlength == <span class="enscript-keyword">sizeof</span>(mDNSv4Addr))
    {
        <span class="enscript-comment">// 2. Got an IPv4 address for the target host; record address and initiate an SPS registration if appropriate
</span>        mDNS_StopQuery(m, question);
        question-&gt;ThisQInterval = -1;
        intf-&gt;SPSAddr[sps].type = mDNSAddrType_IPv4;
        intf-&gt;SPSAddr[sps].ip.v4 = answer-&gt;rdata-&gt;u.ipv4;
        mDNS_Lock(m);
        <span class="enscript-keyword">if</span> (sps == intf-&gt;NextSPSAttempt/3) SendSPSRegistration(m, intf, zeroID);    <span class="enscript-comment">// If we're ready for this result, use it now
</span>        mDNS_Unlock(m);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_A &amp;&amp; answer-&gt;rdlength == 0)
    {
        <span class="enscript-comment">// 3. Got negative response -- target host apparently has IPv6 disabled -- so try looking up the target host's IPv4 address(es) instead
</span>        mDNS_StopQuery(m, question);
        LogSPS(<span class="enscript-string">&quot;NetWakeResolve: SPS %d %##s has no IPv4 address, will try IPv6 instead&quot;</span>, sps, question-&gt;qname.c);
        question-&gt;qtype = kDNSType_AAAA;
        mDNS_StartQuery(m, question);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_AAAA &amp;&amp; answer-&gt;rdlength == <span class="enscript-keyword">sizeof</span>(mDNSv6Addr) &amp;&amp; mDNSv6AddressIsLinkLocal(&amp;answer-&gt;rdata-&gt;u.ipv6))
    {
        <span class="enscript-comment">// 4. Got the target host's IPv6 link-local address; record address and initiate an SPS registration if appropriate
</span>        mDNS_StopQuery(m, question);
        question-&gt;ThisQInterval = -1;
        intf-&gt;SPSAddr[sps].type = mDNSAddrType_IPv6;
        intf-&gt;SPSAddr[sps].ip.v6 = answer-&gt;rdata-&gt;u.ipv6;
        mDNS_Lock(m);
        <span class="enscript-keyword">if</span> (sps == intf-&gt;NextSPSAttempt/3) SendSPSRegistration(m, intf, zeroID);    <span class="enscript-comment">// If we're ready for this result, use it now
</span>        mDNS_Unlock(m);
    }
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSCoreHaveAdvertisedMulticastServices</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;rr-&gt;resrec) || (rr-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; !AuthRecord_uDNS(rr) &amp;&amp; !mDNSSameIPPort(rr-&gt;resrec.rdata-&gt;u.srv.port, DiscardPort)))
            <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WAKE_ONLY_SERVICE</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AC_ONLY_SERVICE</span>   2

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendGoodbyesForSelectServices</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool *servicePresent, mDNSu32 serviceType)
{
    AuthRecord *rr;
    *servicePresent = mDNSfalse;

    <span class="enscript-comment">// Mark all the records we need to deregister and send them
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-comment">// If the service type is wake only service and the auth flags match and requires a goodbye
</span>        <span class="enscript-comment">// OR if the service type is AC only and it is not a keepalive record,
</span>        <span class="enscript-comment">// mark the records we need to deregister and send them
</span>        <span class="enscript-keyword">if</span> ((serviceType == WAKE_ONLY_SERVICE &amp;&amp; (rr-&gt;AuthFlags &amp; AuthFlagsWakeOnly) &amp;&amp;
                rr-&gt;resrec.RecordType == kDNSRecordTypeShared &amp;&amp; rr-&gt;RequireGoodbye) ||
            (serviceType == AC_ONLY_SERVICE &amp;&amp; !mDNS_KeepaliveRecord(&amp;rr-&gt;resrec)))
        {
            rr-&gt;ImmedAnswer = mDNSInterfaceMark;
            *servicePresent = mDNStrue;
        }
    }
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-comment">// This function is used only in the case of local NIC proxy. For external
</span><span class="enscript-comment">// sleep proxy server, we do this in SPSInitRecordsBeforeUpdate when we
</span><span class="enscript-comment">// walk the resource records.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendGoodbyesForWakeOnlyService</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool *WakeOnlyService)
{
    <span class="enscript-keyword">return</span> SendGoodbyesForSelectServices(m, WakeOnlyService, WAKE_ONLY_SERVICE);
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>


mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendSleepGoodbyes</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool AllInterfaces, mDNSBool unicast)
{
    AuthRecord *rr;
    m-&gt;SleepState = SleepState_Sleeping;

    <span class="enscript-comment">// If AllInterfaces is not set, the caller has already marked it appropriately
</span>    <span class="enscript-comment">// on which interfaces this should be sent.
</span>    <span class="enscript-keyword">if</span> (AllInterfaces)
    {
        NetworkInterfaceInfo *intf;
        <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        {
            intf-&gt;SendGoodbyes = 1;
        }
    }
    <span class="enscript-keyword">if</span> (unicast)
    {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
        SleepRecordRegistrations(m);    <span class="enscript-comment">// If we have no SPS, need to deregister our uDNS records
</span>#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UNICAST_DISABLED */</span>
    }

    <span class="enscript-comment">// Mark all the records we need to deregister and send them
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeShared &amp;&amp; rr-&gt;RequireGoodbye)
            rr-&gt;ImmedAnswer = mDNSInterfaceMark;
    SendResponses(m);
}

<span class="enscript-comment">/*
 * This function attempts to detect if multiple interfaces are on the same subnet.
 * It makes this determination based only on the IPv4 Addresses and subnet masks.
 * IPv6 link local addresses that are configured by default on all interfaces make
 * it hard to make this determination
 *
 * The 'real' fix for this would be to send out multicast packets over one interface
 * and conclude that multiple interfaces are on the same subnet only if these packets
 * are seen on other interfaces on the same system
 */</span>
mDNSlocal mDNSBool <span class="enscript-function-name">skipSameSubnetRegistration</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID *regID, mDNSu32 count, mDNSInterfaceID intfid)
{
    NetworkInterfaceInfo *intf;
    NetworkInterfaceInfo *newIntf;
    mDNSu32 i;

    <span class="enscript-keyword">for</span> (newIntf = FirstInterfaceForID(m, intfid); newIntf; newIntf = newIntf-&gt;next)
    {
        <span class="enscript-keyword">if</span> ((newIntf-&gt;InterfaceID != intfid) ||
            (newIntf-&gt;ip.type     != mDNSAddrType_IPv4))
        {
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">for</span> ( i = 0; i &lt; count; i++)
        {
            <span class="enscript-keyword">for</span> (intf = FirstInterfaceForID(m, regID[i]); intf; intf = intf-&gt;next)
            {
                <span class="enscript-keyword">if</span> ((intf-&gt;InterfaceID != regID[i]) ||
                    (intf-&gt;ip.type     != mDNSAddrType_IPv4))
                {
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-keyword">if</span> ((intf-&gt;ip.ip.v4.NotAnInteger &amp; intf-&gt;mask.ip.v4.NotAnInteger) == (newIntf-&gt;ip.ip.v4.NotAnInteger &amp; newIntf-&gt;mask.ip.v4.NotAnInteger))
                {
                    LogSPS(<span class="enscript-string">&quot;%s : Already registered for the same subnet (IPv4) for interface %s&quot;</span>, __func__, intf-&gt;ifname);
                    <span class="enscript-keyword">return</span> (mDNStrue);
                }
            }
        }
    }
    <span class="enscript-keyword">return</span> (mDNSfalse);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DoKeepaliveCallbacks</span>(mDNS *m)
{
    <span class="enscript-comment">// Loop through the keepalive records and callback with an error
</span>    m-&gt;CurrentRecord = m-&gt;ResourceRecords;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> ((mDNS_KeepaliveRecord(&amp;rr-&gt;resrec)) &amp;&amp; (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering))
        {
            LogSPS(<span class="enscript-string">&quot;DoKeepaliveCallbacks: Invoking the callback for %s&quot;</span>, ARDisplayString(m, rr));
            <span class="enscript-keyword">if</span> (rr-&gt;RecordCallback)
                rr-&gt;RecordCallback(m, rr, mStatus_BadStateErr);
        }
        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

<span class="enscript-comment">// BeginSleepProcessing is called, with the lock held, from either mDNS_Execute or mDNSCoreMachineSleep
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">BeginSleepProcessing</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSBool SendGoodbyes = mDNStrue;
    mDNSBool WakeOnlyService  = mDNSfalse;
    mDNSBool invokeKACallback = mDNStrue;
    <span class="enscript-type">const</span> CacheRecord *sps[3] = { mDNSNULL };
    mDNSOpaque64 updateIntID = zeroOpaque64;
    mDNSInterfaceID registeredIntfIDS[128] = { 0 };
    mDNSu32 registeredCount = 0;
    <span class="enscript-type">int</span> skippedRegistrations = 0;

    m-&gt;NextScheduledSPRetry = m-&gt;timenow;

    <span class="enscript-comment">// Clear out the SCDynamic entry that stores the external SPS information
</span>    mDNSPlatformClearSPSData();

    <span class="enscript-keyword">if</span>      (!m-&gt;SystemWakeOnLANEnabled) LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: m-&gt;SystemWakeOnLANEnabled is false&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!mDNSCoreHaveAdvertisedMulticastServices(m)) LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: No advertised services&quot;</span>);
    <span class="enscript-keyword">else</span>    <span class="enscript-comment">// If we have at least one advertised service
</span>    {
        NetworkInterfaceInfo *intf;
        <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        {
            mDNSBool skipFullSleepProxyRegistration = mDNSfalse;
            <span class="enscript-comment">// Intialize it to false. These values make sense only when SleepState is set to Sleeping.
</span>            intf-&gt;SendGoodbyes = 0;

            <span class="enscript-comment">// If it is not multicast capable, we could not have possibly discovered sleep proxy
</span>            <span class="enscript-comment">// servers.
</span>            <span class="enscript-keyword">if</span> (!intf-&gt;McastTxRx || mDNSPlatformInterfaceIsD2D(intf-&gt;InterfaceID))
            {
                LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: %-6s Ignoring for registrations&quot;</span>, intf-&gt;ifname);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// If we are not capable of WOMP, then don't register with sleep proxy.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Note: If we are not NetWake capable, we don't browse for the sleep proxy server.
</span>            <span class="enscript-comment">// We might find sleep proxy servers in the cache and start a resolve on them.
</span>            <span class="enscript-comment">// But then if the interface goes away, we won't stop these questions because
</span>            <span class="enscript-comment">// mDNS_DeactivateNetWake_internal assumes that a browse has been started for it
</span>            <span class="enscript-comment">// to stop both the browse and resolve questions.
</span>            <span class="enscript-keyword">if</span> (!intf-&gt;NetWake)
            {
                LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: %-6s not capable of magic packet wakeup&quot;</span>, intf-&gt;ifname);
                intf-&gt;SendGoodbyes = 1;
                skippedRegistrations++;
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// Check if we have already registered with a sleep proxy for this subnet.
</span>            <span class="enscript-comment">// If so, then the subsequent in-NIC sleep proxy registration is limited to any keepalive records that belong
</span>            <span class="enscript-comment">// to the interface.
</span>            <span class="enscript-keyword">if</span> (skipSameSubnetRegistration(m, registeredIntfIDS, registeredCount, intf-&gt;InterfaceID))
            {
                LogSPS(<span class="enscript-string">&quot;%s : Skipping full sleep proxy registration on %s&quot;</span>, __func__, intf-&gt;ifname);
                skipFullSleepProxyRegistration = mDNStrue;
            }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-keyword">if</span> (SupportsInNICProxy(intf))
            {
                mDNSBool keepaliveOnly = mDNSfalse;
                <span class="enscript-type">const</span> mStatus err = ActivateLocalProxy(intf, skipFullSleepProxyRegistration, &amp;keepaliveOnly);
                <span class="enscript-keyword">if</span> (!skipFullSleepProxyRegistration &amp;&amp; !err)
                {
                    SendGoodbyesForWakeOnlyService(m, &amp;WakeOnlyService);

                    <span class="enscript-comment">// Send goodbyes for all advertised services if the only record offloaded was the keepalive record.
</span>                    SendGoodbyes     = (keepaliveOnly) ? mDNStrue: mDNSfalse;
                    invokeKACallback = mDNSfalse;
                    LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: %-6s using local proxy&quot;</span>, intf-&gt;ifname);
                    <span class="enscript-comment">// This will leave m-&gt;SleepState set to SleepState_Transferring,
</span>                    <span class="enscript-comment">// which is okay because with no outstanding resolves, or updates in flight,
</span>                    <span class="enscript-comment">// mDNSCoreReadyForSleep() will conclude correctly that all the updates have already completed
</span>
                    <span class="enscript-comment">// Setting this flag activates the SleepLimit which delays sleep by 5 seconds and
</span>                    <span class="enscript-comment">// will allow the system to deregister any BTMM records.
</span>                    m-&gt;NextScheduledSPRetry  = m-&gt;timenow + (5 * mDNSPlatformOneSecond);
                    registeredIntfIDS[registeredCount] = intf-&gt;InterfaceID;
                    registeredCount++;
                }
                <span class="enscript-keyword">continue</span>;
            }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-keyword">if</span> (!skipFullSleepProxyRegistration)
            {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
                <span class="enscript-comment">// If on battery, do not attempt to offload to external sleep proxies
</span>                <span class="enscript-keyword">if</span> (m-&gt;SystemWakeOnLANEnabled == mDNS_WakeOnBattery)
                {
                    LogSPS(<span class="enscript-string">&quot;BegingSleepProcessing: Not connected to AC power - Not registering with an external sleep proxy.&quot;</span>);
                    <span class="enscript-keyword">return</span>;
                }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
                FindSPSInCache(m, &amp;intf-&gt;NetWakeBrowse, sps);
                <span class="enscript-keyword">if</span> (!sps[0]) LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: %-6s %#a No Sleep Proxy Server found (Next Browse Q in %d, interval %d)&quot;</span>,
                                    intf-&gt;ifname, &amp;intf-&gt;ip, NextQSendTime(&amp;intf-&gt;NetWakeBrowse) - m-&gt;timenow, intf-&gt;NetWakeBrowse.ThisQInterval);
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-type">int</span> i;
                    mDNSu32 scopeid;
                    SendGoodbyes = mDNSfalse;
                    intf-&gt;NextSPSAttempt = 0;
                    intf-&gt;NextSPSAttemptTime = m-&gt;timenow + mDNSPlatformOneSecond;

                    scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, intf-&gt;InterfaceID, mDNStrue);
                    <span class="enscript-comment">// Now we know for sure that we have to wait for registration to complete on this interface.
</span>                    <span class="enscript-keyword">if</span> (scopeid &lt; (<span class="enscript-keyword">sizeof</span>(updateIntID) * mDNSNBBY))
                        bit_set_opaque64(updateIntID, scopeid);

                    <span class="enscript-comment">// Don't need to set m-&gt;NextScheduledSPRetry here because we already set &quot;m-&gt;NextScheduledSPRetry = m-&gt;timenow&quot; above
</span>                    <span class="enscript-keyword">for</span> (i=0; i&lt;3; i++)
                    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ForceAlerts</span>
                        <span class="enscript-keyword">if</span> (intf-&gt;SPSAddr[i].type)
                            LogFatalError(<span class="enscript-string">&quot;BeginSleepProcessing: %s %d intf-&gt;SPSAddr[i].type %d&quot;</span>, intf-&gt;ifname, i, intf-&gt;SPSAddr[i].type);
                        <span class="enscript-keyword">if</span> (intf-&gt;NetWakeResolve[i].ThisQInterval &gt;= 0)
                            LogFatalError(<span class="enscript-string">&quot;BeginSleepProcessing: %s %d intf-&gt;NetWakeResolve[i].ThisQInterval %d&quot;</span>, intf-&gt;ifname, i, intf-&gt;NetWakeResolve[i].ThisQInterval);
#<span class="enscript-reference">endif</span>
                        intf-&gt;SPSAddr[i].type = mDNSAddrType_None;
                        <span class="enscript-keyword">if</span> (intf-&gt;NetWakeResolve[i].ThisQInterval &gt;= 0) mDNS_StopQuery(m, &amp;intf-&gt;NetWakeResolve[i]);
                        intf-&gt;NetWakeResolve[i].ThisQInterval = -1;
                        <span class="enscript-keyword">if</span> (sps[i])
                        {
                            LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: %-6s Found Sleep Proxy Server %d TTL %d %s&quot;</span>, intf-&gt;ifname, i, sps[i]-&gt;resrec.rroriginalttl, CRDisplayString(m, sps[i]));
                            mDNS_SetupQuestion(&amp;intf-&gt;NetWakeResolve[i], intf-&gt;InterfaceID, &amp;sps[i]-&gt;resrec.rdata-&gt;u.name, kDNSType_SRV, NetWakeResolve, intf);
                            intf-&gt;NetWakeResolve[i].ReturnIntermed = mDNStrue;
                            mDNS_StartQuery_internal(m, &amp;intf-&gt;NetWakeResolve[i]);

                            <span class="enscript-comment">// If we are registering with a Sleep Proxy for a new subnet, add it to our list
</span>                            registeredIntfIDS[registeredCount] = intf-&gt;InterfaceID;
                            registeredCount++;
                        }
                    }
                }
            }
        }
    }

    <span class="enscript-comment">// If we have at least one interface on which we are registering with an external sleep proxy,
</span>    <span class="enscript-comment">// initialize all the records appropriately.
</span>    <span class="enscript-keyword">if</span> (!mDNSOpaque64IsZero(&amp;updateIntID))
        SPSInitRecordsBeforeUpdate(m, updateIntID, &amp;WakeOnlyService);

    <span class="enscript-comment">// Call the applicaitons that registered a keepalive record to inform them that we failed to offload
</span>    <span class="enscript-comment">// the records to a sleep proxy.
</span>    <span class="enscript-keyword">if</span> (invokeKACallback)
    {
        LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: Did not register with an in-NIC proxy - invoking the callbacks for KA records&quot;</span>);
        DoKeepaliveCallbacks(m);
    }

    <span class="enscript-comment">// SendSleepGoodbyes last two arguments control whether we send goodbyes on all
</span>    <span class="enscript-comment">// interfaces and also deregister unicast registrations.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - If there are no sleep proxy servers, then send goodbyes on all interfaces
</span>    <span class="enscript-comment">//   for both multicast and unicast.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - If we skipped registrations on some interfaces, then we have already marked
</span>    <span class="enscript-comment">//   them appropriately above. We don't need to send goodbyes for unicast as
</span>    <span class="enscript-comment">//   we have registered with at least one sleep proxy.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - If we are not planning to send any goodbyes, then check for WakeOnlyServices.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: If we are planning to send goodbyes, we mark the record with mDNSInterfaceAny
</span>    <span class="enscript-comment">// and call SendResponses which inturn calls ShouldSendGoodbyesBeforeSleep which looks
</span>    <span class="enscript-comment">// at WakeOnlyServices first.
</span>    <span class="enscript-keyword">if</span> (SendGoodbyes)
    {
        LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: Not registering with Sleep Proxy Server&quot;</span>);
        SendSleepGoodbyes(m, mDNStrue, mDNStrue);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (skippedRegistrations)
    {
        LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: Not registering with Sleep Proxy Server on all interfaces&quot;</span>);
        SendSleepGoodbyes(m, mDNSfalse, mDNSfalse);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (WakeOnlyService)
    {
        <span class="enscript-comment">// If we saw WakeOnly service above, send the goodbyes now.
</span>        LogSPS(<span class="enscript-string">&quot;BeginSleepProcessing: Sending goodbyes for WakeOnlyService&quot;</span>);
        SendResponses(m);
    }
}

<span class="enscript-comment">// Call mDNSCoreMachineSleep(m, mDNStrue) when the machine is about to go to sleep.
</span><span class="enscript-comment">// Call mDNSCoreMachineSleep(m, mDNSfalse) when the machine is has just woken up.
</span><span class="enscript-comment">// Normally, the platform support layer below mDNSCore should call this, not the client layer above.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreMachineSleep</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool sleep)
{
    AuthRecord *rr;

    LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_INFO,
        PUB_S <span class="enscript-string">&quot; (old state %d) at %d&quot;</span>, sleep ? <span class="enscript-string">&quot;Sleeping&quot;</span> : <span class="enscript-string">&quot;Waking&quot;</span>, m-&gt;SleepState, m-&gt;timenow);

    <span class="enscript-keyword">if</span> (sleep &amp;&amp; !m-&gt;SleepState)        <span class="enscript-comment">// Going to sleep
</span>    {
        mDNS_Lock(m);
        <span class="enscript-comment">// If we're going to sleep, need to stop advertising that we're a Sleep Proxy Server
</span>        <span class="enscript-keyword">if</span> (m-&gt;SPSSocket)
        {
            mDNSu8 oldstate = m-&gt;SPSState;
            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// mDNS_DeregisterService expects to be called without the lock held, so we emulate that here
</span>            m-&gt;SPSState = 2;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
            <span class="enscript-keyword">if</span> (oldstate == 1) mDNS_DeregisterService(m, &amp;m-&gt;SPSRecords);
#<span class="enscript-reference">else</span>
            (<span class="enscript-type">void</span>)oldstate;
#<span class="enscript-reference">endif</span>
            mDNS_ReclaimLockAfterCallback();
        }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
        <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket)
        {
            mDNSPlatformUDPClose(m-&gt;SSDPSocket);
            m-&gt;SSDPSocket = mDNSNULL;
        }
#<span class="enscript-reference">endif</span>
        m-&gt;SleepState = SleepState_Transferring;
        <span class="enscript-keyword">if</span> (m-&gt;SystemWakeOnLANEnabled &amp;&amp; m-&gt;DelaySleep)
        {
            <span class="enscript-comment">// If we just woke up moments ago, allow ten seconds for networking to stabilize before going back to sleep
</span>            LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
                      <span class="enscript-string">&quot;mDNSCoreMachineSleep: Re-sleeping immediately after waking; will delay for %d ticks&quot;</span>, m-&gt;DelaySleep - m-&gt;timenow);
            m-&gt;SleepLimit = NonZeroTime(m-&gt;DelaySleep + mDNSPlatformOneSecond * 10);
        }
        <span class="enscript-keyword">else</span>
        {
            m-&gt;DelaySleep = 0;
            m-&gt;SleepLimit = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond * 10);
            m-&gt;mDNSStats.Sleeps++;
            BeginSleepProcessing(m);
        }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
        SuspendLLQs(m);
#<span class="enscript-reference">endif</span>
        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;mDNSCoreMachineSleep: m-&gt;SleepState %d (&quot;</span> PUB_S <span class="enscript-string">&quot;) seq %d&quot;</span>,
                  m-&gt;SleepState,
                  m-&gt;SleepState == SleepState_Transferring ? <span class="enscript-string">&quot;Transferring&quot;</span> :
                  m-&gt;SleepState == SleepState_Sleeping     ? <span class="enscript-string">&quot;Sleeping&quot;</span>     : <span class="enscript-string">&quot;?&quot;</span>, m-&gt;SleepSeqNum);
        mDNS_Unlock(m);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!sleep)        <span class="enscript-comment">// Waking up
</span>    {
        mDNSu32 slot;
        CacheGroup *cg;
        CacheRecord *cr;
        NetworkInterfaceInfo *intf;
        mDNSs32 currtime, diff;

        mDNS_Lock(m);
        <span class="enscript-comment">// Reset SleepLimit back to 0 now that we're awake again.
</span>        m-&gt;SleepLimit = 0;

        <span class="enscript-comment">// If we were previously sleeping, but now we're not, increment m-&gt;SleepSeqNum to indicate that we're entering a new period of wakefulness
</span>        <span class="enscript-keyword">if</span> (m-&gt;SleepState != SleepState_Awake)
        {
            m-&gt;SleepState = SleepState_Awake;
            m-&gt;SleepSeqNum++;
            <span class="enscript-comment">// If the machine wakes and then immediately tries to sleep again (e.g. a maintenance wake)
</span>            <span class="enscript-comment">// then we enforce a minimum delay of five seconds before we begin sleep processing.
</span>            <span class="enscript-comment">// This is to allow time for the Ethernet link to come up, DHCP to get an address, mDNS to issue queries, etc.,
</span>            <span class="enscript-comment">// before we make our determination of whether there's a Sleep Proxy out there we should register with.
</span>            m-&gt;DelaySleep = NonZeroTime(m-&gt;timenow + kDarkWakeDelaySleep);
        }

        <span class="enscript-keyword">if</span> (m-&gt;SPSState == 3)
        {
            m-&gt;SPSState = 0;
            mDNSCoreBeSleepProxyServer_internal(m, m-&gt;SPSType, m-&gt;SPSPortability, m-&gt;SPSMarginalPower, m-&gt;SPSTotalPower, m-&gt;SPSFeatureFlags);
        }
        m-&gt;mDNSStats.Wakes++;
        <span class="enscript-comment">// ... and the same for NextSPSAttempt
</span>        <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next)) intf-&gt;NextSPSAttempt = -1;

        <span class="enscript-comment">// Restart unicast and multicast queries
</span>        mDNSCoreRestartQueries(m);

        <span class="enscript-comment">// and reactivtate service registrations
</span>        m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond);
        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
                  <span class="enscript-string">&quot;mDNSCoreMachineSleep waking: NextSRVUpdate in %d %d&quot;</span>, m-&gt;NextSRVUpdate - m-&gt;timenow, m-&gt;timenow);

        <span class="enscript-comment">// 2. Re-validate our cache records
</span>        currtime = mDNSPlatformUTC();

        diff = currtime - m-&gt;TimeSlept;
        FORALL_CACHERECORDS(slot, cg, cr)
        {
            <span class="enscript-comment">// Temporary fix: For unicast cache records, look at how much time we slept.
</span>            <span class="enscript-comment">// Adjust the RecvTime by the amount of time we slept so that we age the
</span>            <span class="enscript-comment">// cache record appropriately. If it is expired already, purge. If there
</span>            <span class="enscript-comment">// is a network change that happens after the wakeup, we might purge the
</span>            <span class="enscript-comment">// cache anyways and this helps only in the case where there are no network
</span>            <span class="enscript-comment">// changes across sleep/wakeup transition.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Note: If there is a network/DNS server change that already happened and
</span>            <span class="enscript-comment">// these cache entries are already refreshed and we are getting a delayed
</span>            <span class="enscript-comment">// wake up notification, we might adjust the TimeRcvd based on the time slept
</span>            <span class="enscript-comment">// now which can cause the cache to purge pre-maturely. As this is not a very
</span>            <span class="enscript-comment">// common case, this should happen rarely.
</span>            <span class="enscript-keyword">if</span> (!cr-&gt;resrec.InterfaceID)
            {
                <span class="enscript-keyword">if</span> (diff &gt; 0)
                {
                    mDNSu32 uTTL = RRUnadjustedTTL(cr-&gt;resrec.rroriginalttl);
                    <span class="enscript-type">const</span> mDNSs32 remain = uTTL - (m-&gt;timenow - cr-&gt;TimeRcvd) / mDNSPlatformOneSecond;

                    <span class="enscript-comment">// -if we have slept longer than the remaining TTL, purge and start fresh.
</span>                    <span class="enscript-comment">// -if we have been sleeping for a long time, we could reduce TimeRcvd below by
</span>                    <span class="enscript-comment">//  a sufficiently big value which could cause the value to go into the future
</span>                    <span class="enscript-comment">//  because of the signed comparison of time. For this to happen, we should have been
</span>                    <span class="enscript-comment">//  sleeping really long (~24 days). For now, we want to be conservative and flush even
</span>                    <span class="enscript-comment">//  if we have slept for more than two days.
</span>
                    <span class="enscript-keyword">if</span> (diff &gt;= remain || diff &gt; (2 * 24 * 3600))
                    {
                        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
                                  <span class="enscript-string">&quot;mDNSCoreMachineSleep: &quot;</span> PRI_S <span class="enscript-string">&quot;: Purging cache entry SleptTime %d, Remaining TTL %d&quot;</span>,
                                  CRDisplayString(m, cr), diff, remain);
                        mDNS_PurgeCacheResourceRecord(m, cr);
                        <span class="enscript-keyword">continue</span>;
                    }
                    cr-&gt;TimeRcvd -= (diff * mDNSPlatformOneSecond);
                    <span class="enscript-keyword">if</span> (m-&gt;timenow - (cr-&gt;TimeRcvd + ((mDNSs32)uTTL * mDNSPlatformOneSecond)) &gt;= 0)
                    {
                        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
                                  <span class="enscript-string">&quot;mDNSCoreMachineSleep: &quot;</span> PRI_S <span class="enscript-string">&quot;: Purging after adjusting the remaining TTL %d by %d seconds&quot;</span>,
                                  CRDisplayString(m, cr), remain, diff);
                        mDNS_PurgeCacheResourceRecord(m, cr);
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG,
                                  <span class="enscript-string">&quot;mDNSCoreMachineSleep: &quot;</span> PRI_S <span class="enscript-string">&quot;: Adjusted the remain ttl %u by %d seconds&quot;</span>,
                                  CRDisplayString(m, cr), remain, diff);
                    }
                }
            }
            <span class="enscript-keyword">else</span>
            {
                mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForWake);
            }
        }

        <span class="enscript-comment">// 3. Retrigger probing and announcing for all our authoritative records
</span>        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr))
            {
                ActivateUnicastRegistration(m, rr);
            }
            <span class="enscript-keyword">else</span>
            {
                mDNSCoreRestartRegistration(m, rr, -1);
            }
        }

        <span class="enscript-comment">// 4. Refresh NAT mappings
</span>        <span class="enscript-comment">// We don't want to have to assume that all hardware can necessarily keep accurate
</span>        <span class="enscript-comment">// track of passage of time while asleep, so on wake we refresh our NAT mappings.
</span>        <span class="enscript-comment">// We typically wake up with no interfaces active, so there's no need to rush to try to find our external address.
</span>        <span class="enscript-comment">// But if we do get a network configuration change, mDNSMacOSXNetworkChanged will call uDNS_SetupDNSConfig, which
</span>        <span class="enscript-comment">// will call mDNS_SetPrimaryInterfaceInfo, which will call RecreateNATMappings to refresh them, potentially sooner
</span>        <span class="enscript-comment">// than five seconds from now.
</span>        LogRedact(MDNS_LOG_CATEGORY_SPS, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;mDNSCoreMachineSleep: recreating NAT mappings in 5 seconds&quot;</span>);
        RecreateNATMappings(m, mDNSPlatformOneSecond * 5);
        mDNS_Unlock(m);
    }
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSCoreReadyForSleep</span>(mDNS *m, mDNSs32 now)
{
    DNSQuestion *q;
    AuthRecord *rr;
    NetworkInterfaceInfo *intf;

    mDNS_Lock(m);

    <span class="enscript-keyword">if</span> (m-&gt;DelaySleep) <span class="enscript-keyword">goto</span> <span class="enscript-reference">notready</span>;

    <span class="enscript-comment">// If we've not hit the sleep limit time, and it's not time for our next retry, we can skip these checks
</span>    <span class="enscript-keyword">if</span> (m-&gt;SleepLimit - now &gt; 0 &amp;&amp; m-&gt;NextScheduledSPRetry - now &gt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">notready</span>;

    m-&gt;NextScheduledSPRetry = now + 0x40000000UL;

    <span class="enscript-comment">// See if we might need to retransmit any lost Sleep Proxy Registrations
</span>    <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
        <span class="enscript-keyword">if</span> (intf-&gt;NextSPSAttempt &gt;= 0)
        {
            <span class="enscript-keyword">if</span> (now - intf-&gt;NextSPSAttemptTime &gt;= 0)
            {
                LogSPS(<span class="enscript-string">&quot;mDNSCoreReadyForSleep: retrying for %s SPS %d try %d&quot;</span>,
                       intf-&gt;ifname, intf-&gt;NextSPSAttempt/3, intf-&gt;NextSPSAttempt);
                SendSPSRegistration(m, intf, zeroID);
                <span class="enscript-comment">// Don't need to &quot;goto notready&quot; here, because if we do still have record registrations
</span>                <span class="enscript-comment">// that have not been acknowledged yet, we'll catch that in the record list scan below.
</span>            }
            <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">if</span> (m-&gt;NextScheduledSPRetry - intf-&gt;NextSPSAttemptTime &gt; 0)
                m-&gt;NextScheduledSPRetry = intf-&gt;NextSPSAttemptTime;
        }

    <span class="enscript-comment">// Scan list of interfaces, and see if we're still waiting for any sleep proxy resolves to complete
</span>    <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
    {
        <span class="enscript-type">int</span> sps = (intf-&gt;NextSPSAttempt == 0) ? 0 : (intf-&gt;NextSPSAttempt-1)/3;
        <span class="enscript-keyword">if</span> (intf-&gt;NetWakeResolve[sps].ThisQInterval &gt;= 0)
        {
            LogSPS(<span class="enscript-string">&quot;mDNSCoreReadyForSleep: waiting for SPS Resolve %s %##s (%s)&quot;</span>,
                   intf-&gt;ifname, intf-&gt;NetWakeResolve[sps].qname.c, DNSTypeName(intf-&gt;NetWakeResolve[sps].qtype));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">spsnotready</span>;
        }
    }

    <span class="enscript-comment">// Scan list of registered records
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))
            <span class="enscript-keyword">if</span> (!mDNSOpaque64IsZero(&amp;rr-&gt;updateIntID))
            { LogSPS(<span class="enscript-string">&quot;mDNSCoreReadyForSleep: waiting for SPS updateIntID 0x%x 0x%x (updateid %d) %s&quot;</span>, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(rr-&gt;updateid), ARDisplayString(m,rr)); <span class="enscript-keyword">goto</span> <span class="enscript-reference">spsnotready</span>; }

    <span class="enscript-comment">// Scan list of private LLQs, and make sure they've all completed their handshake with the server
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;LongLived &amp;&amp; q-&gt;ReqLease == 0 &amp;&amp; q-&gt;tcp)
        {
            LogSPS(<span class="enscript-string">&quot;mDNSCoreReadyForSleep: waiting for LLQ %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">notready</span>;
        }

    <span class="enscript-comment">// Scan list of registered records
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
        <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr))
        {
            <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Refresh &amp;&amp; rr-&gt;tcp)
            { LogSPS(<span class="enscript-string">&quot;mDNSCoreReadyForSleep: waiting for Record updateIntID 0x%x 0x%x (updateid %d) %s&quot;</span>, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(rr-&gt;updateid), ARDisplayString(m,rr)); <span class="enscript-keyword">goto</span> <span class="enscript-reference">notready</span>; }
        }

    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span> mDNStrue;

<span class="enscript-reference">spsnotready</span>:

    <span class="enscript-comment">// If we failed to complete sleep proxy registration within ten seconds, we give up on that
</span>    <span class="enscript-comment">// and allow up to ten seconds more to complete wide-area deregistration instead
</span>    <span class="enscript-keyword">if</span> (now - m-&gt;SleepLimit &gt;= 0)
    {
        LogMsg(<span class="enscript-string">&quot;Failed to register with SPS, now sending goodbyes&quot;</span>);

        <span class="enscript-keyword">for</span> (intf = GetFirstActiveInterface(m-&gt;HostInterfaces); intf; intf = GetFirstActiveInterface(intf-&gt;next))
            <span class="enscript-keyword">if</span> (intf-&gt;NetWakeBrowse.ThisQInterval &gt;= 0)
            {
                LogSPS(<span class="enscript-string">&quot;ReadyForSleep mDNS_DeactivateNetWake %s %##s (%s)&quot;</span>,
                       intf-&gt;ifname, intf-&gt;NetWakeResolve[0].qname.c, DNSTypeName(intf-&gt;NetWakeResolve[0].qtype));
                mDNS_DeactivateNetWake_internal(m, intf);
            }

        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
            <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr))
                <span class="enscript-keyword">if</span> (!mDNSOpaque64IsZero(&amp;rr-&gt;updateIntID))
                {
                    LogSPS(<span class="enscript-string">&quot;ReadyForSleep clearing updateIntID 0x%x 0x%x (updateid %d) for %s&quot;</span>, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(rr-&gt;updateid), ARDisplayString(m, rr));
                    rr-&gt;updateIntID = zeroOpaque64;
                }

        <span class="enscript-comment">// We'd really like to allow up to ten seconds more here,
</span>        <span class="enscript-comment">// but if we don't respond to the sleep notification within 30 seconds
</span>        <span class="enscript-comment">// we'll be put back to sleep forcibly without the chance to schedule the next maintenance wake.
</span>        <span class="enscript-comment">// Right now we wait 16 sec after wake for all the interfaces to come up, then we wait up to 10 seconds
</span>        <span class="enscript-comment">// more for SPS resolves and record registrations to complete, which puts us at 26 seconds.
</span>        <span class="enscript-comment">// If we allow just one more second to send our goodbyes, that puts us at 27 seconds.
</span>        m-&gt;SleepLimit = now + mDNSPlatformOneSecond * 1;

        SendSleepGoodbyes(m, mDNStrue, mDNStrue);
    }

<span class="enscript-reference">notready</span>:
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport mDNSs32 <span class="enscript-function-name">mDNSCoreIntervalToNextWake</span>(mDNS *<span class="enscript-type">const</span> m, mDNSs32 now)
{
    AuthRecord *ar;

    <span class="enscript-comment">// Even when we have no wake-on-LAN-capable interfaces, or we failed to find a sleep proxy, or we have other
</span>    <span class="enscript-comment">// failure scenarios, we still want to wake up in at most 120 minutes, to see if the network environment has changed.
</span>    <span class="enscript-comment">// E.g. we might wake up and find no wireless network because the base station got rebooted just at that moment,
</span>    <span class="enscript-comment">// and if that happens we don't want to just give up and go back to sleep and never try again.
</span>    mDNSs32 e = now + (120 * 60 * mDNSPlatformOneSecond);       <span class="enscript-comment">// Sleep for at most 120 minutes
</span>
    NATTraversalInfo *nat;
    <span class="enscript-keyword">for</span> (nat = m-&gt;NATTraversals; nat; nat=nat-&gt;next)
        <span class="enscript-keyword">if</span> (nat-&gt;Protocol &amp;&amp; nat-&gt;ExpiryTime &amp;&amp; nat-&gt;ExpiryTime - now &gt; mDNSPlatformOneSecond*4)
        {
            mDNSs32 t = nat-&gt;ExpiryTime - (nat-&gt;ExpiryTime - now) / 10;     <span class="enscript-comment">// Wake up when 90% of the way to the expiry time
</span>            <span class="enscript-keyword">if</span> (e - t &gt; 0) e = t;
            LogSPS(<span class="enscript-string">&quot;ComputeWakeTime: %p %s Int %5d Ext %5d Err %d Retry %5d Interval %5d Expire %5d Wake %5d&quot;</span>,
                   nat, nat-&gt;Protocol == NATOp_MapTCP ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;UDP&quot;</span>,
                   mDNSVal16(nat-&gt;IntPort), mDNSVal16(nat-&gt;ExternalPort), nat-&gt;Result,
                   nat-&gt;retryPortMap ? (nat-&gt;retryPortMap - now) / mDNSPlatformOneSecond : 0,
                   nat-&gt;retryInterval / mDNSPlatformOneSecond,
                   nat-&gt;ExpiryTime ? (nat-&gt;ExpiryTime - now) / mDNSPlatformOneSecond : 0,
                   (t - now) / mDNSPlatformOneSecond);
        }

    <span class="enscript-comment">// This loop checks both the time we need to renew wide-area registrations,
</span>    <span class="enscript-comment">// and the time we need to renew Sleep Proxy registrations
</span>    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar = ar-&gt;next)
        <span class="enscript-keyword">if</span> (ar-&gt;expire &amp;&amp; ar-&gt;expire - now &gt; mDNSPlatformOneSecond*4)
        {
            mDNSs32 t = ar-&gt;expire - (ar-&gt;expire - now) / 10;       <span class="enscript-comment">// Wake up when 90% of the way to the expiry time
</span>            <span class="enscript-keyword">if</span> (e - t &gt; 0) e = t;
            LogSPS(<span class="enscript-string">&quot;ComputeWakeTime: %p Int %7d Next %7d Expire %7d Wake %7d %s&quot;</span>,
                   ar, ar-&gt;ThisAPInterval / mDNSPlatformOneSecond,
                   (ar-&gt;LastAPTime + ar-&gt;ThisAPInterval - now) / mDNSPlatformOneSecond,
                   ar-&gt;expire ? (ar-&gt;expire - now) / mDNSPlatformOneSecond : 0,
                   (t - now) / mDNSPlatformOneSecond, ARDisplayString(m, ar));
        }

    <span class="enscript-keyword">return</span>(e - now);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Packet</span> <span class="enscript-variable-name">Reception</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MustSendRecord</span>(RR) ((RR)-&gt;NR_AnswerTo || (RR)-&gt;NR_AdditionalTo)

mDNSlocal mDNSu8 *<span class="enscript-function-name">GenerateUnicastResponse</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> query, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                          <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSBool LegacyQuery, DNSMessage *<span class="enscript-type">const</span> response, AuthRecord *ResponseRecords)
{
    mDNSu8          *responseptr     = response-&gt;data;
    <span class="enscript-type">const</span> mDNSu8    *<span class="enscript-type">const</span> limit     = response-&gt;data + <span class="enscript-keyword">sizeof</span>(response-&gt;data);
    <span class="enscript-type">const</span> mDNSu8    *ptr             = query-&gt;data;
    AuthRecord  *rr;
    mDNSu32 maxttl = (!InterfaceID) ? mDNSMaximumUnicastTTLSeconds : mDNSMaximumMulticastTTLSeconds;
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// Initialize the response fields so we can answer the questions
</span>    InitializeDNSMessage(&amp;response-&gt;h, query-&gt;h.id, ResponseFlags);

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 1. Write out the list of questions we are actually going to answer with this packet
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">if</span> (LegacyQuery)
    {
        maxttl = kStaticCacheTTL;
        <span class="enscript-keyword">for</span> (i=0; i&lt;query-&gt;h.numQuestions; i++)                     <span class="enscript-comment">// For each question...
</span>        {
            DNSQuestion q;
            ptr = getQuestion(query, ptr, end, InterfaceID, &amp;q);    <span class="enscript-comment">// get the question...
</span>            <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span>(mDNSNULL);

            <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)       <span class="enscript-comment">// and search our list of proposed answers
</span>            {
                <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo == ptr)                         <span class="enscript-comment">// If we're going to generate a record answering this question
</span>                {                                                   <span class="enscript-comment">// then put the question in the question section
</span>                    responseptr = putQuestion(response, responseptr, limit, &amp;q.qname, q.qtype, q.qclass);
                    <span class="enscript-keyword">if</span> (!responseptr) { debugf(<span class="enscript-string">&quot;GenerateUnicastResponse: Ran out of space for questions!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
                    <span class="enscript-keyword">break</span>;      <span class="enscript-comment">// break out of the ResponseRecords loop, and go on to the next question
</span>                }
            }
        }

        <span class="enscript-keyword">if</span> (response-&gt;h.numQuestions == 0) { LogMsg(<span class="enscript-string">&quot;GenerateUnicastResponse: ERROR! Why no questions?&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 2. Write Answers
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)
        <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo)
        {
            mDNSu8 *p = PutResourceRecordTTL(response, responseptr, &amp;response-&gt;h.numAnswers, &amp;rr-&gt;resrec,
                                             maxttl &lt; rr-&gt;resrec.rroriginalttl ? maxttl : rr-&gt;resrec.rroriginalttl);
            <span class="enscript-keyword">if</span> (p) responseptr = p;
            <span class="enscript-keyword">else</span> { debugf(<span class="enscript-string">&quot;GenerateUnicastResponse: Ran out of space for answers!&quot;</span>); response-&gt;h.flags.b[0] |= kDNSFlag0_TC; }
        }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 3. Write Additionals
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)
        <span class="enscript-keyword">if</span> (rr-&gt;NR_AdditionalTo &amp;&amp; !rr-&gt;NR_AnswerTo)
        {
            mDNSu8 *p = PutResourceRecordTTL(response, responseptr, &amp;response-&gt;h.numAdditionals, &amp;rr-&gt;resrec,
                                             maxttl &lt; rr-&gt;resrec.rroriginalttl ? maxttl : rr-&gt;resrec.rroriginalttl);
            <span class="enscript-keyword">if</span> (p) responseptr = p;
            <span class="enscript-keyword">else</span> debugf(<span class="enscript-string">&quot;GenerateUnicastResponse: No more space for additionals&quot;</span>);
        }

    <span class="enscript-keyword">return</span>(responseptr);
}

<span class="enscript-comment">// AuthRecord *our is our Resource Record
</span><span class="enscript-comment">// CacheRecord *pkt is the Resource Record from the response packet we've witnessed on the network
</span><span class="enscript-comment">// Returns 0 if there is no conflict
</span><span class="enscript-comment">// Returns +1 if there was a conflict and we won
</span><span class="enscript-comment">// Returns -1 if there was a conflict and we lost and have to rename
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">CompareRData</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> our, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pkt)
{
    mDNSu8 ourdata[256], *ourptr = ourdata, *ourend;
    mDNSu8 pktdata[256], *pktptr = pktdata, *pktend;
    <span class="enscript-keyword">if</span> (!our) { LogMsg(<span class="enscript-string">&quot;CompareRData ERROR: our is NULL&quot;</span>); <span class="enscript-keyword">return</span>(+1); }
    <span class="enscript-keyword">if</span> (!pkt) { LogMsg(<span class="enscript-string">&quot;CompareRData ERROR: pkt is NULL&quot;</span>); <span class="enscript-keyword">return</span>(+1); }

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang_analyzer__</span>)
    <span class="enscript-comment">// Get rid of analyzer warnings about ourptr and pktptr pointing to garbage after retruning from putRData().
</span>    <span class="enscript-comment">// There are no clear indications from the analyzer of the cause of the supposed problem.
</span>    mDNSPlatformMemZero(ourdata, 1);
    mDNSPlatformMemZero(pktdata, 1);
#<span class="enscript-reference">endif</span>
    ourend = putRData(mDNSNULL, ourdata, ourdata + <span class="enscript-keyword">sizeof</span>(ourdata), &amp;our-&gt;resrec);
    pktend = putRData(mDNSNULL, pktdata, pktdata + <span class="enscript-keyword">sizeof</span>(pktdata), &amp;pkt-&gt;resrec);
    <span class="enscript-keyword">while</span> (ourptr &lt; ourend &amp;&amp; pktptr &lt; pktend &amp;&amp; *ourptr == *pktptr) { ourptr++; pktptr++; }
    <span class="enscript-keyword">if</span> (ourptr &gt;= ourend &amp;&amp; pktptr &gt;= pktend) <span class="enscript-keyword">return</span>(0);            <span class="enscript-comment">// If data identical, not a conflict
</span>
    <span class="enscript-keyword">if</span> (ourptr &gt;= ourend) <span class="enscript-keyword">return</span>(-1);                               <span class="enscript-comment">// Our data ran out first; We lost
</span>    <span class="enscript-keyword">if</span> (pktptr &gt;= pktend) <span class="enscript-keyword">return</span>(+1);                               <span class="enscript-comment">// Packet data ran out first; We won
</span>    <span class="enscript-keyword">if</span> (*pktptr &gt; *ourptr) <span class="enscript-keyword">return</span>(-1);                              <span class="enscript-comment">// Our data is numerically lower; We lost
</span>    <span class="enscript-keyword">if</span> (*pktptr &lt; *ourptr) <span class="enscript-keyword">return</span>(+1);                              <span class="enscript-comment">// Packet data is numerically lower; We won
</span>
    LogMsg(<span class="enscript-string">&quot;CompareRData ERROR: Invalid state&quot;</span>);
    <span class="enscript-keyword">return</span>(-1);
}

mDNSlocal mDNSBool <span class="enscript-function-name">PacketRecordMatches</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pktrr, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> master)
{
    <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rr-&gt;resrec, &amp;pktrr-&gt;resrec))
    {
        <span class="enscript-type">const</span> AuthRecord *r2 = rr;
        <span class="enscript-keyword">while</span> (r2-&gt;DependentOn) r2 = r2-&gt;DependentOn;
        <span class="enscript-keyword">if</span> (r2 == master) <span class="enscript-keyword">return</span>(mDNStrue);
    }
    <span class="enscript-keyword">return</span>(mDNSfalse);
}

<span class="enscript-comment">// See if we have an authoritative record that's identical to this packet record,
</span><span class="enscript-comment">// whose canonical DependentOn record is the specified master record.
</span><span class="enscript-comment">// The DependentOn pointer is typically used for the TXT record of service registrations
</span><span class="enscript-comment">// It indicates that there is no inherent conflict detection for the TXT record
</span><span class="enscript-comment">// -- it depends on the SRV record to resolve name conflicts
</span><span class="enscript-comment">// If we find any identical ResourceRecords in our authoritative list, then follow their DependentOn
</span><span class="enscript-comment">// pointer chain (if any) to make sure we reach the canonical DependentOn record
</span><span class="enscript-comment">// If the record has no DependentOn, then just return that record's pointer
</span><span class="enscript-comment">// Returns NULL if we don't have any local RRs that are identical to the one from the packet
</span>mDNSlocal mDNSBool <span class="enscript-function-name">MatchDependentOn</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pktrr, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> master)
{
    <span class="enscript-type">const</span> AuthRecord *r1;
    <span class="enscript-keyword">for</span> (r1 = m-&gt;ResourceRecords; r1; r1=r1-&gt;next)
    {
        <span class="enscript-keyword">if</span> (PacketRecordMatches(r1, pktrr, master)) <span class="enscript-keyword">return</span>(mDNStrue);
    }
    <span class="enscript-keyword">for</span> (r1 = m-&gt;DuplicateRecords; r1; r1=r1-&gt;next)
    {
        <span class="enscript-keyword">if</span> (PacketRecordMatches(r1, pktrr, master)) <span class="enscript-keyword">return</span>(mDNStrue);
    }
    <span class="enscript-keyword">return</span>(mDNSfalse);
}

<span class="enscript-comment">// Find the canonical RRSet pointer for this RR received in a packet.
</span><span class="enscript-comment">// If we find any identical AuthRecord in our authoritative list, then follow its RRSet
</span><span class="enscript-comment">// pointers (if any) to make sure we return the canonical member of this name/type/class
</span><span class="enscript-comment">// Returns NULL if we don't have any local RRs that are identical to the one from the packet
</span>mDNSlocal <span class="enscript-type">const</span> AuthRecord *<span class="enscript-function-name">FindRRSet</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pktrr)
{
    <span class="enscript-type">const</span> AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rr-&gt;resrec, &amp;pktrr-&gt;resrec))
        {
            <span class="enscript-keyword">return</span>(rr-&gt;RRSet ? rr-&gt;RRSet : rr);
        }
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// PacketRRConflict is called when we've received an RR (pktrr) which has the same name
</span><span class="enscript-comment">// as one of our records (our) but different rdata.
</span><span class="enscript-comment">// 1. If our record is not a type that's supposed to be unique, we don't care.
</span><span class="enscript-comment">// 2a. If our record is marked as dependent on some other record for conflict detection, ignore this one.
</span><span class="enscript-comment">// 2b. If the packet rr exactly matches one of our other RRs, and *that* record's DependentOn pointer
</span><span class="enscript-comment">//     points to our record, ignore this conflict (e.g. the packet record matches one of our
</span><span class="enscript-comment">//     TXT records, and that record is marked as dependent on 'our', its SRV record).
</span><span class="enscript-comment">// 3. If we have some *other* RR that exactly matches the one from the packet, and that record and our record
</span><span class="enscript-comment">//    are members of the same RRSet, then this is not a conflict.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">PacketRRConflict</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> our, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> pktrr)
{
    <span class="enscript-comment">// If not supposed to be unique, not a conflict
</span>    <span class="enscript-keyword">if</span> (!(our-&gt;resrec.RecordType &amp; kDNSRecordTypeUniqueMask)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// If a dependent record, not a conflict
</span>    <span class="enscript-keyword">if</span> (our-&gt;DependentOn || MatchDependentOn(m, pktrr, our)) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// If the pktrr matches a member of ourset, not a conflict
</span>        <span class="enscript-type">const</span> AuthRecord *ourset = our-&gt;RRSet ? our-&gt;RRSet : our;
        <span class="enscript-type">const</span> AuthRecord *pktset = FindRRSet(m, pktrr);
        <span class="enscript-keyword">if</span> (pktset == ourset) <span class="enscript-keyword">return</span>(mDNSfalse);

        <span class="enscript-comment">// For records we're proxying, where we don't know the full
</span>        <span class="enscript-comment">// relationship between the records, having any matching record
</span>        <span class="enscript-comment">// in our AuthRecords list is sufficient evidence of non-conflict
</span>        <span class="enscript-keyword">if</span> (our-&gt;WakeUp.HMAC.l[0] &amp;&amp; pktset) <span class="enscript-keyword">return</span>(mDNSfalse);
    }

    <span class="enscript-comment">// Okay, this is a conflict
</span>    <span class="enscript-keyword">return</span>(mDNStrue);
}

<span class="enscript-comment">// Note: ResolveSimultaneousProbe calls mDNS_Deregister_internal which can call a user callback, which may change
</span><span class="enscript-comment">// the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ResolveSimultaneousProbe</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> query, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                        DNSQuestion *q, AuthRecord *our)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateAuthorities(query, end);
    mDNSBool FoundUpdate = mDNSfalse;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; query-&gt;h.numAuthorities; i++)
    {
        ptr = GetLargeResourceRecord(m, query, ptr, end, q-&gt;InterfaceID, kDNSRecordTypePacketAuth, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; CacheRecordAnswersQuestion(&amp;m-&gt;rec.r, q))
        {
            FoundUpdate = mDNStrue;
            <span class="enscript-keyword">if</span> (PacketRRConflict(m, our, &amp;m-&gt;rec.r))
            {
                <span class="enscript-type">int</span> result          = (<span class="enscript-type">int</span>)our-&gt;resrec.rrclass - (<span class="enscript-type">int</span>)m-&gt;rec.r.resrec.rrclass;
                <span class="enscript-keyword">if</span> (!result) result = (<span class="enscript-type">int</span>)our-&gt;resrec.rrtype  - (<span class="enscript-type">int</span>)m-&gt;rec.r.resrec.rrtype;
                <span class="enscript-keyword">if</span> (!result) result = CompareRData(our, &amp;m-&gt;rec.r);
                <span class="enscript-keyword">if</span> (result)
                {
                    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> msg = (result &lt; 0) ? <span class="enscript-string">&quot;lost:&quot;</span> : (result &gt; 0) ? <span class="enscript-string">&quot;won: &quot;</span> : <span class="enscript-string">&quot;tie: &quot;</span>;
                    LogMsg(<span class="enscript-string">&quot;ResolveSimultaneousProbe: %p Pkt Record:        %08lX %s&quot;</span>, q-&gt;InterfaceID, m-&gt;rec.r.resrec.rdatahash, CRDisplayString(m, &amp;m-&gt;rec.r));
                    LogMsg(<span class="enscript-string">&quot;ResolveSimultaneousProbe: %p Our Record %d %s %08lX %s&quot;</span>, our-&gt;resrec.InterfaceID, our-&gt;ProbeCount, msg, our-&gt;resrec.rdatahash, ARDisplayString(m, our));
                }
                <span class="enscript-comment">// If we lost the tie-break for simultaneous probes, we don't immediately give up, because we might be seeing stale packets on the network.
</span>                <span class="enscript-comment">// Instead we pause for one second, to give the other host (if real) a chance to establish its name, and then try probing again.
</span>                <span class="enscript-comment">// If there really is another live host out there with the same name, it will answer our probes and we'll then rename.
</span>                <span class="enscript-keyword">if</span> (result &lt; 0)
                {
                    m-&gt;SuppressProbes   = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond);
                    our-&gt;ProbeCount     = DefaultProbeCountForTypeUnique;
                    our-&gt;AnnounceCount  = InitialAnnounceCount;
                    InitializeLastAPTime(m, our);
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                }
            }
#<span class="enscript-reference">if</span> 0
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;ResolveSimultaneousProbe: %p Pkt Record:        %08lX %s&quot;</span>, q-&gt;InterfaceID, m-&gt;rec.r.resrec.rdatahash, CRDisplayString(m, &amp;m-&gt;rec.r));
                LogMsg(<span class="enscript-string">&quot;ResolveSimultaneousProbe: %p Our Record %d ign:  %08lX %s&quot;</span>, our-&gt;resrec.InterfaceID, our-&gt;ProbeCount, our-&gt;resrec.rdatahash, ARDisplayString(m, our));
            }
#<span class="enscript-reference">endif</span>
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }
    <span class="enscript-keyword">if</span> (!FoundUpdate)
        LogInfo(<span class="enscript-string">&quot;ResolveSimultaneousProbe: %##s (%s): No Update Record found&quot;</span>, our-&gt;resrec.name-&gt;c, DNSTypeName(our-&gt;resrec.rrtype));
<span class="enscript-reference">exit</span>:
    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>}

mDNSlocal CacheRecord *<span class="enscript-function-name">FindIdenticalRecordInCache</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> pktrr)
{
    CacheGroup *cg = CacheGroupForRecord(m, pktrr);
    CacheRecord *rr;
    mDNSBool match;
    <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!pktrr-&gt;InterfaceID)
        {
            <span class="enscript-type">const</span> mDNSu32 id1 = (pktrr-&gt;rDNSServer ? pktrr-&gt;rDNSServer-&gt;resGroupID : 0);
            <span class="enscript-type">const</span> mDNSu32 id2 = (rr-&gt;resrec.rDNSServer ? rr-&gt;resrec.rDNSServer-&gt;resGroupID : 0);
            match = (id1 == id2);
        }
        <span class="enscript-keyword">else</span> match = (pktrr-&gt;InterfaceID == rr-&gt;resrec.InterfaceID);

        <span class="enscript-keyword">if</span> (match &amp;&amp; IdenticalSameNameRecord(pktrr, &amp;rr-&gt;resrec)) <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>(rr);
}
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeregisterProxyRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    rr-&gt;WakeUp.HMAC    = zeroEthAddr; <span class="enscript-comment">// Clear HMAC so that mDNS_Deregister_internal doesn't waste packets trying to wake this host
</span>    rr-&gt;RequireGoodbye = mDNSfalse;   <span class="enscript-comment">// and we don't want to send goodbye for it
</span>    mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
    SetSPSProxyListChanged(m-&gt;rec.r.resrec.InterfaceID);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ClearKeepaliveProxyRecords</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> OwnerOptData *<span class="enscript-type">const</span> owner, AuthRecord *<span class="enscript-type">const</span> thelist, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;ClearKeepaliveProxyRecords ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = thelist;

    <span class="enscript-comment">// Normally, the RDATA of the keepalive record will be different each time and hence we always
</span>    <span class="enscript-comment">// clean up the keepalive record.
</span>    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (InterfaceID == rr-&gt;resrec.InterfaceID &amp;&amp; mDNSSameEthAddress(&amp;owner-&gt;HMAC, &amp;rr-&gt;WakeUp.HMAC))
        {
            <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;m-&gt;rec.r.resrec))
            {
                LogSPS(<span class="enscript-string">&quot;ClearKeepaliveProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s&quot;</span>,
                       m-&gt;ProxyRecords, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, rr-&gt;WakeUp.seq, owner-&gt;seq, ARDisplayString(m, rr));
                DeregisterProxyRecord(m, rr);
            }
        }
        <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>        <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

<span class="enscript-comment">// Called from mDNSCoreReceiveUpdate when we get a sleep proxy registration request,
</span><span class="enscript-comment">// to check our lists and discard any stale duplicates of this record we already have
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ClearIdenticalProxyRecords</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> OwnerOptData *<span class="enscript-type">const</span> owner, AuthRecord *<span class="enscript-type">const</span> thelist)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;ClearIdenticalProxyRecords ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = thelist;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.InterfaceID == rr-&gt;resrec.InterfaceID &amp;&amp; mDNSSameEthAddress(&amp;owner-&gt;HMAC, &amp;rr-&gt;WakeUp.HMAC))
            <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rr-&gt;resrec, &amp;m-&gt;rec.r.resrec))
            {
                LogSPS(<span class="enscript-string">&quot;ClearIdenticalProxyRecords: Removing %3d H-MAC %.6a I-MAC %.6a %d %d %s&quot;</span>,
                       m-&gt;ProxyRecords, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, rr-&gt;WakeUp.seq, owner-&gt;seq, ARDisplayString(m, rr));
                DeregisterProxyRecord(m, rr);
            }
        <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>        <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

<span class="enscript-comment">// Called from ProcessQuery when we get an mDNS packet with an owner record in it
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ClearProxyRecords</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> OwnerOptData *<span class="enscript-type">const</span> owner, AuthRecord *<span class="enscript-type">const</span> thelist)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;ClearProxyRecords ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = thelist;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.InterfaceID == rr-&gt;resrec.InterfaceID &amp;&amp; mDNSSameEthAddress(&amp;owner-&gt;HMAC, &amp;rr-&gt;WakeUp.HMAC))
            <span class="enscript-keyword">if</span> (owner-&gt;seq != rr-&gt;WakeUp.seq || m-&gt;timenow - rr-&gt;TimeRcvd &gt; mDNSPlatformOneSecond * 60)
            {
                <span class="enscript-keyword">if</span> (rr-&gt;AddressProxy.type == mDNSAddrType_IPv6)
                {
                    <span class="enscript-comment">// We don't do this here because we know that the host is waking up at this point, so we don't send
</span>                    <span class="enscript-comment">// Unsolicited Neighbor Advertisements -- even Neighbor Advertisements agreeing with what the host should be
</span>                    <span class="enscript-comment">// saying itself -- because it can cause some IPv6 stacks to falsely conclude that there's an address conflict.
</span>                    #<span class="enscript-keyword">if</span> MDNS_USE_Unsolicited_Neighbor_Advertisements
                    LogSPS(<span class="enscript-string">&quot;NDP Announcement -- Releasing traffic for H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                           &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m,rr));
                    SendNDP(m, NDP_Adv, NDP_Override, rr, &amp;rr-&gt;AddressProxy.ip.v6, &amp;rr-&gt;WakeUp.IMAC, &amp;AllHosts_v6, &amp;AllHosts_v6_Eth);
                    #endif
                }
                LogSPS(<span class="enscript-string">&quot;ClearProxyRecords: Removing %3d AC %2d %02X H-MAC %.6a I-MAC %.6a %d %d %s&quot;</span>,
                       m-&gt;ProxyRecords, rr-&gt;AnnounceCount, rr-&gt;resrec.RecordType,
                       &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, rr-&gt;WakeUp.seq, owner-&gt;seq, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) rr-&gt;resrec.RecordType = kDNSRecordTypeShared;
                rr-&gt;WakeUp.HMAC = zeroEthAddr;  <span class="enscript-comment">// Clear HMAC so that mDNS_Deregister_internal doesn't waste packets trying to wake this host
</span>                rr-&gt;RequireGoodbye = mDNSfalse; <span class="enscript-comment">// and we don't want to send goodbye for it, since real host is now back and functional
</span>                mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
                SetSPSProxyListChanged(m-&gt;rec.r.resrec.InterfaceID);
            }
        <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>        <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

<span class="enscript-comment">// ProcessQuery examines a received query to see if we have any answers to give
</span>mDNSlocal mDNSu8 *<span class="enscript-function-name">ProcessQuery</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> query, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                               <span class="enscript-type">const</span> mDNSAddr *srcaddr, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSBool LegacyQuery, mDNSBool QueryWasMulticast,
                               mDNSBool QueryWasLocalUnicast, DNSMessage *<span class="enscript-type">const</span> response)
{
    <span class="enscript-type">const</span> mDNSBool FromLocalSubnet   = mDNS_AddressIsLocalSubnet(m, InterfaceID, srcaddr);
    AuthRecord   *ResponseRecords    = mDNSNULL;
    AuthRecord  **nrp                = &amp;ResponseRecords;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">POOF_ENABLED</span>
    mDNSBool    notD2D = !mDNSPlatformInterfaceIsD2D(InterfaceID);  <span class="enscript-comment">// We don't run the POOF algorithm on D2D interfaces.
</span>    CacheRecord  *ExpectedAnswers    = mDNSNULL;            <span class="enscript-comment">// Records in our cache we expect to see updated
</span>    CacheRecord **eap                = &amp;ExpectedAnswers;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">POOF_ENABLED</span>

    DNSQuestion  *DupQuestions       = mDNSNULL;            <span class="enscript-comment">// Our questions that are identical to questions in this packet
</span>    DNSQuestion **dqp                = &amp;DupQuestions;
    mDNSs32 delayresponse      = 0;
    mDNSBool SendLegacyResponse = mDNSfalse;
    <span class="enscript-type">const</span> mDNSu8 *ptr;
    mDNSu8       *responseptr        = mDNSNULL;
    AuthRecord   *rr;
    <span class="enscript-type">int</span> i;
    CacheRecord *McastNSEC3Records   = mDNSNULL;

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 1. Look in Additional Section for an OPT record
</span>    <span class="enscript-comment">// ***
</span>    ptr = LocateOptRR(query, end, DNSOpt_OwnerData_ID_Space);
    <span class="enscript-keyword">if</span> (ptr)
    {
        ptr = GetLargeResourceRecord(m, query, ptr, end, InterfaceID, kDNSRecordTypePacketAdd, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_OPT)
        {
            <span class="enscript-type">const</span> rdataOPT *opt;
            <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> e = (<span class="enscript-type">const</span> rdataOPT *)&amp;m-&gt;rec.r.resrec.rdata-&gt;u.data[m-&gt;rec.r.resrec.rdlength];
            <span class="enscript-comment">// Find owner sub-option(s). We verify that the MAC is non-zero, otherwise we could inadvertently
</span>            <span class="enscript-comment">// delete all our own AuthRecords (which are identified by having zero MAC tags on them).
</span>            <span class="enscript-keyword">for</span> (opt = &amp;m-&gt;rec.r.resrec.rdata-&gt;u.opt[0]; opt &lt; e; opt++)
                <span class="enscript-keyword">if</span> (opt-&gt;opt == kDNSOpt_Owner &amp;&amp; opt-&gt;u.owner.vers == 0 &amp;&amp; opt-&gt;u.owner.HMAC.l[0])
                {
                    ClearProxyRecords(m, &amp;opt-&gt;u.owner, m-&gt;DuplicateRecords);
                    ClearProxyRecords(m, &amp;opt-&gt;u.owner, m-&gt;ResourceRecords);
                }
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Look in Authority Section for NSEC3 record
</span>    <span class="enscript-comment">//
</span>
    mDNSParseNSEC3Records(m, query, end, InterfaceID, &amp;McastNSEC3Records);

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 2. Parse Question Section and mark potential answers
</span>    <span class="enscript-comment">// ***
</span>    ptr = query-&gt;data;
    <span class="enscript-keyword">for</span> (i=0; i&lt;query-&gt;h.numQuestions; i++)                     <span class="enscript-comment">// For each question...
</span>    {
        mDNSBool QuestionNeedsMulticastResponse;
        <span class="enscript-type">int</span> NumAnswersForThisQuestion = 0;
        AuthRecord *NSECAnswer = mDNSNULL;
        DNSQuestion pktq, *q;
        ptr = getQuestion(query, ptr, end, InterfaceID, &amp;pktq); <span class="enscript-comment">// get the question...
</span>        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

        <span class="enscript-comment">// The only queries that *need* a multicast response are:
</span>        <span class="enscript-comment">// * Queries sent via multicast
</span>        <span class="enscript-comment">// * from port 5353
</span>        <span class="enscript-comment">// * that don't have the kDNSQClass_UnicastResponse bit set
</span>        <span class="enscript-comment">// These queries need multicast responses because other clients will:
</span>        <span class="enscript-comment">// * suppress their own identical questions when they see these questions, and
</span>        <span class="enscript-comment">// * expire their cache records if they don't see the expected responses
</span>        <span class="enscript-comment">// For other queries, we may still choose to send the occasional multicast response anyway,
</span>        <span class="enscript-comment">// to keep our neighbours caches warm, and for ongoing conflict detection.
</span>        QuestionNeedsMulticastResponse = QueryWasMulticast &amp;&amp; !LegacyQuery &amp;&amp; !(pktq.qclass &amp; kDNSQClass_UnicastResponse);

        <span class="enscript-keyword">if</span> (pktq.qclass &amp; kDNSQClass_UnicastResponse)
            m-&gt;mDNSStats.UnicastBitInQueries++;
        <span class="enscript-keyword">else</span>
            m-&gt;mDNSStats.NormalQueries++;

        <span class="enscript-comment">// Clear the UnicastResponse flag -- don't want to confuse the rest of the code that follows later
</span>        pktq.qclass &amp;= ~kDNSQClass_UnicastResponse;

        <span class="enscript-comment">// Note: We use the m-&gt;CurrentRecord mechanism here because calling ResolveSimultaneousProbe
</span>        <span class="enscript-comment">// can result in user callbacks which may change the record list and/or question list.
</span>        <span class="enscript-comment">// Also note: we just mark potential answer records here, without trying to build the
</span>        <span class="enscript-comment">// &quot;ResponseRecords&quot; list, because we don't want to risk user callbacks deleting records
</span>        <span class="enscript-comment">// from that list while we're in the middle of trying to build it.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
            LogMsg(<span class="enscript-string">&quot;ProcessQuery ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
        m-&gt;CurrentRecord = m-&gt;ResourceRecords;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
        {
            rr = m-&gt;CurrentRecord;
            m-&gt;CurrentRecord = rr-&gt;next;
            <span class="enscript-keyword">if</span> (AnyTypeRecordAnswersQuestion(rr, &amp;pktq) &amp;&amp; (QueryWasMulticast || QueryWasLocalUnicast || rr-&gt;AllowRemoteQuery))
            {
                m-&gt;mDNSStats.MatchingAnswersForQueries++;
                <span class="enscript-keyword">if</span> (RRTypeAnswersQuestionType(&amp;rr-&gt;resrec, pktq.qtype))
                {
                    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique)
                        ResolveSimultaneousProbe(m, query, end, &amp;pktq, rr);
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ResourceRecordIsValidAnswer(rr))
                    {
                        NumAnswersForThisQuestion++;

                        <span class="enscript-comment">// Note: We should check here if this is a probe-type query, and if so, generate an immediate
</span>                        <span class="enscript-comment">// unicast answer back to the source, because timeliness in answering probes is important.
</span>
                        <span class="enscript-comment">// Notes:
</span>                        <span class="enscript-comment">// NR_AnswerTo pointing into query packet means &quot;answer via immediate legacy unicast&quot; (may *also* choose to multicast)
</span>                        <span class="enscript-comment">// NR_AnswerTo == NR_AnswerUnicast   means &quot;answer via delayed unicast&quot; (to modern querier; may promote to multicast instead)
</span>                        <span class="enscript-comment">// NR_AnswerTo == NR_AnswerMulticast means &quot;definitely answer via multicast&quot; (can't downgrade to unicast later)
</span>                        <span class="enscript-comment">// If we're not multicasting this record because the kDNSQClass_UnicastResponse bit was set,
</span>                        <span class="enscript-comment">// but the multicast querier is not on a matching subnet (e.g. because of overlaid subnets on one link)
</span>                        <span class="enscript-comment">// then we'll multicast it anyway (if we unicast, the receiver will ignore it because it has an apparently non-local source)
</span>                        <span class="enscript-keyword">if</span> (QuestionNeedsMulticastResponse || (!FromLocalSubnet &amp;&amp; QueryWasMulticast &amp;&amp; !LegacyQuery))
                        {
                            <span class="enscript-comment">// We only mark this question for sending if it is at least one second since the last time we multicast it
</span>                            <span class="enscript-comment">// on this interface. If it is more than a second, or LastMCInterface is different, then we may multicast it.
</span>                            <span class="enscript-comment">// This is to guard against the case where someone blasts us with queries as fast as they can.
</span>                            <span class="enscript-keyword">if</span> ((mDNSu32)(m-&gt;timenow - rr-&gt;LastMCTime) &gt;= (mDNSu32)mDNSPlatformOneSecond ||
                                (rr-&gt;LastMCInterface != mDNSInterfaceMark &amp;&amp; rr-&gt;LastMCInterface != InterfaceID))
                                rr-&gt;NR_AnswerTo = NR_AnswerMulticast;
                        }
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!rr-&gt;NR_AnswerTo) rr-&gt;NR_AnswerTo = LegacyQuery ? ptr : NR_AnswerUnicast;
                    }
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rr-&gt;resrec.RecordType &amp; kDNSRecordTypeActiveUniqueMask) &amp;&amp; ResourceRecordIsValidAnswer(rr))
                {
                    <span class="enscript-comment">// If we don't have any answers for this question, but we do own another record with the same name,
</span>                    <span class="enscript-comment">// then we'll want to mark it to generate an NSEC record on this interface
</span>                    <span class="enscript-keyword">if</span> (!NSECAnswer) NSECAnswer = rr;
                }
            }
        }

        <span class="enscript-keyword">if</span> (NumAnswersForThisQuestion == 0 &amp;&amp; NSECAnswer)
        {
            NumAnswersForThisQuestion++;
            NSECAnswer-&gt;SendNSECNow = InterfaceID;
            m-&gt;NextScheduledResponse = m-&gt;timenow;
        }

        <span class="enscript-comment">// If we couldn't answer this question, someone else might be able to,
</span>        <span class="enscript-comment">// so use random delay on response to reduce collisions
</span>        <span class="enscript-keyword">if</span> (NumAnswersForThisQuestion == 0) delayresponse = mDNSPlatformOneSecond;  <span class="enscript-comment">// Divided by 50 = 20ms
</span>
        <span class="enscript-keyword">if</span> (query-&gt;h.flags.b[0] &amp; kDNSFlag0_TC)
            m-&gt;mDNSStats.KnownAnswerMultiplePkts++;
        <span class="enscript-comment">// We only do the following accelerated cache expiration and duplicate question suppression processing
</span>        <span class="enscript-comment">// for non-truncated multicast queries with multicast responses.
</span>        <span class="enscript-comment">// For any query generating a unicast response we don't do this because we can't assume we will see the response.
</span>        <span class="enscript-comment">// For truncated queries we don't do this because a response we're expecting might be suppressed by a subsequent
</span>        <span class="enscript-comment">// known-answer packet, and when there's packet loss we can't safely assume we'll receive *all* known-answer packets.
</span>        <span class="enscript-keyword">if</span> (QuestionNeedsMulticastResponse &amp;&amp; !(query-&gt;h.flags.b[0] &amp; kDNSFlag0_TC))
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">POOF_ENABLED</span>
            <span class="enscript-keyword">if</span> (notD2D)
            {
                CacheGroup *cg = CacheGroupForName(m, pktq.qnamehash, &amp;pktq.qname);
                CacheRecord *cr;
    
                <span class="enscript-comment">// Make a list indicating which of our own cache records we expect to see updated as a result of this query
</span>                <span class="enscript-comment">// Note: Records larger than 1K are not habitually multicast, so don't expect those to be updated
</span>                <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
                {
                    <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, &amp;pktq) &amp;&amp; cr-&gt;resrec.rdlength &lt;= SmallRecordLimit)
                    {
                        <span class="enscript-keyword">if</span> (!cr-&gt;NextInKAList &amp;&amp; eap != &amp;cr-&gt;NextInKAList)
                        {
                            *eap = cr;
                            eap = &amp;cr-&gt;NextInKAList;
                        }
                    }
                }
            }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">POOF_ENABLED</span>

            <span class="enscript-comment">// Check if this question is the same as any of mine.
</span>            <span class="enscript-comment">// We only do this for non-truncated queries. Right now it would be too complicated to try
</span>            <span class="enscript-comment">// to keep track of duplicate suppression state between multiple packets, especially when we
</span>            <span class="enscript-comment">// can't guarantee to receive all of the Known Answer packets that go with a particular query.
</span>            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
            {
                <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; m-&gt;timenow - q-&gt;LastQTxTime &gt; mDNSPlatformOneSecond / 4)
                {
                    <span class="enscript-keyword">if</span> (!q-&gt;InterfaceID || q-&gt;InterfaceID == InterfaceID)
                    {
                        <span class="enscript-keyword">if</span> (q-&gt;NextInDQList == mDNSNULL &amp;&amp; dqp != &amp;q-&gt;NextInDQList)
                        {
                            <span class="enscript-keyword">if</span> (q-&gt;qtype == pktq.qtype &amp;&amp;
                                q-&gt;qclass == pktq.qclass &amp;&amp;
                                q-&gt;qnamehash == pktq.qnamehash &amp;&amp; SameDomainName(&amp;q-&gt;qname, &amp;pktq.qname))
                            { *dqp = q; dqp = &amp;q-&gt;NextInDQList; }
                        }
                    }
                }
            }
        }
    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 3. Now we can safely build the list of marked answers
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)              <span class="enscript-comment">// Now build our list of potential answers
</span>        <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo)                                    <span class="enscript-comment">// If we marked the record...
</span>            AddRecordToResponseList(&amp;nrp, rr, mDNSNULL);        <span class="enscript-comment">// ... add it to the list
</span>
    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 4. Add additional records
</span>    <span class="enscript-comment">// ***
</span>    AddAdditionalsToResponseList(m, ResponseRecords, &amp;nrp, InterfaceID);

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 5. Parse Answer Section and cancel any records disallowed by Known-Answer list
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;query-&gt;h.numAnswers; i++)                       <span class="enscript-comment">// For each record in the query's answer section...
</span>    {
        <span class="enscript-comment">// Get the record...
</span>        CacheRecord *ourcacherr;
        ptr = GetLargeResourceRecord(m, query, ptr, end, InterfaceID, kDNSRecordTypePacketAns, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative)
        {
            <span class="enscript-comment">// See if this Known-Answer suppresses any of our currently planned answers
</span>            <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)
            {
                <span class="enscript-keyword">if</span> (MustSendRecord(rr) &amp;&amp; ShouldSuppressKnownAnswer(&amp;m-&gt;rec.r, rr))
                {
                    m-&gt;mDNSStats.KnownAnswerSuppressions++;
                    rr-&gt;NR_AnswerTo = mDNSNULL;
                    rr-&gt;NR_AdditionalTo = mDNSNULL;
                }
            }

            <span class="enscript-comment">// See if this Known-Answer suppresses any previously scheduled answers (for multi-packet KA suppression)
</span>            <span class="enscript-keyword">for</span> (rr=m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            {
                <span class="enscript-comment">// If we're planning to send this answer on this interface, and only on this interface, then allow KA suppression
</span>                <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer == InterfaceID &amp;&amp; ShouldSuppressKnownAnswer(&amp;m-&gt;rec.r, rr))
                {
                    <span class="enscript-keyword">if</span> (srcaddr-&gt;type == mDNSAddrType_IPv4)
                    {
                        <span class="enscript-keyword">if</span> (mDNSSameIPv4Address(rr-&gt;v4Requester, srcaddr-&gt;ip.v4)) rr-&gt;v4Requester = zerov4Addr;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (srcaddr-&gt;type == mDNSAddrType_IPv6)
                    {
                        <span class="enscript-keyword">if</span> (mDNSSameIPv6Address(rr-&gt;v6Requester, srcaddr-&gt;ip.v6)) rr-&gt;v6Requester = zerov6Addr;
                    }
                    <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(rr-&gt;v4Requester) &amp;&amp; mDNSIPv6AddressIsZero(rr-&gt;v6Requester))
                    {
                        m-&gt;mDNSStats.KnownAnswerSuppressions++;
                        rr-&gt;ImmedAnswer  = mDNSNULL;
                        rr-&gt;ImmedUnicast = mDNSfalse;
    #<span class="enscript-keyword">if</span> MDNS_LOG_ANSWER_SUPPRESSION_TIMES
                        LogMsg(<span class="enscript-string">&quot;Suppressed after%4d: %s&quot;</span>, m-&gt;timenow - rr-&gt;ImmedAnswerMarkTime, ARDisplayString(m, rr));
    #endif
                    }
                }
            }

            ourcacherr = FindIdenticalRecordInCache(m, &amp;m-&gt;rec.r.resrec);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">POOF_ENABLED</span>
            <span class="enscript-keyword">if</span> (notD2D)
            {
                <span class="enscript-comment">// Having built our ExpectedAnswers list from the questions in this packet, we then remove
</span>                <span class="enscript-comment">// any records that are suppressed by the Known Answer list in this packet.
</span>                eap = &amp;ExpectedAnswers;
                <span class="enscript-keyword">while</span> (*eap)
                {
                    CacheRecord *cr = *eap;
                    <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; IdenticalResourceRecord(&amp;m-&gt;rec.r.resrec, &amp;cr-&gt;resrec))
                    { *eap = cr-&gt;NextInKAList; cr-&gt;NextInKAList = mDNSNULL; }
                    <span class="enscript-keyword">else</span> eap = &amp;cr-&gt;NextInKAList;
                }
            }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">POOF_ENABLED</span>

            <span class="enscript-comment">// See if this Known-Answer is a surprise to us. If so, we shouldn't suppress our own query.
</span>            <span class="enscript-keyword">if</span> (!ourcacherr)
            {
                dqp = &amp;DupQuestions;
                <span class="enscript-keyword">while</span> (*dqp)
                {
                    DNSQuestion *q = *dqp;
                    <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(&amp;m-&gt;rec.r, q))
                    { *dqp = q-&gt;NextInDQList; q-&gt;NextInDQList = mDNSNULL; }
                    <span class="enscript-keyword">else</span> dqp = &amp;q-&gt;NextInDQList;
                }
            }
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 6. Cancel any additionals that were added because of now-deleted records
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)
        <span class="enscript-keyword">if</span> (rr-&gt;NR_AdditionalTo &amp;&amp; !MustSendRecord(rr-&gt;NR_AdditionalTo))
        { rr-&gt;NR_AnswerTo = mDNSNULL; rr-&gt;NR_AdditionalTo = mDNSNULL; }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 7. Mark the send flags on the records we plan to send
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">for</span> (rr=ResponseRecords; rr; rr=rr-&gt;NextResponse)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo)
        {
            mDNSBool SendMulticastResponse = mDNSfalse;     <span class="enscript-comment">// Send modern multicast response
</span>            mDNSBool SendUnicastResponse   = mDNSfalse;     <span class="enscript-comment">// Send modern unicast response (not legacy unicast response)
</span>
            <span class="enscript-comment">// If it's been one TTL/4 since we multicast this, then send a multicast response 
</span>            <span class="enscript-comment">// for conflict detection, etc.
</span>            <span class="enscript-keyword">if</span> ((mDNSu32)(m-&gt;timenow - rr-&gt;LastMCTime) &gt;= (mDNSu32)TicksTTL(rr)/4)
            {
                SendMulticastResponse = mDNStrue;
                <span class="enscript-comment">// If this record was marked for modern (delayed) unicast response, then mark it as promoted to
</span>                <span class="enscript-comment">// multicast response instead (don't want to end up ALSO setting SendUnicastResponse in the check below).
</span>                <span class="enscript-comment">// If this record was marked for legacy unicast response, then we mustn't change the NR_AnswerTo value.
</span>                <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo == NR_AnswerUnicast)
                {
                    m-&gt;mDNSStats.UnicastDemotedToMulticast++;
                    rr-&gt;NR_AnswerTo = NR_AnswerMulticast;
                }
            }

            <span class="enscript-comment">// If the client insists on a multicast response, then we'd better send one
</span>            <span class="enscript-keyword">if</span>      (rr-&gt;NR_AnswerTo == NR_AnswerMulticast)
            {
                m-&gt;mDNSStats.MulticastResponses++;
                SendMulticastResponse = mDNStrue;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo == NR_AnswerUnicast)
            {
                m-&gt;mDNSStats.UnicastResponses++;
                SendUnicastResponse   = mDNStrue;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;NR_AnswerTo)
            {
                SendLegacyResponse    = mDNStrue;
            }

            <span class="enscript-keyword">if</span> (SendMulticastResponse || SendUnicastResponse)
            {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_LOG_ANSWER_SUPPRESSION_TIMES</span>
                rr-&gt;ImmedAnswerMarkTime = m-&gt;timenow;
#<span class="enscript-reference">endif</span>
                m-&gt;NextScheduledResponse = m-&gt;timenow;
                <span class="enscript-comment">// If we're already planning to send this on another interface, just send it on all interfaces
</span>                <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer &amp;&amp; rr-&gt;ImmedAnswer != InterfaceID)
                    rr-&gt;ImmedAnswer = mDNSInterfaceMark;
                <span class="enscript-keyword">else</span>
                {
                    rr-&gt;ImmedAnswer = InterfaceID;          <span class="enscript-comment">// Record interface to send it on
</span>                    <span class="enscript-keyword">if</span> (SendUnicastResponse) rr-&gt;ImmedUnicast = mDNStrue;
                    <span class="enscript-keyword">if</span> (srcaddr-&gt;type == mDNSAddrType_IPv4)
                    {
                        <span class="enscript-keyword">if</span>      (mDNSIPv4AddressIsZero(rr-&gt;v4Requester)) rr-&gt;v4Requester = srcaddr-&gt;ip.v4;
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(rr-&gt;v4Requester, srcaddr-&gt;ip.v4)) rr-&gt;v4Requester = onesIPv4Addr;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (srcaddr-&gt;type == mDNSAddrType_IPv6)
                    {
                        <span class="enscript-keyword">if</span>      (mDNSIPv6AddressIsZero(rr-&gt;v6Requester)) rr-&gt;v6Requester = srcaddr-&gt;ip.v6;
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!mDNSSameIPv6Address(rr-&gt;v6Requester, srcaddr-&gt;ip.v6)) rr-&gt;v6Requester = onesIPv6Addr;
                    }
                }
            }
            <span class="enscript-comment">// If TC flag is set, it means we should expect that additional known answers may be coming in another packet,
</span>            <span class="enscript-comment">// so we allow roughly half a second before deciding to reply (we've observed inter-packet delays of 100-200ms on 802.11)
</span>            <span class="enscript-comment">// else, if record is a shared one, spread responses over 100ms to avoid implosion of simultaneous responses
</span>            <span class="enscript-comment">// else, for a simple unique record reply, we can reply immediately; no need for delay
</span>            <span class="enscript-keyword">if</span>      (query-&gt;h.flags.b[0] &amp; kDNSFlag0_TC) delayresponse = mDNSPlatformOneSecond * 20;            <span class="enscript-comment">// Divided by 50 = 400ms
</span>            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeShared) delayresponse = mDNSPlatformOneSecond;      <span class="enscript-comment">// Divided by 50 = 20ms
</span>        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;NR_AdditionalTo &amp;&amp; rr-&gt;NR_AdditionalTo-&gt;NR_AnswerTo == NR_AnswerMulticast)
        {
            <span class="enscript-comment">// Since additional records are an optimization anyway, we only ever send them on one interface at a time
</span>            <span class="enscript-comment">// If two clients on different interfaces do queries that invoke the same optional additional answer,
</span>            <span class="enscript-comment">// then the earlier client is out of luck
</span>            rr-&gt;ImmedAdditional = InterfaceID;
            <span class="enscript-comment">// No need to set m-&gt;NextScheduledResponse here
</span>            <span class="enscript-comment">// We'll send these additional records when we send them, or not, as the case may be
</span>        }
    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 8. If we think other machines are likely to answer these questions, set our packet suppression timer
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">if</span> (delayresponse &amp;&amp; (!m-&gt;SuppressSending || (m-&gt;SuppressSending - m-&gt;timenow) &lt; (delayresponse + 49) / 50))
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_LOG_ANSWER_SUPPRESSION_TIMES</span>
        mDNSs32 oldss = m-&gt;SuppressSending;
        <span class="enscript-keyword">if</span> (oldss &amp;&amp; delayresponse)
            LogMsg(<span class="enscript-string">&quot;Current SuppressSending delay%5ld; require%5ld&quot;</span>, m-&gt;SuppressSending - m-&gt;timenow, (delayresponse + 49) / 50);
#<span class="enscript-reference">endif</span>
        <span class="enscript-comment">// Pick a random delay:
</span>        <span class="enscript-comment">// We start with the base delay chosen above (typically either 1 second or 20 seconds),
</span>        <span class="enscript-comment">// and add a random value in the range 0-5 seconds (making 1-6 seconds or 20-25 seconds).
</span>        <span class="enscript-comment">// This is an integer value, with resolution determined by the platform clock rate.
</span>        <span class="enscript-comment">// We then divide that by 50 to get the delay value in ticks. We defer the division until last
</span>        <span class="enscript-comment">// to get better results on platforms with coarse clock granularity (e.g. ten ticks per second).
</span>        <span class="enscript-comment">// The +49 before dividing is to ensure we round up, not down, to ensure that even
</span>        <span class="enscript-comment">// on platforms where the native clock rate is less than fifty ticks per second,
</span>        <span class="enscript-comment">// we still guarantee that the final calculated delay is at least one platform tick.
</span>        <span class="enscript-comment">// We want to make sure we don't ever allow the delay to be zero ticks,
</span>        <span class="enscript-comment">// because if that happens we'll fail the Bonjour Conformance Test.
</span>        <span class="enscript-comment">// Our final computed delay is 20-120ms for normal delayed replies,
</span>        <span class="enscript-comment">// or 400-500ms in the case of multi-packet known-answer lists.
</span>        m-&gt;SuppressSending = m-&gt;timenow + (delayresponse + (mDNSs32)mDNSRandom((mDNSu32)mDNSPlatformOneSecond*5) + 49) / 50;
        <span class="enscript-keyword">if</span> (m-&gt;SuppressSending == 0) m-&gt;SuppressSending = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_LOG_ANSWER_SUPPRESSION_TIMES</span>
        <span class="enscript-keyword">if</span> (oldss &amp;&amp; delayresponse)
            LogMsg(<span class="enscript-string">&quot;Set     SuppressSending to   %5ld&quot;</span>, m-&gt;SuppressSending - m-&gt;timenow);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 9. If query is from a legacy client, or from a new client requesting a unicast reply, then generate a unicast response too
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">if</span> (SendLegacyResponse)
        responseptr = GenerateUnicastResponse(query, end, InterfaceID, LegacyQuery, response, ResponseRecords);

<span class="enscript-reference">exit</span>:
    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>
    <span class="enscript-comment">// ***
</span>    <span class="enscript-comment">// *** 10. Finally, clear our link chains ready for use next time
</span>    <span class="enscript-comment">// ***
</span>    <span class="enscript-keyword">while</span> (ResponseRecords)
    {
        rr = ResponseRecords;
        ResponseRecords = rr-&gt;NextResponse;
        rr-&gt;NextResponse    = mDNSNULL;
        rr-&gt;NR_AnswerTo     = mDNSNULL;
        rr-&gt;NR_AdditionalTo = mDNSNULL;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">POOF_ENABLED</span>
    <span class="enscript-keyword">while</span> (ExpectedAnswers &amp;&amp; notD2D)
    {
        CacheRecord *cr = ExpectedAnswers;
        ExpectedAnswers = cr-&gt;NextInKAList;
        cr-&gt;NextInKAList = mDNSNULL;

        <span class="enscript-comment">// For non-truncated queries, we can definitively say that we should expect
</span>        <span class="enscript-comment">// to be seeing a response for any records still left in the ExpectedAnswers list
</span>        <span class="enscript-keyword">if</span> (!(query-&gt;h.flags.b[0] &amp; kDNSFlag0_TC))
            <span class="enscript-keyword">if</span> (cr-&gt;UnansweredQueries == 0 || m-&gt;timenow - cr-&gt;LastUnansweredTime &gt;= mDNSPlatformOneSecond * 3/4)
            {
                cr-&gt;UnansweredQueries++;
                cr-&gt;LastUnansweredTime = m-&gt;timenow;
                <span class="enscript-keyword">if</span> (cr-&gt;UnansweredQueries &gt; 1)
                        debugf(<span class="enscript-string">&quot;ProcessQuery: UnansweredQueries %lu %s&quot;</span>, cr-&gt;UnansweredQueries, CRDisplayString(m, cr));
                SetNextCacheCheckTimeForRecord(m, cr);
            }

        <span class="enscript-comment">// If we've seen multiple unanswered queries for this record,
</span>        <span class="enscript-comment">// then mark it to expire in five seconds if we don't get a response by then.
</span>        <span class="enscript-keyword">if</span> (cr-&gt;UnansweredQueries &gt;= MaxUnansweredQueries)
        {
            <span class="enscript-comment">// Only show debugging message if this record was not about to expire anyway
</span>            <span class="enscript-keyword">if</span> (RRExpireTime(cr) - m-&gt;timenow &gt; (mDNSs32) kDefaultReconfirmTimeForNoAnswer * 4 / 3 + mDNSPlatformOneSecond)
                    LogInfo(<span class="enscript-string">&quot;ProcessQuery: UnansweredQueries %lu interface %lu TTL %lu mDNS_Reconfirm() for %s&quot;</span>,
                       cr-&gt;UnansweredQueries, InterfaceID, (RRExpireTime(cr) - m-&gt;timenow + mDNSPlatformOneSecond-1) / mDNSPlatformOneSecond, CRDisplayString(m, cr));

            m-&gt;mDNSStats.PoofCacheDeletions++;
            mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForNoAnswer);
        }
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">POOF_ENABLED</span>

    <span class="enscript-keyword">while</span> (DupQuestions)
    {
        DNSQuestion *q = DupQuestions;
        DupQuestions = q-&gt;NextInDQList;
        q-&gt;NextInDQList = mDNSNULL;
        RecordDupSuppressInfo(q-&gt;DupSuppress, m-&gt;timenow, InterfaceID, srcaddr-&gt;type);
        debugf(<span class="enscript-string">&quot;ProcessQuery: Recorded DSI for %##s (%s) on %p/%s&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), InterfaceID,
               srcaddr-&gt;type == mDNSAddrType_IPv4 ? <span class="enscript-string">&quot;v4&quot;</span> : <span class="enscript-string">&quot;v6&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (McastNSEC3Records)
    {
        debugf(<span class="enscript-string">&quot;ProcessQuery: McastNSEC3Records not used&quot;</span>);
        FreeNSECRecords(m, McastNSEC3Records);
    }

    <span class="enscript-keyword">return</span>(responseptr);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveQuery</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                    <span class="enscript-type">const</span> mDNSAddr *srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *dstaddr, mDNSIPPort dstport,
                                    <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    mDNSu8    *responseend = mDNSNULL;
    mDNSBool QueryWasLocalUnicast = srcaddr &amp;&amp; dstaddr &amp;&amp;
                                    !mDNSAddrIsDNSMulticast(dstaddr) &amp;&amp; mDNS_AddressIsLocalSubnet(m, InterfaceID, srcaddr);

    <span class="enscript-keyword">if</span> (!dstaddr || (!InterfaceID &amp;&amp; mDNSAddrIsDNSMulticast(dstaddr)))
    {
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> reason = !dstaddr ? <span class="enscript-string">&quot;Received over TCP connection&quot;</span> : <span class="enscript-string">&quot;Multicast, but no InterfaceID&quot;</span>;
        LogMsg(<span class="enscript-string">&quot;Ignoring Query from %#-15a:%-5d to %#-15a:%-5d on 0x%p with &quot;</span>
               <span class="enscript-string">&quot;%2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes (%s)&quot;</span>,
               srcaddr, mDNSVal16(srcport), dstaddr, mDNSVal16(dstport), InterfaceID,
               msg-&gt;h.numQuestions,   msg-&gt;h.numQuestions   == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
               msg-&gt;h.numAnswers,     msg-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
               msg-&gt;h.numAuthorities, msg-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
               msg-&gt;h.numAdditionals, msg-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot; &quot;</span>    : <span class="enscript-string">&quot;s&quot;</span>, end - msg-&gt;data, reason);
        <span class="enscript-keyword">return</span>;
    }

    verbosedebugf(<span class="enscript-string">&quot;Received Query from %#-15a:%-5d to %#-15a:%-5d on 0x%p with &quot;</span>
                  <span class="enscript-string">&quot;%2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes&quot;</span>,
                  srcaddr, mDNSVal16(srcport), dstaddr, mDNSVal16(dstport), InterfaceID,
                  msg-&gt;h.numQuestions,   msg-&gt;h.numQuestions   == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
                  msg-&gt;h.numAnswers,     msg-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
                  msg-&gt;h.numAuthorities, msg-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
                  msg-&gt;h.numAdditionals, msg-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot; &quot;</span>    : <span class="enscript-string">&quot;s&quot;</span>, end - msg-&gt;data);

    responseend = ProcessQuery(m, msg, end, srcaddr, InterfaceID,
                               !mDNSSameIPPort(srcport, MulticastDNSPort), mDNSAddrIsDNSMulticast(dstaddr), QueryWasLocalUnicast, &amp;m-&gt;omsg);

    <span class="enscript-keyword">if</span> (responseend)    <span class="enscript-comment">// If responseend is non-null, that means we built a unicast response packet
</span>    {
        debugf(<span class="enscript-string">&quot;Unicast Response: %d Question%s, %d Answer%s, %d Additional%s to %#-15a:%d on %p/%ld&quot;</span>,
               m-&gt;omsg.h.numQuestions,   m-&gt;omsg.h.numQuestions   == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
               m-&gt;omsg.h.numAnswers,     m-&gt;omsg.h.numAnswers     == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
               m-&gt;omsg.h.numAdditionals, m-&gt;omsg.h.numAdditionals == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>,
               srcaddr, mDNSVal16(srcport), InterfaceID, srcaddr-&gt;type);
        mDNSSendDNSMessage(m, &amp;m-&gt;omsg, responseend, InterfaceID, mDNSNULL, mDNSNULL, srcaddr, srcport, mDNSNULL, mDNSfalse);
    }
}

#<span class="enscript-reference">if</span> 0
mDNSlocal mDNSBool <span class="enscript-function-name">TrustedSource</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr)
{
    DNSServer *s;
    (<span class="enscript-type">void</span>)m; <span class="enscript-comment">// Unused
</span>    (<span class="enscript-type">void</span>)srcaddr; <span class="enscript-comment">// Unused
</span>    <span class="enscript-keyword">for</span> (s = m-&gt;DNSServers; s; s = s-&gt;next)
        <span class="enscript-keyword">if</span> (mDNSSameAddress(srcaddr, &amp;s-&gt;addr)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">return</span>(mDNSfalse);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> UDPSocket_struct
{
    mDNSIPPort port; <span class="enscript-comment">// MUST BE FIRST FIELD -- mDNSCoreReceive expects every UDPSocket_struct to begin with mDNSIPPort port
</span>};

mDNSlocal DNSQuestion *<span class="enscript-function-name">ExpectingUnicastResponseForQuestion</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSIPPort port, <span class="enscript-type">const</span> mDNSOpaque16 id, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> question, mDNSBool tcp, DNSQuestion ** suspiciousQ)
{
    DNSQuestion *q;
    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!tcp &amp;&amp; !q-&gt;LocalSocket) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (mDNSSameIPPort(tcp ? q-&gt;tcpSrcPort : q-&gt;LocalSocket-&gt;port, port)       &amp;&amp;
            q-&gt;qtype                  == question-&gt;qtype     &amp;&amp;
            q-&gt;qclass                 == question-&gt;qclass    &amp;&amp;
            q-&gt;qnamehash              == question-&gt;qnamehash &amp;&amp;
            SameDomainName(&amp;q-&gt;qname, &amp;question-&gt;qname))
        {
            <span class="enscript-keyword">if</span> (mDNSSameOpaque16(q-&gt;TargetQID, id)) <span class="enscript-keyword">return</span>(q);
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Everything but the QIDs match up, should we be suspicious?
</span>                <span class="enscript-keyword">if</span> (!tcp &amp;&amp; suspiciousQ)
                {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
                    <span class="enscript-keyword">if</span> (mDNSSameOpaque16(q-&gt;LastTargetQID, id)) <span class="enscript-comment">// Only be suspicious if this is also not the &quot;last&quot; used QID (on a DNS server set change)
</span>                    {
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR, <span class="enscript-string">&quot;Ignored but not suspicious LastTargetQID %d TargetQID %d&quot;</span>, mDNSVal16(q-&gt;LastTargetQID), mDNSVal16(q-&gt;TargetQID));
                    }
                    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
                    *suspiciousQ = q;
                }
                <span class="enscript-keyword">return</span>(mDNSNULL);
            }
        }
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// This function is called when we receive a unicast response. This could be the case of a unicast response from the
</span><span class="enscript-comment">// DNS server or a response to the QU query. Hence, the cache record's InterfaceId can be both NULL or non-NULL (QU case)
</span>mDNSlocal DNSQuestion *<span class="enscript-function-name">ExpectingUnicastResponseForRecord</span>(mDNS *<span class="enscript-type">const</span> m,
                                                         <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSBool SrcLocal, <span class="enscript-type">const</span> mDNSIPPort port, <span class="enscript-type">const</span> mDNSOpaque16 id, <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> rr, mDNSBool tcp)
{
    DNSQuestion *q;
    (<span class="enscript-type">void</span>)id;

    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!q-&gt;DuplicateOf &amp;&amp; ResourceRecordAnswersUnicastResponse(&amp;rr-&gt;resrec, q))
        {
            <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID))
            {
                debugf(<span class="enscript-string">&quot;ExpectingUnicastResponseForRecord msg-&gt;h.id %d q-&gt;TargetQID %d for %s&quot;</span>, mDNSVal16(id), mDNSVal16(q-&gt;TargetQID), CRDisplayString(m, rr));

                <span class="enscript-keyword">if</span> (mDNSSameOpaque16(q-&gt;TargetQID, id))
                {
                    mDNSIPPort srcp;
                    <span class="enscript-keyword">if</span> (!tcp)
                    {
                        srcp = q-&gt;LocalSocket ? q-&gt;LocalSocket-&gt;port : zeroIPPort;
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        srcp = q-&gt;tcpSrcPort;
                    }
                    <span class="enscript-keyword">if</span> (mDNSSameIPPort(srcp, port)) <span class="enscript-keyword">return</span>(q);

                    <span class="enscript-comment">//  if (mDNSSameAddress(srcaddr, &amp;q-&gt;Target))                   return(mDNStrue);
</span>                    <span class="enscript-comment">//  if (q-&gt;LongLived &amp;&amp; mDNSSameAddress(srcaddr, &amp;q-&gt;servAddr)) return(mDNStrue); Shouldn't need this now that we have LLQType checking
</span>                    <span class="enscript-comment">//  if (TrustedSource(m, srcaddr))                              return(mDNStrue);
</span>                    LogInfo(<span class="enscript-string">&quot;WARNING: Ignoring suspect uDNS response for %##s (%s) from %#a:%d %s&quot;</span>,
                            q-&gt;qname.c, DNSTypeName(q-&gt;qtype), srcaddr, mDNSVal16(port), CRDisplayString(m, rr));
                    <span class="enscript-keyword">return</span>(mDNSNULL);
                }
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (SrcLocal &amp;&amp; q-&gt;ExpectUnicastResp &amp;&amp; (mDNSu32)(m-&gt;timenow - q-&gt;ExpectUnicastResp) &lt; (mDNSu32)(mDNSPlatformOneSecond*2))
                    <span class="enscript-keyword">return</span>(q);
            }
        }
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// Certain data types need more space for in-memory storage than their in-packet rdlength would imply
</span><span class="enscript-comment">// Currently this applies only to rdata types containing more than one domainname,
</span><span class="enscript-comment">// or types where the domainname is not the last item in the structure.
</span>mDNSlocal mDNSu16 <span class="enscript-function-name">GetRDLengthMem</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-keyword">switch</span> (rr-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>: <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(rdataSOA);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:  <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(rdataRP);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:  <span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(rdataPX);
    <span class="enscript-reference">default</span>:           <span class="enscript-keyword">return</span> rr-&gt;rdlength;
    }
}

mDNSexport CacheRecord *<span class="enscript-function-name">CreateNewCacheEntry</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, CacheGroup *cg, mDNSs32 delay, mDNSBool Add, <span class="enscript-type">const</span> mDNSAddr *sourceAddress)
{
    CacheRecord *rr = mDNSNULL;
    mDNSu16 RDLength = GetRDLengthMem(&amp;m-&gt;rec.r.resrec);

    <span class="enscript-keyword">if</span> (!m-&gt;rec.r.resrec.InterfaceID) debugf(<span class="enscript-string">&quot;CreateNewCacheEntry %s&quot;</span>, CRDisplayString(m, &amp;m-&gt;rec.r));

    <span class="enscript-comment">//if (RDLength &gt; InlineCacheRDSize)
</span>    <span class="enscript-comment">//  LogInfo(&quot;Rdata len %4d &gt; InlineCacheRDSize %d %s&quot;, RDLength, InlineCacheRDSize, CRDisplayString(m, &amp;m-&gt;rec.r));
</span>
    <span class="enscript-keyword">if</span> (!cg) cg = GetCacheGroup(m, slot, &amp;m-&gt;rec.r.resrec); <span class="enscript-comment">// If we don't have a CacheGroup for this name, make one now
</span>    <span class="enscript-keyword">if</span> (cg) rr = GetCacheRecord(m, cg, RDLength);   <span class="enscript-comment">// Make a cache record, being careful not to recycle cg
</span>    <span class="enscript-keyword">if</span> (!rr) NoCacheAnswer(m, &amp;m-&gt;rec.r);
    <span class="enscript-keyword">else</span>
    {
        RData *saveptr         = rr-&gt;resrec.rdata;   <span class="enscript-comment">// Save the rr-&gt;resrec.rdata pointer
</span>        *rr                    = m-&gt;rec.r;           <span class="enscript-comment">// Block copy the CacheRecord object
</span>        rr-&gt;resrec.rdata       = saveptr;            <span class="enscript-comment">// Restore rr-&gt;resrec.rdata after the structure assignment
</span>        rr-&gt;resrec.name        = cg-&gt;name;           <span class="enscript-comment">// And set rr-&gt;resrec.name to point into our CacheGroup header
</span>        rr-&gt;resrec.mortality   = Mortality_Mortal;

        rr-&gt;DelayDelivery = delay;

        <span class="enscript-comment">// If this is an oversized record with external storage allocated, copy rdata to external storage
</span>        <span class="enscript-keyword">if</span>      (rr-&gt;resrec.rdata == (RData*)&amp;rr-&gt;smallrdatastorage &amp;&amp; RDLength &gt; InlineCacheRDSize)
            LogMsg(<span class="enscript-string">&quot;rr-&gt;resrec.rdata == &amp;rr-&gt;rdatastorage but length &gt; InlineCacheRDSize %##s&quot;</span>, m-&gt;rec.r.resrec.name-&gt;c);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdata != (RData*)&amp;rr-&gt;smallrdatastorage &amp;&amp; RDLength &lt;= InlineCacheRDSize)
            LogMsg(<span class="enscript-string">&quot;rr-&gt;resrec.rdata != &amp;rr-&gt;rdatastorage but length &lt;= InlineCacheRDSize %##s&quot;</span>, m-&gt;rec.r.resrec.name-&gt;c);
        <span class="enscript-keyword">if</span> (RDLength &gt; InlineCacheRDSize)
            mDNSPlatformMemCopy(rr-&gt;resrec.rdata, m-&gt;rec.r.resrec.rdata, sizeofRDataHeader + RDLength);

        rr-&gt;next = mDNSNULL;                    <span class="enscript-comment">// Clear 'next' pointer
</span>        rr-&gt;nsec = mDNSNULL;
        rr-&gt;soa  = mDNSNULL;

        <span class="enscript-keyword">if</span> (sourceAddress)
            rr-&gt;sourceAddress = *sourceAddress;

        <span class="enscript-keyword">if</span> (!rr-&gt;resrec.InterfaceID)
        {
            m-&gt;rrcache_totalused_unicast += rr-&gt;resrec.rdlength;
            <span class="enscript-keyword">if</span> (DNSSECRecordType(rr-&gt;resrec.rrtype))
                BumpDNSSECStats(m, kStatsActionIncrement, kStatsTypeMemoryUsage, rr-&gt;resrec.rdlength);
        }

        <span class="enscript-keyword">if</span> (Add)
        {
            *(cg-&gt;rrcache_tail) = rr;               <span class="enscript-comment">// Append this record to tail of cache slot list
</span>            cg-&gt;rrcache_tail = &amp;(rr-&gt;next);         <span class="enscript-comment">// Advance tail pointer
</span>            CacheRecordAdd(m, rr);  <span class="enscript-comment">// CacheRecordAdd calls SetNextCacheCheckTimeForRecord(m, rr); for us
</span>        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Can't use the &quot;cg-&gt;name&quot; if we are not adding to the cache as the
</span>            <span class="enscript-comment">// CacheGroup may be released anytime if it is empty
</span>            domainname *name = (domainname *) mDNSPlatformMemAllocate(DomainNameLength(cg-&gt;name));
            <span class="enscript-keyword">if</span> (name)
            {
                AssignDomainName(name, cg-&gt;name);
                rr-&gt;resrec.name   = name;
            }
            <span class="enscript-keyword">else</span>
            {
                ReleaseCacheRecord(m, rr);
                NoCacheAnswer(m, &amp;m-&gt;rec.r);
                rr = mDNSNULL;
            }
        }
    }
    <span class="enscript-keyword">return</span>(rr);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RefreshCacheRecordCacheGroupOrder</span>(CacheGroup *cg, CacheRecord *cr)
{   <span class="enscript-comment">//  Move the cache record to the tail of the cache group to maintain a fresh ordering
</span>    <span class="enscript-keyword">if</span> (cg-&gt;rrcache_tail != &amp;cr-&gt;next)          <span class="enscript-comment">// If not already at the tail
</span>    {
        CacheRecord **rp;
        <span class="enscript-keyword">for</span> (rp = &amp;cg-&gt;members; *rp; rp = &amp;(*rp)-&gt;next)
        {
            <span class="enscript-keyword">if</span> (*rp == cr)                      <span class="enscript-comment">// This item points to this record
</span>            {
                *rp = cr-&gt;next;                 <span class="enscript-comment">// Remove this record
</span>                <span class="enscript-keyword">break</span>;
            }
        }
        cr-&gt;next = mDNSNULL;                    <span class="enscript-comment">// This record is now last
</span>        *(cg-&gt;rrcache_tail) = cr;               <span class="enscript-comment">// Append this record to tail of cache group
</span>        cg-&gt;rrcache_tail = &amp;(cr-&gt;next);         <span class="enscript-comment">// Advance tail pointer
</span>    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RefreshCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *rr, mDNSu32 ttl)
{
    rr-&gt;TimeRcvd             = m-&gt;timenow;
    rr-&gt;resrec.rroriginalttl = ttl;
    rr-&gt;UnansweredQueries = 0;
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.mortality != Mortality_Mortal) rr-&gt;resrec.mortality = Mortality_Immortal;
    SetNextCacheCheckTimeForRecord(m, rr);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">GrantCacheExtensions</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSu32 lease)
{
    CacheRecord *rr;
    CacheGroup *cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (rr-&gt;CRActiveQuestion == q)
        {
            <span class="enscript-comment">//LogInfo(&quot;GrantCacheExtensions: new lease %d / %s&quot;, lease, CRDisplayString(m, rr));
</span>            RefreshCacheRecord(m, rr, lease);
        }
}

mDNSlocal mDNSu32 <span class="enscript-function-name">GetEffectiveTTL</span>(<span class="enscript-type">const</span> uDNS_LLQType LLQType, mDNSu32 ttl)      <span class="enscript-comment">// TTL in seconds
</span>{
    <span class="enscript-keyword">if</span>      (LLQType == uDNS_LLQ_Entire) ttl = kLLQ_DefLease;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (LLQType == uDNS_LLQ_Events)
    {
        <span class="enscript-comment">// If the TTL is -1 for uDNS LLQ event packet, that means &quot;remove&quot;
</span>        <span class="enscript-keyword">if</span> (ttl == 0xFFFFFFFF) ttl = 0;
        <span class="enscript-keyword">else</span> ttl = kLLQ_DefLease;
    }
    <span class="enscript-keyword">else</span>    <span class="enscript-comment">// else not LLQ (standard uDNS response)
</span>    {
        <span class="enscript-comment">// The TTL is already capped to a maximum value in GetLargeResourceRecord, but just to be extra safe we
</span>        <span class="enscript-comment">// also do this check here to make sure we can't get overflow below when we add a quarter to the TTL
</span>        <span class="enscript-keyword">if</span> (ttl &gt; 0x60000000UL / mDNSPlatformOneSecond) ttl = 0x60000000UL / mDNSPlatformOneSecond;

        ttl = RRAdjustTTL(ttl);

        <span class="enscript-comment">// For mDNS, TTL zero means &quot;delete this record&quot;
</span>        <span class="enscript-comment">// For uDNS, TTL zero means: this data is true at this moment, but don't cache it.
</span>        <span class="enscript-comment">// For the sake of network efficiency, we impose a minimum effective TTL of 15 seconds.
</span>        <span class="enscript-comment">// This means that we'll do our 80, 85, 90, 95% queries at 12.00, 12.75, 13.50, 14.25 seconds
</span>        <span class="enscript-comment">// respectively, and then if we get no response, delete the record from the cache at 15 seconds.
</span>        <span class="enscript-comment">// This gives the server up to three seconds to respond between when we send our 80% query at 12 seconds
</span>        <span class="enscript-comment">// and when we delete the record at 15 seconds. Allowing cache lifetimes less than 15 seconds would
</span>        <span class="enscript-comment">// (with the current code) result in the server having even less than three seconds to respond
</span>        <span class="enscript-comment">// before we deleted the record and reported a &quot;remove&quot; event to any active questions.
</span>        <span class="enscript-comment">// Furthermore, with the current code, if we were to allow a TTL of less than 2 seconds
</span>        <span class="enscript-comment">// then things really break (e.g. we end up making a negative cache entry).
</span>        <span class="enscript-comment">// In the future we may want to revisit this and consider properly supporting non-cached (TTL=0) uDNS answers.
</span>        <span class="enscript-keyword">if</span> (ttl &lt; 15) ttl = 15;
    }

    <span class="enscript-keyword">return</span> ttl;
}

<span class="enscript-comment">// When the response does not match the question directly, we still want to cache them sometimes. The current response is
</span><span class="enscript-comment">// in m-&gt;rec.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">IsResponseAcceptable</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> CacheRecord *crlist, DNSQuestion *q, mDNSBool *nseclist)
{
    CacheRecord *<span class="enscript-type">const</span> newcr = &amp;m-&gt;rec.r;
    ResourceRecord *rr = &amp;newcr-&gt;resrec;
    <span class="enscript-type">const</span> CacheRecord *cr;

    *nseclist = mDNSfalse;
    <span class="enscript-keyword">for</span> (cr = crlist; cr != (CacheRecord*)1; cr = cr-&gt;NextInCFList)
    {
        domainname *target = GetRRDomainNameTarget(&amp;cr-&gt;resrec);
        <span class="enscript-comment">// When we issue a query for A record, the response might contain both a CNAME and A records. Only the CNAME would
</span>        <span class="enscript-comment">// match the question and we already created a cache entry in the previous pass of this loop. Now when we process
</span>        <span class="enscript-comment">// the A record, it does not match the question because the record name here is the CNAME. Hence we try to
</span>        <span class="enscript-comment">// match with the previous records to make it an AcceptableResponse. We have to be careful about setting the
</span>        <span class="enscript-comment">// DNSServer value that we got in the previous pass. This can happen for other record types like SRV also.
</span>
        <span class="enscript-keyword">if</span> (target &amp;&amp; cr-&gt;resrec.rdatahash == rr-&gt;namehash &amp;&amp; SameDomainName(target, rr-&gt;name))
        {
            LogDebug(<span class="enscript-string">&quot;IsResponseAcceptable: Found a matching entry for %##s in the CacheFlushRecords %s&quot;</span>, rr-&gt;name-&gt;c, CRDisplayString(m, cr));
            <span class="enscript-keyword">return</span> (mDNStrue);
        }
    }

    <span class="enscript-comment">// Either the question requires validation or we are validating a response with DNSSEC in which case
</span>    <span class="enscript-comment">// we need to accept the RRSIGs also so that we can validate the response. It is also possible that
</span>    <span class="enscript-comment">// we receive NSECs for our query which does not match the qname and we need to cache in that case
</span>    <span class="enscript-comment">// too. nseclist is set if they have to be cached as part of the negative cache record.
</span>    <span class="enscript-keyword">if</span> (q &amp;&amp; DNSSECQuestion(q))
    {
        mDNSBool same = SameDomainName(&amp;q-&gt;qname, rr-&gt;name);
        <span class="enscript-keyword">if</span> (same &amp;&amp; (q-&gt;qtype == rr-&gt;rrtype || rr-&gt;rrtype == kDNSType_CNAME))
        {
            LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting, same name and qtype %s, CR %s&quot;</span>, DNSTypeName(q-&gt;qtype),
                    CRDisplayString(m, newcr));
            <span class="enscript-keyword">return</span> mDNStrue;
        }
        <span class="enscript-comment">// We cache RRSIGS if it covers the question type or NSEC.  If it covers a NSEC,
</span>        <span class="enscript-comment">// &quot;nseclist&quot; is set
</span>        <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_RRSIG)
        {
            RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)newcr-&gt;smallrdatastorage.data;
            rdataRRSig *rrsig = &amp;rdb-&gt;rrsig;
            mDNSu16 typeCovered = swap16(rrsig-&gt;typeCovered);

            <span class="enscript-comment">// Note the ordering. If we are looking up the NSEC record, then the RRSIG's typeCovered
</span>            <span class="enscript-comment">// would match the qtype and they are cached normally as they are not used to prove the
</span>            <span class="enscript-comment">// non-existence of any name. In that case, it is like any other normal dnssec validation
</span>            <span class="enscript-comment">// and hence nseclist should not be set.
</span>
            <span class="enscript-keyword">if</span> (same &amp;&amp; ((typeCovered == q-&gt;qtype) || (typeCovered == kDNSType_CNAME)))
            {
                LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting RRSIG %s matches question type %s&quot;</span>, CRDisplayString(m, newcr),
                        DNSTypeName(q-&gt;qtype));
                <span class="enscript-keyword">return</span> mDNStrue;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (typeCovered == kDNSType_NSEC || typeCovered == kDNSType_NSEC3)
            {
                LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting RRSIG %s matches %s type (nseclist = 1)&quot;</span>, CRDisplayString(m, newcr), DNSTypeName(typeCovered));
                *nseclist = mDNStrue;
                <span class="enscript-keyword">return</span> mDNStrue;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (typeCovered == kDNSType_SOA)
            {
                LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting RRSIG %s matches SOA type (nseclist = 1)&quot;</span>, CRDisplayString(m, newcr));
                *nseclist = mDNStrue;
                <span class="enscript-keyword">return</span> mDNStrue;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_NSEC)
        {
            <span class="enscript-keyword">if</span> (!UNICAST_NSEC(rr))
            {
                LogMsg(<span class="enscript-string">&quot;IsResponseAcceptable: ERROR!! Not a unicast NSEC %s&quot;</span>, CRDisplayString(m, newcr));
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
            LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting NSEC %s (nseclist = 1)&quot;</span>, CRDisplayString(m, newcr));
            *nseclist = mDNStrue;
            <span class="enscript-keyword">return</span> mDNStrue;
        }
        <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_SOA)
        {
            LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting SOA %s (nseclist = 1)&quot;</span>, CRDisplayString(m, newcr));
            *nseclist = mDNStrue;
            <span class="enscript-keyword">return</span> mDNStrue;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_NSEC3)
        {
            LogInfo(<span class="enscript-string">&quot;IsResponseAcceptable: Accepting NSEC3 %s (nseclist = 1)&quot;</span>, CRDisplayString(m, newcr));
            *nseclist = mDNStrue;
            <span class="enscript-keyword">return</span> mDNStrue;
        }
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeNSECRecords</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *NSECRecords)
{
    CacheRecord *rp, *next;

    <span class="enscript-keyword">for</span> (rp = NSECRecords; rp; rp = next)
    {
        next = rp-&gt;next;
        ReleaseCacheRecord(m, rp);
    }
}

<span class="enscript-comment">// If we received zero DNSSEC records even when the DO/EDNS0 bit was set, we need to provide this
</span><span class="enscript-comment">// information to ValidatingResponse question to indicate the DNSSEC status to the application
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveNoDNSSECAnswers</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">const</span> mDNSAddr *dstaddr,
    mDNSIPPort dstport, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = response-&gt;data;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; response-&gt;h.numQuestions &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
    {
        DNSQuestion pktq;
        DNSQuestion *qptr = mDNSNULL;
        ptr = getQuestion(response, ptr, end, InterfaceID, &amp;pktq);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; (qptr = ExpectingUnicastResponseForQuestion(m, dstport, response-&gt;h.id, &amp;pktq, !dstaddr, mDNSNULL)) &amp;&amp;
            qptr-&gt;ValidatingResponse)
        {
            DNSQuestion *next, *q;

            <span class="enscript-keyword">if</span> (qptr-&gt;DuplicateOf)
                LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveNoDNSSECAnswers: ERROR!! qptr %##s (%s) Duplicate question matching response&quot;</span>, qptr-&gt;qname.c, DNSTypeName(qptr-&gt;qtype));

            <span class="enscript-comment">// Be careful to call the callback for duplicate questions first and then the original
</span>            <span class="enscript-comment">// question. If we called the callback on the original question, it could stop and 
</span>            <span class="enscript-comment">// a duplicate question would become the original question.
</span>            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client (and us) to legally make mDNS API calls
</span>            <span class="enscript-keyword">for</span> (q = qptr-&gt;next ; q &amp;&amp; q != m-&gt;NewQuestions; q = next)
            {
                next = q-&gt;next;
                <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf == qptr)
                {
                    <span class="enscript-keyword">if</span> (q-&gt;ValidatingResponse)
                        LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveNoDNSSECAnswers: qptr %##s (%s) Duplicate question found&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    <span class="enscript-keyword">else</span>
                        LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveNoDNSSECAnswers: ERROR!! qptr %##s (%s) Duplicate question not ValidatingResponse&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback)
                        q-&gt;QuestionCallback(m, q, mDNSNULL, QC_nodnssec);
                }
            }
            <span class="enscript-keyword">if</span> (qptr-&gt;QuestionCallback)
                qptr-&gt;QuestionCallback(m, qptr, mDNSNULL, QC_nodnssec);
            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveNoUnicastAnswers</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">const</span> mDNSAddr *dstaddr,
                                               mDNSIPPort dstport, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, uDNS_LLQType LLQType, mDNSu8 rcode, CacheRecord *NSECRecords)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr   = response-&gt;data;
    CacheRecord *SOARecord = mDNSNULL;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; response-&gt;h.numQuestions &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
    {
        DNSQuestion q;
        DNSQuestion *qptr = mDNSNULL;
        ptr = getQuestion(response, ptr, end, InterfaceID, &amp;q);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; (qptr = ExpectingUnicastResponseForQuestion(m, dstport, response-&gt;h.id, &amp;q, !dstaddr, mDNSNULL)))
        {
            CacheRecord *cr, *neg = mDNSNULL;
            CacheGroup *cg = CacheGroupForName(m, q.qnamehash, &amp;q.qname);
            <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
            {
                <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, qptr))
                {
                    <span class="enscript-comment">// 1. If we got a fresh answer to this query, then don't need to generate a negative entry
</span>                    <span class="enscript-keyword">if</span> (RRExpireTime(cr) - m-&gt;timenow &gt; 0) <span class="enscript-keyword">break</span>;
                    <span class="enscript-comment">// 2. If we already had a negative entry, keep track of it so we can resurrect it instead of creating a new one
</span>                    <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative) neg = cr;
                }
            }
            <span class="enscript-comment">// When we're doing parallel unicast and multicast queries for dot-local names (for supporting Microsoft
</span>            <span class="enscript-comment">// Active Directory sites) we don't want to waste memory making negative cache entries for all the unicast answers.
</span>            <span class="enscript-comment">// Otherwise we just fill up our cache with negative entries for just about every single multicast name we ever look up
</span>            <span class="enscript-comment">// (since the Microsoft Active Directory server is going to assert that pretty much every single multicast name doesn't exist).
</span>            <span class="enscript-comment">// This is not only a waste of memory, but there's also the problem of those negative entries confusing us later -- e.g. we
</span>            <span class="enscript-comment">// suppress sending our mDNS query packet because we think we already have a valid (negative) answer to that query in our cache.
</span>            <span class="enscript-comment">// The one exception is that we *DO* want to make a negative cache entry for &quot;local. SOA&quot;, for the (common) case where we're
</span>            <span class="enscript-comment">// *not* on a Microsoft Active Directory network, and there is no authoritative server for &quot;local&quot;. Note that this is not
</span>            <span class="enscript-comment">// in conflict with the mDNS spec, because that spec says, &quot;Multicast DNS Zones have no SOA record,&quot; so it's okay to cache
</span>            <span class="enscript-comment">// negative answers for &quot;local. SOA&quot; from a uDNS server, because the mDNS spec already says that such records do not exist :-)
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// By suppressing negative responses, it might take longer to timeout a .local question as it might be expecting a
</span>            <span class="enscript-comment">// response e.g., we deliver a positive &quot;A&quot; response and suppress negative &quot;AAAA&quot; response and the upper layer may
</span>            <span class="enscript-comment">// be waiting longer to get the AAAA response before returning the &quot;A&quot; response to the application. To handle this
</span>            <span class="enscript-comment">// case without creating the negative cache entries, we generate a negative response and let the layer above us
</span>            <span class="enscript-comment">// do the appropriate thing. This negative response is also needed for appending new search domains.
</span>            <span class="enscript-keyword">if</span> (!InterfaceID &amp;&amp; q.qtype != kDNSType_SOA &amp;&amp; IsLocalDomain(&amp;q.qname))
            {
                <span class="enscript-keyword">if</span> (!cr)
                {
                    <span class="enscript-type">const</span> mDNSBool noData = ((response-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask) == kDNSFlag1_RC_NoErr) ? mDNStrue : mDNSfalse;
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] mDNSCoreReceiveNoUnicastAnswers: Generate negative response for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              q.request_id, mDNSVal16(q.TargetQID), DM_NAME_PARAM(q.qname.c), DNSTypeName(q.qtype));
                    m-&gt;CurrentQuestion = qptr;
                    <span class="enscript-comment">// We are not creating a cache record in this case, we need to pass back
</span>                    <span class="enscript-comment">// the error we got so that the proxy code can return the right one to
</span>                    <span class="enscript-comment">// the application
</span>                    <span class="enscript-keyword">if</span> (qptr-&gt;ProxyQuestion)
                        qptr-&gt;responseFlags = response-&gt;h.flags;
                    GenerateNegativeResponseEx(m, mDNSInterface_Any, QC_forceresponse, noData);
                    m-&gt;CurrentQuestion = mDNSNULL;
                }
                <span class="enscript-keyword">else</span>
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] mDNSCoreReceiveNoUnicastAnswers: Skipping check and not creating a negative cache entry for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              q.request_id, mDNSVal16(q.TargetQID), DM_NAME_PARAM(q.qname.c), DNSTypeName(q.qtype));
                }
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (!cr)
                {
                    <span class="enscript-comment">// We start off assuming a negative caching TTL of 60 seconds
</span>                    <span class="enscript-comment">// but then look to see if we can find an SOA authority record to tell us a better value we should be using
</span>                    mDNSu32 negttl = 60;
                    <span class="enscript-type">int</span> repeat = 0;
                    <span class="enscript-type">const</span> domainname *name = &amp;q.qname;
                    mDNSu32 hash = q.qnamehash;

                    <span class="enscript-comment">// Special case for our special Microsoft Active Directory &quot;local SOA&quot; check.
</span>                    <span class="enscript-comment">// Some cheap home gateways don't include an SOA record in the authority section when
</span>                    <span class="enscript-comment">// they send negative responses, so we don't know how long to cache the negative result.
</span>                    <span class="enscript-comment">// Because we don't want to keep hitting the root name servers with our query to find
</span>                    <span class="enscript-comment">// if we're on a network using Microsoft Active Directory using &quot;local&quot; as a private
</span>                    <span class="enscript-comment">// internal top-level domain, we make sure to cache the negative result for at least one day.
</span>                    <span class="enscript-keyword">if</span> (q.qtype == kDNSType_SOA &amp;&amp; SameDomainName(&amp;q.qname, &amp;localdomain)) negttl = 60 * 60 * 24;

                    <span class="enscript-comment">// If we're going to make (or update) a negative entry, then look for the appropriate TTL from the SOA record
</span>                    <span class="enscript-keyword">if</span> (response-&gt;h.numAuthorities &amp;&amp; (ptr = LocateAuthorities(response, end)) != mDNSNULL)
                    {
                        ptr = GetLargeResourceRecord(m, response, ptr, end, InterfaceID, kDNSRecordTypePacketAuth, &amp;m-&gt;rec);
                        <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_SOA)
                        {
                            CacheGroup *cgSOA = CacheGroupForRecord(m, &amp;m-&gt;rec.r.resrec);
                            <span class="enscript-type">const</span> rdataSOA *<span class="enscript-type">const</span> soa = (<span class="enscript-type">const</span> rdataSOA *)m-&gt;rec.r.resrec.rdata-&gt;u.data;
                            mDNSu32 ttl_s = soa-&gt;min;
                            <span class="enscript-comment">// We use the lesser of the SOA.MIN field and the SOA record's TTL, *except*
</span>                            <span class="enscript-comment">// for the SOA record for &quot;.&quot;, where the record is reported as non-cacheable
</span>                            <span class="enscript-comment">// (TTL zero) for some reason, so in this case we just take the SOA record's TTL as-is
</span>                            <span class="enscript-keyword">if</span> (ttl_s &gt; m-&gt;rec.r.resrec.rroriginalttl &amp;&amp; m-&gt;rec.r.resrec.name-&gt;c[0])
                                ttl_s = m-&gt;rec.r.resrec.rroriginalttl;
                            <span class="enscript-keyword">if</span> (negttl &lt; ttl_s) negttl = ttl_s;

                            <span class="enscript-comment">// Create the SOA record as we may have to return this to the questions
</span>                            <span class="enscript-comment">// that we are acting as a proxy for currently or in the future.
</span>                            SOARecord = CreateNewCacheEntry(m, HashSlotFromNameHash(m-&gt;rec.r.resrec.namehash), cgSOA, 1, mDNSfalse, mDNSNULL);

                            <span class="enscript-comment">// Special check for SOA queries: If we queried for a.b.c.d.com, and got no answer,
</span>                            <span class="enscript-comment">// with an Authority Section SOA record for d.com, then this is a hint that the authority
</span>                            <span class="enscript-comment">// is d.com, and consequently SOA records b.c.d.com and c.d.com don't exist either.
</span>                            <span class="enscript-comment">// To do this we set the repeat count so the while loop below will make a series of negative cache entries for us
</span>                            <span class="enscript-comment">//
</span>                            <span class="enscript-comment">// For ProxyQuestions, we don't do this as we need to create additional SOA records to cache them
</span>                            <span class="enscript-comment">// along with the negative cache record. For simplicity, we don't create the additional records.
</span>                            <span class="enscript-keyword">if</span> (!qptr-&gt;ProxyQuestion &amp;&amp; q.qtype == kDNSType_SOA)
                            {
                                <span class="enscript-type">int</span> qcount = CountLabels(&amp;q.qname);
                                <span class="enscript-type">int</span> scount = CountLabels(m-&gt;rec.r.resrec.name);
                                <span class="enscript-keyword">if</span> (qcount - 1 &gt; scount)
                                    <span class="enscript-keyword">if</span> (SameDomainName(SkipLeadingLabels(&amp;q.qname, qcount - scount), m-&gt;rec.r.resrec.name))
                                        repeat = qcount - 1 - scount;
                            }
                        }
                        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                    }

                    <span class="enscript-comment">// If we already had a negative entry in the cache, then we double our existing negative TTL. This is to avoid
</span>                    <span class="enscript-comment">// the case where the record doesn't exist (e.g. particularly for things like our lb._dns-sd._udp.&lt;domain&gt; query),
</span>                    <span class="enscript-comment">// and the server returns no SOA record (or an SOA record with a small MIN TTL) so we assume a TTL
</span>                    <span class="enscript-comment">// of 60 seconds, and we end up polling the server every minute for a record that doesn't exist.
</span>                    <span class="enscript-comment">// With this fix in place, when this happens, we double the effective TTL each time (up to one hour),
</span>                    <span class="enscript-comment">// so that we back off our polling rate and don't keep hitting the server continually.
</span>                    <span class="enscript-keyword">if</span> (neg)
                    {
                        <span class="enscript-keyword">if</span> (negttl &lt; neg-&gt;resrec.rroriginalttl * 2)
                            negttl = neg-&gt;resrec.rroriginalttl * 2;
                        <span class="enscript-keyword">if</span> (negttl &gt; 3600)
                            negttl = 3600;
                    }

                    negttl = GetEffectiveTTL(LLQType, negttl);  <span class="enscript-comment">// Add 25% grace period if necessary
</span>
                    <span class="enscript-comment">// If we already had a negative cache entry just update it, else make one or more new negative cache entries.
</span>                    <span class="enscript-keyword">if</span> (neg)
                    {
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                  <span class="enscript-string">&quot;[R%u-&gt;Q%u] mDNSCoreReceiveNoUnicastAnswers: Renewing negative TTL from %d to %d &quot;</span> PRI_S,
                                  q.request_id, mDNSVal16(q.TargetQID), neg-&gt;resrec.rroriginalttl, negttl, CRDisplayString(m, neg));
                        RefreshCacheRecord(m, neg, negttl);
                        <span class="enscript-comment">// When we created the cache for the first time and answered the question, the question's
</span>                        <span class="enscript-comment">// interval was set to MaxQuestionInterval. If the cache is about to expire and we are resending
</span>                        <span class="enscript-comment">// the queries, the interval should still be at MaxQuestionInterval. If the query is being
</span>                        <span class="enscript-comment">// restarted (setting it to InitialQuestionInterval) for other reasons e.g., wakeup,
</span>                        <span class="enscript-comment">// we should reset its question interval here to MaxQuestionInterval.
</span>                        ResetQuestionState(m, qptr);
                        <span class="enscript-keyword">if</span> (DNSSECQuestion(qptr))
                            neg-&gt;CRDNSSECQuestion = 1;
                        <span class="enscript-comment">// Update the NSEC records again.
</span>                        <span class="enscript-comment">// TBD: Need to purge and revalidate if the cached NSECS and the new set are not same.
</span>                        <span class="enscript-keyword">if</span> (NSECRecords)
                        {
                            <span class="enscript-keyword">if</span> (!AddNSECSForCacheRecord(m, NSECRecords, neg, rcode))
                            {
                                <span class="enscript-comment">// We might just have an SOA record for zones that are not signed and hence don't log
</span>                                <span class="enscript-comment">// this as an error
</span>                                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                                          <span class="enscript-string">&quot;[R%u-&gt;Q%d] mDNSCoreReceiveNoUnicastAnswers: AddNSECSForCacheRecord failed to add NSEC for negcr &quot;</span> PRI_S<span class="enscript-string">&quot; during refresh&quot;</span>,
                                          q.request_id, mDNSVal16(q.TargetQID), CRDisplayString(m, neg));
                                FreeNSECRecords(m, NSECRecords);
                                neg-&gt;CRDNSSECQuestion = 0;
                            }
                            NSECRecords = mDNSNULL;
                        }
                        <span class="enscript-keyword">if</span> (SOARecord)
                        {
                            <span class="enscript-keyword">if</span> (neg-&gt;soa)
                                ReleaseCacheRecord(m, neg-&gt;soa);
                            neg-&gt;soa = SOARecord;
                            SOARecord = mDNSNULL;
                        }
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">while</span> (1)
                        {
                            CacheRecord *negcr;
                            debugf(<span class="enscript-string">&quot;mDNSCoreReceiveNoUnicastAnswers making negative cache entry TTL %d for %##s (%s)&quot;</span>, negttl, name-&gt;c, DNSTypeName(q.qtype));
                            MakeNegativeCacheRecord(m, &amp;m-&gt;rec.r, name, hash, q.qtype, q.qclass, negttl, mDNSInterface_Any, qptr-&gt;qDNSServer);
                            m-&gt;rec.r.responseFlags = response-&gt;h.flags;
                            <span class="enscript-comment">// We create SOA records above which might create new cache groups. Earlier
</span>                            <span class="enscript-comment">// in the function we looked up the cache group for the name and it could have
</span>                            <span class="enscript-comment">// been NULL. If we pass NULL cg to new cache entries that we create below,
</span>                            <span class="enscript-comment">// it will create additional cache groups for the same name. To avoid that,
</span>                            <span class="enscript-comment">// look up the cache group again to re-initialize cg again.
</span>                            cg = CacheGroupForName(m, hash, name);
                            <span class="enscript-keyword">if</span> (NSECRecords &amp;&amp; DNSSECQuestion(qptr))
                            {
                                <span class="enscript-comment">// Create the cache entry with delay and then add the NSEC records
</span>                                <span class="enscript-comment">// to it and add it immediately.
</span>                                negcr = CreateNewCacheEntry(m, HashSlotFromNameHash(hash), cg, 1, mDNStrue, mDNSNULL);
                                <span class="enscript-keyword">if</span> (negcr)
                                {
                                    negcr-&gt;CRDNSSECQuestion = 0;
                                    <span class="enscript-keyword">if</span> (!AddNSECSForCacheRecord(m, NSECRecords, negcr, rcode))
                                    {
                                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                                                  <span class="enscript-string">&quot;[R%u-&gt;Q%u] mDNSCoreReceiveNoUnicastAnswers: AddNSECSForCacheRecord failed to add NSEC for negcr &quot;</span> PRI_S,
                                                  q.request_id, mDNSVal16(q.TargetQID), CRDisplayString(m, negcr));
                                        FreeNSECRecords(m, NSECRecords);
                                    }
                                    <span class="enscript-keyword">else</span>
                                    {
                                        negcr-&gt;CRDNSSECQuestion = 1;
                                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                                  <span class="enscript-string">&quot;[R%u-&gt;Q%u] mDNSCoreReceiveNoUnicastAnswers: AddNSECSForCacheRecord added neg NSEC for &quot;</span> PRI_S,
                                                  q.request_id, mDNSVal16(q.TargetQID), CRDisplayString(m, negcr));
                                    }
                                    NSECRecords = mDNSNULL;
                                    negcr-&gt;DelayDelivery = 0;
                                    CacheRecordDeferredAdd(m, negcr);
                                }
                                m-&gt;rec.r.resrec.RecordType = 0; <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                                <span class="enscript-keyword">break</span>;
                            }
                            <span class="enscript-keyword">else</span>
                            {
                                <span class="enscript-comment">// Need to add with a delay so that we can tag the SOA record
</span>                                negcr = CreateNewCacheEntry(m, HashSlotFromNameHash(hash), cg, 1, mDNStrue, mDNSNULL);
                                <span class="enscript-keyword">if</span> (negcr)
                                {
                                    negcr-&gt;CRDNSSECQuestion = 0;
                                    <span class="enscript-keyword">if</span> (DNSSECQuestion(qptr))
                                        negcr-&gt;CRDNSSECQuestion = 1;
                                    negcr-&gt;DelayDelivery = 0;

                                    <span class="enscript-keyword">if</span> (SOARecord)
                                    {
                                        <span class="enscript-keyword">if</span> (negcr-&gt;soa)
                                            ReleaseCacheRecord(m, negcr-&gt;soa);
                                        negcr-&gt;soa = SOARecord;
                                        SOARecord = mDNSNULL;
                                    }
                                    CacheRecordDeferredAdd(m, negcr);
                                }
                            }
                            m-&gt;rec.r.responseFlags = zeroID;
                            m-&gt;rec.r.resrec.RecordType = 0; <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                            <span class="enscript-keyword">if</span> (!repeat) <span class="enscript-keyword">break</span>;
                            repeat--;
                            name = (<span class="enscript-type">const</span> domainname *)(name-&gt;c + 1 + name-&gt;c[0]);
                            hash = DomainNameHashValue(name);
                        }
                }
            }
        }
    }
    <span class="enscript-keyword">if</span> (NSECRecords)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveNoUnicastAnswers: NSECRecords not used&quot;</span>);
        FreeNSECRecords(m, NSECRecords);
    }
    <span class="enscript-keyword">if</span> (SOARecord)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveNoUnicastAnswers: SOARecord not used&quot;</span>);
        ReleaseCacheRecord(m, SOARecord);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCorePrintStoredProxyRecords</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rrPtr = mDNSNULL;
    <span class="enscript-keyword">if</span> (!m-&gt;SPSRRSet) <span class="enscript-keyword">return</span>;
    LogSPS(<span class="enscript-string">&quot;Stored Proxy records :&quot;</span>);
    <span class="enscript-keyword">for</span> (rrPtr = m-&gt;SPSRRSet; rrPtr; rrPtr = rrPtr-&gt;next)
    {
        LogSPS(<span class="enscript-string">&quot;%s&quot;</span>, ARDisplayString(m, rrPtr));
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">mDNSCoreRegisteredProxyRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    AuthRecord *rrPtr = mDNSNULL;

    <span class="enscript-keyword">for</span> (rrPtr = m-&gt;SPSRRSet; rrPtr; rrPtr = rrPtr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (IdenticalResourceRecord(&amp;rrPtr-&gt;resrec, &amp;rr-&gt;resrec))
        {
            LogSPS(<span class="enscript-string">&quot;mDNSCoreRegisteredProxyRecord: Ignoring packet registered with sleep proxy : %s &quot;</span>, ARDisplayString(m, rr));
            <span class="enscript-keyword">return</span> mDNStrue;
        }
    }
    mDNSCorePrintStoredProxyRecords(m);
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport CacheRecord* <span class="enscript-function-name">mDNSCoreReceiveCacheCheck</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, uDNS_LLQType LLQType,
    <span class="enscript-type">const</span> mDNSu32 slot, CacheGroup *cg, DNSQuestion *unicastQuestion, CacheRecord ***cfp, CacheRecord **NSECCachePtr,
    mDNSInterfaceID InterfaceID)
{
    CacheRecord *cr;
    CacheRecord **cflocal = *cfp;

    <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
    {
        mDNSBool match;
        <span class="enscript-comment">// Resource record received via unicast, the resGroupID should match ?
</span>        <span class="enscript-keyword">if</span> (!InterfaceID)
        {
            <span class="enscript-type">const</span> mDNSu32 id1 = (cr-&gt;resrec.rDNSServer ? cr-&gt;resrec.rDNSServer-&gt;resGroupID : 0);
            <span class="enscript-type">const</span> mDNSu32 id2 = (m-&gt;rec.r.resrec.rDNSServer ? m-&gt;rec.r.resrec.rDNSServer-&gt;resGroupID : 0);
            match = (id1 == id2);
        }
        <span class="enscript-keyword">else</span>
            match = (cr-&gt;resrec.InterfaceID == InterfaceID);
        <span class="enscript-comment">// If we found this exact resource record, refresh its TTL
</span>        <span class="enscript-keyword">if</span> (match &amp;&amp; IdenticalSameNameRecord(&amp;m-&gt;rec.r.resrec, &amp;cr-&gt;resrec))
        {
            <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rdlength &gt; InlineCacheRDSize)
                verbosedebugf(<span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Found record size %5d interface %p already in cache: %s&quot;</span>,
                              m-&gt;rec.r.resrec.rdlength, InterfaceID, CRDisplayString(m, &amp;m-&gt;rec.r));

            <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask)
            {
                <span class="enscript-comment">// If this packet record has the kDNSClass_UniqueRRSet flag set, then add it to our cache flushing list
</span>                <span class="enscript-keyword">if</span> (cr-&gt;NextInCFList == mDNSNULL &amp;&amp; *cfp != &amp;cr-&gt;NextInCFList &amp;&amp; LLQType != uDNS_LLQ_Events)
                {
                    *cflocal = cr;
                    cflocal = &amp;cr-&gt;NextInCFList;
                    *cflocal = (CacheRecord*)1;
                    *cfp = &amp;cr-&gt;NextInCFList;
                }

                <span class="enscript-comment">// If this packet record is marked unique, and our previous cached copy was not, then fix it
</span>                <span class="enscript-keyword">if</span> (!(cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask))
                {
                    DNSQuestion *q;
                    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
                    {
                        <span class="enscript-keyword">if</span> (CacheRecordAnswersQuestion(cr, q))
                            q-&gt;UniqueAnswers++;
                    }
                    cr-&gt;resrec.RecordType = m-&gt;rec.r.resrec.RecordType;
                }
            }

            <span class="enscript-keyword">if</span> (!SameRDataBody(&amp;m-&gt;rec.r.resrec, &amp;cr-&gt;resrec.rdata-&gt;u, SameDomainNameCS))
            {
                <span class="enscript-comment">// If the rdata of the packet record differs in name capitalization from the record in our cache
</span>                <span class="enscript-comment">// then mDNSPlatformMemSame will detect this. In this case, throw the old record away, so that clients get
</span>                <span class="enscript-comment">// a 'remove' event for the record with the old capitalization, and then an 'add' event for the new one.
</span>                <span class="enscript-comment">// &lt;rdar://problem/4015377&gt; mDNS -F returns the same domain multiple times with different casing
</span>                cr-&gt;resrec.rroriginalttl = 0;
                cr-&gt;TimeRcvd = m-&gt;timenow;
                cr-&gt;UnansweredQueries = MaxUnansweredQueries;
                SetNextCacheCheckTimeForRecord(m, cr);
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Discarding due to domainname case change old: &quot;</span> PRI_S, CRDisplayString(m, cr));
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Discarding due to domainname case change new: &quot;</span> PRI_S, CRDisplayString(m, &amp;m-&gt;rec.r));
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Discarding due to domainname case change in %d slot %3d in %d %d&quot;</span>,
                          NextCacheCheckEvent(cr) - m-&gt;timenow, slot, m-&gt;rrcache_nextcheck[slot] - m-&gt;timenow, m-&gt;NextCacheCheck - m-&gt;timenow);
                <span class="enscript-comment">// DO NOT break out here -- we want to continue as if we never found it
</span>            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rroriginalttl &gt; 0)
            {
                DNSQuestion *q;

                m-&gt;mDNSStats.CacheRefreshed++;
                
                <span class="enscript-keyword">if</span> (cr-&gt;resrec.mortality == Mortality_Ghost &amp;&amp; unicastQuestion &amp;&amp; (unicastQuestion-&gt;allowExpired != AllowExpired_AllowExpiredAnswers) &amp;&amp; !cr-&gt;DelayDelivery)
                {
                    cr-&gt;DelayDelivery = NonZeroTime(m-&gt;timenow);
                    debugf(<span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Reset DelayDelivery for mortalityExpired EXP:%d RR %s&quot;</span>, m-&gt;timenow - RRExpireTime(cr), CRDisplayString(m, cr));
                }

                <span class="enscript-keyword">if</span> (cr-&gt;resrec.rroriginalttl == 0) debugf(<span class="enscript-string">&quot;uDNS rescuing %s&quot;</span>, CRDisplayString(m, cr));
                RefreshCacheRecord(m, cr, m-&gt;rec.r.resrec.rroriginalttl);
                <span class="enscript-comment">// RefreshCacheRecordCacheGroupOrder will modify the cache group member list that is currently being iterated over in this for-loop.
</span>                <span class="enscript-comment">// It is safe to call because the else-if body will unconditionally break out of the for-loop now that it has found the entry to update.
</span>                RefreshCacheRecordCacheGroupOrder(cg, cr);
                cr-&gt;responseFlags = response-&gt;h.flags;

                <span class="enscript-comment">// If we may have NSEC records returned with the answer (which we don't know yet as it
</span>                <span class="enscript-comment">// has not been processed), we need to cache them along with the first cache
</span>                <span class="enscript-comment">// record in the list that answers the question so that it can be used for validation
</span>                <span class="enscript-comment">// later. The &quot;type&quot; check below is to make sure that we cache on the cache record
</span>                <span class="enscript-comment">// that would answer the question. It is possible that we might cache additional things
</span>                <span class="enscript-comment">// e.g., MX question might cache A records also, and we want to cache the NSEC on
</span>                <span class="enscript-comment">// the record that answers the question.
</span>                <span class="enscript-keyword">if</span> (response-&gt;h.numAnswers &amp;&amp; unicastQuestion &amp;&amp; unicastQuestion-&gt;qtype == cr-&gt;resrec.rrtype
                    &amp;&amp; !(*NSECCachePtr))
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: rescuing RR &quot;</span> PRI_S, CRDisplayString(m, cr));
                    *NSECCachePtr = cr;
                }
                <span class="enscript-comment">// We have to reset the question interval to MaxQuestionInterval so that we don't keep
</span>                <span class="enscript-comment">// polling the network once we get a valid response back. For the first time when a new
</span>                <span class="enscript-comment">// cache entry is created, AnswerCurrentQuestionWithResourceRecord does that.
</span>                <span class="enscript-comment">// Subsequently, if we reissue questions from within the mDNSResponder e.g., DNS server
</span>                <span class="enscript-comment">// configuration changed, without flushing the cache, we reset the question interval here.
</span>                <span class="enscript-comment">// Currently, we do this for for both multicast and unicast questions as long as the record
</span>                <span class="enscript-comment">// type is unique. For unicast, resource record is always unique and for multicast it is
</span>                <span class="enscript-comment">// true for records like A etc. but not for PTR.
</span>                <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask)
                {
                    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
                    {
                        <span class="enscript-keyword">if</span> (!q-&gt;DuplicateOf &amp;&amp; !q-&gt;LongLived &amp;&amp;
                            ActiveQuestion(q) &amp;&amp; CacheRecordAnswersQuestion(cr, q))
                        {
                            ResetQuestionState(m, q);
                            debugf(<span class="enscript-string">&quot;mDNSCoreReceiveCacheCheck: Set MaxQuestionInterval for %p %##s (%s)&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                            <span class="enscript-keyword">break</span>;      <span class="enscript-comment">// Why break here? Aren't there other questions we might want to look at?-- SC July 2010
</span>                        }
                    }
                }
                <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// Check usage of RefreshCacheRecordCacheGroupOrder before removing (See note above)
</span>            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// If the packet TTL is zero, that means we're deleting this record.
</span>                <span class="enscript-comment">// To give other hosts on the network a chance to protest, we push the deletion
</span>                <span class="enscript-comment">// out one second into the future. Also, we set UnansweredQueries to MaxUnansweredQueries.
</span>                <span class="enscript-comment">// Otherwise, we'll do final queries for this record at 80% and 90% of its apparent
</span>                <span class="enscript-comment">// lifetime (800ms and 900ms from now) which is a pointless waste of network bandwidth.
</span>                <span class="enscript-comment">// If record's current expiry time is more than a second from now, we set it to expire in one second.
</span>                <span class="enscript-comment">// If the record is already going to expire in less than one second anyway, we leave it alone --
</span>                <span class="enscript-comment">// we don't want to let the goodbye packet *extend* the record's lifetime in our cache.
</span>                debugf(<span class="enscript-string">&quot;DE for %s&quot;</span>, CRDisplayString(m, cr));
                <span class="enscript-keyword">if</span> (RRExpireTime(cr) - m-&gt;timenow &gt; mDNSPlatformOneSecond)
                {
                    cr-&gt;resrec.rroriginalttl = 1;
                    cr-&gt;TimeRcvd = m-&gt;timenow;
                    cr-&gt;UnansweredQueries = MaxUnansweredQueries;
                    SetNextCacheCheckTimeForRecord(m, cr);
                }
                <span class="enscript-keyword">break</span>;
            }
        }
    }
    <span class="enscript-keyword">return</span> cr;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSParseNSEC3Records</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, <span class="enscript-type">const</span> mDNSu8 *end,
    <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, CacheRecord **NSEC3Records)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr;
    CacheRecord *rr;
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">if</span> (!response-&gt;h.numAuthorities)
        <span class="enscript-keyword">return</span>;
    ptr = LocateAuthorities(response, end);
    <span class="enscript-keyword">if</span> (!ptr)
    {
        LogInfo(<span class="enscript-string">&quot;mDNSParseNSEC3Records: ERROR can't locate authorities&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">for</span> (i = 0; i &lt; response-&gt;h.numAuthorities &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
    {
        CacheGroup *cg;

        ptr = GetLargeResourceRecord(m, response, ptr, end, InterfaceID, kDNSRecordTypePacketAuth, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (!ptr || m-&gt;rec.r.resrec.RecordType == kDNSRecordTypePacketNegative || m-&gt;rec.r.resrec.rrtype != kDNSType_NSEC3)
        {
            debugf(<span class="enscript-string">&quot;mDNSParseNSEC3Records: ptr %p, Record %s, ignoring&quot;</span>, ptr, CRDisplayString(m, &amp;m-&gt;rec.r));
            m-&gt;rec.r.resrec.RecordType = 0;
            <span class="enscript-keyword">continue</span>;
        }
        cg = CacheGroupForRecord(m, &amp;m-&gt;rec.r.resrec);
        <span class="enscript-comment">// Create the cache entry but don't add it to the cache it. We need
</span>        <span class="enscript-comment">// to cache this along with the main cache record.
</span>        rr = CreateNewCacheEntry(m, HashSlotFromNameHash(m-&gt;rec.r.resrec.namehash), cg, 0, mDNSfalse, mDNSNULL);
        <span class="enscript-keyword">if</span> (rr)
        {
            debugf(<span class="enscript-string">&quot;mDNSParseNSEC3Records: %s&quot;</span>, CRDisplayString(m, rr));
            *NSEC3Records = rr;
            NSEC3Records = &amp;rr-&gt;next;
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreResetRecord</span>(mDNS *<span class="enscript-type">const</span> m)
{
    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>}

<span class="enscript-comment">// Note: mDNSCoreReceiveResponse calls mDNS_Deregister_internal which can call a user callback, which may change
</span><span class="enscript-comment">// the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span><span class="enscript-comment">// InterfaceID non-NULL tells us the interface this multicast response was received on
</span><span class="enscript-comment">// InterfaceID NULL tells us this was a unicast response
</span><span class="enscript-comment">// dstaddr NULL tells us we received this over an outgoing TCP connection we made
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveResponse</span>(mDNS *<span class="enscript-type">const</span> m,
                                       <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> response, <span class="enscript-type">const</span> mDNSu8 *end,
                                       <span class="enscript-type">const</span> mDNSAddr *srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *dstaddr, mDNSIPPort dstport,
                                       <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSBool ResponseMCast = dstaddr &amp;&amp; mDNSAddrIsDNSMulticast(dstaddr);
    mDNSBool ResponseSrcLocal = !srcaddr || mDNS_AddressIsLocalSubnet(m, InterfaceID, srcaddr);
    DNSQuestion *llqMatch = mDNSNULL;
    DNSQuestion *unicastQuestion = mDNSNULL;
    uDNS_LLQType LLQType      = uDNS_recvLLQResponse(m, response, end, srcaddr, srcport, &amp;llqMatch);

    <span class="enscript-comment">// &quot;(CacheRecord*)1&quot; is a special (non-zero) end-of-list marker
</span>    <span class="enscript-comment">// We use this non-zero marker so that records in our CacheFlushRecords list will always have NextInCFList
</span>    <span class="enscript-comment">// set non-zero, and that tells GetCacheEntity() that they're not, at this moment, eligible for recycling.
</span>    CacheRecord *CacheFlushRecords = (CacheRecord*)1;
    CacheRecord **cfp = &amp;CacheFlushRecords;
    CacheRecord *NSECRecords = mDNSNULL;
    CacheRecord *NSECCachePtr = mDNSNULL;
    CacheRecord **nsecp = &amp;NSECRecords;
    CacheRecord *McastNSEC3Records = mDNSNULL;
    mDNSBool nseclist;
    mDNSu8 rcode = <span class="enscript-string">'\0'</span>;
    mDNSBool rrsigsCreated = mDNSfalse;
    mDNSBool DNSSECQuestion = mDNSfalse;
    NetworkInterfaceInfo *llintf = FirstIPv4LLInterfaceForID(m, InterfaceID);
    mDNSBool    recordAcceptedInResponse = mDNSfalse; <span class="enscript-comment">// Set if a record is accepted from a unicast mDNS response that answers an existing question.
</span>
    <span class="enscript-comment">// All records in a DNS response packet are treated as equally valid statements of truth. If we want
</span>    <span class="enscript-comment">// to guard against spoof responses, then the only credible protection against that is cryptographic
</span>    <span class="enscript-comment">// security, e.g. DNSSEC., not worrying about which section in the spoof packet contained the record.
</span>    <span class="enscript-type">int</span> firstauthority  =                   response-&gt;h.numAnswers;
    <span class="enscript-type">int</span> firstadditional = firstauthority  + response-&gt;h.numAuthorities;
    <span class="enscript-type">int</span> totalrecords    = firstadditional + response-&gt;h.numAdditionals;
    <span class="enscript-type">const</span> mDNSu8 *ptr   = response-&gt;data;
    DNSServer *uDNSServer = mDNSNULL;

    debugf(<span class="enscript-string">&quot;Received Response from %#-15a addressed to %#-15a on %p with &quot;</span>
           <span class="enscript-string">&quot;%2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes LLQType %d&quot;</span>,
           srcaddr, dstaddr, InterfaceID,
           response-&gt;h.numQuestions,   response-&gt;h.numQuestions   == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           response-&gt;h.numAnswers,     response-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           response-&gt;h.numAuthorities, response-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
           response-&gt;h.numAdditionals, response-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot; &quot;</span>    : <span class="enscript-string">&quot;s&quot;</span>, end - response-&gt;data, LLQType);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    <span class="enscript-keyword">if</span> (mDNSSameIPPort(srcport, UnicastDNSPort))
    {
        MetricsUpdateDNSResponseSize((mDNSu32)(end - (mDNSu8 *)response));
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// According to RFC 2181 &lt;<a href="http://www.ietf.org/rfc/rfc2181.txt">http://www.ietf.org/rfc/rfc2181.txt</a>&gt;
</span>    <span class="enscript-comment">//    When a DNS client receives a reply with TC
</span>    <span class="enscript-comment">//    set, it should ignore that response, and query again, using a
</span>    <span class="enscript-comment">//    mechanism, such as a TCP connection, that will permit larger replies.
</span>    <span class="enscript-comment">// It feels wrong to be throwing away data after the network went to all the trouble of delivering it to us, but
</span>    <span class="enscript-comment">// delivering some records of the RRSet first and then the remainder a couple of milliseconds later was causing
</span>    <span class="enscript-comment">// failures in our Microsoft Active Directory client, which expects to get the entire set of answers at once.
</span>    <span class="enscript-comment">// &lt;rdar://problem/6690034&gt; Can't bind to Active Directory
</span>    <span class="enscript-comment">// In addition, if the client immediately canceled its query after getting the initial partial response, then we'll
</span>    <span class="enscript-comment">// abort our TCP connection, and not complete the operation, and end up with an incomplete RRSet in our cache.
</span>    <span class="enscript-comment">// Next time there's a query for this RRSet we'll see answers in our cache, and assume we have the whole RRSet already,
</span>    <span class="enscript-comment">// and not even do the TCP query.
</span>    <span class="enscript-comment">// Accordingly, if we get a uDNS reply with kDNSFlag0_TC set, we bail out and wait for the TCP response containing the
</span>    <span class="enscript-comment">// entire RRSet, with the following exception. If the response contains an answer section and one or more records in
</span>    <span class="enscript-comment">// either the authority section or additional section, then that implies that truncation occurred beyond the answer
</span>    <span class="enscript-comment">// section, and the answer section is therefore assumed to be complete.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// From section 6.2 of RFC 1035 &lt;<a href="https://tools.ietf.org/html/rfc1035">https://tools.ietf.org/html/rfc1035</a>&gt;:
</span>    <span class="enscript-comment">//    When a response is so long that truncation is required, the truncation
</span>    <span class="enscript-comment">//    should start at the end of the response and work forward in the
</span>    <span class="enscript-comment">//    datagram.  Thus if there is any data for the authority section, the
</span>    <span class="enscript-comment">//    answer section is guaranteed to be unique.
</span>    <span class="enscript-keyword">if</span> (!InterfaceID &amp;&amp; (response-&gt;h.flags.b[0] &amp; kDNSFlag0_TC) &amp;&amp;
        ((response-&gt;h.numAnswers == 0) || ((response-&gt;h.numAuthorities == 0) &amp;&amp; (response-&gt;h.numAdditionals == 0)))) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (LLQType == uDNS_LLQ_Ignore) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// 1. We ignore questions (if any) in mDNS response packets
</span>    <span class="enscript-comment">// 2. If this is an LLQ response, we handle it much the same
</span>    <span class="enscript-comment">// Otherwise, this is a authoritative uDNS answer, so arrange for any stale records to be purged
</span>    <span class="enscript-keyword">if</span> (ResponseMCast || LLQType == uDNS_LLQ_Events)
        ptr = LocateAnswers(response, end);
    <span class="enscript-comment">// Otherwise, for one-shot queries, any answers in our cache that are not also contained
</span>    <span class="enscript-comment">// in this response packet are immediately deemed to be invalid.
</span>    <span class="enscript-keyword">else</span>
    {
        mDNSBool failure, returnEarly;
        rcode = (mDNSu8)(response-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask);
        failure = !(rcode == kDNSFlag1_RC_NoErr || rcode == kDNSFlag1_RC_NXDomain || rcode == kDNSFlag1_RC_NotAuth);
        returnEarly = mDNSfalse;
        <span class="enscript-comment">// We could possibly combine this with the similar loop at the end of this function --
</span>        <span class="enscript-comment">// instead of tagging cache records here and then rescuing them if we find them in the answer section,
</span>        <span class="enscript-comment">// we could instead use the &quot;m-&gt;PktNum&quot; mechanism to tag each cache record with the packet number in
</span>        <span class="enscript-comment">// which it was received (or refreshed), and then at the end if we find any cache records which
</span>        <span class="enscript-comment">// answer questions in this packet's question section, but which aren't tagged with this packet's
</span>        <span class="enscript-comment">// packet number, then we deduce they are old and delete them
</span>        <span class="enscript-keyword">for</span> (i = 0; i &lt; response-&gt;h.numQuestions &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
        {
            DNSQuestion q, *qptr = mDNSNULL, *suspiciousForQ = mDNSNULL;
            ptr = getQuestion(response, ptr, end, InterfaceID, &amp;q);
            <span class="enscript-keyword">if</span> (ptr &amp;&amp; (qptr = ExpectingUnicastResponseForQuestion(m, dstport, response-&gt;h.id, &amp;q, !dstaddr, &amp;suspiciousForQ)))
            {
                <span class="enscript-keyword">if</span> (!failure)
                {
                    CacheRecord *cr;
                    <span class="enscript-comment">// Remember the unicast question that we found, which we use to make caching
</span>                    <span class="enscript-comment">// decisions later on in this function
</span>                    CacheGroup *cg = CacheGroupForName(m, q.qnamehash, &amp;q.qname);
                    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(response-&gt;h.id))
                    {
                        unicastQuestion = qptr;
                        <span class="enscript-keyword">if</span> (qptr-&gt;qDNSServer &amp;&amp; DNSSECQuestion(qptr))
                        {
                            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                   <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Setting aware for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) on &quot;</span> PRI_IP_ADDR,
                                   qptr-&gt;request_id, mDNSVal16(qptr-&gt;TargetQID), DM_NAME_PARAM(qptr-&gt;qname.c),
                                   DNSTypeName(qptr-&gt;qtype), &amp;qptr-&gt;qDNSServer-&gt;addr);

                            qptr-&gt;qDNSServer-&gt;DNSSECAware = mDNStrue;
                            qptr-&gt;qDNSServer-&gt;req_DO = mDNStrue;
                        }
                        <span class="enscript-keyword">if</span> (qptr-&gt;ValidatingResponse)
                            DNSSECQuestion = mDNStrue;
                    }
                    <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
                    {
                        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, qptr))
                        {
                            debugf(<span class="enscript-string">&quot;uDNS marking %p %##s (%s) %p %s&quot;</span>, q.InterfaceID, q.qname.c, DNSTypeName(q.qtype),
                                   cr-&gt;resrec.InterfaceID, CRDisplayString(m, cr));
                            <span class="enscript-comment">// Don't want to disturb rroriginalttl here, because code below might need it for the exponential backoff doubling algorithm
</span>                            cr-&gt;TimeRcvd          = m-&gt;timenow - TicksTTL(cr) - 1;
                            cr-&gt;UnansweredQueries = MaxUnansweredQueries;
                            cr-&gt;CRDNSSECQuestion = 0;
                            <span class="enscript-keyword">if</span> (unicastQuestion &amp;&amp; DNSSECQuestion(unicastQuestion))
                            {
                                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                       <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: CRDNSSECQuestion set for record &quot;</span> PRI_S <span class="enscript-string">&quot;, question &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                                       unicastQuestion-&gt;request_id, mDNSVal16(unicastQuestion-&gt;TargetQID),
                                       CRDisplayString(m, cr), DM_NAME_PARAM(unicastQuestion-&gt;qname.c),
                                       DNSTypeName(unicastQuestion-&gt;qtype));
                                cr-&gt;CRDNSSECQuestion = 1;
                            }
                        }
                    }
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-keyword">if</span> (qptr)
                    {
                        <span class="enscript-comment">// If we recv any error from the DNSServer for a DNSSEC Query and if we know that the server
</span>                        <span class="enscript-comment">// is not DNSSEC aware, stop doing DNSSEC for that DNSServer. Note that by setting the
</span>                        <span class="enscript-comment">// req_DO to false here, the next retransmission for this question will turn off validation
</span>                        <span class="enscript-comment">// and hence retransmit without the EDNS0/DOK option.
</span>                        <span class="enscript-keyword">if</span> (DNSSECOptionalQuestion(qptr) &amp;&amp; qptr-&gt;qDNSServer &amp;&amp; !qptr-&gt;qDNSServer-&gt;DNSSECAware)
                        {
                            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                   <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Server %p responded with code %d to DNSSEC Query &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;), clear DO flag&quot;</span>,
                                   qptr-&gt;request_id, mDNSVal16(qptr-&gt;TargetQID), qptr-&gt;qDNSServer, rcode,
                                   DM_NAME_PARAM(q.qname.c), DNSTypeName(q.qtype));
                            qptr-&gt;qDNSServer-&gt;req_DO = mDNSfalse;
                        }
                        <span class="enscript-comment">// For Unicast DNS Queries, penalize the DNSServer
</span>                        <span class="enscript-keyword">else</span>
                        {
                            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                   <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Server %p responded with code %d to query &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                                   qptr-&gt;request_id, mDNSVal16(qptr-&gt;TargetQID), qptr-&gt;qDNSServer, rcode,
                                   DM_NAME_PARAM(q.qname.c), DNSTypeName(q.qtype));
                            PenalizeDNSServer(m, qptr, response-&gt;h.flags);
                        }
                    }
                    returnEarly = mDNStrue;
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!InterfaceID &amp;&amp; suspiciousForQ)
            {
                <span class="enscript-comment">// If a response is suspicious for a question, then reissue the question via TCP
</span>                LogInfo(<span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Server %p responded suspiciously to query %##s (%s) qID %d != rID: %d&quot;</span>,
                        suspiciousForQ-&gt;request_id, mDNSVal16(suspiciousForQ-&gt;TargetQID),
                        suspiciousForQ-&gt;qDNSServer, q.qname.c, DNSTypeName(q.qtype),
                        mDNSVal16(suspiciousForQ-&gt;TargetQID), mDNSVal16(response-&gt;h.id));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
                m-&gt;NextSuspiciousTimeout = NonZeroTime(m-&gt;timenow + (SUSPICIOUS_REPLY_DEFENSE_SECS * mDNSPlatformOneSecond));
#<span class="enscript-reference">endif</span>
                uDNS_RestartQuestionAsTCP(m, suspiciousForQ, srcaddr, srcport);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                suspiciousForQ-&gt;metrics.dnsOverTCPState = DNSOverTCP_Suspicious;
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">return</span>;
            }
        }
        <span class="enscript-keyword">if</span> (returnEarly)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                   <span class="enscript-string">&quot;[Q%d] Ignoring %2d Answer&quot;</span> PUB_S <span class="enscript-string">&quot; %2d Authorit&quot;</span> PUB_S <span class="enscript-string">&quot; %2d Additional&quot;</span> PUB_S,
                   mDNSVal16(response-&gt;h.id),
                   response-&gt;h.numAnswers,     response-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span> : <span class="enscript-string">&quot;s,&quot;</span>,
                   response-&gt;h.numAuthorities, response-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
                   response-&gt;h.numAdditionals, response-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>);
            <span class="enscript-comment">// not goto exit because we won't have any CacheFlushRecords and we do not want to
</span>            <span class="enscript-comment">// generate negative cache entries (we want to query the next server)
</span>            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (unicastQuestion &amp;&amp; DNSSECQuestion(unicastQuestion))
        {
            BumpDNSSECStats(m, kStatsActionSet, kStatsTypeMsgSize, (end - response-&gt;data));
        }
    }

    <span class="enscript-comment">// Parse the NSEC3 records from the Authority section before we process
</span>    <span class="enscript-comment">// the Answer section so that we can cache them along with the proper
</span>    <span class="enscript-comment">// cache records we create.
</span>    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(response-&gt;h.id))
        mDNSParseNSEC3Records(m, response, end, InterfaceID, &amp;McastNSEC3Records);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; totalrecords &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
    {
        <span class="enscript-comment">// All responses sent via LL multicast are acceptable for caching
</span>        <span class="enscript-comment">// All responses received over our outbound TCP connections are acceptable for caching
</span>        <span class="enscript-comment">// We accept all records in a unicast response to a multicast query once we find one that
</span>        <span class="enscript-comment">// answers an active question.
</span>        mDNSBool AcceptableResponse = ResponseMCast || !dstaddr || LLQType || recordAcceptedInResponse;
        <span class="enscript-comment">// (Note that just because we are willing to cache something, that doesn't necessarily make it a trustworthy answer
</span>        <span class="enscript-comment">// to any specific question -- any code reading records from the cache needs to make that determination for itself.)
</span>
        <span class="enscript-type">const</span> mDNSu8 RecordType =
            (i &lt; firstauthority ) ? (mDNSu8)kDNSRecordTypePacketAns  :
            (i &lt; firstadditional) ? (mDNSu8)kDNSRecordTypePacketAuth : (mDNSu8)kDNSRecordTypePacketAdd;
        ptr = GetLargeResourceRecord(m, response, ptr, end, InterfaceID, RecordType, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;        <span class="enscript-comment">// Break out of the loop and clean up our CacheFlushRecords list before exiting
</span>
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            mDNSCoreResetRecord(m);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// We have already parsed the NSEC3 records and cached them approrpriately for
</span>        <span class="enscript-comment">// multicast responses.
</span>        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(response-&gt;h.id) &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_NSEC3)
        {
            mDNSCoreResetRecord(m);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-comment">// Don't want to cache OPT or TSIG pseudo-RRs
</span>        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rrtype == kDNSType_TSIG)
        {
            mDNSCoreResetRecord(m);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rrtype == kDNSType_OPT)
        {
            <span class="enscript-type">const</span> rdataOPT *opt;
            <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> e = (<span class="enscript-type">const</span> rdataOPT *)&amp;m-&gt;rec.r.resrec.rdata-&gt;u.data[m-&gt;rec.r.resrec.rdlength];
            <span class="enscript-comment">// Find owner sub-option(s). We verify that the MAC is non-zero, otherwise we could inadvertently
</span>            <span class="enscript-comment">// delete all our own AuthRecords (which are identified by having zero MAC tags on them).
</span>            <span class="enscript-keyword">for</span> (opt = &amp;m-&gt;rec.r.resrec.rdata-&gt;u.opt[0]; opt &lt; e; opt++)
                <span class="enscript-keyword">if</span> (opt-&gt;opt == kDNSOpt_Owner &amp;&amp; opt-&gt;u.owner.vers == 0 &amp;&amp; opt-&gt;u.owner.HMAC.l[0])
                {
                    ClearProxyRecords(m, &amp;opt-&gt;u.owner, m-&gt;DuplicateRecords);
                    ClearProxyRecords(m, &amp;opt-&gt;u.owner, m-&gt;ResourceRecords);
                }
            mDNSCoreResetRecord(m);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-comment">// if a CNAME record points to itself, then don't add it to the cache
</span>        <span class="enscript-keyword">if</span> ((m-&gt;rec.r.resrec.rrtype == kDNSType_CNAME) &amp;&amp; SameDomainName(m-&gt;rec.r.resrec.name, &amp;m-&gt;rec.r.resrec.rdata-&gt;u.name))
        {
            LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: CNAME loop domain name %##s&quot;</span>, m-&gt;rec.r.resrec.name-&gt;c);
            mDNSCoreResetRecord(m);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// When we receive uDNS LLQ responses, we assume a long cache lifetime --
</span>        <span class="enscript-comment">// In the case of active LLQs, we'll get remove events when the records actually do go away
</span>        <span class="enscript-comment">// In the case of polling LLQs, we assume the record remains valid until the next poll
</span>        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(response-&gt;h.id))
            m-&gt;rec.r.resrec.rroriginalttl = GetEffectiveTTL(LLQType, m-&gt;rec.r.resrec.rroriginalttl);

        <span class="enscript-comment">// If response was not sent via LL multicast,
</span>        <span class="enscript-comment">// then see if it answers a recent query of ours, which would also make it acceptable for caching.
</span>        <span class="enscript-keyword">if</span> (!ResponseMCast)
        {
            <span class="enscript-keyword">if</span> (LLQType)
            {
                <span class="enscript-comment">// For Long Lived queries that are both sent over UDP and Private TCP, LLQType is set.
</span>                <span class="enscript-comment">// Even though it is AcceptableResponse, we need a matching DNSServer pointer for the
</span>                <span class="enscript-comment">// queries to get ADD/RMV events. To lookup the question, we can't use
</span>                <span class="enscript-comment">// ExpectingUnicastResponseForRecord as the port numbers don't match. uDNS_recvLLQRespose
</span>                <span class="enscript-comment">// has already matched the question using the 64 bit Id in the packet and we use that here.
</span>
                <span class="enscript-keyword">if</span> (llqMatch != mDNSNULL) m-&gt;rec.r.resrec.rDNSServer = uDNSServer = llqMatch-&gt;qDNSServer;

                <span class="enscript-comment">// If this is a DNSSEC question that is also LongLived, don't accept records from the
</span>                <span class="enscript-comment">// Additional/Authority section blindly. We need to go through IsAcceptableResponse below
</span>                <span class="enscript-comment">// so that NSEC/NSEC3 record are cached in the nseclist if we accept them. This can happen
</span>                <span class="enscript-comment">// for both negative responses and wildcard expanded positive responses as both of come
</span>                <span class="enscript-comment">// back with NSEC/NSEC3s.
</span>                <span class="enscript-keyword">if</span> (unicastQuestion &amp;&amp; DNSSECQuestion(unicastQuestion))
                    AcceptableResponse = mDNSfalse;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!AcceptableResponse || !dstaddr)
            {
                <span class="enscript-comment">// For responses that come over TCP (Responses that can't fit within UDP) or TLS (Private queries
</span>                <span class="enscript-comment">// that are not long lived e.g., AAAA lookup in a Private domain), it is indicated by !dstaddr.
</span>                <span class="enscript-comment">// Even though it is AcceptableResponse, we still need a DNSServer pointer for the resource records that
</span>                <span class="enscript-comment">// we create.
</span>
                DNSQuestion *q = ExpectingUnicastResponseForRecord(m, srcaddr, ResponseSrcLocal, dstport, response-&gt;h.id, &amp;m-&gt;rec.r, !dstaddr);

                <span class="enscript-comment">// Initialize the DNS server on the resource record which will now filter what questions we answer with
</span>                <span class="enscript-comment">// this record.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// We could potentially lookup the DNS server based on the source address, but that may not work always
</span>                <span class="enscript-comment">// and that's why ExpectingUnicastResponseForRecord does not try to verify whether the response came
</span>                <span class="enscript-comment">// from the DNS server that queried. We follow the same logic here. If we can find a matching quetion based
</span>                <span class="enscript-comment">// on the &quot;id&quot; and &quot;source port&quot;, then this response answers the question and assume the response
</span>                <span class="enscript-comment">// came from the same DNS server that we sent the query to.
</span>
                <span class="enscript-keyword">if</span> (q != mDNSNULL)
                {
                    AcceptableResponse = mDNStrue;
                    <span class="enscript-keyword">if</span> (!InterfaceID)
                    {
                        debugf(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: InterfaceID %p %##s (%s)&quot;</span>, q-&gt;InterfaceID, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                        m-&gt;rec.r.resrec.rDNSServer = uDNSServer = q-&gt;qDNSServer;
                        <span class="enscript-keyword">if</span> (!unicastQuestion) unicastQuestion = q;      <span class="enscript-comment">//  Acceptable responses to unicast questions need to have (unicastQuestion != nil)
</span>                    }
                    <span class="enscript-keyword">else</span>
                    {
                        <span class="enscript-comment">// Accept all remaining records in this unicast response to an mDNS query.
</span>                        recordAcceptedInResponse = mDNStrue;
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                               <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Accepting response for query: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                               q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));
                    }
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// If we can't find a matching question, we need to see whether we have seen records earlier that matched
</span>                    <span class="enscript-comment">// the question. The code below does that. So, make this record unacceptable for now
</span>                    <span class="enscript-keyword">if</span> (!InterfaceID)
                    {
                        debugf(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Can't find question for record name %##s&quot;</span>, m-&gt;rec.r.resrec.name-&gt;c);
                        AcceptableResponse = mDNSfalse;
                    }
                }
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (llintf &amp;&amp; llintf-&gt;IgnoreIPv4LL &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_A)
        {
            <span class="enscript-comment">// There are some routers (rare, thankfully) that generate bogus ARP responses for
</span>            <span class="enscript-comment">// any IPv4 address they dont recognize, including RFC 3927 IPv4 link-local addresses.
</span>            <span class="enscript-comment">// To work with these broken routers, client devices need to blacklist these broken
</span>            <span class="enscript-comment">// routers and ignore their bogus ARP responses. Some devices implement a technique
</span>            <span class="enscript-comment">// such as the one described in US Patent 7436783, which lets clients detect and
</span>            <span class="enscript-comment">// ignore these broken routers: &lt;<a href="https://www.google.com/patents/US7436783">https://www.google.com/patents/US7436783</a>&gt;
</span>
            <span class="enscript-comment">// OS X and iOS do not implement this defensive mechanism, instead taking a simpler
</span>            <span class="enscript-comment">// approach of just detecting these broken routers and completely disabling IPv4
</span>            <span class="enscript-comment">// link-local communication on interfaces where a broken router is detected.
</span>            <span class="enscript-comment">// OS X and iOS set the IFEF_ARPLL interface flag on interfaces
</span>            <span class="enscript-comment">// that are deemed safe for IPv4 link-local communication;
</span>            <span class="enscript-comment">// the flag is cleared on interfaces where a broken router is detected.
</span>
            <span class="enscript-comment">// OS X and iOS will not even try to communicate with an IPv4
</span>            <span class="enscript-comment">// link-local destination on an interface without the IFEF_ARPLL flag set.
</span>            <span class="enscript-comment">// This can cause some badly written applications to freeze for a long time if they
</span>            <span class="enscript-comment">// attempt to connect to an IPv4 link-local destination address and then wait for
</span>            <span class="enscript-comment">// that connection attempt to time out before trying other candidate addresses.
</span>
            <span class="enscript-comment">// To mask this client bug, we suppress acceptance of IPv4 link-local address
</span>            <span class="enscript-comment">// records on interfaces where we know the OS will be unwilling even to attempt
</span>            <span class="enscript-comment">// communication with those IPv4 link-local destination addresses.
</span>            <span class="enscript-comment">// &lt;rdar://problem/9400639&gt; kSuppress IPv4LL answers on interfaces without IFEF_ARPLL
</span>
            <span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> rr = &amp;m-&gt;rec.r;
            <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;smallrdatastorage.data;
            <span class="enscript-keyword">if</span> (mDNSv4AddressIsLinkLocal(&amp;rdb-&gt;ipv4))
            {
                LogInfo(<span class="enscript-string">&quot;mDNSResponder: Dropping LinkLocal packet %s&quot;</span>, CRDisplayString(m, &amp;m-&gt;rec.r));
                mDNSCoreResetRecord(m);
                <span class="enscript-keyword">continue</span>;
            }
        }

        <span class="enscript-comment">// 1. Check that this packet resource record does not conflict with any of ours
</span>        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(response-&gt;h.id) &amp;&amp; m-&gt;rec.r.resrec.rrtype != kDNSType_NSEC)
        {
            <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
                LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
            m-&gt;CurrentRecord = m-&gt;ResourceRecords;
            <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
            {
                AuthRecord *rr = m-&gt;CurrentRecord;
                m-&gt;CurrentRecord = rr-&gt;next;
                <span class="enscript-comment">// We accept all multicast responses, and unicast responses resulting from queries we issued
</span>                <span class="enscript-comment">// For other unicast responses, this code accepts them only for responses with an
</span>                <span class="enscript-comment">// (apparently) local source address that pertain to a record of our own that's in probing state
</span>                <span class="enscript-keyword">if</span> (!AcceptableResponse &amp;&amp; !(ResponseSrcLocal &amp;&amp; rr-&gt;resrec.RecordType == kDNSRecordTypeUnique)) <span class="enscript-keyword">continue</span>;

                <span class="enscript-keyword">if</span> (PacketRRMatchesSignature(&amp;m-&gt;rec.r, rr))        <span class="enscript-comment">// If interface, name, type (if shared record) and class match...
</span>                {
                    <span class="enscript-comment">// ... check to see if type and rdata are identical
</span>                    <span class="enscript-keyword">if</span> (IdenticalSameNameRecord(&amp;m-&gt;rec.r.resrec, &amp;rr-&gt;resrec))
                    {
                        <span class="enscript-comment">// If the RR in the packet is identical to ours, just check they're not trying to lower the TTL on us
</span>                        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rroriginalttl &gt;= rr-&gt;resrec.rroriginalttl/2 || m-&gt;SleepState)
                        {
                            <span class="enscript-comment">// If we were planning to send on this -- and only this -- interface, then we don't need to any more
</span>                            <span class="enscript-keyword">if</span>      (rr-&gt;ImmedAnswer == InterfaceID) { rr-&gt;ImmedAnswer = mDNSNULL; rr-&gt;ImmedUnicast = mDNSfalse; }
                        }
                        <span class="enscript-keyword">else</span>
                        {
                            <span class="enscript-keyword">if</span>      (rr-&gt;ImmedAnswer == mDNSNULL)    { rr-&gt;ImmedAnswer = InterfaceID;       m-&gt;NextScheduledResponse = m-&gt;timenow; }
                            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;ImmedAnswer != InterfaceID) { rr-&gt;ImmedAnswer = mDNSInterfaceMark; m-&gt;NextScheduledResponse = m-&gt;timenow; }
                        }
                    }
                    <span class="enscript-comment">// else, the packet RR has different type or different rdata -- check to see if this is a conflict
</span>                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rroriginalttl &gt; 0 &amp;&amp; PacketRRConflict(m, rr, &amp;m-&gt;rec.r))
                    {
                        LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Pkt Record: %08lX %s (interface %d)&quot;</span>,
                            m-&gt;rec.r.resrec.rdatahash, CRDisplayString(m, &amp;m-&gt;rec.r), IIDPrintable(InterfaceID));
                        LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Our Record: %08lX %s&quot;</span>, rr-&gt;resrec.rdatahash, ARDisplayString(m, rr));

                        <span class="enscript-comment">// If this record is marked DependentOn another record for conflict detection purposes,
</span>                        <span class="enscript-comment">// then *that* record has to be bumped back to probing state to resolve the conflict
</span>                        <span class="enscript-keyword">if</span> (rr-&gt;DependentOn)
                        {
                            <span class="enscript-keyword">while</span> (rr-&gt;DependentOn) rr = rr-&gt;DependentOn;
                            LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Dep Record: %08lX %s&quot;</span>, rr-&gt;resrec.rdatahash, ARDisplayString(m, rr));
                        }

                        <span class="enscript-comment">// If we've just whacked this record's ProbeCount, don't need to do it again
</span>                        <span class="enscript-keyword">if</span> (rr-&gt;ProbeCount &gt; DefaultProbeCountForTypeUnique)
                            LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Already reset to Probing: %s&quot;</span>, ARDisplayString(m, rr));
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;ProbeCount == DefaultProbeCountForTypeUnique)
                            LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Ignoring response received before we even began probing: %s&quot;</span>, ARDisplayString(m, rr));
                        <span class="enscript-keyword">else</span>
                        {
                            LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Received from %#a:%d %s&quot;</span>, srcaddr, mDNSVal16(srcport), CRDisplayString(m, &amp;m-&gt;rec.r));
                            <span class="enscript-comment">// If we'd previously verified this record, put it back to probing state and try again
</span>                            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeVerified)
                            {
                                LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Resetting to Probing: %s&quot;</span>, ARDisplayString(m, rr));
                                rr-&gt;resrec.RecordType     = kDNSRecordTypeUnique;
                                <span class="enscript-comment">// We set ProbeCount to one more than the usual value so we know we've already touched this record.
</span>                                <span class="enscript-comment">// This is because our single probe for &quot;example-name.local&quot; could yield a response with (say) two A records and
</span>                                <span class="enscript-comment">// three AAAA records in it, and we don't want to call RecordProbeFailure() five times and count that as five conflicts.
</span>                                <span class="enscript-comment">// This special value is recognised and reset to DefaultProbeCountForTypeUnique in SendQueries().
</span>                                rr-&gt;ProbeCount     = DefaultProbeCountForTypeUnique + 1;
                                rr-&gt;AnnounceCount  = InitialAnnounceCount;
                                InitializeLastAPTime(m, rr);
                                RecordProbeFailure(m, rr);  <span class="enscript-comment">// Repeated late conflicts also cause us to back off to the slower probing rate
</span>                            }
                            <span class="enscript-comment">// If we're probing for this record, we just failed
</span>                            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique)
                            {
	                            <span class="enscript-comment">// At this point in the code, we're probing for uniqueness.
</span>	                            <span class="enscript-comment">// We've sent at least one probe (rr-&gt;ProbeCount &lt; DefaultProbeCountForTypeUnique)
</span>	                            <span class="enscript-comment">// but we haven't completed probing yet (rr-&gt;resrec.RecordType == kDNSRecordTypeUnique).
</span>                                <span class="enscript-comment">// Before we call deregister, check if this is a packet we registered with the sleep proxy.
</span>                                <span class="enscript-keyword">if</span> (!mDNSCoreRegisteredProxyRecord(m, rr))
                                {
                                    <span class="enscript-keyword">if</span> ((rr-&gt;ProbingConflictCount == 0) || (m-&gt;MPktNum != rr-&gt;LastConflictPktNum))
                                    {
                                        <span class="enscript-type">const</span> NetworkInterfaceInfo *<span class="enscript-type">const</span> intf = FirstInterfaceForID(m, InterfaceID);
                                        rr-&gt;ProbingConflictCount++;
                                        rr-&gt;LastConflictPktNum = m-&gt;MPktNum;
                                        <span class="enscript-keyword">if</span> (ResponseMCast &amp;&amp; (!intf || intf-&gt;SupportsUnicastMDNSResponse) &amp;&amp;
                                            (rr-&gt;ProbingConflictCount &lt;= kMaxAllowedMCastProbingConflicts))
                                        {
                                            LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: ProbeCount %d; restarting probing after %d-tick pause due to possibly &quot;</span>
                                                <span class="enscript-string">&quot;spurious multicast conflict (%d/%d) via interface %d for %s&quot;</span>,
                                                rr-&gt;ProbeCount, kProbingConflictPauseDuration, rr-&gt;ProbingConflictCount,
                                                kMaxAllowedMCastProbingConflicts, IIDPrintable(InterfaceID), ARDisplayString(m, rr));
                                            rr-&gt;ProbeCount = DefaultProbeCountForTypeUnique;
                                            rr-&gt;LastAPTime = m-&gt;timenow + kProbingConflictPauseDuration - rr-&gt;ThisAPInterval;
                                            SetNextAnnounceProbeTime(m, rr);
                                        }
                                        <span class="enscript-keyword">else</span>
                                        {
                                            LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: ProbeCount %d; will deregister %s due to %scast conflict via interface %d&quot;</span>,
                                                rr-&gt;ProbeCount, ARDisplayString(m, rr), ResponseMCast ? <span class="enscript-string">&quot;multi&quot;</span> : <span class="enscript-string">&quot;uni&quot;</span>, IIDPrintable(InterfaceID));
                                            m-&gt;mDNSStats.NameConflicts++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
                                            <span class="enscript-comment">// See if this record was also registered with any D2D plugins.
</span>                                            D2D_stop_advertising_record(rr);
#<span class="enscript-reference">endif</span>
                                            mDNS_Deregister_internal(m, rr, mDNS_Dereg_conflict);
                                        }
                                    }
                                }
                            }
                            <span class="enscript-comment">// We assumed this record must be unique, but we were wrong. (e.g. There are two mDNSResponders on the
</span>                            <span class="enscript-comment">// same machine giving different answers for the reverse mapping record, or there are two machines on the
</span>                            <span class="enscript-comment">// network using the same IP address.) This is simply a misconfiguration, and there's nothing we can do
</span>                            <span class="enscript-comment">// to fix it -- e.g. it's not our job to be trying to change the machine's IP address. We just discard our
</span>                            <span class="enscript-comment">// record to avoid continued conflicts (as we do for a conflict on our Unique records) and get on with life.
</span>                            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeKnownUnique)
                            {
                                LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Unexpected conflict discarding %s&quot;</span>, ARDisplayString(m, rr));
                                m-&gt;mDNSStats.KnownUniqueNameConflicts++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
                                D2D_stop_advertising_record(rr);
#<span class="enscript-reference">endif</span>
                                mDNS_Deregister_internal(m, rr, mDNS_Dereg_conflict);
                            }
                            <span class="enscript-keyword">else</span>
                                LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Unexpected record type %X %s&quot;</span>, rr-&gt;resrec.RecordType, ARDisplayString(m, rr));
                        }
                    }
                    <span class="enscript-comment">// Else, matching signature, different type or rdata, but not a considered a conflict.
</span>                    <span class="enscript-comment">// If the packet record has the cache-flush bit set, then we check to see if we
</span>                    <span class="enscript-comment">// have any record(s) of the same type that we should re-assert to rescue them
</span>                    <span class="enscript-comment">// (see note about &quot;multi-homing and bridged networks&quot; at the end of this function).
</span>                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rrtype == rr-&gt;resrec.rrtype)
                        <span class="enscript-keyword">if</span> ((m-&gt;rec.r.resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) &amp;&amp; (mDNSu32)(m-&gt;timenow - rr-&gt;LastMCTime) &gt; (mDNSu32)mDNSPlatformOneSecond/2)
                        { rr-&gt;ImmedAnswer = mDNSInterfaceMark; m-&gt;NextScheduledResponse = m-&gt;timenow; }
                }
            }
        }

        nseclist = mDNSfalse;
        <span class="enscript-keyword">if</span> (!AcceptableResponse)
        {
            AcceptableResponse = IsResponseAcceptable(m, CacheFlushRecords, unicastQuestion, &amp;nseclist);
            <span class="enscript-keyword">if</span> (AcceptableResponse) m-&gt;rec.r.resrec.rDNSServer = uDNSServer;
        }

        <span class="enscript-comment">// 2. See if we want to add this packet resource record to our cache
</span>        <span class="enscript-comment">// We only try to cache answers if we have a cache to put them in
</span>        <span class="enscript-comment">// Also, we ignore any apparent attempts at cache poisoning unicast to us that do not answer any outstanding active query
</span>        <span class="enscript-keyword">if</span> (!AcceptableResponse) {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;[Q%d] mDNSCoreReceiveResponse ignoring &quot;</span> PRI_S,
                   mDNSVal16(response-&gt;h.id), CRDisplayString(m, &amp;m-&gt;rec.r));
        }
        <span class="enscript-keyword">if</span> (m-&gt;rrcache_size &amp;&amp; AcceptableResponse)
        {
            <span class="enscript-type">const</span> mDNSu32 slot = HashSlotFromNameHash(m-&gt;rec.r.resrec.namehash);
            CacheGroup *cg = CacheGroupForRecord(m, &amp;m-&gt;rec.r.resrec);
            CacheRecord *rr = mDNSNULL;

            <span class="enscript-comment">// 2a. Check if this packet resource record is already in our cache.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// If this record should go in the nseclist, don't look in the cache for updating it.
</span>            <span class="enscript-comment">// They are supposed to be cached under the &quot;nsec&quot; field of the cache record for
</span>            <span class="enscript-comment">// validation. Just create the cache record. 
</span>            <span class="enscript-keyword">if</span> (!nseclist)
            {
                rr = mDNSCoreReceiveCacheCheck(m, response, LLQType, slot, cg, unicastQuestion, &amp;cfp, &amp;NSECCachePtr, InterfaceID);
            }

            <span class="enscript-comment">// If packet resource record not in our cache, add it now
</span>            <span class="enscript-comment">// (unless it is just a deletion of a record we never had, in which case we don't care)
</span>            <span class="enscript-keyword">if</span> (!rr &amp;&amp; m-&gt;rec.r.resrec.rroriginalttl &gt; 0)
            {
                <span class="enscript-type">const</span> mDNSBool AddToCFList = (m-&gt;rec.r.resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) &amp;&amp; (LLQType != uDNS_LLQ_Events);
                mDNSs32 delay;

                <span class="enscript-keyword">if</span> (AddToCFList)
                    delay = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond);
                <span class="enscript-keyword">else</span>
                    delay = CheckForSoonToExpireRecords(m, m-&gt;rec.r.resrec.name, m-&gt;rec.r.resrec.namehash);

                <span class="enscript-comment">// If unique, assume we may have to delay delivery of this 'add' event.
</span>                <span class="enscript-comment">// Below, where we walk the CacheFlushRecords list, we either call CacheRecordDeferredAdd()
</span>                <span class="enscript-comment">// to immediately to generate answer callbacks, or we call ScheduleNextCacheCheckTime()
</span>                <span class="enscript-comment">// to schedule an mDNS_Execute task at the appropriate time.
</span>                rr = CreateNewCacheEntry(m, slot, cg, delay, !nseclist, srcaddr);
                <span class="enscript-keyword">if</span> (rr)
                {
                    rr-&gt;responseFlags = response-&gt;h.flags;
                    <span class="enscript-comment">// If we are not creating signatures, then we need to inform DNSSEC so that
</span>                    <span class="enscript-comment">// it does not wait forever. Don't do this if we got NSEC records
</span>                    <span class="enscript-comment">// as it indicates that this name does not exist.
</span>                    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_RRSIG &amp;&amp; !nseclist)
                    {
                        rrsigsCreated = mDNStrue;
                    }
                    <span class="enscript-comment">// Remember whether we created a cache record in response to a DNSSEC question.
</span>                    <span class="enscript-comment">// This helps DNSSEC code not to reissue the question to fetch the DNSSEC records.
</span>                    rr-&gt;CRDNSSECQuestion = 0;
                    <span class="enscript-keyword">if</span> (unicastQuestion &amp;&amp; DNSSECQuestion(unicastQuestion))
                    {
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                               <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: CRDNSSECQuestion set for new record &quot;</span> PRI_S <span class="enscript-string">&quot;, question &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                               unicastQuestion-&gt;request_id, mDNSVal16(unicastQuestion-&gt;TargetQID), CRDisplayString(m, rr),
                               DM_NAME_PARAM(unicastQuestion-&gt;qname.c), DNSTypeName(unicastQuestion-&gt;qtype));
                        rr-&gt;CRDNSSECQuestion = 1;
                    }
                    <span class="enscript-comment">// NSEC/NSEC3 records and its signatures are cached with the negative cache entry
</span>                    <span class="enscript-comment">// which we should be creating below. It is also needed in the wildcard
</span>                    <span class="enscript-comment">// expanded answer case and in that case it is cached along with the answer.
</span>                    <span class="enscript-keyword">if</span> (nseclist)
                    {
                        rr-&gt;TimeRcvd = m-&gt;timenow;
                        *nsecp = rr;
                        nsecp = &amp;rr-&gt;next;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (AddToCFList)
                    {
                        *cfp = rr;
                        cfp = &amp;rr-&gt;NextInCFList;
                        *cfp = (CacheRecord*)1;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;DelayDelivery)
                    {
                        ScheduleNextCacheCheckTime(m, slot, rr-&gt;DelayDelivery);
                    }
                }
            }
        }
        mDNSCoreResetRecord(m);
    }

<span class="enscript-reference">exit</span>:
    mDNSCoreResetRecord(m);

    <span class="enscript-comment">// If we've just received one or more records with their cache flush bits set,
</span>    <span class="enscript-comment">// then scan that cache slot to see if there are any old stale records we need to flush
</span>    <span class="enscript-keyword">while</span> (CacheFlushRecords != (CacheRecord*)1)
    {
        CacheRecord *r1 = CacheFlushRecords, *r2;
        <span class="enscript-type">const</span> mDNSu32 slot = HashSlotFromNameHash(r1-&gt;resrec.namehash);
        <span class="enscript-type">const</span> CacheGroup *cg = CacheGroupForRecord(m, &amp;r1-&gt;resrec);
        mDNSBool purgedRecords = mDNSfalse;
        CacheFlushRecords = CacheFlushRecords-&gt;NextInCFList;
        r1-&gt;NextInCFList = mDNSNULL;

        <span class="enscript-comment">// Look for records in the cache with the same signature as this new one with the cache flush
</span>        <span class="enscript-comment">// bit set, and either (a) if they're fresh, just make sure the whole RRSet has the same TTL
</span>        <span class="enscript-comment">// (as required by DNS semantics) or (b) if they're old, mark them for deletion in one second.
</span>        <span class="enscript-comment">// We make these TTL adjustments *only* for records that still have *more* than one second
</span>        <span class="enscript-comment">// remaining to live. Otherwise, a record that we tagged for deletion half a second ago
</span>        <span class="enscript-comment">// (and now has half a second remaining) could inadvertently get its life extended, by either
</span>        <span class="enscript-comment">// (a) if we got an explicit goodbye packet half a second ago, the record would be considered
</span>        <span class="enscript-comment">// &quot;fresh&quot; and would be incorrectly resurrected back to the same TTL as the rest of the RRSet,
</span>        <span class="enscript-comment">// or (b) otherwise, the record would not be fully resurrected, but would be reset to expire
</span>        <span class="enscript-comment">// in one second, thereby inadvertently delaying its actual expiration, instead of hastening it.
</span>        <span class="enscript-comment">// If this were to happen repeatedly, the record's expiration could be deferred indefinitely.
</span>        <span class="enscript-comment">// To avoid this, we need to ensure that the cache flushing operation will only act to
</span>        <span class="enscript-comment">// *decrease* a record's remaining lifetime, never *increase* it.
</span>        <span class="enscript-keyword">for</span> (r2 = cg ? cg-&gt;members : mDNSNULL; r2; r2=r2-&gt;next)
        {
            mDNSu16 id1;
            mDNSu16 id2;
            <span class="enscript-keyword">if</span> (!r1-&gt;resrec.InterfaceID)
            {
                id1 = (r1-&gt;resrec.rDNSServer ? r1-&gt;resrec.rDNSServer-&gt;resGroupID : 0);
                id2 = (r2-&gt;resrec.rDNSServer ? r2-&gt;resrec.rDNSServer-&gt;resGroupID : 0);
            }
            <span class="enscript-keyword">else</span>
            {
                id1 = id2 = 0;
            }
            <span class="enscript-comment">// When we receive new RRSIGs e.g., for DNSKEY record, we should not flush the old
</span>            <span class="enscript-comment">// RRSIGS e.g., for TXT record. To do so, we need to look at the typeCovered field of
</span>            <span class="enscript-comment">// the new RRSIG that we received. Process only if the typeCovered matches.
</span>            <span class="enscript-keyword">if</span> ((r1-&gt;resrec.rrtype == r2-&gt;resrec.rrtype) &amp;&amp; (r1-&gt;resrec.rrtype == kDNSType_RRSIG))
            {
                rdataRRSig *rrsig1 = (rdataRRSig *)(((RDataBody2 *)(r1-&gt;resrec.rdata-&gt;u.data))-&gt;data);
                rdataRRSig *rrsig2 = (rdataRRSig *)(((RDataBody2 *)(r2-&gt;resrec.rdata-&gt;u.data))-&gt;data);
                <span class="enscript-keyword">if</span> (swap16(rrsig1-&gt;typeCovered) != swap16(rrsig2-&gt;typeCovered))
                {
                    debugf(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: Received RRSIG typeCovered %s, found %s, not processing&quot;</span>,
                        DNSTypeName(swap16(rrsig1-&gt;typeCovered)), DNSTypeName(swap16(rrsig2-&gt;typeCovered)));
                    <span class="enscript-keyword">continue</span>;
                }
            }

            <span class="enscript-comment">// For Unicast (null InterfaceID) the resolver IDs should also match
</span>            <span class="enscript-keyword">if</span> ((r1-&gt;resrec.InterfaceID == r2-&gt;resrec.InterfaceID) &amp;&amp;
                (r1-&gt;resrec.InterfaceID || (id1 == id2)) &amp;&amp;
                r1-&gt;resrec.rrtype      == r2-&gt;resrec.rrtype &amp;&amp;
                r1-&gt;resrec.rrclass     == r2-&gt;resrec.rrclass)
            {
                <span class="enscript-keyword">if</span> (r1-&gt;resrec.mortality == Mortality_Mortal &amp;&amp; r2-&gt;resrec.mortality != Mortality_Mortal)
                {
                    verbosedebugf(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: R1(%p) is being immortalized by R2(%p)&quot;</span>, r1, r2);
                    r1-&gt;resrec.mortality = Mortality_Immortal;   <span class="enscript-comment">//  Immortalize the replacement record
</span>                }

                <span class="enscript-comment">// If record is recent, just ensure the whole RRSet has the same TTL (as required by DNS semantics)
</span>                <span class="enscript-comment">// else, if record is old, mark it to be flushed
</span>                <span class="enscript-keyword">if</span> (m-&gt;timenow - r2-&gt;TimeRcvd &lt; mDNSPlatformOneSecond &amp;&amp; RRExpireTime(r2) - m-&gt;timenow &gt; mDNSPlatformOneSecond)
                {
                    <span class="enscript-comment">// If we find mismatched TTLs in an RRSet, correct them.
</span>                    <span class="enscript-comment">// We only do this for records with a TTL of 2 or higher. It's possible to have a
</span>                    <span class="enscript-comment">// goodbye announcement with the cache flush bit set (or a case-change on record rdata,
</span>                    <span class="enscript-comment">// which we treat as a goodbye followed by an addition) and in that case it would be
</span>                    <span class="enscript-comment">// inappropriate to synchronize all the other records to a TTL of 0 (or 1).
</span>
                    <span class="enscript-comment">// We suppress the message for the specific case of correcting from 240 to 60 for type TXT,
</span>                    <span class="enscript-comment">// because certain early Bonjour devices are known to have this specific mismatch, and
</span>                    <span class="enscript-comment">// there's no point filling syslog with messages about something we already know about.
</span>                    <span class="enscript-comment">// We also don't log this for uDNS responses, since a caching name server is obliged
</span>                    <span class="enscript-comment">// to give us an aged TTL to correct for how long it has held the record,
</span>                    <span class="enscript-comment">// so our received TTLs are expected to vary in that case
</span>
                    <span class="enscript-comment">// We also suppress log message in the case of SRV records that are received
</span>                    <span class="enscript-comment">// with a TTL of 4500 that are already cached with a TTL of 120 seconds, since
</span>                    <span class="enscript-comment">// this behavior was observed for a number of discoveryd based AppleTV's in iOS 8
</span>                    <span class="enscript-comment">// GM builds.
</span>                    <span class="enscript-keyword">if</span> (r2-&gt;resrec.rroriginalttl != r1-&gt;resrec.rroriginalttl &amp;&amp; r1-&gt;resrec.rroriginalttl &gt; 1)
                    {
                        <span class="enscript-keyword">if</span> (!(r2-&gt;resrec.rroriginalttl == 240 &amp;&amp; r1-&gt;resrec.rroriginalttl == 60 &amp;&amp; r2-&gt;resrec.rrtype == kDNSType_TXT) &amp;&amp;
                            !(r2-&gt;resrec.rroriginalttl == 120 &amp;&amp; r1-&gt;resrec.rroriginalttl == 4500 &amp;&amp; r2-&gt;resrec.rrtype == kDNSType_SRV) &amp;&amp;
                            mDNSOpaque16IsZero(response-&gt;h.id))
                            LogInfo(<span class="enscript-string">&quot;Correcting TTL from %4d to %4d for %s&quot;</span>,
                                    r2-&gt;resrec.rroriginalttl, r1-&gt;resrec.rroriginalttl, CRDisplayString(m, r2));
                        r2-&gt;resrec.rroriginalttl = r1-&gt;resrec.rroriginalttl;
                    }
                    r2-&gt;TimeRcvd = m-&gt;timenow;
                    SetNextCacheCheckTimeForRecord(m, r2);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r2-&gt;resrec.InterfaceID) <span class="enscript-comment">// else, if record is old, mark it to be flushed
</span>                {
                    verbosedebugf(<span class="enscript-string">&quot;Cache flush new %p age %d expire in %d %s&quot;</span>, r1, m-&gt;timenow - r1-&gt;TimeRcvd, RRExpireTime(r1) - m-&gt;timenow, CRDisplayString(m, r1));
                    verbosedebugf(<span class="enscript-string">&quot;Cache flush old %p age %d expire in %d %s&quot;</span>, r2, m-&gt;timenow - r2-&gt;TimeRcvd, RRExpireTime(r2) - m-&gt;timenow, CRDisplayString(m, r2));
                    <span class="enscript-comment">// We set stale records to expire in one second.
</span>                    <span class="enscript-comment">// This gives the owner a chance to rescue it if necessary.
</span>                    <span class="enscript-comment">// This is important in the case of multi-homing and bridged networks:
</span>                    <span class="enscript-comment">//   Suppose host X is on Ethernet. X then connects to an AirPort base station, which happens to be
</span>                    <span class="enscript-comment">//   bridged onto the same Ethernet. When X announces its AirPort IP address with the cache-flush bit
</span>                    <span class="enscript-comment">//   set, the AirPort packet will be bridged onto the Ethernet, and all other hosts on the Ethernet
</span>                    <span class="enscript-comment">//   will promptly delete their cached copies of the (still valid) Ethernet IP address record.
</span>                    <span class="enscript-comment">//   By delaying the deletion by one second, we give X a change to notice that this bridging has
</span>                    <span class="enscript-comment">//   happened, and re-announce its Ethernet IP address to rescue it from deletion from all our caches.
</span>
                    <span class="enscript-comment">// We set UnansweredQueries to MaxUnansweredQueries to avoid expensive and unnecessary
</span>                    <span class="enscript-comment">// final expiration queries for this record.
</span>
                    <span class="enscript-comment">// If a record is deleted twice, first with an explicit DE record, then a second time by virtue of the cache
</span>                    <span class="enscript-comment">// flush bit on the new record replacing it, then we allow the record to be deleted immediately, without the usual
</span>                    <span class="enscript-comment">// one-second grace period. This improves responsiveness for mDNS_Update(), as used for things like iChat status updates.
</span>                    <span class="enscript-comment">// &lt;rdar://problem/5636422&gt; Updating TXT records is too slow
</span>                    <span class="enscript-comment">// We check for &quot;rroriginalttl == 1&quot; because we want to include records tagged by the &quot;packet TTL is zero&quot; check above,
</span>                    <span class="enscript-comment">// which sets rroriginalttl to 1, but not records tagged by the rdata case-change check, which sets rroriginalttl to 0.
</span>                    <span class="enscript-keyword">if</span> (r2-&gt;TimeRcvd == m-&gt;timenow &amp;&amp; r2-&gt;resrec.rroriginalttl == 1 &amp;&amp; r2-&gt;UnansweredQueries == MaxUnansweredQueries)
                    {
                        LogInfo(<span class="enscript-string">&quot;Cache flush for DE record %s&quot;</span>, CRDisplayString(m, r2));
                        r2-&gt;resrec.rroriginalttl = 0;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (RRExpireTime(r2) - m-&gt;timenow &gt; mDNSPlatformOneSecond)
                    {
                        <span class="enscript-comment">// We only set a record to expire in one second if it currently has *more* than a second to live
</span>                        <span class="enscript-comment">// If it's already due to expire in a second or less, we just leave it alone
</span>                        r2-&gt;resrec.rroriginalttl = 1;
                        r2-&gt;UnansweredQueries = MaxUnansweredQueries;
                        r2-&gt;TimeRcvd = m-&gt;timenow - 1;
                        <span class="enscript-comment">// We use (m-&gt;timenow - 1) instead of m-&gt;timenow, because we use that to identify records
</span>                        <span class="enscript-comment">// that we marked for deletion via an explicit DE record
</span>                    }
                    SetNextCacheCheckTimeForRecord(m, r2);
                }
                <span class="enscript-keyword">else</span>
                {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                    <span class="enscript-keyword">if</span> (r2-&gt;resrec.mortality == Mortality_Ghost)
                    {
                        DNSQuestion * q;
                        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
                        {
                            <span class="enscript-keyword">if</span> (!q-&gt;LongLived &amp;&amp; ActiveQuestion(q) &amp;&amp;
                                CacheRecordAnswersQuestion(r2, q) &amp;&amp;
                                q-&gt;metrics.expiredAnswerState == ExpiredAnswer_AnsweredWithExpired)
                            {
                                q-&gt;metrics.expiredAnswerState = ExpiredAnswer_ExpiredAnswerChanged;
                            }
                        }
                    }
#<span class="enscript-reference">endif</span>
                    <span class="enscript-comment">// Old uDNS records are scheduled to be purged instead of given at most one second to live.
</span>                    r2-&gt;resrec.mortality = Mortality_Mortal;       <span class="enscript-comment">//  We want it purged, so remove any immortality
</span>                    mDNS_PurgeCacheResourceRecord(m, r2);
                    purgedRecords = mDNStrue;
                }
            }
        }

        <span class="enscript-keyword">if</span> (r1-&gt;DelayDelivery)  <span class="enscript-comment">// If we were planning to delay delivery of this record, see if we still need to
</span>        {
            <span class="enscript-comment">// If we had a unicast question for this response with at least one positive answer and we
</span>            <span class="enscript-comment">// have NSECRecords, it is most likely a wildcard expanded answer. Cache the NSEC and its
</span>            <span class="enscript-comment">// signatures along with the cache record which will be used for validation later. If
</span>            <span class="enscript-comment">// we rescued a few records earlier in this function, then NSECCachePtr would be set. In that
</span>            <span class="enscript-comment">// use that instead.
</span>            <span class="enscript-keyword">if</span> (response-&gt;h.numAnswers &amp;&amp; unicastQuestion &amp;&amp; NSECRecords)
            {
                <span class="enscript-keyword">if</span> (!NSECCachePtr)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                           <span class="enscript-string">&quot;[R%d-&gt;Q%d] mDNSCoreReceiveResponse: Updating NSECCachePtr to &quot;</span> PRI_S,
                           unicastQuestion-&gt;request_id, mDNSVal16(unicastQuestion-&gt;TargetQID), CRDisplayString(m, r1));
                    NSECCachePtr = r1;
                }
                <span class="enscript-comment">// Note: We need to do this before we call CacheRecordDeferredAdd as this
</span>                <span class="enscript-comment">// might start the verification process which needs these NSEC records
</span>                <span class="enscript-keyword">if</span> (!AddNSECSForCacheRecord(m, NSECRecords, NSECCachePtr, rcode))
                {
                    LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: AddNSECSForCacheRecord failed to add NSEC for %s&quot;</span>, CRDisplayString(m, NSECCachePtr));
                    FreeNSECRecords(m, NSECRecords);
                }
                NSECRecords = mDNSNULL;
                NSECCachePtr = mDNSNULL;
            }
            <span class="enscript-keyword">if</span> (r1-&gt;resrec.InterfaceID)
            {
                r1-&gt;DelayDelivery = CheckForSoonToExpireRecords(m, r1-&gt;resrec.name, r1-&gt;resrec.namehash);
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// If uDNS records from an older RRset were scheduled to be purged, then delay delivery slightly to allow
</span>                <span class="enscript-comment">// them to be deleted before any ADD events for this record.
</span>                r1-&gt;DelayDelivery = purgedRecords ? NonZeroTime(m-&gt;timenow) : 0;
            }
            <span class="enscript-comment">// If no longer delaying, deliver answer now, else schedule delivery for the appropriate time
</span>            <span class="enscript-keyword">if</span> (!r1-&gt;DelayDelivery) CacheRecordDeferredAdd(m, r1);
            <span class="enscript-keyword">else</span> ScheduleNextCacheCheckTime(m, slot, r1-&gt;DelayDelivery);
        }
    }

    <span class="enscript-comment">// If we have not consumed the NSEC records yet e.g., just refreshing the cache,
</span>    <span class="enscript-comment">// update them now for future validations.
</span>    <span class="enscript-keyword">if</span> (NSECRecords &amp;&amp; NSECCachePtr)
    {
        LogInfo(<span class="enscript-string">&quot;mDNSCoreReceieveResponse: Updating NSEC records in %s&quot;</span>, CRDisplayString(m, NSECCachePtr));
        <span class="enscript-keyword">if</span> (!AddNSECSForCacheRecord(m, NSECRecords, NSECCachePtr, rcode))
        {
            LogInfo(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: AddNSECSForCacheRecord failed to add NSEC for %s&quot;</span>, CRDisplayString(m, NSECCachePtr));
            FreeNSECRecords(m, NSECRecords);
        }
        NSECRecords = mDNSNULL;
        NSECCachePtr = mDNSNULL;
    }

    <span class="enscript-comment">// If there is at least one answer and we did not create RRSIGs and there was a
</span>    <span class="enscript-comment">// ValidatingResponse question waiting for this response, give a hint that no RRSIGs
</span>    <span class="enscript-comment">// were created. We don't need to give a hint:
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - if we have no answers, the mDNSCoreReceiveNoUnicastAnswers below should
</span>    <span class="enscript-comment">//   generate a negative response
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - if we have NSECRecords, it means we might have a potential proof for
</span>    <span class="enscript-comment">//   non-existence of name that we are looking for
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> (response-&gt;h.numAnswers &amp;&amp; !rrsigsCreated &amp;&amp; DNSSECQuestion &amp;&amp; !NSECRecords)
        mDNSCoreReceiveNoDNSSECAnswers(m, response, end, dstaddr, dstport, InterfaceID);

    <span class="enscript-comment">// See if we need to generate negative cache entries for unanswered unicast questions
</span>    mDNSCoreReceiveNoUnicastAnswers(m, response, end, dstaddr, dstport, InterfaceID, LLQType, rcode, NSECRecords);

    <span class="enscript-keyword">if</span> (McastNSEC3Records)
    {
        debugf(<span class="enscript-string">&quot;mDNSCoreReceiveResponse: McastNSEC3Records not used&quot;</span>);
        FreeNSECRecords(m, McastNSEC3Records);
    }
}

<span class="enscript-comment">// ScheduleWakeup causes all proxy records with WakeUp.HMAC matching mDNSEthAddr 'e' to be deregistered, causing
</span><span class="enscript-comment">// multiple wakeup magic packets to be sent if appropriate, and all records to be ultimately freed after a few seconds.
</span><span class="enscript-comment">// ScheduleWakeup is called on mDNS record conflicts, ARP conflicts, NDP conflicts, or reception of trigger traffic
</span><span class="enscript-comment">// that warrants waking the sleeping host.
</span><span class="enscript-comment">// ScheduleWakeup must be called with the lock held (ScheduleWakeupForList uses mDNS_Deregister_internal)
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ScheduleWakeupForList</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID InterfaceID, mDNSEthAddr *e, AuthRecord *<span class="enscript-type">const</span> thelist)
{
    <span class="enscript-comment">// We need to use the m-&gt;CurrentRecord mechanism here when dealing with DuplicateRecords list as
</span>    <span class="enscript-comment">// mDNS_Deregister_internal deregisters duplicate records immediately as they are not used
</span>    <span class="enscript-comment">// to send wakeups or goodbyes. See the comment in that function for more details. To keep it
</span>    <span class="enscript-comment">// simple, we use the same mechanism for both lists.
</span>    <span class="enscript-keyword">if</span> (!e-&gt;l[0])
    {
        LogMsg(<span class="enscript-string">&quot;ScheduleWakeupForList ERROR: Target HMAC is zero&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    m-&gt;CurrentRecord = thelist;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp; mDNSSameEthAddress(&amp;rr-&gt;WakeUp.HMAC, e))
        {
            LogInfo(<span class="enscript-string">&quot;ScheduleWakeupForList: Scheduling wakeup packets for %s&quot;</span>, ARDisplayString(m, rr));
            mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
        }
        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ScheduleWakeup</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID InterfaceID, mDNSEthAddr *e)
{
    <span class="enscript-keyword">if</span> (!e-&gt;l[0]) { LogMsg(<span class="enscript-string">&quot;ScheduleWakeup ERROR: Target HMAC is zero&quot;</span>); <span class="enscript-keyword">return</span>; }
    ScheduleWakeupForList(m, InterfaceID, e, m-&gt;DuplicateRecords);
    ScheduleWakeupForList(m, InterfaceID, e, m-&gt;ResourceRecords);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SPSRecordCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> ar, mStatus result)
{
    <span class="enscript-keyword">if</span> (result &amp;&amp; result != mStatus_MemFree)
        LogInfo(<span class="enscript-string">&quot;SPS Callback %d %s&quot;</span>, result, ARDisplayString(m, ar));

    <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
    {
        mDNS_Lock(m);
        LogMsg(<span class="enscript-string">&quot;%-7s Conflicting mDNS -- waking %.6a %s&quot;</span>, InterfaceNameForID(m, ar-&gt;resrec.InterfaceID), &amp;ar-&gt;WakeUp.HMAC, ARDisplayString(m, ar));
        <span class="enscript-keyword">if</span> (ar-&gt;WakeUp.HMAC.l[0])
        {
            SendWakeup(m, ar-&gt;resrec.InterfaceID, &amp;ar-&gt;WakeUp.IMAC, &amp;ar-&gt;WakeUp.password, mDNSfalse);  <span class="enscript-comment">// Send one wakeup magic packet
</span>            ScheduleWakeup(m, ar-&gt;resrec.InterfaceID, &amp;ar-&gt;WakeUp.HMAC);                               <span class="enscript-comment">// Schedule all other records with the same owner to be woken
</span>        }
        mDNS_Unlock(m);
    }

    <span class="enscript-keyword">if</span> (result == mStatus_NameConflict || result == mStatus_MemFree)
    {
        m-&gt;ProxyRecords--;
        mDNSPlatformMemFree(ar);
        mDNS_UpdateAllowSleep(m);
    }
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">GetValueForMACAddr</span>(mDNSu8 *ptr, mDNSu8 *limit, mDNSEthAddr *eth)
{
    <span class="enscript-type">int</span>     i;
    mDNSs8  hval   = 0;
    <span class="enscript-type">int</span>     colons = 0;
    mDNSu8  val    = 0;

    <span class="enscript-keyword">for</span> (i = 0; ptr &lt; limit &amp;&amp; *ptr != <span class="enscript-string">' '</span> &amp;&amp; i &lt; 17; i++, ptr++)
    {
        hval = HexVal(*ptr);
        <span class="enscript-keyword">if</span> (hval != -1)
        {
            val &lt;&lt;= 4;
            val |= hval;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">':'</span>)
        {
            <span class="enscript-keyword">if</span> (colons &gt;=5)
            {
                LogMsg(<span class="enscript-string">&quot;GetValueForMACAddr: Address malformed colons %d val %d&quot;</span>, colons, val);
                <span class="enscript-keyword">return</span> mDNSNULL;
            }
            eth-&gt;b[colons] = val;
            colons++;
            val = 0;
        }
    }
    <span class="enscript-keyword">if</span> (colons != 5)
    {
        LogMsg(<span class="enscript-string">&quot;GetValueForMACAddr: Address malformed colons %d&quot;</span>, colons);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    eth-&gt;b[colons] = val;
    <span class="enscript-keyword">return</span> ptr;
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">GetValueForIPv6Addr</span>(mDNSu8 *ptr, mDNSu8 *limit, mDNSv6Addr *v6)
{
    <span class="enscript-type">int</span> hval;
    <span class="enscript-type">int</span> value;
    <span class="enscript-type">int</span> numBytes;
    <span class="enscript-type">int</span> digitsProcessed;
    <span class="enscript-type">int</span> zeroFillStart;
    <span class="enscript-type">int</span> numColons;
    mDNSu8 v6addr[16];

    <span class="enscript-comment">// RFC 3513: Section 2.2 specifies IPv6 presentation format. The following parsing
</span>    <span class="enscript-comment">// handles both (1) and (2) and does not handle embedded IPv4 addresses.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// First forms a address in &quot;v6addr&quot;, then expands to fill the zeroes in and returns
</span>    <span class="enscript-comment">// the result in &quot;v6&quot;
</span>
    numColons = numBytes = value = digitsProcessed = zeroFillStart = 0;
    <span class="enscript-keyword">while</span> (ptr &lt; limit &amp;&amp; *ptr != <span class="enscript-string">' '</span>)
    {
        hval = HexVal(*ptr);
        <span class="enscript-keyword">if</span> (hval != -1)
        {
            value &lt;&lt;= 4;
            value |= hval;
            digitsProcessed = 1;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">':'</span>)
        {
            <span class="enscript-keyword">if</span> (!digitsProcessed)
            {
                <span class="enscript-comment">// If we have already seen a &quot;::&quot;, we should not see one more. Handle the special
</span>                <span class="enscript-comment">// case of &quot;::&quot;
</span>                <span class="enscript-keyword">if</span> (numColons)
                {
                    <span class="enscript-comment">// if we never filled any bytes and the next character is space (we have reached the end)
</span>                    <span class="enscript-comment">// we are done
</span>                    <span class="enscript-keyword">if</span> (!numBytes &amp;&amp; (ptr + 1) &lt; limit &amp;&amp; *(ptr + 1) == <span class="enscript-string">' '</span>)
                    {
                        mDNSPlatformMemZero(v6-&gt;b, 16);
                        <span class="enscript-keyword">return</span> ptr + 1;
                    }
                    LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr: zeroFillStart non-zero %d&quot;</span>, zeroFillStart);
                    <span class="enscript-keyword">return</span> mDNSNULL;
                }

                <span class="enscript-comment">// We processed &quot;::&quot;. We need to fill zeroes later. For now, mark the
</span>                <span class="enscript-comment">// point where we will start filling zeroes from.
</span>                zeroFillStart = numBytes;
                numColons++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ptr + 1) &lt; limit &amp;&amp; *(ptr + 1) == <span class="enscript-string">' '</span>)
            {
                <span class="enscript-comment">// We have a trailing &quot;:&quot; i.e., no more characters after &quot;:&quot;
</span>                LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr: Trailing colon&quot;</span>);
                <span class="enscript-keyword">return</span> mDNSNULL;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// For a fully expanded IPv6 address, we fill the 14th and 15th byte outside of this while
</span>                <span class="enscript-comment">// loop below as there is no &quot;:&quot; at the end. Hence, the last two bytes that can possibly
</span>                <span class="enscript-comment">// filled here is 12 and 13.
</span>                <span class="enscript-keyword">if</span> (numBytes &gt; 13) { LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr:1: numBytes is %d&quot;</span>, numBytes); <span class="enscript-keyword">return</span> mDNSNULL; }

                v6addr[numBytes++] = (mDNSu8) ((value &gt;&gt; 8) &amp; 0xFF);
                v6addr[numBytes++] = (mDNSu8) (value &amp; 0xFF);
                digitsProcessed = value = 0;

                <span class="enscript-comment">// Make sure that we did not fill the 13th and 14th byte above
</span>                <span class="enscript-keyword">if</span> (numBytes &gt; 14) { LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr:2: numBytes is %d&quot;</span>, numBytes); <span class="enscript-keyword">return</span> mDNSNULL; }
            }
        }
        ptr++;
    }

    <span class="enscript-comment">// We should be processing the last set of bytes following the last &quot;:&quot; here
</span>    <span class="enscript-keyword">if</span> (!digitsProcessed)
    {
        LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr: no trailing bytes after colon, numBytes is %d&quot;</span>, numBytes);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }

    <span class="enscript-keyword">if</span> (numBytes &gt; 14) { LogMsg(<span class="enscript-string">&quot;GetValueForIPv6Addr:3: numBytes is %d&quot;</span>, numBytes); <span class="enscript-keyword">return</span> mDNSNULL; }
    v6addr[numBytes++] = (mDNSu8) ((value &gt;&gt; 8) &amp; 0xFF);
    v6addr[numBytes++] = (mDNSu8) (value &amp; 0xFF);

    <span class="enscript-keyword">if</span> (zeroFillStart)
    {
        <span class="enscript-type">int</span> i, j, n;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; zeroFillStart; i++)
            v6-&gt;b[i] = v6addr[i];
        <span class="enscript-keyword">for</span> (j = i, n = 0; n &lt; 16 - numBytes; j++, n++)
            v6-&gt;b[j] = 0;
        <span class="enscript-keyword">for</span> (; j &lt; 16; i++, j++)
            v6-&gt;b[j] = v6addr[i];
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (numBytes == 16)
        mDNSPlatformMemCopy(v6-&gt;b, v6addr, 16);
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;GetValueForIPv6addr: Not enough bytes for IPv6 address, numBytes is %d&quot;</span>, numBytes);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    <span class="enscript-keyword">return</span> ptr;
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">GetValueForIPv4Addr</span>(mDNSu8 *ptr, mDNSu8 *limit, mDNSv4Addr *v4)
{
    mDNSu32 val;
    <span class="enscript-type">int</span> dots = 0;
    val = 0;

    <span class="enscript-keyword">for</span> ( ; ptr &lt; limit &amp;&amp; *ptr != <span class="enscript-string">' '</span>; ptr++)
    {
        <span class="enscript-keyword">if</span> (*ptr &gt;= <span class="enscript-string">'0'</span> &amp;&amp;  *ptr &lt;= <span class="enscript-string">'9'</span>)
            val = val * 10 + *ptr - <span class="enscript-string">'0'</span>;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">'.'</span>)
        {
            <span class="enscript-keyword">if</span> (val &gt; 255 || dots &gt;= 3)
            {
                LogMsg(<span class="enscript-string">&quot;GetValueForIPv4Addr: something wrong ptr(%p) %c, limit %p, dots %d&quot;</span>, ptr, *ptr, limit, dots);
                <span class="enscript-keyword">return</span> mDNSNULL;
            }
            v4-&gt;b[dots++] = val;
            val = 0;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// We have a zero at the end and if we reached that, then we are done.
</span>            <span class="enscript-keyword">if</span> (*ptr == 0 &amp;&amp; ptr == limit - 1 &amp;&amp; dots == 3)
            {
                v4-&gt;b[dots] = val;
                <span class="enscript-keyword">return</span> ptr + 1;
            }
            <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;GetValueForIPv4Addr: something wrong ptr(%p) %c, limit %p, dots %d&quot;</span>, ptr, *ptr, limit, dots); <span class="enscript-keyword">return</span> mDNSNULL; }
        }
    }
    <span class="enscript-keyword">if</span> (dots != 3) { LogMsg(<span class="enscript-string">&quot;GetValueForIPv4Addr: Address malformed dots %d&quot;</span>, dots); <span class="enscript-keyword">return</span> mDNSNULL; }
    v4-&gt;b[dots] = val;
    <span class="enscript-keyword">return</span> ptr;
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">GetValueForKeepalive</span>(mDNSu8 *ptr, mDNSu8 *limit, mDNSu32 *value)
{
    mDNSu32 val;

    val = 0;
    <span class="enscript-keyword">for</span> ( ; ptr &lt; limit &amp;&amp; *ptr != <span class="enscript-string">' '</span>; ptr++)
    {
        <span class="enscript-keyword">if</span> (*ptr &lt; <span class="enscript-string">'0'</span> || *ptr &gt; <span class="enscript-string">'9'</span>)
        {
            <span class="enscript-comment">// We have a zero at the end and if we reached that, then we are done.
</span>            <span class="enscript-keyword">if</span> (*ptr == 0 &amp;&amp; ptr == limit - 1)
            {
                *value = val;
                <span class="enscript-keyword">return</span> ptr + 1;
            }
            <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;GetValueForKeepalive: *ptr %d, ptr %p, limit %p, ptr +1 %d&quot;</span>, *ptr, ptr, limit, *(ptr + 1)); <span class="enscript-keyword">return</span> mDNSNULL; }
        }
        val = val * 10 + *ptr - <span class="enscript-string">'0'</span>;
    }
    *value = val;
    <span class="enscript-keyword">return</span> ptr;
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSValidKeepAliveRecord</span>(AuthRecord *rr)
{
    mDNSAddr    laddr, raddr;
    mDNSEthAddr eth;
    mDNSIPPort  lport, rport;
    mDNSu32     timeout, seq, ack;
    mDNSu16     win;

    <span class="enscript-keyword">if</span> (!mDNS_KeepaliveRecord(&amp;rr-&gt;resrec))
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    timeout = seq = ack = 0;
    win = 0;
    laddr = raddr = zeroAddr;
    lport = rport = zeroIPPort;
    eth = zeroEthAddr;

    mDNS_ExtractKeepaliveInfo(rr, &amp;timeout, &amp;laddr, &amp;raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);

    <span class="enscript-keyword">if</span> (mDNSAddressIsZero(&amp;laddr) || mDNSIPPortIsZero(lport) ||
        mDNSAddressIsZero(&amp;raddr) || mDNSIPPortIsZero(rport) ||
        mDNSEthAddressIsZero(eth))
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">return</span> mDNStrue;
}


mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ExtractKeepaliveInfo</span>(AuthRecord *ar, mDNSu32 *timeout, mDNSAddr *laddr, mDNSAddr *raddr, mDNSEthAddr *eth, mDNSu32 *seq,
                                         mDNSu32 *ack, mDNSIPPort *lport, mDNSIPPort *rport, mDNSu16 *win)
{
    <span class="enscript-keyword">if</span> (ar-&gt;resrec.rrtype != kDNSType_NULL)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (mDNS_KeepaliveRecord(&amp;ar-&gt;resrec))
    {
        <span class="enscript-type">int</span> len = ar-&gt;resrec.rdlength;
        mDNSu8 *ptr = &amp;ar-&gt;resrec.rdata-&gt;u.txt.c[1];
        mDNSu8 *limit = ptr + len - 1; <span class="enscript-comment">// Exclude the first byte that is the length
</span>        mDNSu32 value = 0;

        <span class="enscript-keyword">while</span> (ptr &lt; limit)
        {
            mDNSu8 param = *ptr;
            ptr += 2;   <span class="enscript-comment">// Skip the letter and the &quot;=&quot;
</span>            <span class="enscript-keyword">if</span> (param == <span class="enscript-string">'h'</span>)
            {
                laddr-&gt;type = mDNSAddrType_IPv4;
                ptr = GetValueForIPv4Addr(ptr, limit, &amp;laddr-&gt;ip.v4);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (param == <span class="enscript-string">'d'</span>)
            {
                raddr-&gt;type = mDNSAddrType_IPv4;
                ptr = GetValueForIPv4Addr(ptr, limit, &amp;raddr-&gt;ip.v4);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (param == <span class="enscript-string">'H'</span>)
            {
                laddr-&gt;type = mDNSAddrType_IPv6;
                ptr = GetValueForIPv6Addr(ptr, limit, &amp;laddr-&gt;ip.v6);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (param == <span class="enscript-string">'D'</span>)
            {
                raddr-&gt;type = mDNSAddrType_IPv6;
                ptr = GetValueForIPv6Addr(ptr, limit, &amp;raddr-&gt;ip.v6);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (param == <span class="enscript-string">'m'</span>)
            {
                ptr = GetValueForMACAddr(ptr, limit, eth);
            }
            <span class="enscript-keyword">else</span>
            {
                ptr = GetValueForKeepalive(ptr, limit, &amp;value);
            }
            <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;mDNS_ExtractKeepaliveInfo: Cannot parse\n&quot;</span>); <span class="enscript-keyword">return</span>; }

            <span class="enscript-comment">// Extract everything in network order so that it is easy for sending a keepalive and also
</span>            <span class="enscript-comment">// for matching incoming TCP packets
</span>            <span class="enscript-keyword">switch</span> (param)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
                *timeout = value;
                <span class="enscript-comment">//if (*timeout &lt; 120) *timeout = 120;
</span>                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'H'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'m'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'i'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'l'</span>:
                lport-&gt;NotAnInteger = swap16((mDNSu16)value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:
                rport-&gt;NotAnInteger = swap16((mDNSu16)value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
                *seq = swap32(value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'a'</span>:
                *ack = swap32(value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
                *win = swap16((mDNSu16)value);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                LogMsg(<span class="enscript-string">&quot;mDNS_ExtractKeepaliveInfo: unknown value %c\n&quot;</span>, param);
                ptr = limit;
                <span class="enscript-keyword">break</span>;
            }
            ptr++; <span class="enscript-comment">// skip the space
</span>        }
    }
}

<span class="enscript-comment">// Matches the proxied auth records to the incoming TCP packet and returns the match and its sequence and ack in &quot;rseq&quot; and &quot;rack&quot; so that
</span><span class="enscript-comment">// the clients need not retrieve this information from the auth record again.
</span>mDNSlocal AuthRecord* <span class="enscript-function-name">mDNS_MatchKeepaliveInfo</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSAddr* pladdr, <span class="enscript-type">const</span> mDNSAddr* praddr, <span class="enscript-type">const</span> mDNSIPPort plport,
                                              <span class="enscript-type">const</span> mDNSIPPort prport, mDNSu32 *rseq, mDNSu32 *rack)
{
    AuthRecord *ar;
    mDNSAddr laddr, raddr;
    mDNSEthAddr eth;
    mDNSIPPort lport, rport;
    mDNSu32 timeout, seq, ack;
    mDNSu16 win;

    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
    {
        timeout = seq = ack = 0;
        win = 0;
        laddr = raddr = zeroAddr;
        lport = rport = zeroIPPort;

        <span class="enscript-keyword">if</span> (!ar-&gt;WakeUp.HMAC.l[0]) <span class="enscript-keyword">continue</span>;

        mDNS_ExtractKeepaliveInfo(ar, &amp;timeout, &amp;laddr, &amp;raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);

        <span class="enscript-comment">// Did we parse correctly ?
</span>        <span class="enscript-keyword">if</span> (!timeout || mDNSAddressIsZero(&amp;laddr) || mDNSAddressIsZero(&amp;raddr) || !seq || !ack || mDNSIPPortIsZero(lport) || mDNSIPPortIsZero(rport) || !win)
        {
            debugf(<span class="enscript-string">&quot;mDNS_MatchKeepaliveInfo: not a valid record %s for keepalive&quot;</span>, ARDisplayString(m, ar));
            <span class="enscript-keyword">continue</span>;
        }

        debugf(<span class="enscript-string">&quot;mDNS_MatchKeepaliveInfo: laddr %#a pladdr %#a, raddr %#a praddr %#a, lport %d plport %d, rport %d prport %d&quot;</span>,
               &amp;laddr, pladdr, &amp;raddr, praddr, mDNSVal16(lport), mDNSVal16(plport), mDNSVal16(rport), mDNSVal16(prport));

        <span class="enscript-comment">// Does it match the incoming TCP packet ?
</span>        <span class="enscript-keyword">if</span> (mDNSSameAddress(&amp;laddr, pladdr) &amp;&amp; mDNSSameAddress(&amp;raddr, praddr) &amp;&amp; mDNSSameIPPort(lport, plport) &amp;&amp; mDNSSameIPPort(rport, prport))
        {
            <span class="enscript-comment">// returning in network order
</span>            *rseq = seq;
            *rack = ack;
            <span class="enscript-keyword">return</span> ar;
        }
    }
    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SendKeepalives</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *ar;

    <span class="enscript-keyword">for</span> (ar = m-&gt;ResourceRecords; ar; ar=ar-&gt;next)
    {
        mDNSu32 timeout, seq, ack;
        mDNSu16 win;
        mDNSAddr laddr, raddr;
        mDNSEthAddr eth;
        mDNSIPPort lport, rport;

        timeout = seq = ack = 0;
        win = 0;

        laddr = raddr = zeroAddr;
        lport = rport = zeroIPPort;

        <span class="enscript-keyword">if</span> (!ar-&gt;WakeUp.HMAC.l[0]) <span class="enscript-keyword">continue</span>;

        mDNS_ExtractKeepaliveInfo(ar, &amp;timeout, &amp;laddr, &amp;raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);

        <span class="enscript-keyword">if</span> (!timeout || mDNSAddressIsZero(&amp;laddr) || mDNSAddressIsZero(&amp;raddr) || !seq || !ack || mDNSIPPortIsZero(lport) || mDNSIPPortIsZero(rport) || !win)
        {
            debugf(<span class="enscript-string">&quot;mDNS_SendKeepalives: not a valid record %s for keepalive&quot;</span>, ARDisplayString(m, ar));
            <span class="enscript-keyword">continue</span>;
        }
        LogMsg(<span class="enscript-string">&quot;mDNS_SendKeepalives: laddr %#a raddr %#a lport %d rport %d&quot;</span>, &amp;laddr, &amp;raddr, mDNSVal16(lport), mDNSVal16(rport));

        <span class="enscript-comment">// When we receive a proxy update, we set KATimeExpire to zero so that we always send a keepalive
</span>        <span class="enscript-comment">// immediately (to detect any potential problems). After that we always set it to a non-zero value.
</span>        <span class="enscript-keyword">if</span> (!ar-&gt;KATimeExpire || (m-&gt;timenow - ar-&gt;KATimeExpire &gt;= 0))
        {
            mDNSPlatformSendKeepalive(&amp;laddr, &amp;raddr, &amp;lport, &amp;rport, seq, ack, win);
            ar-&gt;KATimeExpire = NonZeroTime(m-&gt;timenow + timeout * mDNSPlatformOneSecond);
        }
        <span class="enscript-keyword">if</span> (m-&gt;NextScheduledKA - ar-&gt;KATimeExpire &gt; 0)
            m-&gt;NextScheduledKA = ar-&gt;KATimeExpire;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SendKeepaliveACK</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *ar)
{
    mDNSu32     timeout, seq, ack, seqInc;
    mDNSu16     win;
    mDNSAddr    laddr, raddr;
    mDNSEthAddr eth;
    mDNSIPPort  lport, rport;
    mDNSu8      *ptr;

    <span class="enscript-keyword">if</span> (ar == mDNSNULL)
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_SendKeepalivesACK: AuthRecord is NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    timeout = seq = ack = 0;
    win = 0;

    laddr = raddr = zeroAddr;
    lport = rport = zeroIPPort;

    mDNS_ExtractKeepaliveInfo(ar, &amp;timeout, &amp;laddr, &amp;raddr, &amp;eth, &amp;seq, &amp;ack, &amp;lport, &amp;rport, &amp;win);

    <span class="enscript-keyword">if</span> (!timeout || mDNSAddressIsZero(&amp;laddr) || mDNSAddressIsZero(&amp;raddr) || !seq || !ack || mDNSIPPortIsZero(lport) || mDNSIPPortIsZero(rport) || !win)
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_SendKeepaliveACK: not a valid record %s for keepalive&quot;</span>, ARDisplayString(m, ar));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// To send a keepalive ACK, we need to add one to the sequence number from the keepalive
</span>    <span class="enscript-comment">// record, which is the TCP connection's &quot;next&quot; sequence number minus one. Otherwise, the
</span>    <span class="enscript-comment">// keepalive ACK also ends up being a keepalive probe. Also, seq is in network byte order, so
</span>    <span class="enscript-comment">// it's converted to host byte order before incrementing it by one.
</span>    ptr = (mDNSu8 *)&amp;seq;
    seqInc = (mDNSu32)((ptr[0] &lt;&lt; 24) | (ptr[1] &lt;&lt; 16) | (ptr[2] &lt;&lt; 8) | ptr[3]) + 1;
    ptr[0] = (mDNSu8)((seqInc &gt;&gt; 24) &amp; 0xFF);
    ptr[1] = (mDNSu8)((seqInc &gt;&gt; 16) &amp; 0xFF);
    ptr[2] = (mDNSu8)((seqInc &gt;&gt;  8) &amp; 0xFF);
    ptr[3] = (mDNSu8)((seqInc      ) &amp; 0xFF);
    LogMsg(<span class="enscript-string">&quot;mDNS_SendKeepaliveACK: laddr %#a raddr %#a lport %d rport %d&quot;</span>, &amp;laddr, &amp;raddr, mDNSVal16(lport), mDNSVal16(rport));
    mDNSPlatformSendKeepalive(&amp;laddr, &amp;raddr, &amp;lport, &amp;rport, seq, ack, win);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveUpdate</span>(mDNS *<span class="enscript-type">const</span> m,
                                     <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *end,
                                     <span class="enscript-type">const</span> mDNSAddr *srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *dstaddr, mDNSIPPort dstport,
                                     <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">int</span> i;
    AuthRecord opt;
    mDNSu8 *p = m-&gt;omsg.data;
    OwnerOptData owner = zeroOwner;     <span class="enscript-comment">// Need to zero this, so we'll know if this Update packet was missing its Owner option
</span>    mDNSu32 updatelease = 0;
    <span class="enscript-type">const</span> mDNSu8 *ptr;

    LogSPS(<span class="enscript-string">&quot;Received Update from %#-15a:%-5d to %#-15a:%-5d on 0x%p with &quot;</span>
           <span class="enscript-string">&quot;%2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes&quot;</span>,
           srcaddr, mDNSVal16(srcport), dstaddr, mDNSVal16(dstport), InterfaceID,
           msg-&gt;h.numQuestions,   msg-&gt;h.numQuestions   == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           msg-&gt;h.numAnswers,     msg-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           msg-&gt;h.numAuthorities, msg-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
           msg-&gt;h.numAdditionals, msg-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot; &quot;</span>    : <span class="enscript-string">&quot;s&quot;</span>, end - msg-&gt;data);

    <span class="enscript-keyword">if</span> (!InterfaceID || !m-&gt;SPSSocket || !mDNSSameIPPort(dstport, m-&gt;SPSSocket-&gt;port)) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (mDNS_PacketLoggingEnabled)
        DumpPacket(mStatus_NoError, mDNSfalse, <span class="enscript-string">&quot;UDP&quot;</span>, srcaddr, srcport, dstaddr, dstport, msg, end, InterfaceID);

    ptr = LocateOptRR(msg, end, DNSOpt_LeaseData_Space + DNSOpt_OwnerData_ID_Space);
    <span class="enscript-keyword">if</span> (ptr)
    {
        ptr = GetLargeResourceRecord(m, msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_OPT)
        {
            <span class="enscript-type">const</span> rdataOPT *o;
            <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> e = (<span class="enscript-type">const</span> rdataOPT *)&amp;m-&gt;rec.r.resrec.rdata-&gt;u.data[m-&gt;rec.r.resrec.rdlength];
            <span class="enscript-keyword">for</span> (o = &amp;m-&gt;rec.r.resrec.rdata-&gt;u.opt[0]; o &lt; e; o++)
            {
                <span class="enscript-keyword">if</span>      (o-&gt;opt == kDNSOpt_Lease) updatelease = o-&gt;u.updatelease;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (o-&gt;opt == kDNSOpt_Owner &amp;&amp; o-&gt;u.owner.vers == 0) owner       = o-&gt;u.owner;
            }
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }

    InitializeDNSMessage(&amp;m-&gt;omsg.h, msg-&gt;h.id, UpdateRespFlags);

    <span class="enscript-keyword">if</span> (!updatelease || !owner.HMAC.l[0])
    {
        <span class="enscript-type">static</span> <span class="enscript-type">int</span> msgs = 0;
        <span class="enscript-keyword">if</span> (msgs &lt; 100)
        {
            msgs++;
            LogMsg(<span class="enscript-string">&quot;Refusing sleep proxy registration from %#a:%d:%s%s&quot;</span>, srcaddr, mDNSVal16(srcport),
                   !updatelease ? <span class="enscript-string">&quot; No lease&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, !owner.HMAC.l[0] ? <span class="enscript-string">&quot; No owner&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
        }
        m-&gt;omsg.h.flags.b[1] |= kDNSFlag1_RC_FormErr;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;ProxyRecords + msg-&gt;h.mDNS_numUpdates &gt; MAX_PROXY_RECORDS)
    {
        <span class="enscript-type">static</span> <span class="enscript-type">int</span> msgs = 0;
        <span class="enscript-keyword">if</span> (msgs &lt; 100)
        {
            msgs++;
            LogMsg(<span class="enscript-string">&quot;Refusing sleep proxy registration from %#a:%d: Too many records %d + %d = %d &gt; %d&quot;</span>, srcaddr, mDNSVal16(srcport),
                   m-&gt;ProxyRecords, msg-&gt;h.mDNS_numUpdates, m-&gt;ProxyRecords + msg-&gt;h.mDNS_numUpdates, MAX_PROXY_RECORDS);
        }
        m-&gt;omsg.h.flags.b[1] |= kDNSFlag1_RC_Refused;
    }
    <span class="enscript-keyword">else</span>
    {
        LogSPS(<span class="enscript-string">&quot;Received Update for H-MAC %.6a I-MAC %.6a Password %.6a seq %d&quot;</span>, &amp;owner.HMAC, &amp;owner.IMAC, &amp;owner.password, owner.seq);

        <span class="enscript-keyword">if</span> (updatelease &gt; 24 * 60 * 60)
            updatelease = 24 * 60 * 60;

        <span class="enscript-keyword">if</span> (updatelease &gt; 0x40000000UL / mDNSPlatformOneSecond)
            updatelease = 0x40000000UL / mDNSPlatformOneSecond;

        ptr = LocateAuthorities(msg, end);

        <span class="enscript-comment">// Clear any stale TCP keepalive records that may exist
</span>        ClearKeepaliveProxyRecords(m, &amp;owner, m-&gt;DuplicateRecords, InterfaceID);
        ClearKeepaliveProxyRecords(m, &amp;owner, m-&gt;ResourceRecords, InterfaceID);

        <span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;h.mDNS_numUpdates &amp;&amp; ptr &amp;&amp; ptr &lt; end; i++)
        {
            ptr = GetLargeResourceRecord(m, msg, ptr, end, InterfaceID, kDNSRecordTypePacketAuth, &amp;m-&gt;rec);
            <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative)
            {
                mDNSu16 RDLengthMem = GetRDLengthMem(&amp;m-&gt;rec.r.resrec);
                AuthRecord *ar = (AuthRecord *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(AuthRecord) - <span class="enscript-keyword">sizeof</span>(RDataBody) + RDLengthMem);
                <span class="enscript-keyword">if</span> (!ar)
                {
                    m-&gt;omsg.h.flags.b[1] |= kDNSFlag1_RC_Refused;
                    <span class="enscript-keyword">break</span>;
                }
                <span class="enscript-keyword">else</span>
                {
                    mDNSu8 RecordType = m-&gt;rec.r.resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask ? kDNSRecordTypeUnique : kDNSRecordTypeShared;
                    m-&gt;rec.r.resrec.rrclass &amp;= ~kDNSClass_UniqueRRSet;
                    <span class="enscript-comment">// All stale keepalive records have been flushed prior to this loop.
</span>                    <span class="enscript-keyword">if</span> (!mDNS_KeepaliveRecord(&amp;m-&gt;rec.r.resrec))
                    {
                        ClearIdenticalProxyRecords(m, &amp;owner, m-&gt;DuplicateRecords); <span class="enscript-comment">// Make sure we don't have any old stale duplicates of this record
</span>                        ClearIdenticalProxyRecords(m, &amp;owner, m-&gt;ResourceRecords);
                    }
                    mDNS_SetupResourceRecord(ar, mDNSNULL, InterfaceID, m-&gt;rec.r.resrec.rrtype, m-&gt;rec.r.resrec.rroriginalttl, RecordType, AuthRecordAny, SPSRecordCallback, ar);
                    AssignDomainName(&amp;ar-&gt;namestorage, m-&gt;rec.r.resrec.name);
                    ar-&gt;resrec.rdlength = GetRDLength(&amp;m-&gt;rec.r.resrec, mDNSfalse);
                    ar-&gt;resrec.rdata-&gt;MaxRDLength = RDLengthMem;
                    mDNSPlatformMemCopy(ar-&gt;resrec.rdata-&gt;u.data, m-&gt;rec.r.resrec.rdata-&gt;u.data, RDLengthMem);
                    ar-&gt;ForceMCast = mDNStrue;
                    ar-&gt;WakeUp     = owner;
                    <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.rrtype == kDNSType_PTR)
                    {
                        mDNSs32 t = ReverseMapDomainType(m-&gt;rec.r.resrec.name);
                        <span class="enscript-keyword">if</span>      (t == mDNSAddrType_IPv4) GetIPv4FromName(&amp;ar-&gt;AddressProxy, m-&gt;rec.r.resrec.name);
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (t == mDNSAddrType_IPv6) GetIPv6FromName(&amp;ar-&gt;AddressProxy, m-&gt;rec.r.resrec.name);
                        debugf(<span class="enscript-string">&quot;mDNSCoreReceiveUpdate: PTR %d %d %#a %s&quot;</span>, t, ar-&gt;AddressProxy.type, &amp;ar-&gt;AddressProxy, ARDisplayString(m, ar));
                        <span class="enscript-keyword">if</span> (ar-&gt;AddressProxy.type) SetSPSProxyListChanged(InterfaceID);
                    }
                    ar-&gt;TimeRcvd   = m-&gt;timenow;
                    ar-&gt;TimeExpire = m-&gt;timenow + updatelease * mDNSPlatformOneSecond;
                    <span class="enscript-keyword">if</span> (m-&gt;NextScheduledSPS - ar-&gt;TimeExpire &gt; 0)
                        m-&gt;NextScheduledSPS = ar-&gt;TimeExpire;
                    ar-&gt;KATimeExpire = 0;
                    mDNS_Register_internal(m, ar);

                    m-&gt;ProxyRecords++;
                    mDNS_UpdateAllowSleep(m);
                    LogSPS(<span class="enscript-string">&quot;SPS Registered %4d %X %s&quot;</span>, m-&gt;ProxyRecords, RecordType, ARDisplayString(m,ar));
                }
            }
            m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>        }

        <span class="enscript-keyword">if</span> (m-&gt;omsg.h.flags.b[1] &amp; kDNSFlag1_RC_Mask)
        {
            LogMsg(<span class="enscript-string">&quot;Refusing sleep proxy registration from %#a:%d: Out of memory&quot;</span>, srcaddr, mDNSVal16(srcport));
            ClearProxyRecords(m, &amp;owner, m-&gt;DuplicateRecords);
            ClearProxyRecords(m, &amp;owner, m-&gt;ResourceRecords);
        }
        <span class="enscript-keyword">else</span>
        {
            mDNS_SetupResourceRecord(&amp;opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
            opt.resrec.rrclass    = NormalMaxDNSMessageData;
            opt.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);   <span class="enscript-comment">// One option in this OPT record
</span>            opt.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
            opt.resrec.rdata-&gt;u.opt[0].opt           = kDNSOpt_Lease;
            opt.resrec.rdata-&gt;u.opt[0].u.updatelease = updatelease;
            p = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, p, &amp;m-&gt;omsg.h.numAdditionals, &amp;opt.resrec, opt.resrec.rroriginalttl, m-&gt;omsg.data + AbsoluteMaxDNSMessageData);
        }
    }

    <span class="enscript-keyword">if</span> (p) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, p, InterfaceID, mDNSNULL, m-&gt;SPSSocket, srcaddr, srcport, mDNSNULL, mDNSfalse);
    mDNS_SendKeepalives(m);
}

mDNSlocal mDNSu32 <span class="enscript-function-name">mDNSGenerateOwnerOptForInterface</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, DNSMessage *msg)
{
    mDNSu8 *ptr    = msg-&gt;data;
    mDNSu8 *end    = mDNSNULL;
    mDNSu32 length = 0;
    AuthRecord opt;
    NetworkInterfaceInfo *intf;

    mDNS_SetupResourceRecord(&amp;opt, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    opt.resrec.rrclass    = NormalMaxDNSMessageData;
    opt.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);
    opt.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);

    intf = FirstInterfaceForID(m, InterfaceID);
    SetupOwnerOpt(m, intf, &amp;opt.resrec.rdata-&gt;u.opt[0]);

    LogSPS(<span class="enscript-string">&quot;Generated OPT record : %s&quot;</span>, ARDisplayString(m, &amp;opt));
    end = PutResourceRecord(msg, ptr, &amp;msg-&gt;h.numAdditionals, &amp;opt.resrec);
    <span class="enscript-keyword">if</span> (end != mDNSNULL)
    {
        <span class="enscript-comment">// Put all the integer values in IETF byte-order (MSB first, LSB second)
</span>        SwapDNSHeaderBytes(msg);
        length = (end - msg-&gt;data);
    }
    <span class="enscript-keyword">else</span>
        LogSPS(<span class="enscript-string">&quot;mDNSGenerateOwnerOptForInterface: Failed to generate owner OPT record&quot;</span>);

    <span class="enscript-keyword">return</span> length;
}

<span class="enscript-comment">// Note that this routine is called both for Sleep Proxy Registrations, and for Standard Dynamic
</span><span class="enscript-comment">// DNS registrations, but (currently) only has to handle the Sleep Proxy Registration reply case,
</span><span class="enscript-comment">// and should ignore Standard Dynamic DNS registration replies, because those are handled elsewhere.
</span><span class="enscript-comment">// Really, both should be unified and handled in one place.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveUpdateR</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">const</span> mDNSAddr *srcaddr, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-keyword">if</span> (InterfaceID)
    {
        mDNSu32 pktlease = 0, spsupdates = 0;
        <span class="enscript-type">const</span> mDNSBool gotlease = GetPktLease(m, msg, end, &amp;pktlease);
        <span class="enscript-type">const</span> mDNSu32 updatelease = gotlease ? pktlease : 60 * 60; <span class="enscript-comment">// If SPS fails to indicate lease time, assume one hour
</span>        <span class="enscript-keyword">if</span> (gotlease) LogSPS(<span class="enscript-string">&quot;DNS Update response contains lease option granting %4d seconds, updateid %d, InterfaceID %p&quot;</span>, updatelease, mDNSVal16(msg-&gt;h.id), InterfaceID);

        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
            LogMsg(<span class="enscript-string">&quot;mDNSCoreReceiveUpdateR ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
        m-&gt;CurrentRecord = m-&gt;ResourceRecords;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
        {
            AuthRecord *<span class="enscript-type">const</span> rr = m-&gt;CurrentRecord;
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID || (!rr-&gt;resrec.InterfaceID &amp;&amp; (rr-&gt;ForceMCast || IsLocalDomain(rr-&gt;resrec.name))))
                <span class="enscript-keyword">if</span> (mDNSSameOpaque16(rr-&gt;updateid, msg-&gt;h.id))
                {
                    <span class="enscript-comment">// We successfully completed this record's registration on this &quot;InterfaceID&quot;. Clear that bit.
</span>                    <span class="enscript-comment">// Clear the updateid when we are done sending on all interfaces.
</span>                    mDNSu32 scopeid = mDNSPlatformInterfaceIndexfromInterfaceID(m, InterfaceID, mDNStrue);
                    <span class="enscript-keyword">if</span> (scopeid &lt; (<span class="enscript-keyword">sizeof</span>(rr-&gt;updateIntID) * mDNSNBBY))
                        bit_clr_opaque64(rr-&gt;updateIntID, scopeid);
                    <span class="enscript-keyword">if</span> (mDNSOpaque64IsZero(&amp;rr-&gt;updateIntID))
                        rr-&gt;updateid = zeroID;
                    rr-&gt;expire   = NonZeroTime(m-&gt;timenow + updatelease * mDNSPlatformOneSecond);
                    spsupdates++;
                    LogSPS(<span class="enscript-string">&quot;Sleep Proxy %s record %2d %5d 0x%x 0x%x (%d) %s&quot;</span>, rr-&gt;WakeUp.HMAC.l[0] ? <span class="enscript-string">&quot;transferred&quot;</span> : <span class="enscript-string">&quot;registered&quot;</span>, spsupdates, updatelease, rr-&gt;updateIntID.l[1], rr-&gt;updateIntID.l[0], mDNSVal16(rr-&gt;updateid), ARDisplayString(m,rr));
                    <span class="enscript-keyword">if</span> (rr-&gt;WakeUp.HMAC.l[0])
                    {
                        rr-&gt;WakeUp.HMAC = zeroEthAddr;  <span class="enscript-comment">// Clear HMAC so that mDNS_Deregister_internal doesn't waste packets trying to wake this host
</span>                        rr-&gt;RequireGoodbye = mDNSfalse; <span class="enscript-comment">// and we don't want to send goodbye for it
</span>                        mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
                    }
                }
            <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>            <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>            <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>                m-&gt;CurrentRecord = rr-&gt;next;
        }
        <span class="enscript-keyword">if</span> (spsupdates) <span class="enscript-comment">// Only do this dynamic store stuff if this was, in fact, a Sleep Proxy Update response
</span>        {
            <span class="enscript-type">char</span> *ifname;
            mDNSAddr spsaddr;
            DNSMessage optMsg;
            <span class="enscript-type">int</span> length;
            <span class="enscript-comment">// Update the dynamic store with the IP Address and MAC address of the sleep proxy
</span>            ifname = InterfaceNameForID(m, InterfaceID);
            mDNSPlatformMemCopy(&amp;spsaddr, srcaddr, <span class="enscript-keyword">sizeof</span> (mDNSAddr));
            mDNSPlatformStoreSPSMACAddr(&amp;spsaddr, ifname);

            <span class="enscript-comment">// Store the Owner OPT record for this interface.
</span>            <span class="enscript-comment">// Configd may use the OPT record if it detects a conflict with the BSP when the system wakes up
</span>            InitializeDNSMessage(&amp;optMsg.h, zeroID, ResponseFlags);
            length = mDNSGenerateOwnerOptForInterface(m, InterfaceID, &amp;optMsg);
            <span class="enscript-keyword">if</span> (length != 0)
            {
                length += <span class="enscript-keyword">sizeof</span>(DNSMessageHeader);
                mDNSPlatformStoreOwnerOptRecord(ifname, &amp;optMsg, length);
            }
        }
    }
    <span class="enscript-comment">// If we were waiting to go to sleep, then this SPS registration or wide-area record deletion
</span>    <span class="enscript-comment">// may have been the thing we were waiting for, so schedule another check to see if we can sleep now.
</span>    <span class="enscript-keyword">if</span> (m-&gt;SleepLimit) m-&gt;NextScheduledSPRetry = m-&gt;timenow;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">MakeNegativeCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> cr,
                                        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> mDNSu16 rrtype, <span class="enscript-type">const</span> mDNSu16 rrclass, mDNSu32 ttl_seconds, mDNSInterfaceID InterfaceID, DNSServer *dnsserver)
{
    <span class="enscript-keyword">if</span> (cr == &amp;m-&gt;rec.r &amp;&amp; m-&gt;rec.r.resrec.RecordType)
        LogFatalError(<span class="enscript-string">&quot;MakeNegativeCacheRecord: m-&gt;rec appears to be already in use for %s&quot;</span>, CRDisplayString(m, &amp;m-&gt;rec.r));

    <span class="enscript-comment">// Create empty resource record
</span>    cr-&gt;resrec.RecordType    = kDNSRecordTypePacketNegative;
    cr-&gt;resrec.InterfaceID   = InterfaceID;
    cr-&gt;resrec.rDNSServer    = dnsserver;
    cr-&gt;resrec.name          = name;    <span class="enscript-comment">// Will be updated to point to cg-&gt;name when we call CreateNewCacheEntry
</span>    cr-&gt;resrec.rrtype        = rrtype;
    cr-&gt;resrec.rrclass       = rrclass;
    cr-&gt;resrec.rroriginalttl = ttl_seconds;
    cr-&gt;resrec.rdlength      = 0;
    cr-&gt;resrec.rdestimate    = 0;
    cr-&gt;resrec.namehash      = namehash;
    cr-&gt;resrec.rdatahash     = 0;
    cr-&gt;resrec.rdata = (RData*)&amp;cr-&gt;smallrdatastorage;
    cr-&gt;resrec.rdata-&gt;MaxRDLength = 0;

    cr-&gt;NextInKAList       = mDNSNULL;
    cr-&gt;TimeRcvd           = m-&gt;timenow;
    cr-&gt;DelayDelivery      = 0;
    cr-&gt;NextRequiredQuery  = m-&gt;timenow;
    cr-&gt;CRActiveQuestion   = mDNSNULL;
    cr-&gt;UnansweredQueries  = 0;
    cr-&gt;LastUnansweredTime = 0;
    cr-&gt;NextInCFList       = mDNSNULL;
    cr-&gt;nsec               = mDNSNULL;
    cr-&gt;soa                = mDNSNULL;
    cr-&gt;CRDNSSECQuestion   = 0;
    <span class="enscript-comment">// Initialize to the basic one and the caller can set it to more
</span>    <span class="enscript-comment">// specific based on the response if any
</span>    cr-&gt;responseFlags      = ResponseFlags;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceive</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *dstaddr, <span class="enscript-type">const</span> mDNSIPPort dstport,
                                <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    mDNSInterfaceID ifid = InterfaceID;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> pkt = (mDNSu8 *)msg;
    <span class="enscript-type">const</span> mDNSu8 StdQ = kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery;
    <span class="enscript-type">const</span> mDNSu8 StdR = kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery;
    <span class="enscript-type">const</span> mDNSu8 UpdQ = kDNSFlag0_QR_Query    | kDNSFlag0_OP_Update;
    <span class="enscript-type">const</span> mDNSu8 UpdR = kDNSFlag0_QR_Response | kDNSFlag0_OP_Update;
    mDNSu8 QR_OP;
    mDNSu8 *ptr = mDNSNULL;
    mDNSBool TLS = (dstaddr == (mDNSAddr *)1);  <span class="enscript-comment">// For debug logs: dstaddr = 0 means TCP; dstaddr = 1 means TLS
</span>    <span class="enscript-keyword">if</span> (TLS) dstaddr = mDNSNULL;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (mDNSSameAddress(srcaddr, &amp;m-&gt;Router))
    {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
        <span class="enscript-keyword">if</span> (mDNSSameIPPort(srcport, SSDPPort) || (m-&gt;SSDPSocket &amp;&amp; mDNSSameIPPort(dstport, m-&gt;SSDPSocket-&gt;port)))
        {
            mDNS_Lock(m);
            LNT_ConfigureRouterInfo(m, InterfaceID, (mDNSu8 *)msg, (mDNSu16)(end - pkt));
            mDNS_Unlock(m);
            <span class="enscript-keyword">return</span>;
        }
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (mDNSSameIPPort(srcport, NATPMPPort))
        {
            mDNS_Lock(m);
            uDNS_ReceiveNATPacket(m, InterfaceID, (mDNSu8 *)msg, (mDNSu16)(end - pkt));
            mDNS_Unlock(m);
            <span class="enscript-keyword">return</span>;
        }
    }
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket &amp;&amp; mDNSSameIPPort(dstport, m-&gt;SSDPSocket-&gt;port)) { debugf(<span class="enscript-string">&quot;Ignoring SSDP response from %#a:%d&quot;</span>, srcaddr, mDNSVal16(srcport)); <span class="enscript-keyword">return</span>; }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)(end - pkt) &lt; <span class="enscript-keyword">sizeof</span>(DNSMessageHeader))
    {
        LogMsg(<span class="enscript-string">&quot;DNS Message from %#a:%d to %#a:%d length %d too short&quot;</span>, srcaddr, mDNSVal16(srcport), dstaddr, mDNSVal16(dstport), (<span class="enscript-type">int</span>)(end - pkt));
        <span class="enscript-keyword">return</span>;
    }
    QR_OP = (mDNSu8)(msg-&gt;h.flags.b[0] &amp; kDNSFlag0_QROP_Mask);
    <span class="enscript-comment">// Read the integer parts which are in IETF byte-order (MSB first, LSB second)
</span>    ptr = (mDNSu8 *)&amp;msg-&gt;h.numQuestions;
    msg-&gt;h.numQuestions   = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt; 8 | ptr[1]);
    msg-&gt;h.numAnswers     = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt; 8 | ptr[3]);
    msg-&gt;h.numAuthorities = (mDNSu16)((mDNSu16)ptr[4] &lt;&lt; 8 | ptr[5]);
    msg-&gt;h.numAdditionals = (mDNSu16)((mDNSu16)ptr[6] &lt;&lt; 8 | ptr[7]);

    <span class="enscript-keyword">if</span> (!m) { LogMsg(<span class="enscript-string">&quot;mDNSCoreReceive ERROR m is NULL&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// We use zero addresses and all-ones addresses at various places in the code to indicate special values like &quot;no address&quot;
</span>    <span class="enscript-comment">// If we accept and try to process a packet with zero or all-ones source address, that could really mess things up
</span>    <span class="enscript-keyword">if</span> (!mDNSAddressIsValid(srcaddr)) { debugf(<span class="enscript-string">&quot;mDNSCoreReceive ignoring packet from %#a&quot;</span>, srcaddr); <span class="enscript-keyword">return</span>; }

    mDNS_Lock(m);
    m-&gt;PktNum++;
    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(msg-&gt;h.id))
    {
        m-&gt;MPktNum++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        <span class="enscript-comment">// Track the number of multicast packets received from a source outside our subnet.
</span>        <span class="enscript-comment">// Check the destination address to avoid accounting for spurious packets that
</span>        <span class="enscript-comment">// comes in with message id zero.
</span>        <span class="enscript-keyword">if</span> (!mDNS_AddressIsLocalSubnet(m, InterfaceID, srcaddr) &amp;&amp; dstaddr &amp;&amp;
            mDNSAddressIsAllDNSLinkGroup(dstaddr))
        {
            m-&gt;RemoteSubnet++;
        }
#<span class="enscript-reference">endif</span> // #<span class="enscript-variable-name">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    }

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (!dstaddr || (!mDNSAddressIsAllDNSLinkGroup(dstaddr) &amp;&amp; (QR_OP == StdR || QR_OP == UpdR)))
        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(msg-&gt;h.id)) <span class="enscript-comment">// uDNS_ReceiveMsg only needs to get real uDNS responses, not &quot;QU&quot; mDNS responses
</span>        {
            ifid = mDNSInterface_Any;
            <span class="enscript-keyword">if</span> (mDNS_PacketLoggingEnabled)
                DumpPacket(mStatus_NoError, mDNSfalse, TLS ? <span class="enscript-string">&quot;TLS&quot;</span> : !dstaddr ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;UDP&quot;</span>, srcaddr, srcport, dstaddr, dstport, msg, end, InterfaceID);
            uDNS_ReceiveMsg(m, msg, end, srcaddr, srcport);
            <span class="enscript-comment">// Note: mDNSCore also needs to get access to received unicast responses
</span>        }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span>      (QR_OP == StdQ) mDNSCoreReceiveQuery   (m, msg, end, srcaddr, srcport, dstaddr, dstport, ifid);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (QR_OP == StdR) mDNSCoreReceiveResponse(m, msg, end, srcaddr, srcport, dstaddr, dstport, ifid);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (QR_OP == UpdQ) mDNSCoreReceiveUpdate  (m, msg, end, srcaddr, srcport, dstaddr, dstport, InterfaceID);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (QR_OP == UpdR) mDNSCoreReceiveUpdateR (m, msg, end, srcaddr,                            InterfaceID);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (mDNS_LoggingEnabled)
        {
            <span class="enscript-type">static</span> <span class="enscript-type">int</span> msgCount = 0;
            <span class="enscript-keyword">if</span> (msgCount &lt; 1000) {
                <span class="enscript-type">int</span> i = 0;
                msgCount++;
                LogInfo(<span class="enscript-string">&quot;Unknown DNS packet type %02X%02X from %#-15a:%-5d to %#-15a:%-5d length %d on %p (ignored)&quot;</span>,
                        msg-&gt;h.flags.b[0], msg-&gt;h.flags.b[1], srcaddr, mDNSVal16(srcport), dstaddr, mDNSVal16(dstport), (<span class="enscript-type">int</span>)(end - pkt), InterfaceID);
                <span class="enscript-keyword">while</span> (i &lt; (<span class="enscript-type">int</span>)(end - pkt))
                {
                    <span class="enscript-type">char</span> buffer[128];
                    <span class="enscript-type">char</span> *p = buffer + mDNS_snprintf(buffer, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot;%04X&quot;</span>, i);
                    <span class="enscript-keyword">do</span> <span class="enscript-keyword">if</span> (i &lt; (<span class="enscript-type">int</span>)(end - pkt)) p += mDNS_snprintf(p, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot; %02X&quot;</span>, pkt[i]);<span class="enscript-keyword">while</span> (++i &amp; 15);
                    LogInfo(<span class="enscript-string">&quot;%s&quot;</span>, buffer);
                }
            }
        }
    }
    <span class="enscript-comment">// Packet reception often causes a change to the task list:
</span>    <span class="enscript-comment">// 1. Inbound queries can cause us to need to send responses
</span>    <span class="enscript-comment">// 2. Conflicing response packets received from other hosts can cause us to need to send defensive responses
</span>    <span class="enscript-comment">// 3. Other hosts announcing deletion of shared records can cause us to need to re-assert those records
</span>    <span class="enscript-comment">// 4. Response packets that answer questions may cause our client to issue new questions
</span>    mDNS_Unlock(m);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Searcher</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Note: We explicitly disallow making a public query be a duplicate of a private one. This is to avoid the
</span><span class="enscript-comment">// circular deadlock where a client does a query for something like &quot;dns-sd -Q _dns-query-tls._tcp.company.com SRV&quot;
</span><span class="enscript-comment">// and we have a key for company.com, so we try to locate the private query server for company.com, which necessarily entails
</span><span class="enscript-comment">// doing a standard DNS query for the _dns-query-tls._tcp SRV record for company.com. If we make the latter (public) query
</span><span class="enscript-comment">// a duplicate of the former (private) query, then it will block forever waiting for an answer that will never come.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We keep SuppressUnusable questions separate so that we can return a quick response to them and not get blocked behind
</span><span class="enscript-comment">// the queries that are not marked SuppressUnusable. But if the query is not suppressed, they are treated the same as
</span><span class="enscript-comment">// non-SuppressUnusable questions. This should be fine as the goal of SuppressUnusable is to return quickly only if it
</span><span class="enscript-comment">// is suppressed. If it is not suppressed, we do try all the DNS servers for valid answers like any other question.
</span><span class="enscript-comment">// The main reason for this design is that cache entries point to a *single* question and that question is responsible
</span><span class="enscript-comment">// for keeping the cache fresh as long as it is active. Having multiple active question for a single cache entry
</span><span class="enscript-comment">// breaks this design principle.
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">// If IsLLQ(Q) is true, it means the question is both:
</span><span class="enscript-comment">// (a) long-lived and
</span><span class="enscript-comment">// (b) being performed by a unicast DNS long-lived query (either full LLQ, or polling)
</span><span class="enscript-comment">// for multicast questions, we don't want to treat LongLived as anything special
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">IsLLQ</span>(Q)                 ((Q)-&gt;LongLived &amp;&amp; !mDNSOpaque16IsZero((Q)-&gt;TargetQID))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AWDLIsIncluded</span>(Q)        (((Q)-&gt;flags &amp; kDNSServiceFlagsIncludeAWDL) != 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SameQuestionKind</span>(Q1, Q2) (mDNSOpaque16IsZero((Q1)-&gt;TargetQID) == mDNSOpaque16IsZero((Q2)-&gt;TargetQID))

mDNSlocal DNSQuestion *<span class="enscript-function-name">FindDuplicateQuestion</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> question)
{
    DNSQuestion *q;
    <span class="enscript-comment">// Note: A question can only be marked as a duplicate of one that occurs *earlier* in the list.
</span>    <span class="enscript-comment">// This prevents circular references, where two questions are each marked as a duplicate of the other.
</span>    <span class="enscript-comment">// Accordingly, we break out of the loop when we get to 'question', because there's no point searching
</span>    <span class="enscript-comment">// further in the list.
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; (q != question); q = q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!SameQuestionKind(q, question))                         <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;qnamehash          != question-&gt;qnamehash)           <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;InterfaceID        != question-&gt;InterfaceID)         <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;qtype              != question-&gt;qtype)               <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;qclass             != question-&gt;qclass)              <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (IsLLQ(q)              != IsLLQ(question))               <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;AuthInfo &amp;&amp; !question-&gt;AuthInfo)                     <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;ValidationRequired != question-&gt;ValidationRequired)  <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;ValidatingResponse != question-&gt;ValidatingResponse)  <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!q-&gt;Suppressed        != !question-&gt;Suppressed)         <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (q-&gt;BrowseThreshold    != question-&gt;BrowseThreshold)     <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (AWDLIsIncluded(q)     != AWDLIsIncluded(question))      <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!SameDomainName(&amp;q-&gt;qname, &amp;question-&gt;qname))           <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">return</span>(q);
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// This is called after a question is deleted, in case other identical questions were being suppressed as duplicates
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateQuestionDuplicates</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    DNSQuestion *q;
    DNSQuestion *first = mDNSNULL;

    <span class="enscript-comment">// This is referring to some other question as duplicate. No other question can refer to this
</span>    <span class="enscript-comment">// question as a duplicate.
</span>    <span class="enscript-keyword">if</span> (question-&gt;DuplicateOf)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;DupQ%d-&gt;Q%d] UpdateQuestionDuplicates: question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) duplicate of %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               question-&gt;request_id, mDNSVal16(question-&gt;DuplicateOf-&gt;TargetQID), mDNSVal16(question-&gt;TargetQID),
               question, DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype), question-&gt;DuplicateOf,
               DM_NAME_PARAM(question-&gt;DuplicateOf-&gt;qname.c), DNSTypeName(question-&gt;DuplicateOf-&gt;qtype));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)        <span class="enscript-comment">// Scan our list of questions
</span>        <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf == question)         <span class="enscript-comment">// To see if any questions were referencing this as their duplicate
</span>        {
            q-&gt;DuplicateOf = first;
            <span class="enscript-keyword">if</span> (!first)
            {
                first = q;
                <span class="enscript-comment">// If q used to be a duplicate, but now is not,
</span>                <span class="enscript-comment">// then inherit the state from the question that's going away
</span>                q-&gt;LastQTime         = question-&gt;LastQTime;
                q-&gt;ThisQInterval     = question-&gt;ThisQInterval;
                q-&gt;ExpectUnicastResp = question-&gt;ExpectUnicastResp;
                q-&gt;LastAnswerPktNum  = question-&gt;LastAnswerPktNum;
                q-&gt;RecentAnswerPkts  = question-&gt;RecentAnswerPkts;
                q-&gt;RequestUnicast    = question-&gt;RequestUnicast;
                q-&gt;LastQTxTime       = question-&gt;LastQTxTime;
                q-&gt;CNAMEReferrals    = question-&gt;CNAMEReferrals;
                q-&gt;nta               = question-&gt;nta;
                q-&gt;servAddr          = question-&gt;servAddr;
                q-&gt;servPort          = question-&gt;servPort;
                q-&gt;qDNSServer        = question-&gt;qDNSServer;
                q-&gt;validDNSServers   = question-&gt;validDNSServers;
                q-&gt;unansweredQueries = question-&gt;unansweredQueries;
                q-&gt;noServerResponse  = question-&gt;noServerResponse;
                q-&gt;triedAllServersOnce = question-&gt;triedAllServersOnce;

                q-&gt;TargetQID         = question-&gt;TargetQID;
                q-&gt;LocalSocket       = question-&gt;LocalSocket;
                <span class="enscript-comment">// No need to close old q-&gt;LocalSocket first -- duplicate questions can't have their own sockets
</span>
                q-&gt;state             = question-&gt;state;
                <span class="enscript-comment">//  q-&gt;tcp               = question-&gt;tcp;
</span>                q-&gt;ReqLease          = question-&gt;ReqLease;
                q-&gt;expire            = question-&gt;expire;
                q-&gt;ntries            = question-&gt;ntries;
                q-&gt;id                = question-&gt;id;

                question-&gt;LocalSocket = mDNSNULL;
                question-&gt;nta        = mDNSNULL;    <span class="enscript-comment">// If we've got a GetZoneData in progress, transfer it to the newly active question
</span>                <span class="enscript-comment">//  question-&gt;tcp        = mDNSNULL;
</span>
                <span class="enscript-keyword">if</span> (q-&gt;LocalSocket)
                    debugf(<span class="enscript-string">&quot;UpdateQuestionDuplicates transferred LocalSocket pointer for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

                <span class="enscript-keyword">if</span> (q-&gt;nta)
                {
                    LogInfo(<span class="enscript-string">&quot;UpdateQuestionDuplicates transferred nta pointer for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    q-&gt;nta-&gt;ZoneDataContext = q;
                }

                <span class="enscript-comment">// Need to work out how to safely transfer this state too -- appropriate context pointers need to be updated or the code will crash
</span>                <span class="enscript-keyword">if</span> (question-&gt;tcp) LogInfo(<span class="enscript-string">&quot;UpdateQuestionDuplicates did not transfer tcp pointer&quot;</span>);

                <span class="enscript-keyword">if</span> (question-&gt;state == LLQ_Established)
                {
                    LogInfo(<span class="enscript-string">&quot;UpdateQuestionDuplicates transferred LLQ state for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                    question-&gt;state = 0;    <span class="enscript-comment">// Must zero question-&gt;state, or mDNS_StopQuery_internal will clean up and cancel our LLQ from the server
</span>                }

                SetNextQueryTime(m,q);
            }
        }
}

mDNSexport McastResolver *<span class="enscript-function-name">mDNS_AddMcastResolver</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">const</span> mDNSInterfaceID interface, mDNSu32 timeout)
{
    McastResolver **p = &amp;m-&gt;McastResolvers;
    McastResolver *tmp = mDNSNULL;

    <span class="enscript-keyword">if</span> (!d) d = (<span class="enscript-type">const</span> domainname *)<span class="enscript-string">&quot;&quot;</span>;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
        <span class="enscript-string">&quot;mDNS_AddMcastResolver: Adding &quot;</span> PUB_DM_NAME <span class="enscript-string">&quot;, InterfaceID %p, timeout %u&quot;</span>, DM_NAME_PARAM(d), interface, timeout);

    mDNS_CheckLock(m);

    <span class="enscript-keyword">while</span> (*p)  <span class="enscript-comment">// Check if we already have this {interface, domain} tuple registered
</span>    {
        <span class="enscript-keyword">if</span> ((*p)-&gt;interface == interface &amp;&amp; SameDomainName(&amp;(*p)-&gt;domain, d))
        {
            <span class="enscript-keyword">if</span> (!((*p)-&gt;flags &amp; McastResolver_FlagDelete)) LogMsg(<span class="enscript-string">&quot;Note: Mcast Resolver domain %##s (%p) registered more than once&quot;</span>, d-&gt;c, interface);
            (*p)-&gt;flags &amp;= ~McastResolver_FlagDelete;
            tmp = *p;
            *p = tmp-&gt;next;
            tmp-&gt;next = mDNSNULL;
        }
        <span class="enscript-keyword">else</span>
            p=&amp;(*p)-&gt;next;
    }

    <span class="enscript-keyword">if</span> (tmp) *p = tmp; <span class="enscript-comment">// move to end of list, to ensure ordering from platform layer
</span>    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// allocate, add to list
</span>        *p = (McastResolver *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(**p));
        <span class="enscript-keyword">if</span> (!*p) LogMsg(<span class="enscript-string">&quot;mDNS_AddMcastResolver: ERROR!! - malloc&quot;</span>);
        <span class="enscript-keyword">else</span>
        {
            (*p)-&gt;interface = interface;
            (*p)-&gt;flags     = McastResolver_FlagNew;
            (*p)-&gt;timeout   = timeout;
            AssignDomainName(&amp;(*p)-&gt;domain, d);
            (*p)-&gt;next = mDNSNULL;
        }
    }
    <span class="enscript-keyword">return</span>(*p);
}

mDNSinline mDNSs32 <span class="enscript-function-name">PenaltyTimeForServer</span>(mDNS *m, DNSServer *server)
{
    mDNSs32 ptime = 0;
    <span class="enscript-keyword">if</span> (server-&gt;penaltyTime != 0)
    {
        ptime = server-&gt;penaltyTime - m-&gt;timenow;
        <span class="enscript-keyword">if</span> (ptime &lt; 0)
        {
            <span class="enscript-comment">// This should always be a positive value between 0 and DNSSERVER_PENALTY_TIME
</span>            <span class="enscript-comment">// If it does not get reset in ResetDNSServerPenalties for some reason, we do it
</span>            <span class="enscript-comment">// here
</span>            LogMsg(<span class="enscript-string">&quot;PenaltyTimeForServer: PenaltyTime negative %d, (server penaltyTime %d, timenow %d) resetting the penalty&quot;</span>,
                   ptime, server-&gt;penaltyTime, m-&gt;timenow);
            server-&gt;penaltyTime = 0;
            ptime = 0;
        }
    }
    <span class="enscript-keyword">return</span> ptime;
}

<span class="enscript-comment">//Checks to see whether the newname is a better match for the name, given the best one we have
</span><span class="enscript-comment">//seen so far (given in bestcount).
</span><span class="enscript-comment">//Returns -1 if the newname is not a better match
</span><span class="enscript-comment">//Returns 0 if the newname is the same as the old match
</span><span class="enscript-comment">//Returns 1 if the newname is a better match
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">BetterMatchForName</span>(<span class="enscript-type">const</span> domainname *name, <span class="enscript-type">int</span> namecount, <span class="enscript-type">const</span> domainname *newname, <span class="enscript-type">int</span> newcount,
                                 <span class="enscript-type">int</span> bestcount)
{
    <span class="enscript-comment">// If the name contains fewer labels than the new server's domain or the new name
</span>    <span class="enscript-comment">// contains fewer labels than the current best, then it can't possibly be a better match
</span>    <span class="enscript-keyword">if</span> (namecount &lt; newcount || newcount &lt; bestcount) <span class="enscript-keyword">return</span> -1;

    <span class="enscript-comment">// If there is no match, return -1 and the caller will skip this newname for
</span>    <span class="enscript-comment">// selection
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// If we find a match and the number of labels is the same as bestcount, then
</span>    <span class="enscript-comment">// we return 0 so that the caller can do additional logic to pick one of
</span>    <span class="enscript-comment">// the best based on some other factors e.g., penaltyTime
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// If we find a match and the number of labels is more than bestcount, then we
</span>    <span class="enscript-comment">// return 1 so that the caller can pick this over the old one.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: newcount can either be equal or greater than bestcount beause of the
</span>    <span class="enscript-comment">// check above.
</span>
    <span class="enscript-keyword">if</span> (SameDomainName(SkipLeadingLabels(name, namecount - newcount), newname))
        <span class="enscript-keyword">return</span> bestcount == newcount ? 0 : 1;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">// Normally, we have McastResolvers for .local, in-addr.arpa and ip6.arpa. But there
</span><span class="enscript-comment">// can be queries that can forced to multicast (ForceMCast) even though they don't end in these
</span><span class="enscript-comment">// names. In that case, we give a default timeout of 5 seconds
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MCAST_TIMEOUT</span>   5
mDNSlocal mDNSu32 <span class="enscript-function-name">GetTimeoutForMcastQuestion</span>(mDNS *m, DNSQuestion *question)
{
    McastResolver *curmatch = mDNSNULL;
    <span class="enscript-type">int</span> bestmatchlen = -1, namecount = CountLabels(&amp;question-&gt;qname);
    McastResolver *curr;
    <span class="enscript-type">int</span> bettermatch, currcount;
    <span class="enscript-keyword">for</span> (curr = m-&gt;McastResolvers; curr; curr = curr-&gt;next)
    {
        currcount = CountLabels(&amp;curr-&gt;domain);
        bettermatch = BetterMatchForName(&amp;question-&gt;qname, namecount, &amp;curr-&gt;domain, currcount, bestmatchlen);
        <span class="enscript-comment">// Take the first best match. If there are multiple equally good matches (bettermatch = 0), we take
</span>        <span class="enscript-comment">// the timeout value from the first one
</span>        <span class="enscript-keyword">if</span> (bettermatch == 1)
        {
            curmatch = curr;
            bestmatchlen = currcount;
        }
    }
    LogInfo(<span class="enscript-string">&quot;GetTimeoutForMcastQuestion: question %##s curmatch %p, Timeout %d&quot;</span>, question-&gt;qname.c, curmatch,
            curmatch ? curmatch-&gt;timeout : DEFAULT_MCAST_TIMEOUT);
    <span class="enscript-keyword">return</span> ( curmatch ? curmatch-&gt;timeout : DEFAULT_MCAST_TIMEOUT);
}

<span class="enscript-comment">// Returns true if it is a Domain Enumeration Query
</span>mDNSexport mDNSBool <span class="enscript-function-name">DomainEnumQuery</span>(<span class="enscript-type">const</span> domainname *qname)
{
    <span class="enscript-type">const</span> mDNSu8 *mDNS_DEQLabels[] = { (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\001b&quot;</span>, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\002db&quot;</span>, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\002lb&quot;</span>,
                                       (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\001r&quot;</span>, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\002dr&quot;</span>, (<span class="enscript-type">const</span> mDNSu8 *)mDNSNULL, };
    <span class="enscript-type">const</span> domainname *d = qname;
    <span class="enscript-type">const</span> mDNSu8 *label;
    <span class="enscript-type">int</span> i = 0;

    <span class="enscript-comment">// We need at least 3 labels (DEQ prefix) + one more label to make a meaningful DE query
</span>    <span class="enscript-keyword">if</span> (CountLabels(qname) &lt; 4) { debugf(<span class="enscript-string">&quot;DomainEnumQuery: question %##s, not enough labels&quot;</span>, qname-&gt;c); <span class="enscript-keyword">return</span> mDNSfalse; }

    label = (<span class="enscript-type">const</span> mDNSu8 *)d;
    <span class="enscript-keyword">while</span> (mDNS_DEQLabels[i] != (<span class="enscript-type">const</span> mDNSu8 *)mDNSNULL)
    {
        <span class="enscript-keyword">if</span> (SameDomainLabel(mDNS_DEQLabels[i], label)) {debugf(<span class="enscript-string">&quot;DomainEnumQuery: DEQ %##s, label1 match&quot;</span>, qname-&gt;c); <span class="enscript-keyword">break</span>;}
        i++;
    }
    <span class="enscript-keyword">if</span> (mDNS_DEQLabels[i] == (<span class="enscript-type">const</span> mDNSu8 *)mDNSNULL)
    {
        debugf(<span class="enscript-string">&quot;DomainEnumQuery: Not a DEQ %##s, label1 mismatch&quot;</span>, qname-&gt;c);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    debugf(<span class="enscript-string">&quot;DomainEnumQuery: DEQ %##s, label1 match&quot;</span>, qname-&gt;c);

    <span class="enscript-comment">// CountLabels already verified the number of labels
</span>    d = (<span class="enscript-type">const</span> domainname *)(d-&gt;c + 1 + d-&gt;c[0]);   <span class="enscript-comment">// Second Label
</span>    label = (<span class="enscript-type">const</span> mDNSu8 *)d;
    <span class="enscript-keyword">if</span> (!SameDomainLabel(label, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\007_dns-sd&quot;</span>))
    {
        debugf(<span class="enscript-string">&quot;DomainEnumQuery: Not a DEQ %##s, label2 mismatch&quot;</span>, qname-&gt;c);
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    debugf(<span class="enscript-string">&quot;DomainEnumQuery: DEQ %##s, label2 match&quot;</span>, qname-&gt;c);

    d = (<span class="enscript-type">const</span> domainname *)(d-&gt;c + 1 + d-&gt;c[0]);   <span class="enscript-comment">// Third Label
</span>    label = (<span class="enscript-type">const</span> mDNSu8 *)d;
    <span class="enscript-keyword">if</span> (!SameDomainLabel(label, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\004_udp&quot;</span>))
    {
        debugf(<span class="enscript-string">&quot;DomainEnumQuery: Not a DEQ %##s, label3 mismatch&quot;</span>, qname-&gt;c);
        <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    debugf(<span class="enscript-string">&quot;DomainEnumQuery: DEQ %##s, label3 match&quot;</span>, qname-&gt;c);

    debugf(<span class="enscript-string">&quot;DomainEnumQuery: Question %##s is a Domain Enumeration query&quot;</span>, qname-&gt;c);

    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// Note: InterfaceID is the InterfaceID of the question
</span>mDNSlocal mDNSBool <span class="enscript-function-name">DNSServerMatch</span>(DNSServer *d, mDNSInterfaceID InterfaceID, mDNSs32 ServiceID)
{
    <span class="enscript-comment">// 1) Unscoped questions (NULL InterfaceID) should consider *only* unscoped DNSServers ( DNSServer
</span>    <span class="enscript-comment">// with scopeType set to kScopeNone)
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2) Scoped questions (non-NULL InterfaceID) should consider *only* scoped DNSServers (DNSServer
</span>    <span class="enscript-comment">// with scopeType set to kScopeInterfaceID) and their InterfaceIDs should match.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 3) Scoped questions (non-zero ServiceID) should consider *only* scoped DNSServers (DNSServer
</span>    <span class="enscript-comment">// with scopeType set to kScopeServiceID) and their ServiceIDs should match.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// The first condition in the &quot;if&quot; statement checks to see if both the question and the DNSServer are
</span>    <span class="enscript-comment">// unscoped. The question is unscoped only if InterfaceID is zero and ServiceID is -1.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// If the first condition fails, following are the possible cases (the notes below are using
</span>    <span class="enscript-comment">// InterfaceID for discussion and the same holds good for ServiceID):
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - DNSServer is not scoped, InterfaceID is not NULL - we should skip the current DNSServer entry
</span>    <span class="enscript-comment">//   as scoped questions should not pick non-scoped DNSServer entry (Refer to (2) above).
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - DNSServer is scoped, InterfaceID is NULL - we should skip the current DNSServer entry as
</span>    <span class="enscript-comment">//   unscoped question should not match scoped DNSServer (Refer to (1) above). The InterfaceID check
</span>    <span class="enscript-comment">//   would fail in this case.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - DNSServer is scoped and InterfaceID is not NULL - the InterfaceID of the question and the DNSServer
</span>    <span class="enscript-comment">//   should match (Refer to (2) above).
</span>
    <span class="enscript-keyword">if</span> (((d-&gt;scopeType == kScopeNone) &amp;&amp; (!InterfaceID &amp;&amp; ServiceID == -1))  ||
        ((d-&gt;scopeType == kScopeInterfaceID) &amp;&amp; d-&gt;interface == InterfaceID) ||
        ((d-&gt;scopeType == kScopeServiceID) &amp;&amp; d-&gt;serviceID == ServiceID))
    {
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Sets all the Valid DNS servers for a question
</span>mDNSexport mDNSu32 <span class="enscript-function-name">SetValidDNSServers</span>(mDNS *m, DNSQuestion *question)
{
    <span class="enscript-type">int</span> bestmatchlen = -1, namecount = CountLabels(&amp;question-&gt;qname);
    DNSServer *curr;
    <span class="enscript-type">int</span> bettermatch, currcount;
    <span class="enscript-type">int</span> index = 0;
    mDNSu32 timeout = 0;
    mDNSBool DEQuery;

    question-&gt;validDNSServers = zeroOpaque128;
    DEQuery = DomainEnumQuery(&amp;question-&gt;qname);
    <span class="enscript-keyword">for</span> (curr = m-&gt;DNSServers; curr; curr = curr-&gt;next)
    {
        debugf(<span class="enscript-string">&quot;SetValidDNSServers: Parsing DNS server Address %#a (Domain %##s), Scope: %d&quot;</span>, &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;scopeType);
        <span class="enscript-comment">// skip servers that will soon be deleted
</span>        <span class="enscript-keyword">if</span> (curr-&gt;flags &amp; DNSServerFlag_Delete)
        {
            debugf(<span class="enscript-string">&quot;SetValidDNSServers: Delete set for index %d, DNS server %#a (Domain %##s), scoped %d&quot;</span>, index, &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;scopeType);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// This happens normally when you unplug the interface where we reset the interfaceID to mDNSInterface_Any for all
</span>        <span class="enscript-comment">// the DNS servers whose scope match the interfaceID. Few seconds later, we also receive the updated DNS configuration.
</span>        <span class="enscript-comment">// But any questions that has mDNSInterface_Any scope that are started/restarted before we receive the update
</span>        <span class="enscript-comment">// (e.g., CheckSuppressUnusableQuestions is called when interfaces are deregistered with the core) should not
</span>        <span class="enscript-comment">// match the scoped entries by mistake.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Note: DNS configuration change will help pick the new dns servers but currently it does not affect the timeout
</span>
        <span class="enscript-comment">// Skip DNSServers that are InterfaceID Scoped but have no valid interfaceid set OR DNSServers that are ServiceID Scoped but have no valid serviceid set
</span>        <span class="enscript-keyword">if</span> (((curr-&gt;scopeType == kScopeInterfaceID) &amp;&amp; (curr-&gt;interface == mDNSInterface_Any)) ||
            ((curr-&gt;scopeType == kScopeServiceID) &amp;&amp; (curr-&gt;serviceID &lt;= 0)))
        {
            LogInfo(<span class="enscript-string">&quot;SetValidDNSServers: ScopeType[%d] Skipping DNS server %#a (Domain %##s) Interface:[%p] Serviceid:[%d]&quot;</span>,
                (<span class="enscript-type">int</span>)curr-&gt;scopeType, &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;interface, curr-&gt;serviceID);
            <span class="enscript-keyword">continue</span>;
        }

        currcount = CountLabels(&amp;curr-&gt;domain);
        <span class="enscript-keyword">if</span> ((!DEQuery || !curr-&gt;isCell) &amp;&amp; DNSServerMatch(curr, question-&gt;InterfaceID, question-&gt;ServiceID))
        {
            bettermatch = BetterMatchForName(&amp;question-&gt;qname, namecount, &amp;curr-&gt;domain, currcount, bestmatchlen);

            <span class="enscript-comment">// If we found a better match (bettermatch == 1) then clear all the bits
</span>            <span class="enscript-comment">// corresponding to the old DNSServers that we have may set before and start fresh.
</span>            <span class="enscript-comment">// If we find an equal match, then include that DNSServer also by setting the corresponding
</span>            <span class="enscript-comment">// bit
</span>            <span class="enscript-keyword">if</span> ((bettermatch == 1) || (bettermatch == 0))
            {
                bestmatchlen = currcount;
                <span class="enscript-keyword">if</span> (bettermatch)
                {
                    debugf(<span class="enscript-string">&quot;SetValidDNSServers: Resetting all the bits&quot;</span>);
                    question-&gt;validDNSServers = zeroOpaque128;
                    timeout = 0;
                }
                debugf(<span class="enscript-string">&quot;SetValidDNSServers: question %##s Setting the bit for DNS server Address %#a (Domain %##s), Scoped:%d index %d,&quot;</span>
                       <span class="enscript-string">&quot; Timeout %d, interface %p&quot;</span>, question-&gt;qname.c, &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;scopeType, index, curr-&gt;timeout,
                       curr-&gt;interface);
                timeout += curr-&gt;timeout;
                <span class="enscript-keyword">if</span> (DEQuery)
                    debugf(<span class="enscript-string">&quot;DomainEnumQuery: Question %##s, DNSServer %#a, cell %d&quot;</span>, question-&gt;qname.c, &amp;curr-&gt;addr, curr-&gt;isCell);
                bit_set_opaque128(question-&gt;validDNSServers, index);
            }
        }
        index++;
    }
    question-&gt;noServerResponse = 0;

    debugf(<span class="enscript-string">&quot;SetValidDNSServers: ValidDNSServer bits 0x%08x%08x%08x%08x for question %p %##s (%s)&quot;</span>,
           question-&gt;validDNSServers.l[3], question-&gt;validDNSServers.l[2], question-&gt;validDNSServers.l[1], question-&gt;validDNSServers.l[0], question, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
    <span class="enscript-comment">// If there are no matching resolvers, then use the default timeout value.
</span>    <span class="enscript-comment">// For ProxyQuestion, shorten the timeout so that dig does not timeout on us in case of no response.
</span>    <span class="enscript-keyword">return</span> ((question-&gt;ProxyQuestion || question-&gt;ValidatingResponse) ? DEFAULT_UDNSSEC_TIMEOUT : timeout ? timeout : DEFAULT_UDNS_TIMEOUT);
}

<span class="enscript-comment">// Get the Best server that matches a name. If you find penalized servers, look for the one
</span><span class="enscript-comment">// that will come out of the penalty box soon
</span>mDNSlocal DNSServer *<span class="enscript-function-name">GetBestServer</span>(mDNS *m, <span class="enscript-type">const</span> domainname *name, mDNSInterfaceID InterfaceID, mDNSs32 ServiceID, mDNSOpaque128 validBits,
    <span class="enscript-type">int</span> *selected, mDNSBool nameMatch)
{
    DNSServer *curmatch = mDNSNULL;
    <span class="enscript-type">int</span> bestmatchlen = -1, namecount = name ? CountLabels(name) : 0;
    DNSServer *curr;
    mDNSs32 bestPenaltyTime, currPenaltyTime;
    <span class="enscript-type">int</span> bettermatch, currcount;
    <span class="enscript-type">int</span> index = 0;
    <span class="enscript-type">int</span> currindex = -1;

    debugf(<span class="enscript-string">&quot;GetBestServer: ValidDNSServer bits  0x%x%x&quot;</span>, validBits.l[1], validBits.l[0]);
    bestPenaltyTime = DNSSERVER_PENALTY_TIME + 1;
    <span class="enscript-keyword">for</span> (curr = m-&gt;DNSServers; curr; curr = curr-&gt;next)
    {
        <span class="enscript-comment">// skip servers that will soon be deleted
</span>        <span class="enscript-keyword">if</span> (curr-&gt;flags &amp; DNSServerFlag_Delete)
        {
            debugf(<span class="enscript-string">&quot;GetBestServer: Delete set for index %d, DNS server %#a (Domain %##s), scoped %d&quot;</span>, index, &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;scopeType);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// Check if this is a valid DNSServer
</span>        <span class="enscript-keyword">if</span> (!bit_get_opaque64(validBits, index))
        {
            debugf(<span class="enscript-string">&quot;GetBestServer: continuing for index %d&quot;</span>, index);
            index++;
            <span class="enscript-keyword">continue</span>;
        }

        currcount = CountLabels(&amp;curr-&gt;domain);
        currPenaltyTime = PenaltyTimeForServer(m, curr);

        debugf(<span class="enscript-string">&quot;GetBestServer: Address %#a (Domain %##s), PenaltyTime(abs) %d, PenaltyTime(rel) %d&quot;</span>,
               &amp;curr-&gt;addr, curr-&gt;domain.c, curr-&gt;penaltyTime, currPenaltyTime);

        <span class="enscript-comment">// If there are multiple best servers for a given question, we will pick the first one
</span>        <span class="enscript-comment">// if none of them are penalized. If some of them are penalized in that list, we pick
</span>        <span class="enscript-comment">// the least penalized one. BetterMatchForName walks through all best matches and
</span>        <span class="enscript-comment">// &quot;currPenaltyTime &lt; bestPenaltyTime&quot; check lets us either pick the first best server
</span>        <span class="enscript-comment">// in the list when there are no penalized servers and least one among them
</span>        <span class="enscript-comment">// when there are some penalized servers.
</span>
        <span class="enscript-keyword">if</span> (DNSServerMatch(curr, InterfaceID, ServiceID))
        {

            <span class="enscript-comment">// If we know that all the names are already equally good matches, then skip calling BetterMatchForName.
</span>            <span class="enscript-comment">// This happens when we initially walk all the DNS servers and set the validity bit on the question.
</span>            <span class="enscript-comment">// Actually we just need PenaltyTime match, but for the sake of readability we just skip the expensive
</span>            <span class="enscript-comment">// part and still do some redundant steps e.g., InterfaceID match
</span>
            <span class="enscript-keyword">if</span> (nameMatch)
                bettermatch = BetterMatchForName(name, namecount, &amp;curr-&gt;domain, currcount, bestmatchlen);
            <span class="enscript-keyword">else</span>
                bettermatch = 0;

            <span class="enscript-comment">// If we found a better match (bettermatch == 1) then we don't need to
</span>            <span class="enscript-comment">// compare penalty times. But if we found an equal match, then we compare
</span>            <span class="enscript-comment">// the penalty times to pick a better match
</span>
            <span class="enscript-keyword">if</span> ((bettermatch == 1) || ((bettermatch == 0) &amp;&amp; currPenaltyTime &lt; bestPenaltyTime))
            {
                currindex = index;
                curmatch = curr;
                bestmatchlen = currcount;
                bestPenaltyTime = currPenaltyTime;
            }
        }
        index++;
    }
    <span class="enscript-keyword">if</span> (selected) *selected = currindex;
    <span class="enscript-keyword">return</span> curmatch;
}

<span class="enscript-comment">// Look up a DNS Server, matching by name and InterfaceID
</span>mDNSlocal DNSServer *<span class="enscript-function-name">GetServerForName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *name, mDNSInterfaceID InterfaceID, mDNSs32 ServiceID)
{
    DNSServer *curmatch = mDNSNULL;
    <span class="enscript-type">char</span> *ifname = mDNSNULL;    <span class="enscript-comment">// for logging purposes only
</span>    mDNSOpaque128 allValid;

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly)
        InterfaceID = mDNSNULL;

    <span class="enscript-keyword">if</span> (InterfaceID) ifname = InterfaceNameForID(m, InterfaceID);

    <span class="enscript-comment">// By passing in all ones, we make sure that every DNS server is considered
</span>    allValid.l[0] = allValid.l[1] = allValid.l[2] = allValid.l[3] = 0xFFFFFFFF;

    curmatch = GetBestServer(m, name, InterfaceID, ServiceID, allValid, mDNSNULL, mDNStrue);

    <span class="enscript-keyword">if</span> (curmatch != mDNSNULL)
        LogInfo(<span class="enscript-string">&quot;GetServerForName: DNS server %#a:%d (Penalty Time Left %d) (Scope %s:%p) for %##s&quot;</span>, &amp;curmatch-&gt;addr,
                mDNSVal16(curmatch-&gt;port), (curmatch-&gt;penaltyTime ? (curmatch-&gt;penaltyTime - m-&gt;timenow) : 0), ifname ? ifname : <span class="enscript-string">&quot;None&quot;</span>,
                InterfaceID, name);
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;GetServerForName: no DNS server (Scope %s:%p) for %##s&quot;</span>, ifname ? ifname : <span class="enscript-string">&quot;None&quot;</span>, InterfaceID, name);

    <span class="enscript-keyword">return</span>(curmatch);
}

<span class="enscript-comment">// Look up a DNS Server for a question within its valid DNSServer bits
</span>mDNSexport DNSServer *<span class="enscript-function-name">GetServerForQuestion</span>(mDNS *m, DNSQuestion *question)
{
    DNSServer *curmatch = mDNSNULL;
    <span class="enscript-type">char</span> *ifname = mDNSNULL;    <span class="enscript-comment">// for logging purposes only
</span>    mDNSInterfaceID InterfaceID = question-&gt;InterfaceID;
    <span class="enscript-type">const</span> domainname *name = &amp;question-&gt;qname;
    <span class="enscript-type">int</span> currindex;

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly)
        InterfaceID = mDNSNULL;

    <span class="enscript-keyword">if</span> (InterfaceID)
        ifname = InterfaceNameForID(m, InterfaceID);

    <span class="enscript-keyword">if</span> (!mDNSOpaque128IsZero(&amp;question-&gt;validDNSServers))
    {
        curmatch = GetBestServer(m, name, InterfaceID, question-&gt;ServiceID, question-&gt;validDNSServers, &amp;currindex, mDNSfalse);
        <span class="enscript-keyword">if</span> (currindex != -1)
            bit_clr_opaque128(question-&gt;validDNSServers, currindex);
    }

    <span class="enscript-keyword">if</span> (curmatch != mDNSNULL)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] GetServerForQuestion: %p DNS server (%p) &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d (Penalty Time Left %d) (Scope &quot;</span> PUB_S <span class="enscript-string">&quot;:%p:%d) for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               question-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question, curmatch, &amp;curmatch-&gt;addr,
               mDNSVal16(curmatch-&gt;port), (curmatch-&gt;penaltyTime ? (curmatch-&gt;penaltyTime - m-&gt;timenow) : 0),
               ifname ? ifname : <span class="enscript-string">&quot;None&quot;</span>, InterfaceID, question-&gt;ServiceID, DM_NAME_PARAM(name), DNSTypeName(question-&gt;qtype));
    }
    <span class="enscript-keyword">else</span>
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;Q%d] GetServerForQuestion: %p no DNS server (Scope &quot;</span> PUB_S <span class="enscript-string">&quot;:%p:%d) for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
               question-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question, ifname ? ifname : <span class="enscript-string">&quot;None&quot;</span>, InterfaceID,
               question-&gt;ServiceID, DM_NAME_PARAM(name), DNSTypeName(question-&gt;qtype));
    }

    <span class="enscript-keyword">return</span>(curmatch);
}

<span class="enscript-comment">// Called in normal client context (lock not held)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">LLQNATCallback</span>(mDNS *m, NATTraversalInfo *n)
{
    DNSQuestion *q;
    mDNS_Lock(m);
    LogInfo(<span class="enscript-string">&quot;LLQNATCallback external address:port %.4a:%u, NAT result %d&quot;</span>, &amp;n-&gt;ExternalAddress, mDNSVal16(n-&gt;ExternalPort), n-&gt;Result);
    n-&gt;clientContext = mDNSNULL; <span class="enscript-comment">// we received at least one callback since starting this NAT-T
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
        <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;LongLived)
            startLLQHandshake(m, q);    <span class="enscript-comment">// If ExternalPort is zero, will do StartLLQPolling instead
</span>    mDNS_Unlock(m);
}

<span class="enscript-comment">// This function takes the DNSServer as a separate argument because sometimes the
</span><span class="enscript-comment">// caller has not yet assigned the DNSServer, but wants to evaluate the Suppressed
</span><span class="enscript-comment">// status before switching to it.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">ShouldSuppressUnicastQuery</span>(<span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> DNSServer *<span class="enscript-type">const</span> server)
{
    mDNSBool suppress = mDNSfalse;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason = NULL;

    <span class="enscript-keyword">if</span> (q-&gt;BlockedByPolicy)
    {
        suppress = mDNStrue;
        reason   = <span class="enscript-string">&quot; (blocked by policy)&quot;</span>;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!server)
    {
        <span class="enscript-keyword">if</span> (!q-&gt;IsUnicastDotLocal)
        {
            suppress = mDNStrue;
            reason   = <span class="enscript-string">&quot; (no DNS server)&quot;</span>;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (server-&gt;isCell &amp;&amp; (q-&gt;flags &amp; kDNSServiceFlagsDenyCellular))
    {
        suppress = mDNStrue;
        reason   = <span class="enscript-string">&quot; (interface is cellular)&quot;</span>;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (server-&gt;isExpensive &amp;&amp; (q-&gt;flags &amp; kDNSServiceFlagsDenyExpensive))
    {
        suppress = mDNStrue;
        reason   = <span class="enscript-string">&quot; (interface is expensive)&quot;</span>;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (server-&gt;isConstrained &amp;&amp; (q-&gt;flags &amp; kDNSServiceFlagsDenyConstrained))
    {
        suppress = mDNStrue;
        reason   = <span class="enscript-string">&quot; (interface is constrained)&quot;</span>;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;SuppressUnusable &amp;&amp; !DNS64IsQueryingARecord(q-&gt;dns64.state))
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;SuppressUnusable)
#<span class="enscript-reference">endif</span>
    {
        <span class="enscript-keyword">if</span> (q-&gt;qtype == kDNSType_A)
        {
            <span class="enscript-keyword">if</span> (!server-&gt;usableA)
            {
                suppress = mDNStrue;
                reason   = <span class="enscript-string">&quot; (A records are unusable)&quot;</span>;
            }
            <span class="enscript-comment">// If the server's configuration allows A record queries, suppress this query if
</span>            <span class="enscript-comment">//     1. the interface associated with the server is CLAT46; and
</span>            <span class="enscript-comment">//     2. the query has the kDNSServiceFlagsPathEvaluationDone flag, indicating that it's from libnetwork.
</span>            <span class="enscript-comment">// See &lt;rdar://problem/42672030&gt; for more info.
</span>            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (server-&gt;isCLAT46 &amp;&amp; (q-&gt;flags &amp; kDNSServiceFlagsPathEvaluationDone))
            {
                suppress = mDNStrue;
                reason   = <span class="enscript-string">&quot; (CLAT46 A records are unusable)&quot;</span>;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;qtype == kDNSType_AAAA)
        {
            <span class="enscript-keyword">if</span> (!server-&gt;usableAAAA)
            {
                suppress = mDNStrue;
                reason   = <span class="enscript-string">&quot; (AAAA records are unusable)&quot;</span>;
            }
        }
    }
    <span class="enscript-keyword">if</span> (suppress)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;[Q%u] ShouldSuppressUnicastQuery: Query suppressed for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; &quot;</span> PUB_S PUB_S,
            mDNSVal16(q-&gt;TargetQID), DM_NAME_PARAM(&amp;q-&gt;qname), DNSTypeName(q-&gt;qtype), reason ? reason : <span class="enscript-string">&quot;&quot;</span>);
    }
    <span class="enscript-keyword">return</span> suppress;
}

mDNSlocal mDNSBool <span class="enscript-function-name">ShouldSuppressQuery</span>(DNSQuestion *q)
{
    <span class="enscript-keyword">if</span> (q-&gt;InterfaceID == mDNSInterface_LocalOnly)
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (!q-&gt;IsUnicastDotLocal &amp;&amp; IsLocalDomain(&amp;q-&gt;qname))
    {
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> (ShouldSuppressUnicastQuery(q, q-&gt;qDNSServer));
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CacheRecordRmvEventsForCurrentQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    CacheRecord *cr;
    CacheGroup *cg;

    cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
    {
        <span class="enscript-comment">// Don't deliver RMV events for negative records
</span>        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                      <span class="enscript-string">&quot;[R%u-&gt;Q%u] CacheRecordRmvEventsForCurrentQuestion: CacheRecord &quot;</span> PRI_S <span class="enscript-string">&quot; Suppressing RMV events for question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;), CRActiveQuestion %p, CurrentAnswers %d&quot;</span>,
                      q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), CRDisplayString(m, cr), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), cr-&gt;CRActiveQuestion, q-&gt;CurrentAnswers);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, q))
        {
            LogInfo(<span class="enscript-string">&quot;CacheRecordRmvEventsForCurrentQuestion: Calling AnswerCurrentQuestionWithResourceRecord (RMV) for question %##s using resource record %s LocalAnswers %d&quot;</span>,
                    q-&gt;qname.c, CRDisplayString(m, cr), q-&gt;LOAddressAnswers);

            q-&gt;CurrentAnswers--;
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rdlength &gt; SmallRecordLimit) q-&gt;LargeAnswers--;
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType &amp; kDNSRecordTypePacketUniqueMask) q-&gt;UniqueAnswers--;
            AnswerCurrentQuestionWithResourceRecord(m, cr, QC_rmv);
            <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) <span class="enscript-keyword">break</span>;     <span class="enscript-comment">// If callback deleted q, then we're finished here
</span>        }
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">IsQuestionNew</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question)
{
    DNSQuestion *q;
    <span class="enscript-keyword">for</span> (q = m-&gt;NewQuestions; q; q = q-&gt;next)
        <span class="enscript-keyword">if</span> (q == question) <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal mDNSBool <span class="enscript-function-name">LocalRecordRmvEventsForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    AuthRecord *rr;
    AuthGroup *ag;

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;LocalRecordRmvEventsForQuestion: ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));

    <span class="enscript-keyword">if</span> (IsQuestionNew(m, q))
    {
        LogInfo(<span class="enscript-string">&quot;LocalRecordRmvEventsForQuestion: New Question %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    m-&gt;CurrentQuestion = q;
    ag = AuthGroupForName(&amp;m-&gt;rrauth, q-&gt;qnamehash, &amp;q-&gt;qname);
    <span class="enscript-keyword">if</span> (ag)
    {
        <span class="enscript-keyword">for</span> (rr = ag-&gt;members; rr; rr=rr-&gt;next)
            <span class="enscript-comment">// Filter the /etc/hosts records - LocalOnly, Unique, A/AAAA/CNAME
</span>            <span class="enscript-keyword">if</span> (UniqueLocalOnlyRecord(rr) &amp;&amp; LocalOnlyRecordAnswersQuestion(rr, q))
            {
                LogInfo(<span class="enscript-string">&quot;LocalRecordRmvEventsForQuestion: Delivering possible Rmv events with record %s&quot;</span>,
                        ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (q-&gt;CurrentAnswers &lt;= 0 || q-&gt;LOAddressAnswers &lt;= 0)
                {
                    LogMsg(<span class="enscript-string">&quot;LocalRecordRmvEventsForQuestion: ERROR!! CurrentAnswers or LOAddressAnswers is zero %p %##s&quot;</span>
                           <span class="enscript-string">&quot; (%s) CurrentAnswers %d, LOAddressAnswers %d&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype),
                           q-&gt;CurrentAnswers, q-&gt;LOAddressAnswers);
                    <span class="enscript-keyword">continue</span>;
                }
                AnswerLocalQuestionWithLocalAuthRecord(m, rr, QC_rmv);      <span class="enscript-comment">// MUST NOT dereference q again
</span>                <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) { m-&gt;CurrentQuestion = mDNSNULL; <span class="enscript-keyword">return</span> mDNSfalse; }
            }
    }
    m-&gt;CurrentQuestion = mDNSNULL;
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// Returns false if the question got deleted while delivering the RMV events
</span><span class="enscript-comment">// The caller should handle the case
</span>mDNSexport mDNSBool <span class="enscript-function-name">CacheRecordRmvEventsForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
        LogMsg(<span class="enscript-string">&quot;CacheRecordRmvEventsForQuestion: ERROR m-&gt;CurrentQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;CurrentQuestion-&gt;qname.c, DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));

    <span class="enscript-comment">// If it is a new question, we have not delivered any ADD events yet. So, don't deliver RMV events.
</span>    <span class="enscript-comment">// If this question was answered using local auth records, then you can't deliver RMVs using cache
</span>    <span class="enscript-keyword">if</span> (!IsQuestionNew(m, q) &amp;&amp; !q-&gt;LOAddressAnswers)
    {
        m-&gt;CurrentQuestion = q;
        CacheRecordRmvEventsForCurrentQuestion(m, q);
        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion != q) { m-&gt;CurrentQuestion = mDNSNULL; <span class="enscript-keyword">return</span> mDNSfalse; }
        m-&gt;CurrentQuestion = mDNSNULL;
    }
    <span class="enscript-keyword">else</span> { LogInfo(<span class="enscript-string">&quot;CacheRecordRmvEventsForQuestion: Question %p %##s (%s) is a new question&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype)); }
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SuppressStatusChanged</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, DNSQuestion **restart)
{
    <span class="enscript-comment">// NOTE: CacheRecordRmvEventsForQuestion will not generate RMV events for queries that have non-zero
</span>    <span class="enscript-comment">// LOAddressAnswers. Hence it is important that we call CacheRecordRmvEventsForQuestion before
</span>    <span class="enscript-comment">// LocalRecordRmvEventsForQuestion (which decrements LOAddressAnswers)
</span>    <span class="enscript-keyword">if</span> (q-&gt;Suppressed)
    {
        q-&gt;Suppressed = mDNSfalse;
        <span class="enscript-keyword">if</span> (!CacheRecordRmvEventsForQuestion(m, q))
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;[R%u-&gt;Q%u] SuppressStatusChanged: Question deleted while delivering RMV events from cache&quot;</span>,
                q-&gt;request_id, mDNSVal16(q-&gt;TargetQID));
            <span class="enscript-keyword">return</span>;
        }
        q-&gt;Suppressed = mDNStrue;
    }

    <span class="enscript-comment">// SuppressUnusable does not affect questions that are answered from the local records (/etc/hosts)
</span>    <span class="enscript-comment">// and Suppressed status does not mean anything for these questions. As we are going to stop the
</span>    <span class="enscript-comment">// question below, we need to deliver the RMV events so that the ADDs that will be delivered during
</span>    <span class="enscript-comment">// the restart will not be a duplicate ADD
</span>    <span class="enscript-keyword">if</span> (!LocalRecordRmvEventsForQuestion(m, q))
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;[R%u-&gt;Q%u] SuppressStatusChanged: Question deleted while delivering RMV events from Local AuthRecords&quot;</span>,
            q-&gt;request_id, mDNSVal16(q-&gt;TargetQID));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// There are two cases here.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. Previously it was suppressed and now it is not suppressed, restart the question so
</span>    <span class="enscript-comment">// that it will start as a new question. Note that we can't just call ActivateUnicastQuery
</span>    <span class="enscript-comment">// because when we get the response, if we had entries in the cache already, it will not answer
</span>    <span class="enscript-comment">// this question if the cache entry did not change. Hence, we need to restart
</span>    <span class="enscript-comment">// the query so that it can be answered from the cache.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. Previously it was not suppressed and now it is suppressed. We need to restart the questions
</span>    <span class="enscript-comment">// so that we redo the duplicate checks in mDNS_StartQuery_internal. A SuppressUnusable question
</span>    <span class="enscript-comment">// is a duplicate of non-SuppressUnusable question if it is not suppressed (Suppressed is false).
</span>    <span class="enscript-comment">// A SuppressUnusable question is not a duplicate of non-SuppressUnusable question if it is suppressed
</span>    <span class="enscript-comment">// (Suppressed is true). The reason for this is that when a question is suppressed, we want an
</span>    <span class="enscript-comment">// immediate response and not want to be blocked behind a question that is querying DNS servers. When
</span>    <span class="enscript-comment">// the question is not suppressed, we don't want two active questions sending packets on the wire.
</span>    <span class="enscript-comment">// This affects both efficiency and also the current design where there is only one active question
</span>    <span class="enscript-comment">// pointed to from a cache entry.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We restart queries in a two step process by first calling stop and build a temporary list which we
</span>    <span class="enscript-comment">// will restart at the end. The main reason for the two step process is to handle duplicate questions.
</span>    <span class="enscript-comment">// If there are duplicate questions, calling stop inherits the values from another question on the list (which
</span>    <span class="enscript-comment">// will soon become the real question) including q-&gt;ThisQInterval which might be zero if it was
</span>    <span class="enscript-comment">// suppressed before. At the end when we have restarted all questions, none of them is active as each
</span>    <span class="enscript-comment">// inherits from one another and we need to reactivate one of the questions here which is a little hacky.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// It is much cleaner and less error prone to build a list of questions and restart at the end.
</span>
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;[R%u-&gt;Q%u] SuppressStatusChanged: Stop question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
        q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));
    mDNS_StopQuery_internal(m, q);
    q-&gt;next = *restart;
    *restart = q;
}

<span class="enscript-comment">// The caller should hold the lock
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">CheckSuppressUnusableQuestions</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q;
    DNSQuestion *restart = mDNSNULL;

    <span class="enscript-comment">// We look through all questions including new questions. During network change events,
</span>    <span class="enscript-comment">// we potentially restart questions here in this function that ends up as new questions,
</span>    <span class="enscript-comment">// which may be suppressed at this instance. Before it is handled we get another network
</span>    <span class="enscript-comment">// event that changes the status e.g., address becomes available. If we did not process
</span>    <span class="enscript-comment">// new questions, we would never change its Suppressed status.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// CurrentQuestion is used by RmvEventsForQuestion below. While delivering RMV events, the
</span>    <span class="enscript-comment">// application callback can potentially stop the current question (detected by CurrentQuestion) or
</span>    <span class="enscript-comment">// *any* other question which could be the next one that we may process here. RestartQuestion
</span>    <span class="enscript-comment">// points to the &quot;next&quot; question which will be automatically advanced in mDNS_StopQuery_internal
</span>    <span class="enscript-comment">// if the &quot;next&quot; question is stopped while the CurrentQuestion is stopped
</span>    <span class="enscript-keyword">if</span> (m-&gt;RestartQuestion)
        LogMsg(<span class="enscript-string">&quot;CheckSuppressUnusableQuestions: ERROR!! m-&gt;RestartQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;RestartQuestion-&gt;qname.c, DNSTypeName(m-&gt;RestartQuestion-&gt;qtype));
    m-&gt;RestartQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;RestartQuestion)
    {
        q = m-&gt;RestartQuestion;
        m-&gt;RestartQuestion = q-&gt;next;
        <span class="enscript-keyword">if</span> (q-&gt;SuppressUnusable)
        {
            <span class="enscript-type">const</span> mDNSBool old = q-&gt;Suppressed;
            q-&gt;Suppressed = ShouldSuppressQuery(q);
            <span class="enscript-keyword">if</span> (q-&gt;Suppressed != old)
            {
                <span class="enscript-comment">// Previously it was not suppressed, Generate RMV events for the ADDs that we might have delivered before
</span>                <span class="enscript-comment">// followed by a negative cache response. Temporarily turn off suppression so that
</span>                <span class="enscript-comment">// AnswerCurrentQuestionWithResourceRecord can answer the question
</span>                SuppressStatusChanged(m, q, &amp;restart);
            }
        }
    }
    <span class="enscript-keyword">while</span> (restart)
    {
        q = restart;
        restart = restart-&gt;next;
        q-&gt;next = mDNSNULL;
        LogInfo(<span class="enscript-string">&quot;CheckSuppressUnusableQuestions: Start question %p %##s (%s)&quot;</span>, q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        mDNS_StartQuery_internal(m, q);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RestartUnicastQuestions</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q;
    DNSQuestion *restartList = mDNSNULL;

    <span class="enscript-keyword">if</span> (m-&gt;RestartQuestion)
        LogMsg(<span class="enscript-string">&quot;RestartUnicastQuestions: ERROR!! m-&gt;RestartQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;RestartQuestion-&gt;qname.c, DNSTypeName(m-&gt;RestartQuestion-&gt;qtype));
    m-&gt;RestartQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;RestartQuestion)
    {
        q = m-&gt;RestartQuestion;
        m-&gt;RestartQuestion = q-&gt;next;
        <span class="enscript-keyword">if</span> (q-&gt;Restart)
        {
            <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))
                LogMsg(<span class="enscript-string">&quot;RestartUnicastQuestions: ERROR!! Restart set for multicast question %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

            q-&gt;Restart = mDNSfalse;
            SuppressStatusChanged(m, q, &amp;restartList);
        }
    }
    <span class="enscript-keyword">while</span> ((q = restartList) != mDNSNULL)
    {
        restartList = q-&gt;next;
        q-&gt;next = mDNSNULL;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;[R%u-&gt;Q%u] RestartUnicastQuestions: Start question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
             q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));
        mDNS_StartQuery_internal(m, q);
    }
}

<span class="enscript-comment">// ValidateParameters() is called by mDNS_StartQuery_internal() to check the client parameters of 
</span><span class="enscript-comment">// DNS Question that are already set by the client before calling mDNS_StartQuery() 
</span>mDNSlocal mStatus <span class="enscript-function-name">ValidateParameters</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    <span class="enscript-keyword">if</span> (!ValidateDomainName(&amp;question-&gt;qname))
    {
        LogMsg(<span class="enscript-string">&quot;ValidateParameters: Attempt to start query with invalid qname %##s (%s)&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        <span class="enscript-keyword">return</span>(mStatus_Invalid);
    }

    <span class="enscript-comment">// If this question is referencing a specific interface, verify it exists 
</span>    <span class="enscript-keyword">if</span> (question-&gt;InterfaceID &amp;&amp; !LocalOnlyOrP2PInterface(question-&gt;InterfaceID))
    {
        NetworkInterfaceInfo *intf = FirstInterfaceForID(m, question-&gt;InterfaceID);
        <span class="enscript-keyword">if</span> (!intf)
            LogInfo(<span class="enscript-string">&quot;ValidateParameters: Note: InterfaceID %d for question %##s (%s) not currently found in active interface list&quot;</span>,
                    IIDPrintable(question-&gt;InterfaceID), question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// InitDNSConfig() is called by InitCommonState() to initialize the DNS configuration of the Question.    
</span><span class="enscript-comment">// These are a subset of the internal uDNS fields. Must be done before ShouldSuppressQuery() &amp; mDNS_PurgeBeforeResolve()
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitDNSConfig</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    <span class="enscript-comment">// First reset all DNS Configuration
</span>    question-&gt;qDNSServer          = mDNSNULL;
    question-&gt;validDNSServers     = zeroOpaque128;
    question-&gt;triedAllServersOnce = mDNSfalse;
    question-&gt;noServerResponse    = mDNSfalse;
    question-&gt;StopTime            = (question-&gt;TimeoutQuestion) ? question-&gt;StopTime : 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    mDNSPlatformMemZero(&amp;question-&gt;metrics, <span class="enscript-keyword">sizeof</span>(question-&gt;metrics));
    question-&gt;metrics.expiredAnswerState = (question-&gt;allowExpired != AllowExpired_None) ? ExpiredAnswer_Allowed : ExpiredAnswer_None;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Need not initialize the DNS Configuration for Local Only OR P2P Questions when timeout not specified
</span>    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(question-&gt;InterfaceID) &amp;&amp; !question-&gt;TimeoutQuestion)
        <span class="enscript-keyword">return</span>;
    <span class="enscript-comment">// Proceed to initialize DNS Configuration (some are set in SetValidDNSServers())
</span>    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(question-&gt;TargetQID))
    {
        mDNSu32 timeout = SetValidDNSServers(m, question);
        <span class="enscript-comment">// We set the timeout value the first time mDNS_StartQuery_internal is called for a question.
</span>        <span class="enscript-comment">// So if a question is restarted when a network change occurs, the StopTime is not reset.
</span>        <span class="enscript-comment">// Note that we set the timeout for all questions. If this turns out to be a duplicate,
</span>        <span class="enscript-comment">// it gets a full timeout value even if the original question times out earlier.
</span>        <span class="enscript-keyword">if</span> (question-&gt;TimeoutQuestion &amp;&amp; !question-&gt;StopTime)
        {
            question-&gt;StopTime = NonZeroTime(m-&gt;timenow + timeout * mDNSPlatformOneSecond);
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;[Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                mDNSVal16(question-&gt;TargetQID), question, DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype));
        }

        question-&gt;qDNSServer = GetServerForQuestion(m, question);
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
            <span class="enscript-string">&quot;[R%u-&gt;Q%u] InitDNSConfig: question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; &quot;</span> PUB_S <span class="enscript-string">&quot; Timeout %d, DNS Server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d&quot;</span>,
            question-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question, DM_NAME_PARAM(question-&gt;qname.c),
            DNSTypeName(question-&gt;qtype), timeout, question-&gt;qDNSServer ? &amp;question-&gt;qDNSServer-&gt;addr : mDNSNULL,
            mDNSVal16(question-&gt;qDNSServer ? question-&gt;qDNSServer-&gt;port : zeroIPPort));
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question-&gt;TimeoutQuestion &amp;&amp; !question-&gt;StopTime)
    {
        <span class="enscript-comment">// If the question is to be timed out and its a multicast, local-only or P2P case,
</span>        <span class="enscript-comment">// then set it's stop time.
</span>        mDNSu32 timeout = LocalOnlyOrP2PInterface(question-&gt;InterfaceID) ?
                            DEFAULT_LO_OR_P2P_TIMEOUT : GetTimeoutForMcastQuestion(m, question);
        question-&gt;StopTime = NonZeroTime(m-&gt;timenow + timeout * mDNSPlatformOneSecond);
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                  <span class="enscript-string">&quot;[R%u-&gt;Q%u] InitDNSConfig: Setting StopTime on the uDNS question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                  question-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question, DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype));
    }
    <span class="enscript-comment">// Set StopTime here since it is a part of DNS Configuration 
</span>    <span class="enscript-keyword">if</span> (question-&gt;StopTime)
        SetNextQueryStopTime(m, question);
    <span class="enscript-comment">// Don't call SetNextQueryTime() if a LocalOnly OR P2P Question since those questions
</span>    <span class="enscript-comment">// will never be transmitted on the wire.
</span>    <span class="enscript-keyword">if</span> (!(LocalOnlyOrP2PInterface(question-&gt;InterfaceID)))
        SetNextQueryTime(m,question);
}

<span class="enscript-comment">// InitCommonState() is called by mDNS_StartQuery_internal() to initialize the common(uDNS/mDNS) internal
</span><span class="enscript-comment">// state fields of the DNS Question. These are independent of the Client layer.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitCommonState</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    <span class="enscript-type">int</span> i;
    mDNSBool isBlocked = mDNSfalse;

    <span class="enscript-comment">// Note: In the case where we already have the answer to this question in our cache, that may be all the client
</span>    <span class="enscript-comment">// wanted, and they may immediately cancel their question. In this case, sending an actual query on the wire would
</span>    <span class="enscript-comment">// be a waste. For that reason, we schedule our first query to go out in half a second (InitialQuestionInterval).
</span>    <span class="enscript-comment">// If AnswerNewQuestion() finds that we have *no* relevant answers currently in our cache, then it will accelerate
</span>    <span class="enscript-comment">// that to go out immediately.
</span>    question-&gt;next              = mDNSNULL;
    <span class="enscript-comment">// ThisQInterval should be initialized before any memory allocations occur. If malloc
</span>    <span class="enscript-comment">// debugging is turned on within mDNSResponder (see mDNSDebug.h for details) it validates
</span>    <span class="enscript-comment">// the question list to check if ThisQInterval is negative which means the question has been
</span>    <span class="enscript-comment">// stopped and can't be on the list. The question is already on the list and ThisQInterval
</span>    <span class="enscript-comment">// can be negative if the caller just stopped it and starting it again. Hence, it always has to
</span>    <span class="enscript-comment">// be initialized. CheckForSoonToExpireRecords below prints the cache records when logging is
</span>    <span class="enscript-comment">// turned ON which can allocate memory e.g., base64 encoding, in the case of DNSSEC.
</span>    question-&gt;ThisQInterval     = InitialQuestionInterval;                  <span class="enscript-comment">// MUST be &gt; zero for an active question
</span>    question-&gt;qnamehash         = DomainNameHashValue(&amp;question-&gt;qname);
    question-&gt;DelayAnswering    = mDNSOpaque16IsZero(question-&gt;TargetQID) ? CheckForSoonToExpireRecords(m, &amp;question-&gt;qname, question-&gt;qnamehash) : 0;
    question-&gt;LastQTime         = m-&gt;timenow;
    question-&gt;ExpectUnicastResp = 0;
    question-&gt;LastAnswerPktNum  = m-&gt;PktNum;
    question-&gt;RecentAnswerPkts  = 0;
    question-&gt;CurrentAnswers    = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

<span class="enscript-comment">// Initial browse threshold used by Finder.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSFinderBrowseThreshold</span> 20

    <span class="enscript-comment">// Set the threshold at which we move to a passive browse state,
</span>    <span class="enscript-comment">// not actively sending queries.
</span>    <span class="enscript-keyword">if</span> (question-&gt;flags &amp; kDNSServiceFlagsThresholdOne)
        question-&gt;BrowseThreshold   = 1;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question-&gt;flags &amp; kDNSServiceFlagsThresholdFinder)
        question-&gt;BrowseThreshold   = mDNSFinderBrowseThreshold;
    <span class="enscript-keyword">else</span>
        question-&gt;BrowseThreshold   = 0;

#<span class="enscript-reference">else</span>   // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
   question-&gt;BrowseThreshold   = 0;
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    question-&gt;CachedAnswerNeedsUpdate = mDNSfalse;

    question-&gt;LargeAnswers      = 0;
    question-&gt;UniqueAnswers     = 0;
    question-&gt;LOAddressAnswers  = 0;
    question-&gt;FlappingInterface1 = mDNSNULL;
    question-&gt;FlappingInterface2 = mDNSNULL;

    <span class="enscript-comment">// if kDNSServiceFlagsServiceIndex flag is SET by the client, then do NOT call mDNSPlatformGetDNSRoutePolicy()
</span>    <span class="enscript-comment">// since we would already have the question-&gt;ServiceID in that case.
</span>    <span class="enscript-keyword">if</span> (!(question-&gt;flags &amp; kDNSServiceFlagsServiceIndex))
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        mDNSPlatformGetDNSRoutePolicy(question, &amp;isBlocked);
#<span class="enscript-reference">else</span>
        question-&gt;ServiceID = -1;
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;InitCommonState: Query for %##s (%s), PID[%d], EUID[%d], ServiceID[%d] is already set by client&quot;</span>, question-&gt;qname.c,
                DNSTypeName(question-&gt;qtype), question-&gt;pid, question-&gt;euid, question-&gt;ServiceID);

    InitDNSConfig(m, question);

    question-&gt;AuthInfo          = GetAuthInfoForQuestion(m, question);

    <span class="enscript-comment">// The question's BlockedByPolicy value must be set before calling ShouldSuppressQuery().
</span>    question-&gt;BlockedByPolicy   = isBlocked ? mDNStrue : mDNSfalse;
    question-&gt;Suppressed        = ShouldSuppressQuery(question);
    question-&gt;NextInDQList      = mDNSNULL;
    question-&gt;SendQNow          = mDNSNULL;
    question-&gt;SendOnAll         = mDNSfalse;
    question-&gt;RequestUnicast    = kDefaultRequestUnicastCount;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-comment">// Set the QU bit in the first query for the following options.
</span>    <span class="enscript-keyword">if</span> ((question-&gt;flags &amp; kDNSServiceFlagsUnicastResponse) || (question-&gt;flags &amp; kDNSServiceFlagsThresholdFinder))
    {
        question-&gt;RequestUnicast    = SET_QU_IN_FIRST_QUERY;
        LogInfo(<span class="enscript-string">&quot;InitCommonState: setting RequestUnicast = %d for %##s (%s)&quot;</span>, question-&gt;RequestUnicast, question-&gt;qname.c,
            DNSTypeName(question-&gt;qtype));
    }
#<span class="enscript-reference">endif</span>  // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    question-&gt;LastQTxTime       = m-&gt;timenow;
    question-&gt;CNAMEReferrals    = 0;

    question-&gt;WakeOnResolveCount = 0;
    <span class="enscript-keyword">if</span> (question-&gt;WakeOnResolve)
    {
        question-&gt;WakeOnResolveCount = InitialWakeOnResolveCount;
    }

    <span class="enscript-keyword">for</span> (i=0; i&lt;DupSuppressInfoSize; i++)
        question-&gt;DupSuppress[i].InterfaceID = mDNSNULL;

    question-&gt;Restart = mDNSfalse;

    debugf(<span class="enscript-string">&quot;InitCommonState: Question %##s (%s) Interface %p Now %d Send in %d Answer in %d (%p) %s (%p)&quot;</span>,
            question-&gt;qname.c, DNSTypeName(question-&gt;qtype), question-&gt;InterfaceID, m-&gt;timenow,
            NextQSendTime(question) - m-&gt;timenow,
            question-&gt;DelayAnswering ? question-&gt;DelayAnswering - m-&gt;timenow : 0,
            question, question-&gt;DuplicateOf ? <span class="enscript-string">&quot;duplicate of&quot;</span> : <span class="enscript-string">&quot;not duplicate&quot;</span>, question-&gt;DuplicateOf);

    <span class="enscript-keyword">if</span> (question-&gt;DelayAnswering)
        LogInfo(<span class="enscript-string">&quot;InitCommonState: Delaying answering for %d ticks while cache stabilizes for %##s (%s)&quot;</span>,
                 question-&gt;DelayAnswering - m-&gt;timenow, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
}

<span class="enscript-comment">// Excludes the DNS Config fields which are already handled by InitDNSConfig()
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitWABState</span>(DNSQuestion *<span class="enscript-type">const</span> question)
{
    <span class="enscript-comment">// We'll create our question-&gt;LocalSocket on demand, if needed.
</span>    <span class="enscript-comment">// We won't need one for duplicate questions, or from questions answered immediately out of the cache.
</span>    <span class="enscript-comment">// We also don't need one for LLQs because (when we're using NAT) we want them all to share a single
</span>    <span class="enscript-comment">// NAT mapping for receiving inbound add/remove events.
</span>    question-&gt;LocalSocket       = mDNSNULL;
    question-&gt;unansweredQueries = 0;
    question-&gt;nta               = mDNSNULL;
    question-&gt;servAddr          = zeroAddr;
    question-&gt;servPort          = zeroIPPort;
    question-&gt;tcp               = mDNSNULL;
    question-&gt;NoAnswer          = NoAnswer_Normal;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitLLQNATState</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-comment">// If we don't have our NAT mapping active, start it now
</span>    <span class="enscript-keyword">if</span> (!m-&gt;LLQNAT.clientCallback)
    {
        m-&gt;LLQNAT.Protocol       = NATOp_MapUDP;
        m-&gt;LLQNAT.IntPort        = m-&gt;UnicastPort4;
        m-&gt;LLQNAT.RequestedPort  = m-&gt;UnicastPort4;
        m-&gt;LLQNAT.clientCallback = LLQNATCallback;
        m-&gt;LLQNAT.clientContext  = (<span class="enscript-type">void</span>*)1; <span class="enscript-comment">// Means LLQ NAT Traversal just started
</span>        mDNS_StartNATOperation_internal(m, &amp;m-&gt;LLQNAT);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitLLQState</span>(DNSQuestion *<span class="enscript-type">const</span> question)
{
    question-&gt;state             = LLQ_Init;
    question-&gt;ReqLease          = 0;
    question-&gt;expire            = 0;
    question-&gt;ntries            = 0;
    question-&gt;id                = zeroOpaque64;
}

<span class="enscript-comment">// InitDNSSECProxyState() is called by mDNS_StartQuery_internal() to initialize
</span><span class="enscript-comment">// DNSSEC &amp; DNS Proxy fields of the DNS Question. 
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitDNSSECProxyState</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    (<span class="enscript-type">void</span>) m;

    <span class="enscript-comment">// DNS server selection affects DNSSEC. Turn off validation if req_DO is not set
</span>    <span class="enscript-comment">// or the request is going over cellular interface.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: This needs to be done here before we call FindDuplicateQuestion as it looks
</span>    <span class="enscript-comment">// at ValidationRequired setting also.
</span>    <span class="enscript-keyword">if</span> (question-&gt;qDNSServer)
    {
        <span class="enscript-keyword">if</span> (question-&gt;qDNSServer-&gt;isCell)
        {
            debugf(<span class="enscript-string">&quot;InitDNSSECProxyState: Turning off validation for %##s (%s); going over cell&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
            question-&gt;ValidationRequired = mDNSfalse;
        }
        <span class="enscript-keyword">if</span> (DNSSECOptionalQuestion(question) &amp;&amp; !(question-&gt;qDNSServer-&gt;req_DO))
        {
            LogInfo(<span class="enscript-string">&quot;InitDNSSECProxyState: Turning off validation for %##s (%s); req_DO false&quot;</span>,
                question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
            question-&gt;ValidationRequired = DNSSEC_VALIDATION_NONE;
        }
    }
    question-&gt;ValidationState = (question-&gt;ValidationRequired ? DNSSECValRequired : DNSSECValNotRequired);
    question-&gt;ValidationStatus = 0;
    question-&gt;responseFlags    = zeroID;
}

<span class="enscript-comment">// Once the question is completely initialized including the duplicate logic, this function
</span><span class="enscript-comment">// is called to finalize the unicast question which requires flushing the cache if needed,
</span><span class="enscript-comment">// activating the query etc.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FinalizeUnicastQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question)
{
    <span class="enscript-comment">// Ensure DNS related info of duplicate question is same as the orig question
</span>    <span class="enscript-keyword">if</span> (question-&gt;DuplicateOf)
    {
        question-&gt;validDNSServers = question-&gt;DuplicateOf-&gt;validDNSServers;
        <span class="enscript-comment">// If current(dup) question has DNS Server assigned but the original question has no DNS Server assigned to it,
</span>        <span class="enscript-comment">// then we log a line as it could indicate an issue
</span>        <span class="enscript-keyword">if</span> (question-&gt;DuplicateOf-&gt;qDNSServer == mDNSNULL)
        {
            <span class="enscript-keyword">if</span> (question-&gt;qDNSServer) {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                       <span class="enscript-string">&quot;[R%d-&gt;Q%d] FinalizeUnicastQuestion: Current(dup) question %p has DNSServer(&quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d) but original question(%p) has no DNS Server! &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                       question-&gt;request_id, mDNSVal16(question-&gt;TargetQID), question,
                       question-&gt;qDNSServer ? &amp;question-&gt;qDNSServer-&gt;addr : mDNSNULL,
                       mDNSVal16(question-&gt;qDNSServer ? question-&gt;qDNSServer-&gt;port : zeroIPPort), question-&gt;DuplicateOf,
                       DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype));
            }

        }
        question-&gt;qDNSServer = question-&gt;DuplicateOf-&gt;qDNSServer;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
               <span class="enscript-string">&quot;[R%d-&gt;DupQ%d-&gt;Q%d] FinalizeUnicastQuestion: Duplicate question %p (%p) &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;), DNS Server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d&quot;</span>,
               question-&gt;request_id, mDNSVal16(question-&gt;DuplicateOf-&gt;TargetQID), mDNSVal16(question-&gt;TargetQID),
               question, question-&gt;DuplicateOf, DM_NAME_PARAM(question-&gt;qname.c), DNSTypeName(question-&gt;qtype),
               question-&gt;qDNSServer ? &amp;question-&gt;qDNSServer-&gt;addr : mDNSNULL,
               mDNSVal16(question-&gt;qDNSServer ? question-&gt;qDNSServer-&gt;port : zeroIPPort));
    }

    ActivateUnicastQuery(m, question, mDNSfalse);

    <span class="enscript-keyword">if</span> (!question-&gt;DuplicateOf &amp;&amp; DNSSECQuestion(question))
    {
        <span class="enscript-comment">// For DNSSEC questions, we need to have the RRSIGs also for verification.
</span>        CheckForDNSSECRecords(m, question);
    }
    <span class="enscript-keyword">if</span> (question-&gt;LongLived)
    {
        <span class="enscript-comment">// Unlike other initializations, InitLLQNATState should be done after
</span>        <span class="enscript-comment">// we determine that it is a unicast question.  LongLived is set for
</span>        <span class="enscript-comment">// both multicast and unicast browse questions but we should initialize
</span>        <span class="enscript-comment">// the LLQ NAT state only for unicast. Otherwise we will unnecessarily
</span>        <span class="enscript-comment">// start the NAT traversal that is not needed.
</span>        InitLLQNATState(m);
    }
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartQuery_internal</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    DNSQuestion **q;
    mStatus vStatus;

    <span class="enscript-comment">// First check for cache space (can't do queries if there is no cache space allocated)
</span>    <span class="enscript-keyword">if</span> (m-&gt;rrcache_size == 0)
        <span class="enscript-keyword">return</span>(mStatus_NoCache);

    vStatus = ValidateParameters(m, question);
    <span class="enscript-keyword">if</span> (vStatus)
        <span class="enscript-keyword">return</span>(vStatus);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_LIBIDN</span>
    <span class="enscript-comment">// If the TLD includes high-ascii bytes, assume it will need to be converted to Punycode.
</span>    <span class="enscript-comment">// (In the future the root name servers may answer UTF-8 queries directly, but for now they do not.)
</span>    <span class="enscript-comment">// This applies to the top label (TLD) only
</span>    <span class="enscript-comment">// -- for the second level and down we try UTF-8 first, and then fall back to Punycode only if UTF-8 fails.
</span>    <span class="enscript-keyword">if</span> (IsHighASCIILabel(LastLabel(&amp;question-&gt;qname)))
    {
        domainname newname;
        <span class="enscript-keyword">if</span> (PerformNextPunycodeConversion(question, &amp;newname))
            AssignDomainName(&amp;question-&gt;qname, &amp;newname);
    }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">USE_LIBIDN</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    question-&gt;TargetQID = Question_uDNS(question) ? mDNS_NewMessageID(m) : zeroID;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    question-&gt;LastTargetQID = zeroID;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
    question-&gt;TargetQID = zeroID;
#<span class="enscript-reference">endif</span>
    debugf(<span class="enscript-string">&quot;mDNS_StartQuery_internal: %##s (%s)&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));

    <span class="enscript-comment">// Note: It important that new questions are appended at the *end* of the list, not prepended at the start
</span>    q = &amp;m-&gt;Questions;
    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(question-&gt;InterfaceID))
        q = &amp;m-&gt;LocalOnlyQuestions;
    <span class="enscript-keyword">while</span> (*q &amp;&amp; *q != question)
        q=&amp;(*q)-&gt;next;

    <span class="enscript-keyword">if</span> (*q)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_StartQuery_internal: Error! Tried to add a question %##s (%s) %p that's already in the active list&quot;</span>,
                question-&gt;qname.c, DNSTypeName(question-&gt;qtype), question);
        <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
    }
    *q = question;

    <span class="enscript-comment">// Intialize the question. The only ordering constraint we have today is that
</span>    <span class="enscript-comment">// InitDNSSECProxyState should be called after the DNS server is selected (in
</span>    <span class="enscript-comment">// InitCommonState -&gt; InitDNSConfig) as DNS server selection affects DNSSEC
</span>    <span class="enscript-comment">// validation.
</span>
    InitCommonState(m, question);
    InitWABState(question);
    InitLLQState(question);
    InitDNSSECProxyState(m, question);

    <span class="enscript-comment">// FindDuplicateQuestion should be called last after all the intialization
</span>    <span class="enscript-comment">// as the duplicate logic could be potentially based on any field in the
</span>    <span class="enscript-comment">// question.
</span>    question-&gt;DuplicateOf  = FindDuplicateQuestion(m, question);
    <span class="enscript-keyword">if</span> (question-&gt;DuplicateOf)
        question-&gt;AuthInfo = question-&gt;DuplicateOf-&gt;AuthInfo;

    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(question-&gt;InterfaceID))
    {
        <span class="enscript-keyword">if</span> (!m-&gt;NewLocalOnlyQuestions)
            m-&gt;NewLocalOnlyQuestions = question;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (!m-&gt;NewQuestions)
            m-&gt;NewQuestions = question;

        <span class="enscript-comment">// If the question's id is non-zero, then it's Wide Area
</span>        <span class="enscript-comment">// MUST NOT do this Wide Area setup until near the end of
</span>        <span class="enscript-comment">// mDNS_StartQuery_internal -- this code may itself issue queries (e.g. SOA,
</span>        <span class="enscript-comment">// NS, etc.) and if we haven't finished setting up our own question and setting
</span>        <span class="enscript-comment">// m-&gt;NewQuestions if necessary then we could end up recursively re-entering
</span>        <span class="enscript-comment">// this routine with the question list data structures in an inconsistent state.
</span>        <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(question-&gt;TargetQID))
        {
            FinalizeUnicastQuestion(m, question);
        }
        <span class="enscript-keyword">else</span>
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
            m-&gt;NumAllInterfaceQuestions++;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;mDNS_StartQuery_internal: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                m-&gt;NumAllInterfaceRecords, m-&gt;NumAllInterfaceQuestions, DM_NAME_PARAM(&amp;question-&gt;qname), DNSTypeName(question-&gt;qtype));
            <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceRecords + m-&gt;NumAllInterfaceQuestions == 1)
            {
                m-&gt;NextBonjourDisableTime = 0;
                <span class="enscript-keyword">if</span> (m-&gt;BonjourEnabled == 0)
                {
                    <span class="enscript-comment">// Enable Bonjour immediately by scheduling network changed processing where
</span>                    <span class="enscript-comment">// we will join the multicast group on each active interface.
</span>                    m-&gt;BonjourEnabled = 1;
                    m-&gt;NetworkChanged = m-&gt;timenow;
                }
            }
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (question-&gt;WakeOnResolve)
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_StartQuery_internal: Purging for %##s&quot;</span>, question-&gt;qname.c);
                mDNS_PurgeBeforeResolve(m, question);
            }
        }
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// CancelGetZoneData is an internal routine (i.e. must be called with the lock already held)
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">CancelGetZoneData</span>(mDNS *<span class="enscript-type">const</span> m, ZoneData *nta)
{
    debugf(<span class="enscript-string">&quot;CancelGetZoneData %##s (%s)&quot;</span>, nta-&gt;question.qname.c, DNSTypeName(nta-&gt;question.qtype));
    <span class="enscript-comment">// This function may be called anytime to free the zone information.The question may or may not have stopped.
</span>    <span class="enscript-comment">// If it was already stopped, mDNS_StopQuery_internal would have set q-&gt;ThisQInterval to -1 and should not
</span>    <span class="enscript-comment">// call it again
</span>    <span class="enscript-keyword">if</span> (nta-&gt;question.ThisQInterval != -1)
    {
        mDNS_StopQuery_internal(m, &amp;nta-&gt;question);
        <span class="enscript-keyword">if</span> (nta-&gt;question.ThisQInterval != -1)
            LogMsg(<span class="enscript-string">&quot;CancelGetZoneData: Question %##s (%s) ThisQInterval %d not -1&quot;</span>, nta-&gt;question.qname.c, DNSTypeName(nta-&gt;question.qtype), nta-&gt;question.ThisQInterval);
    }
    mDNSPlatformMemFree(nta);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StopQuery_internal</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    CacheGroup *cg = CacheGroupForName(m, question-&gt;qnamehash, &amp;question-&gt;qname);
    CacheRecord *cr;
    DNSQuestion **qp = &amp;m-&gt;Questions;

    <span class="enscript-comment">//LogInfo(&quot;mDNS_StopQuery_internal %##s (%s)&quot;, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
</span>
    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(question-&gt;InterfaceID))
        qp = &amp;m-&gt;LocalOnlyQuestions;
    <span class="enscript-keyword">while</span> (*qp &amp;&amp; *qp != question) qp=&amp;(*qp)-&gt;next;
    <span class="enscript-keyword">if</span> (*qp) *qp = (*qp)-&gt;next;
    <span class="enscript-keyword">else</span>
    {
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">ForceAlerts</span>
        <span class="enscript-keyword">if</span> (question-&gt;ThisQInterval &gt;= 0)   <span class="enscript-comment">// Only log error message if the query was supposed to be active
</span>#<span class="enscript-reference">endif</span>
        LogFatalError(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Question %##s (%s) not found in active list&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        <span class="enscript-keyword">return</span>(mStatus_BadReferenceErr);
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-keyword">if</span> (!LocalOnlyOrP2PInterface(question-&gt;InterfaceID) &amp;&amp; mDNSOpaque16IsZero(question-&gt;TargetQID))
    {
        <span class="enscript-keyword">if</span> (m-&gt;NumAllInterfaceRecords + m-&gt;NumAllInterfaceQuestions == 1)
            m-&gt;NextBonjourDisableTime = NonZeroTime(m-&gt;timenow + (BONJOUR_DISABLE_DELAY * mDNSPlatformOneSecond));
        m-&gt;NumAllInterfaceQuestions--;
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;mDNS_StopQuery_internal: NumAllInterfaceRecords %u NumAllInterfaceQuestions %u &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
            m-&gt;NumAllInterfaceRecords, m-&gt;NumAllInterfaceQuestions, DM_NAME_PARAM(&amp;question-&gt;qname), DNSTypeName(question-&gt;qtype));
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    <span class="enscript-keyword">if</span> (Question_uDNS(question) &amp;&amp; !question-&gt;metrics.answered &amp;&amp; (question-&gt;metrics.querySendCount &gt; 0))
    {
        <span class="enscript-type">const</span> domainname *  queryName;
        mDNSBool            isForCell;
        mDNSu32             durationMs;

        queryName  = question-&gt;metrics.originalQName ? question-&gt;metrics.originalQName : &amp;question-&gt;qname;
        isForCell  = (question-&gt;qDNSServer &amp;&amp; question-&gt;qDNSServer-&gt;isCell);
        durationMs = ((m-&gt;timenow - question-&gt;metrics.firstQueryTime) * 1000) / mDNSPlatformOneSecond;
        MetricsUpdateDNSQueryStats(queryName, question-&gt;qtype, mDNSNULL, question-&gt;metrics.querySendCount, question-&gt;metrics.expiredAnswerState, question-&gt;metrics.dnsOverTCPState, durationMs, isForCell);
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// Take care to cut question from list *before* calling UpdateQuestionDuplicates
</span>    UpdateQuestionDuplicates(m, question);
    <span class="enscript-comment">// But don't trash ThisQInterval until afterwards.
</span>    question-&gt;ThisQInterval = -1;

    <span class="enscript-comment">// If there are any cache records referencing this as their active question, then see if there is any
</span>    <span class="enscript-comment">// other question that is also referencing them, else their CRActiveQuestion needs to get set to NULL.
</span>    <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion == question)
        {
            DNSQuestion *q;
            DNSQuestion *replacement = mDNSNULL;
            <span class="enscript-comment">// If we find an active question that is answered by this cached record, use it as the cache record's
</span>            <span class="enscript-comment">// CRActiveQuestion replacement. If there are no such questions, but there's at least one unsuppressed inactive
</span>            <span class="enscript-comment">// question that is answered by this cache record, then use an inactive one to not forgo generating RMV events
</span>            <span class="enscript-comment">// via CacheRecordRmv() when the cache record expires.
</span>            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q &amp;&amp; (q != m-&gt;NewQuestions); q = q-&gt;next)
            {
                <span class="enscript-keyword">if</span> (!q-&gt;DuplicateOf &amp;&amp; !q-&gt;Suppressed &amp;&amp; CacheRecordAnswersQuestion(cr, q))
                {
                    <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &gt; 0)
                    {
                        replacement = q;
                        <span class="enscript-keyword">break</span>;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!replacement)
                    {
                        replacement = q;
                    }
                }
            }
            <span class="enscript-keyword">if</span> (replacement)
                debugf(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Updating CRActiveQuestion to %p for cache record %s, Original question CurrentAnswers %d, new question &quot;</span>
                       <span class="enscript-string">&quot;CurrentAnswers %d, Suppressed %d&quot;</span>, replacement, CRDisplayString(m,cr), question-&gt;CurrentAnswers, replacement-&gt;CurrentAnswers, replacement-&gt;Suppressed);
            cr-&gt;CRActiveQuestion = replacement;    <span class="enscript-comment">// Question used to be active; new value may or may not be null
</span>            <span class="enscript-keyword">if</span> (!replacement) m-&gt;rrcache_active--; <span class="enscript-comment">// If no longer active, decrement rrcache_active count
</span>        }
    }

    <span class="enscript-comment">// If we just deleted the question that CacheRecordAdd() or CacheRecordRmv() is about to look at,
</span>    <span class="enscript-comment">// bump its pointer forward one question.
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == question)
    {
        debugf(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Just deleted the currently active question: %##s (%s)&quot;</span>,
               question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        m-&gt;CurrentQuestion = question-&gt;next;
    }

    <span class="enscript-keyword">if</span> (m-&gt;NewQuestions == question)
    {
        debugf(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Just deleted a new question that wasn't even answered yet: %##s (%s)&quot;</span>,
               question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        m-&gt;NewQuestions = question-&gt;next;
    }

    <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyQuestions == question) m-&gt;NewLocalOnlyQuestions = question-&gt;next;

    <span class="enscript-keyword">if</span> (m-&gt;RestartQuestion == question)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Just deleted the current restart question: %##s (%s)&quot;</span>,
               question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        m-&gt;RestartQuestion = question-&gt;next;
    }

    <span class="enscript-keyword">if</span> (m-&gt;ValidationQuestion == question)
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_StopQuery_internal: Just deleted the current Validation question: %##s (%s)&quot;</span>,
               question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        m-&gt;ValidationQuestion = question-&gt;next;
    }

    <span class="enscript-comment">// Take care not to trash question-&gt;next until *after* we've updated m-&gt;CurrentQuestion and m-&gt;NewQuestions
</span>    question-&gt;next = mDNSNULL;

    <span class="enscript-comment">// LogMsg(&quot;mDNS_StopQuery_internal: Question %##s (%s) removed&quot;, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
</span>
    <span class="enscript-comment">// And finally, cancel any associated GetZoneData operation that's still running.
</span>    <span class="enscript-comment">// Must not do this until last, because there's a good chance the GetZoneData question is the next in the list,
</span>    <span class="enscript-comment">// so if we delete it earlier in this routine, we could find that our &quot;question-&gt;next&quot; pointer above is already
</span>    <span class="enscript-comment">// invalid before we even use it. By making sure that we update m-&gt;CurrentQuestion and m-&gt;NewQuestions if necessary
</span>    <span class="enscript-comment">// *first*, then they're all ready to be updated a second time if necessary when we cancel our GetZoneData query.
</span>    <span class="enscript-keyword">if</span> (question-&gt;tcp) { DisposeTCPConn(question-&gt;tcp); question-&gt;tcp = mDNSNULL; }
    <span class="enscript-keyword">if</span> (question-&gt;LocalSocket) { mDNSPlatformUDPClose(question-&gt;LocalSocket); question-&gt;LocalSocket = mDNSNULL; }
    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(question-&gt;TargetQID) &amp;&amp; question-&gt;LongLived)
    {
        <span class="enscript-comment">// Scan our list to see if any more wide-area LLQs remain. If not, stop our NAT Traversal.
</span>        DNSQuestion *q;
        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
            <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;LongLived) <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (!q)
        {
            <span class="enscript-keyword">if</span> (!m-&gt;LLQNAT.clientCallback)       <span class="enscript-comment">// Should never happen, but just in case...
</span>            {
                LogMsg(<span class="enscript-string">&quot;mDNS_StopQuery ERROR LLQNAT.clientCallback NULL&quot;</span>);
            }
            <span class="enscript-keyword">else</span>
            {
                LogInfo(<span class="enscript-string">&quot;Stopping LLQNAT&quot;</span>);
                mDNS_StopNATOperation_internal(m, &amp;m-&gt;LLQNAT);
                m-&gt;LLQNAT.clientCallback = mDNSNULL; <span class="enscript-comment">// Means LLQ NAT Traversal not running
</span>            }
        }

        <span class="enscript-comment">// If necessary, tell server it can delete this LLQ state
</span>        <span class="enscript-keyword">if</span> (question-&gt;state == LLQ_Established)
        {
            question-&gt;ReqLease = 0;
            sendLLQRefresh(m, question);
            <span class="enscript-comment">// If we need need to make a TCP connection to cancel the LLQ, that's going to take a little while.
</span>            <span class="enscript-comment">// We clear the tcp-&gt;question backpointer so that when the TCP connection completes, it doesn't
</span>            <span class="enscript-comment">// crash trying to access our cancelled question, but we don't cancel the TCP operation itself --
</span>            <span class="enscript-comment">// we let that run out its natural course and complete asynchronously.
</span>            <span class="enscript-keyword">if</span> (question-&gt;tcp)
            {
                question-&gt;tcp-&gt;question = mDNSNULL;
                question-&gt;tcp           = mDNSNULL;
            }
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question-&gt;dnsPushServer != mDNSNULL)
        {
            UnSubscribeToDNSPushNotificationServer(m, question);
        }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-comment">// wait until we send the refresh above which needs the nta
</span>    <span class="enscript-keyword">if</span> (question-&gt;nta) { CancelGetZoneData(m, question-&gt;nta); question-&gt;nta = mDNSNULL; }

    <span class="enscript-keyword">if</span> (question-&gt;ValidationRequired &amp;&amp; question-&gt;DNSSECAuthInfo)
    {
        LogInfo(<span class="enscript-string">&quot;mDNS_StopQuery_internal: freeing DNSSECAuthInfo %##s&quot;</span>, question-&gt;qname.c);
        question-&gt;DAIFreeCallback(m, question-&gt;DNSSECAuthInfo);
        question-&gt;DNSSECAuthInfo = mDNSNULL;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    <span class="enscript-keyword">if</span> (question-&gt;metrics.originalQName)
    {
        mDNSPlatformMemFree(question-&gt;metrics.originalQName);
        question-&gt;metrics.originalQName = mDNSNULL;
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    DNS64ResetState(question);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_StartQuery_internal(m, question);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StopQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_StopQuery_internal(m, question);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

<span class="enscript-comment">// Note that mDNS_StopQueryWithRemoves() does not currently implement the full generality of the other APIs
</span><span class="enscript-comment">// Specifically, question callbacks invoked as a result of this call cannot themselves make API calls.
</span><span class="enscript-comment">// We invoke the callback without using mDNS_DropLockBeforeCallback/mDNS_ReclaimLockAfterCallback
</span><span class="enscript-comment">// specifically to catch and report if the client callback does try to make API calls
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_StopQueryWithRemoves</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question)
{
    mStatus status;
    DNSQuestion *qq;
    mDNS_Lock(m);

    <span class="enscript-comment">// Check if question is new -- don't want to give remove events for a question we haven't even answered yet
</span>    <span class="enscript-keyword">for</span> (qq = m-&gt;NewQuestions; qq; qq=qq-&gt;next) <span class="enscript-keyword">if</span> (qq == question) <span class="enscript-keyword">break</span>;

    status = mDNS_StopQuery_internal(m, question);
    <span class="enscript-keyword">if</span> (status == mStatus_NoError &amp;&amp; !qq)
    {
        <span class="enscript-type">const</span> CacheRecord *cr;
        CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, question-&gt;qnamehash, &amp;question-&gt;qname);
        LogInfo(<span class="enscript-string">&quot;Generating terminal removes for %##s (%s)&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr=cr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; SameNameCacheRecordAnswersQuestion(cr, question))
            {
                <span class="enscript-comment">// Don't use mDNS_DropLockBeforeCallback() here, since we don't allow API calls
</span>                <span class="enscript-keyword">if</span> (question-&gt;QuestionCallback)
                    question-&gt;QuestionCallback(m, question, &amp;cr-&gt;resrec, mDNSfalse);
            }
        }
    }
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_Reconfirm</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> cr)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForNoAnswer);
    <span class="enscript-keyword">if</span> (status == mStatus_NoError) ReconfirmAntecedents(m, cr-&gt;resrec.name, cr-&gt;resrec.namehash, cr-&gt;resrec.InterfaceID, 0);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_ReconfirmByValue</span>(mDNS *<span class="enscript-type">const</span> m, ResourceRecord *<span class="enscript-type">const</span> rr)
{
    mStatus status = mStatus_BadReferenceErr;
    CacheRecord *cr;
    mDNS_Lock(m);
    cr = FindIdenticalRecordInCache(m, rr);
    debugf(<span class="enscript-string">&quot;mDNS_ReconfirmByValue: %p %s&quot;</span>, cr, RRDisplayString(m, rr));
    <span class="enscript-keyword">if</span> (cr) status = mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForNoAnswer);
    <span class="enscript-keyword">if</span> (status == mStatus_NoError) ReconfirmAntecedents(m, cr-&gt;resrec.name, cr-&gt;resrec.namehash, cr-&gt;resrec.InterfaceID, 0);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSlocal mStatus <span class="enscript-function-name">mDNS_StartBrowse_internal</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question,
                                            <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> srv, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                            <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu32 flags,
                                            mDNSBool ForceMCast, mDNSBool useBackgroundTrafficClass,
                                            mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context)
{
    question-&gt;InterfaceID      = InterfaceID;
    question-&gt;flags            = flags;
    question-&gt;qtype            = kDNSType_PTR;
    question-&gt;qclass           = kDNSClass_IN;
    question-&gt;LongLived        = mDNStrue;
    question-&gt;ExpectUnique     = mDNSfalse;
    question-&gt;ForceMCast       = ForceMCast;
    question-&gt;ReturnIntermed   = (flags &amp; kDNSServiceFlagsReturnIntermediates) != 0;
    question-&gt;SuppressUnusable = mDNSfalse;
    question-&gt;AppendSearchDomains = mDNSfalse;
    question-&gt;TimeoutQuestion  = 0;
    question-&gt;WakeOnResolve    = 0;
    question-&gt;UseBackgroundTraffic = useBackgroundTrafficClass;
    question-&gt;ValidationRequired = 0;
    question-&gt;ValidatingResponse = 0;
    question-&gt;ProxyQuestion    = 0;
    question-&gt;QuestionCallback = Callback;
    question-&gt;QuestionContext  = Context;

    <span class="enscript-keyword">if</span> (!ConstructServiceName(&amp;question-&gt;qname, mDNSNULL, srv, domain))
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);

    <span class="enscript-keyword">return</span>(mDNS_StartQuery_internal(m, question));
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartBrowse</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question,
                                    <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> srv, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                    <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu32 flags,
                                    mDNSBool ForceMCast, mDNSBool useBackgroundTrafficClass,
                                    mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_StartBrowse_internal(m, question, srv, domain, InterfaceID, flags, ForceMCast, useBackgroundTrafficClass, Callback, Context);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}


mDNSexport mStatus <span class="enscript-function-name">mDNS_GetDomains</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question, mDNS_DomainType DomainType, <span class="enscript-type">const</span> domainname *dom,
                                   <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context)
{
    question-&gt;InterfaceID      = InterfaceID;
    question-&gt;flags            = 0;
    question-&gt;qtype            = kDNSType_PTR;
    question-&gt;qclass           = kDNSClass_IN;
    question-&gt;LongLived        = mDNSfalse;
    question-&gt;ExpectUnique     = mDNSfalse;
    question-&gt;ForceMCast       = mDNSfalse;
    question-&gt;ReturnIntermed   = mDNSfalse;
    question-&gt;SuppressUnusable = mDNSfalse;
    question-&gt;AppendSearchDomains = mDNSfalse;
    question-&gt;TimeoutQuestion  = 0;
    question-&gt;WakeOnResolve    = 0;
    question-&gt;UseBackgroundTraffic = mDNSfalse;
    question-&gt;ValidationRequired = 0;
    question-&gt;ValidatingResponse = 0;
    question-&gt;ProxyQuestion    = 0;
    question-&gt;pid              = mDNSPlatformGetPID();
    question-&gt;euid             = 0;
    question-&gt;QuestionCallback = Callback;
    question-&gt;QuestionContext  = Context;
    <span class="enscript-keyword">if</span> (DomainType &gt; mDNS_DomainTypeMax) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;question-&gt;qname, mDNS_DomainTypeNames[DomainType])) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (!dom) dom = &amp;localdomain;
    <span class="enscript-keyword">if</span> (!AppendDomainName(&amp;question-&gt;qname, dom)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">return</span>(mDNS_StartQuery(m, question));
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Responder</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSexport mStatus <span class="enscript-function-name">mDNS_Register</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_Register_internal(m, rr);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_Update</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mDNSu32 newttl,
                               <span class="enscript-type">const</span> mDNSu16 newrdlength, RData *<span class="enscript-type">const</span> newrdata, mDNSRecordUpdateCallback *Callback)
{
    <span class="enscript-keyword">if</span> (!ValidateRData(rr-&gt;resrec.rrtype, newrdlength, newrdata))
    {
        LogMsg(<span class="enscript-string">&quot;Attempt to update record with invalid rdata: %s&quot;</span>, GetRRDisplayString_rdb(&amp;rr-&gt;resrec, &amp;newrdata-&gt;u, m-&gt;MsgBuffer));
        <span class="enscript-keyword">return</span>(mStatus_Invalid);
    }

    mDNS_Lock(m);

    <span class="enscript-comment">// If TTL is unspecified, leave TTL unchanged
</span>    <span class="enscript-keyword">if</span> (newttl == 0) newttl = rr-&gt;resrec.rroriginalttl;

    <span class="enscript-comment">// If we already have an update queued up which has not gone through yet, give the client a chance to free that memory
</span>    <span class="enscript-keyword">if</span> (rr-&gt;NewRData)
    {
        RData *n = rr-&gt;NewRData;
        rr-&gt;NewRData = mDNSNULL;                            <span class="enscript-comment">// Clear the NewRData pointer ...
</span>        <span class="enscript-keyword">if</span> (rr-&gt;UpdateCallback)
            rr-&gt;UpdateCallback(m, rr, n, rr-&gt;newrdlength);  <span class="enscript-comment">// ...and let the client free this memory, if necessary
</span>    }

    rr-&gt;NewRData             = newrdata;
    rr-&gt;newrdlength          = newrdlength;
    rr-&gt;UpdateCallback       = Callback;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (rr-&gt;ARType != AuthRecordLocalOnly &amp;&amp; rr-&gt;ARType != AuthRecordP2P &amp;&amp; !IsLocalDomain(rr-&gt;resrec.name))
    {
        mStatus status = uDNS_UpdateRecord(m, rr);
        <span class="enscript-comment">// The caller frees the memory on error, don't retain stale pointers
</span>        <span class="enscript-keyword">if</span> (status != mStatus_NoError) { rr-&gt;NewRData = mDNSNULL; rr-&gt;newrdlength = 0; }
        mDNS_Unlock(m);
        <span class="enscript-keyword">return</span>(status);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (RRLocalOnly(rr) || (rr-&gt;resrec.rroriginalttl == newttl &amp;&amp;
                            rr-&gt;resrec.rdlength == newrdlength &amp;&amp; mDNSPlatformMemSame(rr-&gt;resrec.rdata-&gt;u.data, newrdata-&gt;u.data, newrdlength)))
        CompleteRDataUpdate(m, rr);
    <span class="enscript-keyword">else</span>
    {
        rr-&gt;AnnounceCount = InitialAnnounceCount;
        InitializeLastAPTime(m, rr);
        <span class="enscript-keyword">while</span> (rr-&gt;NextUpdateCredit &amp;&amp; m-&gt;timenow - rr-&gt;NextUpdateCredit &gt;= 0) GrantUpdateCredit(rr);
        <span class="enscript-keyword">if</span> (!rr-&gt;UpdateBlocked &amp;&amp; rr-&gt;UpdateCredits) rr-&gt;UpdateCredits--;
        <span class="enscript-keyword">if</span> (!rr-&gt;NextUpdateCredit) rr-&gt;NextUpdateCredit = NonZeroTime(m-&gt;timenow + kUpdateCreditRefreshInterval);
        <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount &gt; rr-&gt;UpdateCredits + 1) rr-&gt;AnnounceCount = (mDNSu8)(rr-&gt;UpdateCredits + 1);
        <span class="enscript-keyword">if</span> (rr-&gt;UpdateCredits &lt;= 5)
        {
            mDNSu32 delay = 6 - rr-&gt;UpdateCredits;      <span class="enscript-comment">// Delay 1 second, then 2, then 3, etc. up to 6 seconds maximum
</span>            <span class="enscript-keyword">if</span> (!rr-&gt;UpdateBlocked) rr-&gt;UpdateBlocked = NonZeroTime(m-&gt;timenow + (mDNSs32)delay * mDNSPlatformOneSecond);
            rr-&gt;ThisAPInterval *= 4;
            rr-&gt;LastAPTime = rr-&gt;UpdateBlocked - rr-&gt;ThisAPInterval;
            LogMsg(<span class="enscript-string">&quot;Excessive update rate for %##s; delaying announcement by %ld second%s&quot;</span>,
                   rr-&gt;resrec.name-&gt;c, delay, delay &gt; 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
        }
        rr-&gt;resrec.rroriginalttl = newttl;
    }

    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// Note: mDNS_Deregister calls mDNS_Deregister_internal which can call a user callback, which may change
</span><span class="enscript-comment">// the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_Deregister</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_Deregister_internal(m, rr, mDNS_Dereg_normal);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

<span class="enscript-comment">// Circular reference: AdvertiseInterface references mDNS_HostNameCallback, which calls mDNS_SetFQDN, which call AdvertiseInterface
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_HostNameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RandomizedHostNameCallback</span>(mDNS *m, AuthRecord *rr, mStatus result);
#<span class="enscript-reference">endif</span>

mDNSlocal AuthRecord *<span class="enscript-function-name">GetInterfaceAddressRecord</span>(NetworkInterfaceInfo *intf, mDNSBool forRandHostname)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        <span class="enscript-keyword">return</span>(forRandHostname ? &amp;intf-&gt;RR_AddrRand : &amp;intf-&gt;RR_A);
#<span class="enscript-reference">else</span>
        (<span class="enscript-type">void</span>)forRandHostname; <span class="enscript-comment">// Unused.
</span>        <span class="enscript-keyword">return</span>(&amp;intf-&gt;RR_A);
#<span class="enscript-reference">endif</span>
}

mDNSlocal AuthRecord *<span class="enscript-function-name">GetFirstAddressRecordEx</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSBool forRandHostname)
{
    NetworkInterfaceInfo *intf;
    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!intf-&gt;Advertise) <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(intf-&gt;InterfaceID)) <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">return</span>(GetInterfaceAddressRecord(intf, forRandHostname));
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GetFirstAddressRecord</span>(M)    GetFirstAddressRecordEx(M, mDNSfalse)

<span class="enscript-comment">// The parameter &quot;set&quot; here refers to the set of AuthRecords used to advertise this interface.
</span><span class="enscript-comment">// (It's a set of records, not a set of interfaces.)
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, mDNSBool useRandomizedHostname)
#<span class="enscript-reference">else</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set)
#<span class="enscript-reference">endif</span>
{
    <span class="enscript-type">const</span> domainname *hostname;
    mDNSRecordCallback *hostnameCallback;
    AuthRecord *addrAR;
    AuthRecord *ptrAR;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-type">const</span> mDNSBool interfaceIsAWDL = mDNSPlatformInterfaceIsAWDL(set-&gt;InterfaceID);
#<span class="enscript-reference">endif</span>
    mDNSu8 addrRecordType;
    <span class="enscript-type">char</span> buffer[MAX_REVERSE_MAPPING_NAME];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (interfaceIsAWDL || useRandomizedHostname)
    {
        hostname         = &amp;m-&gt;RandomizedHostname;
        hostnameCallback = mDNS_RandomizedHostNameCallback;
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
        hostname         = &amp;m-&gt;MulticastHostname;
        hostnameCallback = mDNS_HostNameCallback;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (!interfaceIsAWDL &amp;&amp; useRandomizedHostname)
    {
        addrAR = &amp;set-&gt;RR_AddrRand;
        ptrAR  = mDNSNULL;
    }
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
    {
        addrAR = &amp;set-&gt;RR_A;
        ptrAR  = &amp;set-&gt;RR_PTR;
    }
    <span class="enscript-keyword">if</span> (addrAR-&gt;resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;

    addrRecordType = set-&gt;DirectLink ? kDNSRecordTypeKnownUnique : kDNSRecordTypeUnique;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (hostname == &amp;m-&gt;RandomizedHostname) addrRecordType = kDNSRecordTypeKnownUnique;
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
        <span class="enscript-string">&quot;AdvertiseInterface: Advertising &quot;</span> PUB_S <span class="enscript-string">&quot; hostname on interface &quot;</span> PUB_S,
        (hostname == &amp;m-&gt;RandomizedHostname) ? <span class="enscript-string">&quot;randomized&quot;</span> : <span class="enscript-string">&quot;normal&quot;</span>, set-&gt;ifname);
#<span class="enscript-reference">else</span>
    LogInfo(<span class="enscript-string">&quot;AdvertiseInterface: Advertising for ifname %s&quot;</span>, set-&gt;ifname);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Send dynamic update for non-linklocal IPv4 Addresses
</span>    mDNS_SetupResourceRecord(addrAR, mDNSNULL, set-&gt;InterfaceID, kDNSType_A, kHostNameTTL, addrRecordType, AuthRecordAny, hostnameCallback, set);
    <span class="enscript-keyword">if</span> (ptrAR) mDNS_SetupResourceRecord(ptrAR, mDNSNULL, set-&gt;InterfaceID, kDNSType_PTR, kHostNameTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ANSWER_REMOTE_HOSTNAME_QUERIES</span>
    addrAR-&gt;AllowRemoteQuery = mDNStrue;
    <span class="enscript-keyword">if</span> (ptrAR) ptrAR-&gt;AllowRemoteQuery = mDNStrue;
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// 1. Set up Address record to map from host name (&quot;foo.local.&quot;) to IP address
</span>    <span class="enscript-comment">// 2. Set up reverse-lookup PTR record to map from our address back to our host name
</span>    AssignDomainName(&amp;addrAR-&gt;namestorage, hostname);
    <span class="enscript-keyword">if</span> (set-&gt;ip.type == mDNSAddrType_IPv4)
    {
        addrAR-&gt;resrec.rrtype        = kDNSType_A;
        addrAR-&gt;resrec.rdata-&gt;u.ipv4 = set-&gt;ip.ip.v4;
        <span class="enscript-comment">// Note: This is reverse order compared to a normal dotted-decimal IP address, so we can't use our customary &quot;%.4a&quot; format code
</span>        mDNS_snprintf(buffer, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot;%d.%d.%d.%d.in-addr.arpa.&quot;</span>,
                      set-&gt;ip.ip.v4.b[3], set-&gt;ip.ip.v4.b[2], set-&gt;ip.ip.v4.b[1], set-&gt;ip.ip.v4.b[0]);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (set-&gt;ip.type == mDNSAddrType_IPv6)
    {
        <span class="enscript-type">int</span> i;
        addrAR-&gt;resrec.rrtype        = kDNSType_AAAA;
        addrAR-&gt;resrec.rdata-&gt;u.ipv6 = set-&gt;ip.ip.v6;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; 16; i++)
        {
            <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> hexValues[] = <span class="enscript-string">&quot;0123456789ABCDEF&quot;</span>;
            buffer[i * 4    ] = hexValues[set-&gt;ip.ip.v6.b[15 - i] &amp; 0x0F];
            buffer[i * 4 + 1] = <span class="enscript-string">'.'</span>;
            buffer[i * 4 + 2] = hexValues[set-&gt;ip.ip.v6.b[15 - i] &gt;&gt; 4];
            buffer[i * 4 + 3] = <span class="enscript-string">'.'</span>;
        }
        mDNS_snprintf(&amp;buffer[64], <span class="enscript-keyword">sizeof</span>(buffer)-64, <span class="enscript-string">&quot;ip6.arpa.&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (ptrAR)
    {
        MakeDomainNameFromDNSNameString(&amp;ptrAR-&gt;namestorage, buffer);
        ptrAR-&gt;AutoTarget = Target_AutoHost;    <span class="enscript-comment">// Tell mDNS that the target of this PTR is to be kept in sync with our host name
</span>        ptrAR-&gt;ForceMCast = mDNStrue;           <span class="enscript-comment">// This PTR points to our dot-local name, so don't ever try to write it into a uDNS server
</span>    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    addrAR-&gt;RRSet = interfaceIsAWDL ? addrAR : GetFirstAddressRecordEx(m, useRandomizedHostname);
#<span class="enscript-reference">else</span>
    addrAR-&gt;RRSet = GetFirstAddressRecord(m);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!addrAR-&gt;RRSet) addrAR-&gt;RRSet = addrAR;
    mDNS_Register_internal(m, addrAR);
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;Initialized RRSet for &quot;</span> PRI_S, ARDisplayString(m, addrAR));
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;RRSet:                &quot;</span> PRI_S, ARDisplayString(m, addrAR-&gt;RRSet));
    <span class="enscript-keyword">if</span> (ptrAR) mDNS_Register_internal(m, ptrAR);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    <span class="enscript-comment">// must be after the mDNS_Register_internal() calls so that records have complete rdata fields, etc
</span>    D2D_start_advertising_interface(set);
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseInterfaceIfNeeded</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(set-&gt;InterfaceID))
    {
        <span class="enscript-keyword">if</span> ((m-&gt;AutoTargetAWDLIncludedCount &gt; 0) || (m-&gt;AutoTargetAWDLOnlyCount &gt; 0))
        {
            AdvertiseInterface(m, set, mDNSfalse);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (m-&gt;AutoTargetServices          &gt; 0) AdvertiseInterface(m, set, mDNSfalse);
        <span class="enscript-keyword">if</span> (m-&gt;AutoTargetAWDLIncludedCount &gt; 0) AdvertiseInterface(m, set, mDNStrue);
    }
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (m-&gt;AutoTargetServices &gt; 0) AdvertiseInterface(m, set);
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeadvertiseInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, DeadvertiseFlags flags)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-type">const</span> mDNSBool interfaceIsAWDL = mDNSPlatformInterfaceIsAWDL(set-&gt;InterfaceID);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Unregister these records.
</span>    <span class="enscript-comment">// When doing the mDNS_Exit processing, we first call DeadvertiseInterface for each interface, so by the time the platform
</span>    <span class="enscript-comment">// support layer gets to call mDNS_DeregisterInterface, the address and PTR records have already been deregistered for it.
</span>    <span class="enscript-comment">// Also, in the event of a name conflict, one or more of our records will have been forcibly deregistered.
</span>    <span class="enscript-comment">// To avoid unnecessary and misleading warning messages, we check the RecordType before calling mDNS_Deregister_internal().
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> ((!interfaceIsAWDL &amp;&amp; (flags &amp; kDeadvertiseFlag_NormalHostname)) ||
        ( interfaceIsAWDL &amp;&amp; (flags &amp; kDeadvertiseFlag_RandHostname)))
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">if</span> (flags &amp; kDeadvertiseFlag_NormalHostname)
#<span class="enscript-reference">endif</span>
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
            <span class="enscript-string">&quot;DeadvertiseInterface: Deadvertising &quot;</span> PUB_S <span class="enscript-string">&quot; hostname on interface &quot;</span> PUB_S,
            (flags &amp; kDeadvertiseFlag_RandHostname) ? <span class="enscript-string">&quot;randomized&quot;</span> : <span class="enscript-string">&quot;normal&quot;</span>, set-&gt;ifname);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
        D2D_stop_advertising_interface(set);
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (set-&gt;RR_A.resrec.RecordType)   mDNS_Deregister_internal(m, &amp;set-&gt;RR_A,   mDNS_Dereg_normal);
        <span class="enscript-keyword">if</span> (set-&gt;RR_PTR.resrec.RecordType) mDNS_Deregister_internal(m, &amp;set-&gt;RR_PTR, mDNS_Dereg_normal);
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (!interfaceIsAWDL &amp;&amp; (flags &amp; kDeadvertiseFlag_RandHostname))
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
            <span class="enscript-string">&quot;DeadvertiseInterface: Deadvertising randomized hostname on interface &quot;</span> PUB_S, set-&gt;ifname);
        AuthRecord *<span class="enscript-type">const</span> ar = &amp;set-&gt;RR_AddrRand;
        <span class="enscript-keyword">if</span> (ar-&gt;resrec.RecordType) mDNS_Deregister_internal(m, ar, mDNS_Dereg_normal);
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">// Change target host name for record.  
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateTargetHostName</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    <span class="enscript-comment">// If this record was also registered with any D2D plugins, stop advertising
</span>    <span class="enscript-comment">// the version with the old host name.
</span>    D2D_stop_advertising_record(rr);
#<span class="enscript-reference">endif</span>

    SetTargetToHostName(m, rr);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">D2D</span>)
    <span class="enscript-comment">// Advertise the record with the updated host name with the D2D plugins if appropriate.
</span>    D2D_start_advertising_record(rr);
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeadvertiseAllInterfaceRecords</span>(mDNS *<span class="enscript-type">const</span> m, DeadvertiseFlags flags)
{
    NetworkInterfaceInfo *intf;
    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
    {
        <span class="enscript-keyword">if</span> (intf-&gt;Advertise) DeadvertiseInterface(m, intf, flags);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetFQDN</span>(mDNS *<span class="enscript-type">const</span> m)
{
    domainname newmname;
    AuthRecord *rr;
    newmname.c[0] = 0;

    <span class="enscript-keyword">if</span> (!AppendDomainLabel(&amp;newmname, &amp;m-&gt;hostlabel))  { LogMsg(<span class="enscript-string">&quot;ERROR: mDNS_SetFQDN: Cannot create MulticastHostname&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (!AppendLiteralLabelString(&amp;newmname, <span class="enscript-string">&quot;local&quot;</span>)) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNS_SetFQDN: Cannot create MulticastHostname&quot;</span>); <span class="enscript-keyword">return</span>; }

    mDNS_Lock(m);

    <span class="enscript-keyword">if</span> (SameDomainNameCS(&amp;m-&gt;MulticastHostname, &amp;newmname)) debugf(<span class="enscript-string">&quot;mDNS_SetFQDN - hostname unchanged&quot;</span>);
    <span class="enscript-keyword">else</span>
    {
        AssignDomainName(&amp;m-&gt;MulticastHostname, &amp;newmname);
        DeadvertiseAllInterfaceRecords(m, kDeadvertiseFlag_NormalHostname);
        AdvertiseNecessaryInterfaceRecords(m);
    }

    <span class="enscript-comment">// 3. Make sure that any AutoTarget SRV records (and the like) get updated
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords;  rr; rr=rr-&gt;next) <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget) UpdateTargetHostName(m, rr);
    <span class="enscript-keyword">for</span> (rr = m-&gt;DuplicateRecords; rr; rr=rr-&gt;next) <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget) UpdateTargetHostName(m, rr);

    mDNS_Unlock(m);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_HostNameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)rr;   <span class="enscript-comment">// Unused parameter
</span>
    #<span class="enscript-keyword">if</span> MDNS_DEBUGMSGS
    {
        <span class="enscript-type">char</span> *msg = <span class="enscript-string">&quot;Unknown result&quot;</span>;
        <span class="enscript-keyword">if</span>      (result == mStatus_NoError) msg = <span class="enscript-string">&quot;Name registered&quot;</span>;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_NameConflict) msg = <span class="enscript-string">&quot;Name conflict&quot;</span>;
        debugf(<span class="enscript-string">&quot;mDNS_HostNameCallback: %##s (%s) %s (%ld)&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), msg, result);
    }
    #endif

    <span class="enscript-keyword">if</span> (result == mStatus_NoError)
    {
        <span class="enscript-comment">// Notify the client that the host name is successfully registered
</span>        <span class="enscript-keyword">if</span> (m-&gt;MainCallback)
            m-&gt;MainCallback(m, mStatus_NoError);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
    {
        domainlabel oldlabel = m-&gt;hostlabel;

        <span class="enscript-comment">// 1. First give the client callback a chance to pick a new name
</span>        <span class="enscript-keyword">if</span> (m-&gt;MainCallback)
            m-&gt;MainCallback(m, mStatus_NameConflict);

        <span class="enscript-comment">// 2. If the client callback didn't do it, add (or increment) an index ourselves
</span>        <span class="enscript-comment">// This needs to be case-INSENSITIVE compare, because we need to know that the name has been changed so as to
</span>        <span class="enscript-comment">// remedy the conflict, and a name that differs only in capitalization will just suffer the exact same conflict again.
</span>        <span class="enscript-keyword">if</span> (SameDomainLabel(m-&gt;hostlabel.c, oldlabel.c))
            IncrementLabelSuffix(&amp;m-&gt;hostlabel, mDNSfalse);

        <span class="enscript-comment">// 3. Generate the FQDNs from the hostlabel,
</span>        <span class="enscript-comment">// and make sure all SRV records, etc., are updated to reference our new hostname
</span>        mDNS_SetFQDN(m);
        LogMsg(<span class="enscript-string">&quot;Local Hostname %#s.local already in use; will try %#s.local instead&quot;</span>, oldlabel.c, m-&gt;hostlabel.c);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        <span class="enscript-comment">// .local hostnames do not require goodbyes - we ignore the MemFree (which is sent directly by
</span>        <span class="enscript-comment">// mDNS_Deregister_internal), and allow the caller to deallocate immediately following mDNS_DeadvertiseInterface
</span>        debugf(<span class="enscript-string">&quot;mDNS_HostNameCallback: MemFree (ignored)&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;mDNS_HostNameCallback: Unknown error %d for registration of record %s&quot;</span>, result,  rr-&gt;resrec.name-&gt;c);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RandomizedHostNameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> addrRecord, <span class="enscript-type">const</span> mStatus result)
{
    (<span class="enscript-type">void</span>)addrRecord;   <span class="enscript-comment">// Unused parameter
</span>
    <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
    {
        AuthRecord *rr;
        domainlabel newUUIDLabel;

        GetRandomUUIDLabel(&amp;newUUIDLabel);
        <span class="enscript-keyword">if</span> (SameDomainLabel(newUUIDLabel.c, m-&gt;RandomizedHostname.c))
        {
            IncrementLabelSuffix(&amp;newUUIDLabel, mDNSfalse);
        }

        mDNS_Lock(m);

        m-&gt;RandomizedHostname.c[0] = 0;
        AppendDomainLabel(&amp;m-&gt;RandomizedHostname, &amp;newUUIDLabel);
        AppendLiteralLabelString(&amp;m-&gt;RandomizedHostname, <span class="enscript-string">&quot;local&quot;</span>);

        DeadvertiseAllInterfaceRecords(m, kDeadvertiseFlag_RandHostname);
        AdvertiseNecessaryInterfaceRecords(m);
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget &amp;&amp; AuthRecordIncludesOrIsAWDL(rr)) UpdateTargetHostName(m, rr);
        }
        <span class="enscript-keyword">for</span> (rr = m-&gt;DuplicateRecords; rr; rr = rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;AutoTarget &amp;&amp; AuthRecordIncludesOrIsAWDL(rr)) UpdateTargetHostName(m, rr);
        }

        mDNS_Unlock(m);
    }
}
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateInterfaceProtocols</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *active)
{
    NetworkInterfaceInfo *intf;
    active-&gt;IPv4Available = mDNSfalse;
    active-&gt;IPv6Available = mDNSfalse;
    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
        <span class="enscript-keyword">if</span> (intf-&gt;InterfaceID == active-&gt;InterfaceID)
        {
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == mDNSAddrType_IPv4 &amp;&amp; intf-&gt;McastTxRx) active-&gt;IPv4Available = mDNStrue;
            <span class="enscript-keyword">if</span> (intf-&gt;ip.type == mDNSAddrType_IPv6 &amp;&amp; intf-&gt;McastTxRx) active-&gt;IPv6Available = mDNStrue;
        }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RestartRecordGetZoneData</span>(mDNS * <span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    LogInfo(<span class="enscript-string">&quot;RestartRecordGetZoneData: ResourceRecords&quot;</span>);
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr) &amp;&amp; rr-&gt;state != regState_NoTarget)
        {
            debugf(<span class="enscript-string">&quot;RestartRecordGetZoneData: StartGetZoneData for %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);
            <span class="enscript-comment">// Zero out the updateid so that if we have a pending response from the server, it won't
</span>            <span class="enscript-comment">// be accepted as a valid response. If we accept the response, we might free the new &quot;nta&quot;
</span>            <span class="enscript-keyword">if</span> (rr-&gt;nta) { rr-&gt;updateid = zeroID; CancelGetZoneData(m, rr-&gt;nta); }
            rr-&gt;nta = StartGetZoneData(m, rr-&gt;resrec.name, ZoneServiceUpdate, RecordRegistrationGotZoneData, rr);
        }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">InitializeNetWakeState</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-comment">// We initialize ThisQInterval to -1 indicating that the question has not been started
</span>    <span class="enscript-comment">// yet. If the question (browse) is started later during interface registration, it will
</span>    <span class="enscript-comment">// be stopped during interface deregistration. We can't sanity check to see if the
</span>    <span class="enscript-comment">// question has been stopped or not before initializing it to -1 because we need to
</span>    <span class="enscript-comment">// initialize it to -1 the very first time.
</span>
    set-&gt;NetWakeBrowse.ThisQInterval = -1;
    <span class="enscript-keyword">for</span> (i=0; i&lt;3; i++)
    {
        set-&gt;NetWakeResolve[i].ThisQInterval = -1;
        set-&gt;SPSAddr[i].type = mDNSAddrType_None;
    }
    set-&gt;NextSPSAttempt     = -1;
    set-&gt;NextSPSAttemptTime = m-&gt;timenow;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ActivateNetWake_internal</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set)
{
    NetworkInterfaceInfo *p = m-&gt;HostInterfaces;
    <span class="enscript-keyword">while</span> (p &amp;&amp; p != set) p=p-&gt;next;
    <span class="enscript-keyword">if</span> (!p) { LogMsg(<span class="enscript-string">&quot;mDNS_ActivateNetWake_internal: NetworkInterfaceInfo %p not found in active list&quot;</span>, set); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (set-&gt;InterfaceActive)
    {
        LogSPS(<span class="enscript-string">&quot;ActivateNetWake for %s (%#a)&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);
        mDNS_StartBrowse_internal(m, &amp;set-&gt;NetWakeBrowse, &amp;SleepProxyServiceType, &amp;localdomain, set-&gt;InterfaceID, 0, mDNSfalse, mDNSfalse, m-&gt;SPSBrowseCallback, set);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_DeactivateNetWake_internal</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set)
{
    NetworkInterfaceInfo *p = m-&gt;HostInterfaces;
    <span class="enscript-keyword">while</span> (p &amp;&amp; p != set) p=p-&gt;next;
    <span class="enscript-keyword">if</span> (!p) { LogMsg(<span class="enscript-string">&quot;mDNS_DeactivateNetWake_internal: NetworkInterfaceInfo %p not found in active list&quot;</span>, set); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// Note: We start the browse only if the interface is NetWake capable and we use this to
</span>    <span class="enscript-comment">// stop the resolves also. Hence, the resolves should not be started without the browse
</span>    <span class="enscript-comment">// being started i.e, resolves should not happen unless NetWake capable which is
</span>    <span class="enscript-comment">// guaranteed by BeginSleepProcessing.
</span>    <span class="enscript-keyword">if</span> (set-&gt;NetWakeBrowse.ThisQInterval &gt;= 0)
    {
        <span class="enscript-type">int</span> i;
        LogSPS(<span class="enscript-string">&quot;DeactivateNetWake for %s (%#a)&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);

        <span class="enscript-comment">// Stop our browse and resolve operations
</span>        mDNS_StopQuery_internal(m, &amp;set-&gt;NetWakeBrowse);
        <span class="enscript-keyword">for</span> (i=0; i&lt;3; i++) <span class="enscript-keyword">if</span> (set-&gt;NetWakeResolve[i].ThisQInterval &gt;= 0) mDNS_StopQuery_internal(m, &amp;set-&gt;NetWakeResolve[i]);

        <span class="enscript-comment">// Make special call to the browse callback to let it know it can to remove all records for this interface
</span>        <span class="enscript-keyword">if</span> (m-&gt;SPSBrowseCallback)
        {
            mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>            m-&gt;SPSBrowseCallback(m, &amp;set-&gt;NetWakeBrowse, mDNSNULL, mDNSfalse);
            mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        }

        <span class="enscript-comment">// Reset our variables back to initial state, so we're ready for when NetWake is turned back on
</span>        <span class="enscript-comment">// (includes resetting NetWakeBrowse.ThisQInterval back to -1)
</span>        InitializeNetWakeState(m, set);
    }
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_RegisterInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed activationSpeed)
{
    AuthRecord *rr;
    mDNSBool FirstOfType = mDNStrue;
    NetworkInterfaceInfo **p = &amp;m-&gt;HostInterfaces;

    <span class="enscript-keyword">if</span> (!set-&gt;InterfaceID)
    { LogMsg(<span class="enscript-string">&quot;mDNS_RegisterInterface: Error! Tried to register a NetworkInterfaceInfo %#a with zero InterfaceID&quot;</span>, &amp;set-&gt;ip); <span class="enscript-keyword">return</span>(mStatus_Invalid); }

    <span class="enscript-keyword">if</span> (!mDNSAddressIsValidNonZero(&amp;set-&gt;mask))
    { LogMsg(<span class="enscript-string">&quot;mDNS_RegisterInterface: Error! Tried to register a NetworkInterfaceInfo %#a with invalid mask %#a&quot;</span>, &amp;set-&gt;ip, &amp;set-&gt;mask); <span class="enscript-keyword">return</span>(mStatus_Invalid); }

    mDNS_Lock(m);

    <span class="enscript-comment">// Assume this interface will be active now, unless we find a duplicate already in the list
</span>    set-&gt;InterfaceActive = mDNStrue;
    set-&gt;IPv4Available   = (mDNSu8)(set-&gt;ip.type == mDNSAddrType_IPv4 &amp;&amp; set-&gt;McastTxRx);
    set-&gt;IPv6Available   = (mDNSu8)(set-&gt;ip.type == mDNSAddrType_IPv6 &amp;&amp; set-&gt;McastTxRx);

    InitializeNetWakeState(m, set);

    <span class="enscript-comment">// Scan list to see if this InterfaceID is already represented
</span>    <span class="enscript-keyword">while</span> (*p)
    {
        <span class="enscript-keyword">if</span> (*p == set)
        {
            LogMsg(<span class="enscript-string">&quot;mDNS_RegisterInterface: Error! Tried to register a NetworkInterfaceInfo that's already in the list&quot;</span>);
            mDNS_Unlock(m);
            <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
        }

        <span class="enscript-keyword">if</span> ((*p)-&gt;InterfaceID == set-&gt;InterfaceID)
        {
            <span class="enscript-comment">// This InterfaceID already represented by a different interface in the list, so mark this instance inactive for now
</span>            set-&gt;InterfaceActive = mDNSfalse;
            <span class="enscript-keyword">if</span> (set-&gt;ip.type == (*p)-&gt;ip.type) FirstOfType = mDNSfalse;
            <span class="enscript-keyword">if</span> (set-&gt;ip.type == mDNSAddrType_IPv4 &amp;&amp; set-&gt;McastTxRx) (*p)-&gt;IPv4Available = mDNStrue;
            <span class="enscript-keyword">if</span> (set-&gt;ip.type == mDNSAddrType_IPv6 &amp;&amp; set-&gt;McastTxRx) (*p)-&gt;IPv6Available = mDNStrue;
        }

        p=&amp;(*p)-&gt;next;
    }

    set-&gt;next = mDNSNULL;
    *p = set;

    <span class="enscript-keyword">if</span> (set-&gt;Advertise) AdvertiseInterfaceIfNeeded(m, set);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
            <span class="enscript-string">&quot;mDNS_RegisterInterface: InterfaceID %u &quot;</span> PUB_S <span class="enscript-string">&quot; (&quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;) &quot;</span> PUB_S,
            IIDPrintable(set-&gt;InterfaceID), set-&gt;ifname, &amp;set-&gt;ip, set-&gt;InterfaceActive ?
            <span class="enscript-string">&quot;not represented in list; marking active and retriggering queries&quot;</span> :
            <span class="enscript-string">&quot;already represented in list; marking inactive for now&quot;</span>);

    <span class="enscript-keyword">if</span> (set-&gt;NetWake) mDNS_ActivateNetWake_internal(m, set);

    <span class="enscript-comment">// In early versions of OS X the IPv6 address remains on an interface even when the interface is turned off,
</span>    <span class="enscript-comment">// giving the false impression that there's an active representative of this interface when there really isn't.
</span>    <span class="enscript-comment">// Therefore, when registering an interface, we want to re-trigger our questions and re-probe our Resource Records,
</span>    <span class="enscript-comment">// even if we believe that we previously had an active representative of this interface.
</span>    <span class="enscript-keyword">if</span> (set-&gt;McastTxRx &amp;&amp; (FirstOfType || set-&gt;InterfaceActive))
    {
        DNSQuestion *q;
        <span class="enscript-comment">// Normally, after an interface comes up, we pause half a second before beginning probing.
</span>        <span class="enscript-comment">// This is to guard against cases where there's rapid interface changes, where we could be confused by
</span>        <span class="enscript-comment">// seeing packets we ourselves sent just moments ago (perhaps when this interface had a different address)
</span>        <span class="enscript-comment">// which are then echoed back after a short delay by some Ethernet switches and some 802.11 base stations.
</span>        <span class="enscript-comment">// We don't want to do a probe, and then see a stale echo of an announcement we ourselves sent,
</span>        <span class="enscript-comment">// and think it's a conflicting answer to our probe.
</span>        <span class="enscript-comment">// In the case of a flapping interface, we pause for five seconds, and reduce the announcement count to one packet.
</span>        mDNSs32 probedelay;
        mDNSu8 numannounce;
        <span class="enscript-keyword">switch</span> (activationSpeed)
        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">FastActivation</span>:
                probedelay = (mDNSs32)0;
                numannounce = InitialAnnounceCount;
                LogMsg(<span class="enscript-string">&quot;mDNS_RegisterInterface: Using fast activation for DirectLink interface %s (%#a)&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);
                <span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
            <span class="enscript-keyword">case</span> <span class="enscript-reference">SlowActivation</span>:
                probedelay = mDNSPlatformOneSecond * 5;
                numannounce = (mDNSu8)1;
                LogMsg(<span class="enscript-string">&quot;mDNS_RegisterInterface: Frequent transitions for interface %s (%#a), doing slow activation&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);
                m-&gt;mDNSStats.InterfaceUpFlap++;
                <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

            <span class="enscript-keyword">case</span> <span class="enscript-reference">NormalActivation</span>:
            <span class="enscript-reference">default</span>:
                probedelay = mDNSPlatformOneSecond / 2;
                numannounce = InitialAnnounceCount;
                <span class="enscript-keyword">break</span>;
        }

        LogInfo(<span class="enscript-string">&quot;mDNS_RegisterInterface: %s (%#a) probedelay %d&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip, probedelay);

        <span class="enscript-comment">// No probe or sending suppression on DirectLink type interfaces.
</span>        <span class="enscript-keyword">if</span> (activationSpeed == FastActivation)
        {
            m-&gt;SuppressSending = 0;
            m-&gt;SuppressProbes = 0;
        }
        <span class="enscript-keyword">else</span>
        {
	        <span class="enscript-comment">// Use a small amount of randomness:
</span>	        <span class="enscript-comment">// In the case of a network administrator turning on an Ethernet hub so that all the
</span>	        <span class="enscript-comment">// connected machines establish link at exactly the same time, we don't want them all
</span>	        <span class="enscript-comment">// to go and hit the network with identical queries at exactly the same moment.
</span>	        <span class="enscript-comment">// We set a random delay of up to InitialQuestionInterval (1/3 second).
</span>	        <span class="enscript-comment">// We must *never* set m-&gt;SuppressSending to more than that (or set it repeatedly in a way
</span>	        <span class="enscript-comment">// that causes mDNSResponder to remain in a prolonged state of SuppressSending, because
</span>	        <span class="enscript-comment">// suppressing packet sending for more than about 1/3 second can cause protocol correctness
</span>	        <span class="enscript-comment">// to start to break down (e.g. we don't answer probes fast enough, and get name conflicts).
</span>	        <span class="enscript-comment">// See &lt;rdar://problem/4073853&gt; mDNS: m-&gt;SuppressSending set too enthusiastically
</span>            <span class="enscript-keyword">if</span> (!m-&gt;SuppressSending) m-&gt;SuppressSending = m-&gt;timenow + (mDNSs32)mDNSRandom((mDNSu32)InitialQuestionInterval);

            <span class="enscript-keyword">if</span> (m-&gt;SuppressProbes == 0 ||
                m-&gt;SuppressProbes - NonZeroTime(m-&gt;timenow + probedelay) &lt; 0)
                m-&gt;SuppressProbes = NonZeroTime(m-&gt;timenow + probedelay);
        }

        <span class="enscript-comment">// Include OWNER option in packets for 60 seconds after connecting to the network. Setting
</span>        <span class="enscript-comment">// it here also handles the wake up case as the network link comes UP after waking causing
</span>        <span class="enscript-comment">// us to reconnect to the network. If we do this as part of the wake up code, it is possible
</span>        <span class="enscript-comment">// that the network link comes UP after 60 seconds and we never set the OWNER option
</span>        m-&gt;AnnounceOwner = NonZeroTime(m-&gt;timenow + 60 * mDNSPlatformOneSecond);
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;mDNS_RegisterInterface: Setting AnnounceOwner&quot;</span>);

        m-&gt;mDNSStats.InterfaceUp++;
        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)                                <span class="enscript-comment">// Scan our list of questions
</span>        {
            <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))
            {
                <span class="enscript-keyword">if</span> (!q-&gt;InterfaceID || q-&gt;InterfaceID == set-&gt;InterfaceID)      <span class="enscript-comment">// If non-specific Q, or Q on this specific interface,
</span>                {                                                               <span class="enscript-comment">// then reactivate this question
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
                    <span class="enscript-comment">// If flapping, delay between first and second queries is nine seconds instead of one second
</span>                    mDNSBool dodelay = (activationSpeed == SlowActivation) &amp;&amp; (q-&gt;FlappingInterface1 == set-&gt;InterfaceID || q-&gt;FlappingInterface2 == set-&gt;InterfaceID);
                    mDNSs32 initial  = dodelay ? InitialQuestionInterval * QuestionIntervalStep2 : InitialQuestionInterval;
                    mDNSs32 qdelay   = dodelay ? kDefaultQueryDelayTimeForFlappingInterface : 0;
                    <span class="enscript-keyword">if</span> (dodelay) LogInfo(<span class="enscript-string">&quot;No cache records expired for %##s (%s); delaying questions by %d seconds&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), qdelay);
#<span class="enscript-reference">else</span>
                    mDNSs32 initial  = InitialQuestionInterval;
                    mDNSs32 qdelay   = 0;
#<span class="enscript-reference">endif</span>

                    <span class="enscript-keyword">if</span> (!q-&gt;ThisQInterval || q-&gt;ThisQInterval &gt; initial)
                    {
                        q-&gt;ThisQInterval  = initial;
                        q-&gt;RequestUnicast = kDefaultRequestUnicastCount;
                    }
                    q-&gt;LastQTime = m-&gt;timenow - q-&gt;ThisQInterval + qdelay;
                    q-&gt;RecentAnswerPkts = 0;
                    SetNextQueryTime(m,q);
                }
            }
        }

        <span class="enscript-comment">// For all our non-specific authoritative resource records (and any dormant records specific to this interface)
</span>        <span class="enscript-comment">// we now need them to re-probe if necessary, and then re-announce.
</span>        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!rr-&gt;resrec.InterfaceID || rr-&gt;resrec.InterfaceID == set-&gt;InterfaceID)
            {
                mDNSCoreRestartRegistration(m, rr, numannounce);
            }
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; !<span class="enscript-variable-name">TARGET_OS_IPHONE</span>
        DNSSECProbe(m);
#<span class="enscript-reference">endif</span>
    }

    RestartRecordGetZoneData(m);

    mDNS_UpdateAllowSleep(m);

    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdjustAddressRecordSetsEx</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *removedIntf, mDNSBool forRandHostname)
{
    NetworkInterfaceInfo *intf;
    <span class="enscript-type">const</span> AuthRecord *oldAR;
    AuthRecord *newAR;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(removedIntf-&gt;InterfaceID)) <span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>
    oldAR = GetInterfaceAddressRecord(removedIntf, forRandHostname);
    newAR = GetFirstAddressRecordEx(m, forRandHostname);
    <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
    {
        AuthRecord *ar;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        <span class="enscript-keyword">if</span> (mDNSPlatformInterfaceIsAWDL(intf-&gt;InterfaceID)) <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
        ar = GetInterfaceAddressRecord(intf, forRandHostname);
        <span class="enscript-keyword">if</span> (ar-&gt;RRSet == oldAR)
        {
            ar-&gt;RRSet = newAR ? newAR : ar;
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;Changed RRSet for &quot;</span> PRI_S, ARDisplayString(m, ar));
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG, <span class="enscript-string">&quot;New RRSet:        &quot;</span> PRI_S, ARDisplayString(m, ar-&gt;RRSet));
        }
    }
}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AdjustAddressRecordSetsForRandHostname</span>(M, REMOVED_INTF) AdjustAddressRecordSetsEx(M, REMOVED_INTF, mDNStrue)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AdjustAddressRecordSets</span>(M, REMOVED_INTF)                AdjustAddressRecordSetsEx(M, REMOVED_INTF, mDNSfalse)

<span class="enscript-comment">// Note: mDNS_DeregisterInterface calls mDNS_Deregister_internal which can call a user callback, which may change
</span><span class="enscript-comment">// the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_DeregisterInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed activationSpeed)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
    (<span class="enscript-type">void</span>)activationSpeed;   <span class="enscript-comment">// Unused parameter
</span>#<span class="enscript-reference">endif</span>
    NetworkInterfaceInfo **p = &amp;m-&gt;HostInterfaces;
    mDNSBool revalidate = mDNSfalse;
    NetworkInterfaceInfo *intf;

    mDNS_Lock(m);

    <span class="enscript-comment">// Find this record in our list
</span>    <span class="enscript-keyword">while</span> (*p &amp;&amp; *p != set) p=&amp;(*p)-&gt;next;
    <span class="enscript-keyword">if</span> (!*p) { debugf(<span class="enscript-string">&quot;mDNS_DeregisterInterface: NetworkInterfaceInfo not found in list&quot;</span>); mDNS_Unlock(m); <span class="enscript-keyword">return</span>; }

    mDNS_DeactivateNetWake_internal(m, set);

    <span class="enscript-comment">// Unlink this record from our list
</span>    *p = (*p)-&gt;next;
    set-&gt;next = mDNSNULL;

    <span class="enscript-keyword">if</span> (!set-&gt;InterfaceActive)
    {
        <span class="enscript-comment">// If this interface not the active member of its set, update the v4/v6Available flags for the active member
</span>        <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
            <span class="enscript-keyword">if</span> (intf-&gt;InterfaceActive &amp;&amp; intf-&gt;InterfaceID == set-&gt;InterfaceID)
                UpdateInterfaceProtocols(m, intf);
    }
    <span class="enscript-keyword">else</span>
    {
        intf = FirstInterfaceForID(m, set-&gt;InterfaceID);
        <span class="enscript-keyword">if</span> (intf)
        {
            LogInfo(<span class="enscript-string">&quot;mDNS_DeregisterInterface: Another representative of InterfaceID %d %s (%#a) exists;&quot;</span>
                    <span class="enscript-string">&quot; making it active&quot;</span>, IIDPrintable(set-&gt;InterfaceID), set-&gt;ifname, &amp;set-&gt;ip);
            <span class="enscript-keyword">if</span> (intf-&gt;InterfaceActive)
                LogMsg(<span class="enscript-string">&quot;mDNS_DeregisterInterface: ERROR intf-&gt;InterfaceActive already set for %s (%#a)&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);
            intf-&gt;InterfaceActive = mDNStrue;
            UpdateInterfaceProtocols(m, intf);

            <span class="enscript-keyword">if</span> (intf-&gt;NetWake) mDNS_ActivateNetWake_internal(m, intf);

            <span class="enscript-comment">// See if another representative *of the same type* exists. If not, we mave have gone from
</span>            <span class="enscript-comment">// dual-stack to v6-only (or v4-only) so we need to reconfirm which records are still valid.
</span>            <span class="enscript-keyword">for</span> (intf = m-&gt;HostInterfaces; intf; intf = intf-&gt;next)
                <span class="enscript-keyword">if</span> (intf-&gt;InterfaceID == set-&gt;InterfaceID &amp;&amp; intf-&gt;ip.type == set-&gt;ip.type)
                    <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (!intf) revalidate = mDNStrue;
        }
        <span class="enscript-keyword">else</span>
        {
            mDNSu32 slot;
            CacheGroup *cg;
            CacheRecord *rr;
            DNSQuestion *q;

            LogInfo(<span class="enscript-string">&quot;mDNS_DeregisterInterface: Last representative of InterfaceID %d %s (%#a) deregistered;&quot;</span>
                    <span class="enscript-string">&quot; marking questions etc. dormant&quot;</span>, IIDPrintable(set-&gt;InterfaceID), set-&gt;ifname, &amp;set-&gt;ip);

            m-&gt;mDNSStats.InterfaceDown++;
 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
            <span class="enscript-keyword">if</span> (set-&gt;McastTxRx &amp;&amp; (activationSpeed == SlowActivation))
            {
                LogMsg(<span class="enscript-string">&quot;mDNS_DeregisterInterface: Frequent transitions for interface %s (%#a)&quot;</span>, set-&gt;ifname, &amp;set-&gt;ip);
                m-&gt;mDNSStats.InterfaceDownFlap++;
            }
#<span class="enscript-reference">endif</span>

            <span class="enscript-comment">// 1. Deactivate any questions specific to this interface, and tag appropriate questions
</span>            <span class="enscript-comment">// so that mDNS_RegisterInterface() knows how swiftly it needs to reactivate them
</span>            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
            {
                <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID))                   <span class="enscript-comment">// Only deactivate multicast quesstions. (Unicast questions are stopped when/if the associated DNS server group goes away.)
</span>                {
                    <span class="enscript-keyword">if</span> (q-&gt;InterfaceID == set-&gt;InterfaceID) q-&gt;ThisQInterval = 0;
                    <span class="enscript-keyword">if</span> (!q-&gt;InterfaceID || q-&gt;InterfaceID == set-&gt;InterfaceID)
                    {
                        q-&gt;FlappingInterface2 = q-&gt;FlappingInterface1;
                        q-&gt;FlappingInterface1 = set-&gt;InterfaceID;       <span class="enscript-comment">// Keep history of the last two interfaces to go away
</span>                    }
                }
            }

            <span class="enscript-comment">// 2. Flush any cache records received on this interface
</span>            revalidate = mDNSfalse;     <span class="enscript-comment">// Don't revalidate if we're flushing the records
</span>            FORALL_CACHERECORDS(slot, cg, rr)
            {
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == set-&gt;InterfaceID)
                {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SLOW_ACTIVATION</span>)
                    <span class="enscript-comment">// If this interface is deemed flapping,
</span>                    <span class="enscript-comment">// postpone deleting the cache records in case the interface comes back again
</span>                    <span class="enscript-keyword">if</span> (set-&gt;McastTxRx &amp;&amp; (activationSpeed == SlowActivation))
                    {
                        <span class="enscript-comment">// For a flapping interface we want these records to go away after 
</span>                        <span class="enscript-comment">// kDefaultReconfirmTimeForFlappingInterface seconds if they are not reconfirmed.
</span>                        mDNS_Reconfirm_internal(m, rr, kDefaultReconfirmTimeForFlappingInterface);
                        <span class="enscript-comment">// We set UnansweredQueries = MaxUnansweredQueries so we don't waste time doing any queries for them --
</span>                        <span class="enscript-comment">// if the interface does come back, any relevant questions will be reactivated anyway
</span>                        rr-&gt;UnansweredQueries = MaxUnansweredQueries;
                    }
                    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
                    {
                        rr-&gt;resrec.mortality = Mortality_Mortal;
                        mDNS_PurgeCacheResourceRecord(m, rr);
                    }
                }
            }
        }
    }

    <span class="enscript-comment">// If we still have address records referring to this one, update them.
</span>    <span class="enscript-comment">// This is safe, because this NetworkInterfaceInfo has already been unlinked from the list,
</span>    <span class="enscript-comment">// so the call to AdjustAddressRecordSets*() wont accidentally find it.
</span>    AdjustAddressRecordSets(m, set);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    AdjustAddressRecordSetsForRandHostname(m, set);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// If we were advertising on this interface, deregister those address and reverse-lookup records now
</span>    <span class="enscript-keyword">if</span> (set-&gt;Advertise) DeadvertiseInterface(m, set, kDeadvertiseFlag_All);

    <span class="enscript-comment">// If we have any cache records received on this interface that went away, then re-verify them.
</span>    <span class="enscript-comment">// In some versions of OS X the IPv6 address remains on an interface even when the interface is turned off,
</span>    <span class="enscript-comment">// giving the false impression that there's an active representative of this interface when there really isn't.
</span>    <span class="enscript-comment">// Don't need to do this when shutting down, because *all* interfaces are about to go away
</span>    <span class="enscript-keyword">if</span> (revalidate &amp;&amp; !m-&gt;ShutdownTime)
    {
        mDNSu32 slot;
        CacheGroup *cg;
        CacheRecord *rr;
        FORALL_CACHERECORDS(slot, cg, rr)
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == set-&gt;InterfaceID)
            mDNS_Reconfirm_internal(m, rr, kDefaultReconfirmTimeForFlappingInterface);
    }

    mDNS_UpdateAllowSleep(m);

    mDNS_Unlock(m);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ServiceCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    ServiceRecordSet *sr = (ServiceRecordSet *)rr-&gt;RecordContext;
    (<span class="enscript-type">void</span>)m;    <span class="enscript-comment">// Unused parameter
</span>
    #<span class="enscript-keyword">if</span> MDNS_DEBUGMSGS
    {
        <span class="enscript-type">char</span> *msg = <span class="enscript-string">&quot;Unknown result&quot;</span>;
        <span class="enscript-keyword">if</span>      (result == mStatus_NoError) msg = <span class="enscript-string">&quot;Name Registered&quot;</span>;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_NameConflict) msg = <span class="enscript-string">&quot;Name Conflict&quot;</span>;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_MemFree) msg = <span class="enscript-string">&quot;Memory Free&quot;</span>;
        debugf(<span class="enscript-string">&quot;ServiceCallback: %##s (%s) %s (%d)&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), msg, result);
    }
    #endif

    <span class="enscript-comment">// Only pass on the NoError acknowledgement for the SRV record (when it finishes probing)
</span>    <span class="enscript-keyword">if</span> (result == mStatus_NoError &amp;&amp; rr != &amp;sr-&gt;RR_SRV) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// If we got a name conflict on either SRV or TXT, forcibly deregister this service, and record that we did that
</span>    <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
    {
        sr-&gt;Conflict = mDNStrue;                <span class="enscript-comment">// Record that this service set had a conflict
</span>        mDNS_DeregisterService(m, sr);          <span class="enscript-comment">// Unlink the records from our list
</span>        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        <span class="enscript-comment">// If the SRV/TXT/PTR records, or the _services._dns-sd._udp record, or any of the subtype PTR records,
</span>        <span class="enscript-comment">// are still in the process of deregistering, don't pass on the NameConflict/MemFree message until
</span>        <span class="enscript-comment">// every record is finished cleaning up.
</span>        mDNSu32 i;
        ExtraResourceRecord *e = sr-&gt;Extras;

        <span class="enscript-keyword">if</span> (sr-&gt;RR_SRV.resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;
        <span class="enscript-keyword">if</span> (sr-&gt;RR_TXT.resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;
        <span class="enscript-keyword">if</span> (sr-&gt;RR_PTR.resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;
        <span class="enscript-keyword">if</span> (sr-&gt;RR_ADV.resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;
        <span class="enscript-keyword">for</span> (i=0; i&lt;sr-&gt;NumSubTypes; i++) <span class="enscript-keyword">if</span> (sr-&gt;SubTypes[i].resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;

        <span class="enscript-keyword">while</span> (e)
        {
            <span class="enscript-keyword">if</span> (e-&gt;r.resrec.RecordType != kDNSRecordTypeUnregistered) <span class="enscript-keyword">return</span>;
            e = e-&gt;next;
        }

        <span class="enscript-comment">// If this ServiceRecordSet was forcibly deregistered, and now its memory is ready for reuse,
</span>        <span class="enscript-comment">// then we can now report the NameConflict to the client
</span>        <span class="enscript-keyword">if</span> (sr-&gt;Conflict) result = mStatus_NameConflict;

    }

    LogInfo(<span class="enscript-string">&quot;ServiceCallback: All records %s for %##s&quot;</span>, (result == mStatus_MemFree ? <span class="enscript-string">&quot;Unregistered&quot;</span> : <span class="enscript-string">&quot;Registered&quot;</span>), sr-&gt;RR_PTR.resrec.name-&gt;c);
    <span class="enscript-comment">// CAUTION: MUST NOT do anything more with sr after calling sr-&gt;Callback(), because the client's callback
</span>    <span class="enscript-comment">// function is allowed to do anything, including deregistering this service and freeing its memory.
</span>    <span class="enscript-keyword">if</span> (sr-&gt;ServiceCallback)
        sr-&gt;ServiceCallback(m, sr, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NSSCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    ServiceRecordSet *sr = (ServiceRecordSet *)rr-&gt;RecordContext;
    <span class="enscript-keyword">if</span> (sr-&gt;ServiceCallback)
        sr-&gt;ServiceCallback(m, sr, result);
}


<span class="enscript-comment">// Derive AuthRecType from the kDNSServiceFlags* values.
</span>mDNSlocal AuthRecType <span class="enscript-function-name">setAuthRecType</span>(mDNSInterfaceID InterfaceID, mDNSu32 flags)
{
    AuthRecType artype;

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly)
        artype = AuthRecordLocalOnly;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P || InterfaceID == mDNSInterface_BLE)
        artype = AuthRecordP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeP2P)
            &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeAWDL))
        artype = AuthRecordAnyIncludeAWDLandP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeP2P))
        artype = AuthRecordAnyIncludeP2P;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((InterfaceID == mDNSInterface_Any) &amp;&amp; (flags &amp; kDNSServiceFlagsIncludeAWDL))
        artype = AuthRecordAnyIncludeAWDL;
    <span class="enscript-keyword">else</span>
        artype = AuthRecordAny;

    <span class="enscript-keyword">return</span> artype;
}

<span class="enscript-comment">// Note:
</span><span class="enscript-comment">// Name is first label of domain name (any dots in the name are actual dots, not label separators)
</span><span class="enscript-comment">// Type is service type (e.g. &quot;_ipp._tcp.&quot;)
</span><span class="enscript-comment">// Domain is fully qualified domain name (i.e. ending with a null label)
</span><span class="enscript-comment">// We always register a TXT, even if it is empty (so that clients are not
</span><span class="enscript-comment">// left waiting forever looking for a nonexistent record.)
</span><span class="enscript-comment">// If the host parameter is mDNSNULL or the root domain (ASCII NUL),
</span><span class="enscript-comment">// then the default host name (m-&gt;MulticastHostname) is automatically used
</span><span class="enscript-comment">// If the optional target host parameter is set, then the storage it points to must remain valid for the lifetime of the service registration
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_RegisterService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr,
                                        <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> host, mDNSIPPort port, RData *<span class="enscript-type">const</span> txtrdata, <span class="enscript-type">const</span> mDNSu8 txtinfo[], mDNSu16 txtlen,
                                        AuthRecord *SubTypes, mDNSu32 NumSubTypes,
                                        mDNSInterfaceID InterfaceID, mDNSServiceCallback Callback, <span class="enscript-type">void</span> *Context, mDNSu32 flags)
{
    mStatus err;
    mDNSu32 i;
    AuthRecType artype;
    mDNSu8 recordType = (flags &amp; kDNSServiceFlagsKnownUnique) ? kDNSRecordTypeKnownUnique : kDNSRecordTypeUnique;

    sr-&gt;ServiceCallback = Callback;
    sr-&gt;ServiceContext  = Context;
    sr-&gt;Conflict        = mDNSfalse;

    sr-&gt;Extras          = mDNSNULL;
    sr-&gt;NumSubTypes     = NumSubTypes;
    sr-&gt;SubTypes        = SubTypes;
    sr-&gt;flags           = flags;

    artype = setAuthRecType(InterfaceID, flags);

    <span class="enscript-comment">// Initialize the AuthRecord objects to sane values
</span>    <span class="enscript-comment">// Need to initialize everything correctly *before* making the decision whether to do a RegisterNoSuchService and bail out
</span>    mDNS_SetupResourceRecord(&amp;sr-&gt;RR_ADV, mDNSNULL, InterfaceID, kDNSType_PTR, kStandardTTL, kDNSRecordTypeAdvisory, artype, ServiceCallback, sr);
    mDNS_SetupResourceRecord(&amp;sr-&gt;RR_PTR, mDNSNULL, InterfaceID, kDNSType_PTR, kStandardTTL, kDNSRecordTypeShared,   artype, ServiceCallback, sr);

    <span class="enscript-keyword">if</span> (flags &amp; kDNSServiceFlagsWakeOnlyService)
    {
        sr-&gt;RR_PTR.AuthFlags = AuthFlagsWakeOnly;
    }

    mDNS_SetupResourceRecord(&amp;sr-&gt;RR_SRV, mDNSNULL, InterfaceID, kDNSType_SRV, kHostNameTTL, recordType, artype, ServiceCallback, sr);
    mDNS_SetupResourceRecord(&amp;sr-&gt;RR_TXT, txtrdata, InterfaceID, kDNSType_TXT, kStandardTTL, recordType, artype, ServiceCallback, sr);

    <span class="enscript-comment">// If port number is zero, that means the client is really trying to do a RegisterNoSuchService
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(port))
        <span class="enscript-keyword">return</span>(mDNS_RegisterNoSuchService(m, &amp;sr-&gt;RR_SRV, name, type, domain, mDNSNULL, InterfaceID, NSSCallback, sr, flags));

    <span class="enscript-comment">// If the caller is registering an oversized TXT record,
</span>    <span class="enscript-comment">// it is the caller's responsibility to allocate a ServiceRecordSet structure that is large enough for it
</span>    <span class="enscript-keyword">if</span> (sr-&gt;RR_TXT.resrec.rdata-&gt;MaxRDLength &lt; txtlen)
        sr-&gt;RR_TXT.resrec.rdata-&gt;MaxRDLength = txtlen;

    <span class="enscript-comment">// Set up the record names
</span>    <span class="enscript-comment">// For now we only create an advisory record for the main type, not for subtypes
</span>    <span class="enscript-comment">// We need to gain some operational experience before we decide if there's a need to create them for subtypes too
</span>    <span class="enscript-keyword">if</span> (ConstructServiceName(&amp;sr-&gt;RR_ADV.namestorage, (<span class="enscript-type">const</span> domainlabel*)<span class="enscript-string">&quot;\x09_services&quot;</span>, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x07_dns-sd\x04_udp&quot;</span>, domain) == mDNSNULL)
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (ConstructServiceName(&amp;sr-&gt;RR_PTR.namestorage, mDNSNULL, type, domain) == mDNSNULL) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (ConstructServiceName(&amp;sr-&gt;RR_SRV.namestorage, name,     type, domain) == mDNSNULL) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    AssignDomainName(&amp;sr-&gt;RR_TXT.namestorage, sr-&gt;RR_SRV.resrec.name);

    <span class="enscript-comment">// 1. Set up the ADV record rdata to advertise our service type
</span>    AssignDomainName(&amp;sr-&gt;RR_ADV.resrec.rdata-&gt;u.name, sr-&gt;RR_PTR.resrec.name);

    <span class="enscript-comment">// 2. Set up the PTR record rdata to point to our service name
</span>    <span class="enscript-comment">// We set up two additionals, so when a client asks for this PTR we automatically send the SRV and the TXT too
</span>    <span class="enscript-comment">// Note: uDNS registration code assumes that Additional1 points to the SRV record
</span>    AssignDomainName(&amp;sr-&gt;RR_PTR.resrec.rdata-&gt;u.name, sr-&gt;RR_SRV.resrec.name);
    sr-&gt;RR_PTR.Additional1 = &amp;sr-&gt;RR_SRV;
    sr-&gt;RR_PTR.Additional2 = &amp;sr-&gt;RR_TXT;

    <span class="enscript-comment">// 2a. Set up any subtype PTRs to point to our service name
</span>    <span class="enscript-comment">// If the client is using subtypes, it is the client's responsibility to have
</span>    <span class="enscript-comment">// already set the first label of the record name to the subtype being registered
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;NumSubTypes; i++)
    {
        domainname st;
        AssignDomainName(&amp;st, sr-&gt;SubTypes[i].resrec.name);
        st.c[1+st.c[0]] = 0;            <span class="enscript-comment">// Only want the first label, not the whole FQDN (particularly for mDNS_RenameAndReregisterService())
</span>        AppendDomainName(&amp;st, type);
        mDNS_SetupResourceRecord(&amp;sr-&gt;SubTypes[i], mDNSNULL, InterfaceID, kDNSType_PTR, kStandardTTL, kDNSRecordTypeShared, artype, ServiceCallback, sr);
        <span class="enscript-keyword">if</span> (ConstructServiceName(&amp;sr-&gt;SubTypes[i].namestorage, mDNSNULL, &amp;st, domain) == mDNSNULL) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        AssignDomainName(&amp;sr-&gt;SubTypes[i].resrec.rdata-&gt;u.name, &amp;sr-&gt;RR_SRV.namestorage);
        sr-&gt;SubTypes[i].Additional1 = &amp;sr-&gt;RR_SRV;
        sr-&gt;SubTypes[i].Additional2 = &amp;sr-&gt;RR_TXT;
    }

    <span class="enscript-comment">// 3. Set up the SRV record rdata.
</span>    sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.priority = 0;
    sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.weight   = 0;
    sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port     = port;

    <span class="enscript-comment">// Setting AutoTarget tells DNS that the target of this SRV is to be automatically kept in sync with our host name
</span>    <span class="enscript-keyword">if</span> (host &amp;&amp; host-&gt;c[0]) AssignDomainName(&amp;sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.target, host);
    <span class="enscript-keyword">else</span> { sr-&gt;RR_SRV.AutoTarget = Target_AutoHost; sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.target.c[0] = <span class="enscript-string">'\0'</span>; }

    <span class="enscript-comment">// 4. Set up the TXT record rdata,
</span>    <span class="enscript-comment">// and set DependentOn because we're depending on the SRV record to find and resolve conflicts for us
</span>    <span class="enscript-comment">// Note: uDNS registration code assumes that DependentOn points to the SRV record
</span>    <span class="enscript-keyword">if</span> (txtinfo == mDNSNULL) sr-&gt;RR_TXT.resrec.rdlength = 0;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (txtinfo != sr-&gt;RR_TXT.resrec.rdata-&gt;u.txt.c)
    {
        sr-&gt;RR_TXT.resrec.rdlength = txtlen;
        <span class="enscript-keyword">if</span> (sr-&gt;RR_TXT.resrec.rdlength &gt; sr-&gt;RR_TXT.resrec.rdata-&gt;MaxRDLength) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
        mDNSPlatformMemCopy(sr-&gt;RR_TXT.resrec.rdata-&gt;u.txt.c, txtinfo, txtlen);
    }
    sr-&gt;RR_TXT.DependentOn = &amp;sr-&gt;RR_SRV;

    mDNS_Lock(m);
    <span class="enscript-comment">// It is important that we register SRV first. uDNS assumes that SRV is registered first so
</span>    <span class="enscript-comment">// that if the SRV cannot find a target, rest of the records that belong to this service
</span>    <span class="enscript-comment">// will not be activated.
</span>    err = mDNS_Register_internal(m, &amp;sr-&gt;RR_SRV);
    <span class="enscript-comment">// If we can't register the SRV record due to errors, bail out. It has not been inserted in
</span>    <span class="enscript-comment">// any list and hence no need to deregister. We could probably do similar checks for other
</span>    <span class="enscript-comment">// records below and bail out. For now, this seems to be sufficient to address rdar://9304275
</span>    <span class="enscript-keyword">if</span> (err)
    {
        mDNS_Unlock(m);
        <span class="enscript-keyword">return</span> err;
    }
    <span class="enscript-keyword">if</span> (!err) err = mDNS_Register_internal(m, &amp;sr-&gt;RR_TXT);
    <span class="enscript-comment">// We register the RR_PTR last, because we want to be sure that in the event of a forced call to
</span>    <span class="enscript-comment">// mDNS_StartExit, the RR_PTR will be the last one to be forcibly deregistered, since that is what triggers
</span>    <span class="enscript-comment">// the mStatus_MemFree callback to ServiceCallback, which in turn passes on the mStatus_MemFree back to
</span>    <span class="enscript-comment">// the client callback, which is then at liberty to free the ServiceRecordSet memory at will. We need to
</span>    <span class="enscript-comment">// make sure we've deregistered all our records and done any other necessary cleanup before that happens.
</span>    <span class="enscript-keyword">if</span> (!err) err = mDNS_Register_internal(m, &amp;sr-&gt;RR_ADV);
    <span class="enscript-keyword">for</span> (i=0; i&lt;NumSubTypes; i++) <span class="enscript-keyword">if</span> (!err) err = mDNS_Register_internal(m, &amp;sr-&gt;SubTypes[i]);
    <span class="enscript-keyword">if</span> (!err) err = mDNS_Register_internal(m, &amp;sr-&gt;RR_PTR);

    mDNS_Unlock(m);

    <span class="enscript-keyword">if</span> (err) mDNS_DeregisterService(m, sr);
    <span class="enscript-keyword">return</span>(err);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_AddRecordToService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr,
                                           ExtraResourceRecord *extra, RData *rdata, mDNSu32 ttl,  mDNSu32 flags)
{
    ExtraResourceRecord **e;
    mStatus status;
    AuthRecType artype;
    mDNSInterfaceID InterfaceID = sr-&gt;RR_PTR.resrec.InterfaceID;
    ResourceRecord *rr;

    artype = setAuthRecType(InterfaceID, flags);

    extra-&gt;next = mDNSNULL;
    mDNS_SetupResourceRecord(&amp;extra-&gt;r, rdata, sr-&gt;RR_PTR.resrec.InterfaceID,
                             extra-&gt;r.resrec.rrtype, ttl, kDNSRecordTypeUnique, artype, ServiceCallback, sr);
    AssignDomainName(&amp;extra-&gt;r.namestorage, sr-&gt;RR_SRV.resrec.name);

    mDNS_Lock(m);
    rr = mDNSNULL;
    <span class="enscript-keyword">if</span> (extra-&gt;r.resrec.rrtype == kDNSType_TXT)
    {
        <span class="enscript-keyword">if</span> (sr-&gt;RR_TXT.resrec.RecordType &amp; kDNSRecordTypeUniqueMask) rr = &amp;sr-&gt;RR_TXT.resrec;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (extra-&gt;r.resrec.rrtype == kDNSType_SRV)
    {
        <span class="enscript-keyword">if</span> (sr-&gt;RR_SRV.resrec.RecordType &amp; kDNSRecordTypeUniqueMask) rr = &amp;sr-&gt;RR_SRV.resrec;
    }

    <span class="enscript-keyword">if</span> (!rr)
    {
        ExtraResourceRecord *srExtra;

        <span class="enscript-keyword">for</span> (srExtra = sr-&gt;Extras; srExtra; srExtra = srExtra-&gt;next)
        {
            <span class="enscript-keyword">if</span> ((srExtra-&gt;r.resrec.rrtype == extra-&gt;r.resrec.rrtype) &amp;&amp; (srExtra-&gt;r.resrec.RecordType &amp; kDNSRecordTypeUniqueMask))
            {
                rr = &amp;srExtra-&gt;r.resrec;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    <span class="enscript-keyword">if</span> (rr &amp;&amp; (extra-&gt;r.resrec.rroriginalttl != rr-&gt;rroriginalttl))
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_AddRecordToService: Correcting TTL from %4d to %4d for %s&quot;</span>,
            extra-&gt;r.resrec.rroriginalttl, rr-&gt;rroriginalttl, RRDisplayString(m, &amp;extra-&gt;r.resrec));
        extra-&gt;r.resrec.rroriginalttl = rr-&gt;rroriginalttl;
    }

    e = &amp;sr-&gt;Extras;
    <span class="enscript-keyword">while</span> (*e) e = &amp;(*e)-&gt;next;

    extra-&gt;r.DependentOn = &amp;sr-&gt;RR_SRV;

    debugf(<span class="enscript-string">&quot;mDNS_AddRecordToService adding record to %##s %s %d&quot;</span>,
           extra-&gt;r.resrec.name-&gt;c, DNSTypeName(extra-&gt;r.resrec.rrtype), extra-&gt;r.resrec.rdlength);

    status = mDNS_Register_internal(m, &amp;extra-&gt;r);
    <span class="enscript-keyword">if</span> (status == mStatus_NoError) *e = extra;

    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_RemoveRecordFromService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr, ExtraResourceRecord *extra,
                                                mDNSRecordCallback MemFreeCallback, <span class="enscript-type">void</span> *Context)
{
    ExtraResourceRecord **e;
    mStatus status;

    mDNS_Lock(m);
    e = &amp;sr-&gt;Extras;
    <span class="enscript-keyword">while</span> (*e &amp;&amp; *e != extra) e = &amp;(*e)-&gt;next;
    <span class="enscript-keyword">if</span> (!*e)
    {
        debugf(<span class="enscript-string">&quot;mDNS_RemoveRecordFromService failed to remove record from %##s&quot;</span>, extra-&gt;r.resrec.name-&gt;c);
        status = mStatus_BadReferenceErr;
    }
    <span class="enscript-keyword">else</span>
    {
        debugf(<span class="enscript-string">&quot;mDNS_RemoveRecordFromService removing record from %##s&quot;</span>, extra-&gt;r.resrec.name-&gt;c);
        extra-&gt;r.RecordCallback = MemFreeCallback;
        extra-&gt;r.RecordContext  = Context;
        *e = (*e)-&gt;next;
        status = mDNS_Deregister_internal(m, &amp;extra-&gt;r, mDNS_Dereg_normal);
    }
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_RenameAndReregisterService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> sr, <span class="enscript-type">const</span> domainlabel *newname)
{
    <span class="enscript-comment">// Note: Don't need to use mDNS_Lock(m) here, because this code is just using public routines
</span>    <span class="enscript-comment">// mDNS_RegisterService() and mDNS_AddRecordToService(), which do the right locking internally.
</span>    domainlabel name1, name2;
    domainname type, domain;
    <span class="enscript-type">const</span> domainname *host = sr-&gt;RR_SRV.AutoTarget ? mDNSNULL : &amp;sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.target;
    ExtraResourceRecord *extras = sr-&gt;Extras;
    mStatus err;

    DeconstructServiceName(sr-&gt;RR_SRV.resrec.name, &amp;name1, &amp;type, &amp;domain);
    <span class="enscript-keyword">if</span> (!newname)
    {
        name2 = name1;
        IncrementLabelSuffix(&amp;name2, mDNStrue);
        newname = &amp;name2;
    }

    <span class="enscript-keyword">if</span> (SameDomainName(&amp;domain, &amp;localdomain))
        debugf(<span class="enscript-string">&quot;%##s service renamed from \&quot;%#s\&quot; to \&quot;%#s\&quot;&quot;</span>, type.c, name1.c, newname-&gt;c);
    <span class="enscript-keyword">else</span> debugf(<span class="enscript-string">&quot;%##s service (domain %##s) renamed from \&quot;%#s\&quot; to \&quot;%#s\&quot;&quot;</span>,type.c, domain.c, name1.c, newname-&gt;c);

    <span class="enscript-comment">// If there's a pending TXT record update at this point, which can happen if a DNSServiceUpdateRecord() call was made
</span>    <span class="enscript-comment">// after the TXT record's deregistration, execute it now, otherwise it will be lost during the service re-registration.
</span>    <span class="enscript-keyword">if</span> (sr-&gt;RR_TXT.NewRData) CompleteRDataUpdate(m, &amp;sr-&gt;RR_TXT);
    err = mDNS_RegisterService(m, sr, newname, &amp;type, &amp;domain,
                               host, sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port,
                               (sr-&gt;RR_TXT.resrec.rdata != &amp;sr-&gt;RR_TXT.rdatastorage) ? sr-&gt;RR_TXT.resrec.rdata : mDNSNULL,
                               sr-&gt;RR_TXT.resrec.rdata-&gt;u.txt.c, sr-&gt;RR_TXT.resrec.rdlength,
                               sr-&gt;SubTypes, sr-&gt;NumSubTypes,
                               sr-&gt;RR_PTR.resrec.InterfaceID, sr-&gt;ServiceCallback, sr-&gt;ServiceContext, sr-&gt;flags);

    <span class="enscript-comment">// mDNS_RegisterService() just reset sr-&gt;Extras to NULL.
</span>    <span class="enscript-comment">// Fortunately we already grabbed ourselves a copy of this pointer (above), so we can now run
</span>    <span class="enscript-comment">// through the old list of extra records, and re-add them to our freshly created service registration
</span>    <span class="enscript-keyword">while</span> (!err &amp;&amp; extras)
    {
        ExtraResourceRecord *e = extras;
        extras = extras-&gt;next;
        err = mDNS_AddRecordToService(m, sr, e, e-&gt;r.resrec.rdata, e-&gt;r.resrec.rroriginalttl, 0);
    }

    <span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">// Note: mDNS_DeregisterService calls mDNS_Deregister_internal which can call a user callback,
</span><span class="enscript-comment">// which may change the record list and/or question list.
</span><span class="enscript-comment">// Any code walking either list must use the CurrentQuestion and/or CurrentRecord mechanism to protect against this.
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_DeregisterService_drt</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr, mDNS_Dereg_type drt)
{
    <span class="enscript-comment">// If port number is zero, that means this was actually registered using mDNS_RegisterNoSuchService()
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(sr-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port)) <span class="enscript-keyword">return</span>(mDNS_DeregisterNoSuchService(m, &amp;sr-&gt;RR_SRV));

    <span class="enscript-keyword">if</span> (sr-&gt;RR_PTR.resrec.RecordType == kDNSRecordTypeUnregistered)
    {
        debugf(<span class="enscript-string">&quot;Service set for %##s already deregistered&quot;</span>, sr-&gt;RR_SRV.resrec.name-&gt;c);
        <span class="enscript-keyword">return</span>(mStatus_BadReferenceErr);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sr-&gt;RR_PTR.resrec.RecordType == kDNSRecordTypeDeregistering)
    {
        LogInfo(<span class="enscript-string">&quot;Service set for %##s already in the process of deregistering&quot;</span>, sr-&gt;RR_SRV.resrec.name-&gt;c);
        <span class="enscript-comment">// Avoid race condition:
</span>        <span class="enscript-comment">// If a service gets a conflict, then we set the Conflict flag to tell us to generate
</span>        <span class="enscript-comment">// an mStatus_NameConflict message when we get the mStatus_MemFree for our PTR record.
</span>        <span class="enscript-comment">// If the client happens to deregister the service in the middle of that process, then
</span>        <span class="enscript-comment">// we clear the flag back to the normal state, so that we deliver a plain mStatus_MemFree
</span>        <span class="enscript-comment">// instead of incorrectly promoting it to mStatus_NameConflict.
</span>        <span class="enscript-comment">// This race condition is exposed particularly when the conformance test generates
</span>        <span class="enscript-comment">// a whole batch of simultaneous conflicts across a range of services all advertised
</span>        <span class="enscript-comment">// using the same system default name, and if we don't take this precaution then
</span>        <span class="enscript-comment">// we end up incrementing m-&gt;nicelabel multiple times instead of just once.
</span>        <span class="enscript-comment">// &lt;rdar://problem/4060169&gt; Bug when auto-renaming Computer Name after name collision
</span>        sr-&gt;Conflict = mDNSfalse;
        <span class="enscript-keyword">return</span>(mStatus_NoError);
    }
    <span class="enscript-keyword">else</span>
    {
        mDNSu32 i;
        mStatus status;
        ExtraResourceRecord *e;
        mDNS_Lock(m);
        e = sr-&gt;Extras;

        <span class="enscript-comment">// We use mDNS_Dereg_repeat because, in the event of a collision, some or all of the
</span>        <span class="enscript-comment">// SRV, TXT, or Extra records could have already been automatically deregistered, and that's okay
</span>        mDNS_Deregister_internal(m, &amp;sr-&gt;RR_SRV, mDNS_Dereg_repeat);
        mDNS_Deregister_internal(m, &amp;sr-&gt;RR_TXT, mDNS_Dereg_repeat);
        mDNS_Deregister_internal(m, &amp;sr-&gt;RR_ADV, drt);

        <span class="enscript-comment">// We deregister all of the extra records, but we leave the sr-&gt;Extras list intact
</span>        <span class="enscript-comment">// in case the client wants to do a RenameAndReregister and reinstate the registration
</span>        <span class="enscript-keyword">while</span> (e)
        {
            mDNS_Deregister_internal(m, &amp;e-&gt;r, mDNS_Dereg_repeat);
            e = e-&gt;next;
        }

        <span class="enscript-keyword">for</span> (i=0; i&lt;sr-&gt;NumSubTypes; i++)
            mDNS_Deregister_internal(m, &amp;sr-&gt;SubTypes[i], drt);

        status = mDNS_Deregister_internal(m, &amp;sr-&gt;RR_PTR, drt);
        mDNS_Unlock(m);
        <span class="enscript-keyword">return</span>(status);
    }
}

<span class="enscript-comment">// Create a registration that asserts that no such service exists with this name.
</span><span class="enscript-comment">// This can be useful where there is a given function is available through several protocols.
</span><span class="enscript-comment">// For example, a printer called &quot;Stuart's Printer&quot; may implement printing via the &quot;pdl-datastream&quot; and &quot;IPP&quot;
</span><span class="enscript-comment">// protocols, but not via &quot;LPR&quot;. In this case it would be prudent for the printer to assert the non-existence of an
</span><span class="enscript-comment">// &quot;LPR&quot; service called &quot;Stuart's Printer&quot;. Without this precaution, another printer than offers only &quot;LPR&quot; printing
</span><span class="enscript-comment">// could inadvertently advertise its service under the same name &quot;Stuart's Printer&quot;, which might be confusing for users.
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_RegisterNoSuchService</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr,
                                              <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                              <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> host,
                                              <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSRecordCallback Callback, <span class="enscript-type">void</span> *Context, mDNSu32 flags)
{
    AuthRecType artype;

    artype = setAuthRecType(InterfaceID, flags);

    mDNS_SetupResourceRecord(rr, mDNSNULL, InterfaceID, kDNSType_SRV, kHostNameTTL, kDNSRecordTypeUnique, artype, Callback, Context);
    <span class="enscript-keyword">if</span> (ConstructServiceName(&amp;rr-&gt;namestorage, name, type, domain) == mDNSNULL) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    rr-&gt;resrec.rdata-&gt;u.srv.priority    = 0;
    rr-&gt;resrec.rdata-&gt;u.srv.weight      = 0;
    rr-&gt;resrec.rdata-&gt;u.srv.port        = zeroIPPort;
    <span class="enscript-keyword">if</span> (host &amp;&amp; host-&gt;c[0]) AssignDomainName(&amp;rr-&gt;resrec.rdata-&gt;u.srv.target, host);
    <span class="enscript-keyword">else</span> rr-&gt;AutoTarget = Target_AutoHost;
    <span class="enscript-keyword">return</span>(mDNS_Register(m, rr));
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_AdvertiseDomains</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr,
                                         mDNS_DomainType DomainType, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">char</span> *domname)
{
    AuthRecType artype;

    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly)
        artype = AuthRecordLocalOnly;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P || InterfaceID == mDNSInterface_BLE)
        artype = AuthRecordP2P;
    <span class="enscript-keyword">else</span>
        artype = AuthRecordAny;
    mDNS_SetupResourceRecord(rr, mDNSNULL, InterfaceID, kDNSType_PTR, kStandardTTL, kDNSRecordTypeShared, artype, mDNSNULL, mDNSNULL);
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;rr-&gt;namestorage, mDNS_DomainTypeNames[DomainType])) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;rr-&gt;resrec.rdata-&gt;u.name, domname)) <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    <span class="enscript-keyword">return</span>(mDNS_Register(m, rr));
}

mDNSlocal mDNSBool <span class="enscript-function-name">mDNS_IdUsedInResourceRecordsList</span>(mDNS * <span class="enscript-type">const</span> m, mDNSOpaque16 id)
{
    AuthRecord *r;
    <span class="enscript-keyword">for</span> (r = m-&gt;ResourceRecords; r; r=r-&gt;next) <span class="enscript-keyword">if</span> (mDNSSameOpaque16(id, r-&gt;updateid)) <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal mDNSBool <span class="enscript-function-name">mDNS_IdUsedInQuestionsList</span>(mDNS * <span class="enscript-type">const</span> m, mDNSOpaque16 id)
{
    DNSQuestion *q;
    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next) <span class="enscript-keyword">if</span> (mDNSSameOpaque16(id, q-&gt;TargetQID)) <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport mDNSOpaque16 <span class="enscript-function-name">mDNS_NewMessageID</span>(mDNS * <span class="enscript-type">const</span> m)
{
    mDNSOpaque16 id;
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">for</span> (i=0; i&lt;10; i++)
    {
        id = mDNSOpaque16fromIntVal(1 + (mDNSu16)mDNSRandom(0xFFFE));
        <span class="enscript-keyword">if</span> (!mDNS_IdUsedInResourceRecordsList(m, id) &amp;&amp; !mDNS_IdUsedInQuestionsList(m, id)) <span class="enscript-keyword">break</span>;
    }

    debugf(<span class="enscript-string">&quot;mDNS_NewMessageID: %5d&quot;</span>, mDNSVal16(id));

    <span class="enscript-keyword">return</span> id;
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Sleep</span> <span class="enscript-variable-name">Proxy</span> <span class="enscript-variable-name">Server</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RestartARPProbing</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-comment">// If we see an ARP from a machine we think is sleeping, then either
</span>    <span class="enscript-comment">// (i) the machine has woken, or
</span>    <span class="enscript-comment">// (ii) it's just a stray old packet from before the machine slept
</span>    <span class="enscript-comment">// To handle the second case, we reset ProbeCount, so we'll suppress our own answers for a while, to avoid
</span>    <span class="enscript-comment">// generating ARP conflicts with a waking machine, and set rr-&gt;LastAPTime so we'll start probing again in 10 seconds.
</span>    <span class="enscript-comment">// If the machine has just woken then we'll discard our records when we see the first new mDNS probe from that machine.
</span>    <span class="enscript-comment">// If it was a stray old packet, then after 10 seconds we'll probe again and then start answering ARPs again. In this case we *do*
</span>    <span class="enscript-comment">// need to send new ARP Announcements, because the owner's ARP broadcasts will have updated neighboring ARP caches, so we need to
</span>    <span class="enscript-comment">// re-assert our (temporary) ownership of that IP address in order to receive subsequent packets addressed to that IPv4 address.
</span>
    rr-&gt;resrec.RecordType = kDNSRecordTypeUnique;
    rr-&gt;ProbeCount        = DefaultProbeCountForTypeUnique;
    rr-&gt;ProbeRestartCount++;

    <span class="enscript-comment">// If we haven't started announcing yet (and we're not already in ten-second-delay mode) the machine is probably
</span>    <span class="enscript-comment">// still going to sleep, so we just reset rr-&gt;ProbeCount so we'll continue probing until it stops responding.
</span>    <span class="enscript-comment">// If we *have* started announcing, the machine is probably in the process of waking back up, so in that case
</span>    <span class="enscript-comment">// we're more cautious and we wait ten seconds before probing it again. We do this because while waking from
</span>    <span class="enscript-comment">// sleep, some network interfaces tend to lose or delay inbound packets, and without this delay, if the waking machine
</span>    <span class="enscript-comment">// didn't answer our three probes within three seconds then we'd announce and cause it an unnecessary address conflict.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount == InitialAnnounceCount &amp;&amp; m-&gt;timenow - rr-&gt;LastAPTime &gt;= 0)
        InitializeLastAPTime(m, rr);
    <span class="enscript-keyword">else</span>
    {
        rr-&gt;AnnounceCount  = InitialAnnounceCount;
        rr-&gt;ThisAPInterval = mDNSPlatformOneSecond;
        rr-&gt;LastAPTime     = m-&gt;timenow + mDNSPlatformOneSecond * 9;    <span class="enscript-comment">// Send first packet at rr-&gt;LastAPTime + rr-&gt;ThisAPInterval, i.e. 10 seconds from now
</span>        SetNextAnnounceProbeTime(m, rr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveRawARP</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> ARP_EthIP *<span class="enscript-type">const</span> arp, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 ARP_op_request = { { 0, 1 } };
    AuthRecord *rr;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, InterfaceID);
    <span class="enscript-keyword">if</span> (!intf) <span class="enscript-keyword">return</span>;

    mDNS_Lock(m);

    <span class="enscript-comment">// Pass 1:
</span>    <span class="enscript-comment">// Process ARP Requests and Probes (but not Announcements), and generate an ARP Reply if necessary.
</span>    <span class="enscript-comment">// We also process ARPs from our own kernel (and 'answer' them by injecting a local ARP table entry)
</span>    <span class="enscript-comment">// We ignore ARP Announcements here -- Announcements are not questions, they're assertions, so we don't need to answer them.
</span>    <span class="enscript-comment">// The times we might need to react to an ARP Announcement are:
</span>    <span class="enscript-comment">// (i) as an indication that the host in question has not gone to sleep yet (so we should delay beginning to proxy for it) or
</span>    <span class="enscript-comment">// (ii) if it's a conflicting Announcement from another host
</span>    <span class="enscript-comment">// -- and we check for these in Pass 2 below.
</span>    <span class="enscript-keyword">if</span> (mDNSSameOpaque16(arp-&gt;op, ARP_op_request) &amp;&amp; !mDNSSameIPv4Address(arp-&gt;spa, arp-&gt;tpa))
    {
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                rr-&gt;AddressProxy.type == mDNSAddrType_IPv4 &amp;&amp; mDNSSameIPv4Address(rr-&gt;AddressProxy.ip.v4, arp-&gt;tpa))
            {
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg1[] = <span class="enscript-string">&quot;ARP Req from owner -- re-probing&quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg2[] = <span class="enscript-string">&quot;Ignoring  ARP Request from      &quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg3[] = <span class="enscript-string">&quot;Creating Local ARP Cache entry  &quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg4[] = <span class="enscript-string">&quot;Answering ARP Request from      &quot;</span>;
                <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> msg = mDNSSameEthAddress(&amp;arp-&gt;sha, &amp;rr-&gt;WakeUp.IMAC) ? msg1 :
                                        (rr-&gt;AnnounceCount == InitialAnnounceCount)     ? msg2 :
                                        mDNSSameEthAddress(&amp;arp-&gt;sha, &amp;intf-&gt;MAC)       ? msg3 : msg4;
                LogMsg(<span class="enscript-string">&quot;Arp %-7s %s %.6a %.4a for %.4a -- H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                       intf-&gt;ifname, msg, arp-&gt;sha.b, arp-&gt;spa.b, arp-&gt;tpa.b,
                       &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (msg == msg1)
                {
                    <span class="enscript-keyword">if</span> ( rr-&gt;ProbeRestartCount &lt; MAX_PROBE_RESTARTS)
                        RestartARPProbing(m, rr);
                    <span class="enscript-keyword">else</span>
                        LogSPS(<span class="enscript-string">&quot;Reached maximum number of restarts for probing - %s&quot;</span>, ARDisplayString(m,rr));
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (msg == msg3)
                {
                    mDNSPlatformSetLocalAddressCacheEntry(&amp;rr-&gt;AddressProxy, &amp;rr-&gt;WakeUp.IMAC, InterfaceID);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (msg == msg4)
                {
                    SendARP(m, 2, rr, (mDNSv4Addr *)arp-&gt;tpa.b, &amp;arp-&gt;sha, (mDNSv4Addr *)arp-&gt;spa.b, &amp;arp-&gt;sha);
                }
            }
    }

    <span class="enscript-comment">// Pass 2:
</span>    <span class="enscript-comment">// For all types of ARP packet we check the Sender IP address to make sure it doesn't conflict with any AddressProxy record we're holding.
</span>    <span class="enscript-comment">// (Strictly speaking we're only checking Announcement/Request/Reply packets, since ARP Probes have zero Sender IP address,
</span>    <span class="enscript-comment">// so by definition (and by design) they can never conflict with any real (i.e. non-zero) IP address).
</span>    <span class="enscript-comment">// We ignore ARPs we sent ourselves (Sender MAC address is our MAC address) because our own proxy ARPs do not constitute a conflict that we need to handle.
</span>    <span class="enscript-comment">// If we see an apparently conflicting ARP, we check the sender hardware address:
</span>    <span class="enscript-comment">//   If the sender hardware address is the original owner this is benign, so we just suppress our own proxy answering for a while longer.
</span>    <span class="enscript-comment">//   If the sender hardware address is *not* the original owner, then this is a conflict, and we need to wake the sleeping machine to handle it.
</span>    <span class="enscript-keyword">if</span> (mDNSSameEthAddress(&amp;arp-&gt;sha, &amp;intf-&gt;MAC))
        debugf(<span class="enscript-string">&quot;ARP from self for %.4a&quot;</span>, arp-&gt;tpa.b);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(arp-&gt;spa, zerov4Addr))
            <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                    rr-&gt;AddressProxy.type == mDNSAddrType_IPv4 &amp;&amp; mDNSSameIPv4Address(rr-&gt;AddressProxy.ip.v4, arp-&gt;spa) &amp;&amp; (rr-&gt;ProbeRestartCount &lt; MAX_PROBE_RESTARTS))
                {
                    <span class="enscript-keyword">if</span> (mDNSSameEthAddress(&amp;zeroEthAddr, &amp;rr-&gt;WakeUp.HMAC))
                    {
                        LogMsg(<span class="enscript-string">&quot;%-7s ARP from %.6a %.4a for %.4a -- Invalid H-MAC %.6a I-MAC %.6a %s&quot;</span>, intf-&gt;ifname,
                                arp-&gt;sha.b, arp-&gt;spa.b, arp-&gt;tpa.b, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        RestartARPProbing(m, rr);
                        <span class="enscript-keyword">if</span> (mDNSSameEthAddress(&amp;arp-&gt;sha, &amp;rr-&gt;WakeUp.IMAC))
                        {
                            LogMsg(<span class="enscript-string">&quot;%-7s ARP %s from owner %.6a %.4a for %-15.4a -- re-starting probing for %s&quot;</span>, intf-&gt;ifname,
                                    mDNSSameIPv4Address(arp-&gt;spa, arp-&gt;tpa) ? <span class="enscript-string">&quot;Announcement &quot;</span> : mDNSSameOpaque16(arp-&gt;op, ARP_op_request) ? <span class="enscript-string">&quot;Request      &quot;</span> : <span class="enscript-string">&quot;Response     &quot;</span>,
                                    arp-&gt;sha.b, arp-&gt;spa.b, arp-&gt;tpa.b, ARDisplayString(m, rr));
                        }
                        <span class="enscript-keyword">else</span>
                        {
                            LogMsg(<span class="enscript-string">&quot;%-7s Conflicting ARP from %.6a %.4a for %.4a -- waking H-MAC %.6a I-MAC %.6a %s&quot;</span>, intf-&gt;ifname,
                                    arp-&gt;sha.b, arp-&gt;spa.b, arp-&gt;tpa.b, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                            ScheduleWakeup(m, rr-&gt;resrec.InterfaceID, &amp;rr-&gt;WakeUp.HMAC);
                        }
                    }
                }
    }

    mDNS_Unlock(m);
}

<span class="enscript-comment">/*
   // Option 1 is Source Link Layer Address Option
   // Option 2 is Target Link Layer Address Option
   mDNSlocal const mDNSEthAddr *GetLinkLayerAddressOption(const IPv6NDP *const ndp, const mDNSu8 *const end, mDNSu8 op)
    {
    const mDNSu8 *options = (mDNSu8 *)(ndp+1);
    while (options &lt; end)
        {
        debugf(&quot;NDP Option %02X len %2d %d&quot;, options[0], options[1], end - options);
        if (options[0] == op &amp;&amp; options[1] == 1) return (const mDNSEthAddr*)(options+2);
        options += options[1] * 8;
        }
    return mDNSNULL;
    }
 */</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveRawND</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> sha, <span class="enscript-type">const</span> mDNSv6Addr *spa,
                                    <span class="enscript-type">const</span> IPv6NDP *<span class="enscript-type">const</span> ndp, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    AuthRecord *rr;
    NetworkInterfaceInfo *intf = FirstInterfaceForID(m, InterfaceID);
    <span class="enscript-keyword">if</span> (!intf) <span class="enscript-keyword">return</span>;

    mDNS_Lock(m);

    <span class="enscript-comment">// Pass 1: Process Neighbor Solicitations, and generate a Neighbor Advertisement if necessary.
</span>    <span class="enscript-keyword">if</span> (ndp-&gt;type == NDP_Sol)
    {
        <span class="enscript-comment">//const mDNSEthAddr *const sha = GetLinkLayerAddressOption(ndp, end, NDP_SrcLL);
</span>        (<span class="enscript-type">void</span>)end;
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                rr-&gt;AddressProxy.type == mDNSAddrType_IPv6 &amp;&amp; mDNSSameIPv6Address(rr-&gt;AddressProxy.ip.v6, ndp-&gt;target))
            {
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg1[] = <span class="enscript-string">&quot;NDP Req from owner -- re-probing&quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg2[] = <span class="enscript-string">&quot;Ignoring  NDP Request from      &quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg3[] = <span class="enscript-string">&quot;Creating Local NDP Cache entry  &quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg4[] = <span class="enscript-string">&quot;Answering NDP Request from      &quot;</span>;
                <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> msg5[] = <span class="enscript-string">&quot;Answering NDP Probe   from      &quot;</span>;
                <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> msg = mDNSSameEthAddress(sha, &amp;rr-&gt;WakeUp.IMAC)   ? msg1 :
                                        (rr-&gt;AnnounceCount == InitialAnnounceCount) ? msg2 :
                                        mDNSSameEthAddress(sha, &amp;intf-&gt;MAC)         ? msg3 :
                                        mDNSIPv6AddressIsZero(*spa)                 ? msg4 : msg5;
                LogSPS(<span class="enscript-string">&quot;%-7s %s %.6a %.16a for %.16a -- H-MAC %.6a I-MAC %.6a %s&quot;</span>,
                       intf-&gt;ifname, msg, sha, spa, &amp;ndp-&gt;target, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                <span class="enscript-keyword">if</span> (msg == msg1)
                {
                    <span class="enscript-keyword">if</span> (rr-&gt;ProbeRestartCount &lt; MAX_PROBE_RESTARTS)
                        RestartARPProbing(m, rr);
                    <span class="enscript-keyword">else</span>
                        LogSPS(<span class="enscript-string">&quot;Reached maximum number of restarts for probing - %s&quot;</span>, ARDisplayString(m,rr));
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (msg == msg3)
                    mDNSPlatformSetLocalAddressCacheEntry(&amp;rr-&gt;AddressProxy, &amp;rr-&gt;WakeUp.IMAC, InterfaceID);
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (msg == msg4)
                    SendNDP(m, NDP_Adv, NDP_Solicited, rr, &amp;ndp-&gt;target, mDNSNULL, spa, sha);
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (msg == msg5)
                    SendNDP(m, NDP_Adv, 0, rr, &amp;ndp-&gt;target, mDNSNULL, &amp;AllHosts_v6, &amp;AllHosts_v6_Eth);
            }
    }

    <span class="enscript-comment">// Pass 2: For all types of NDP packet we check the Sender IP address to make sure it doesn't conflict with any AddressProxy record we're holding.
</span>    <span class="enscript-keyword">if</span> (mDNSSameEthAddress(sha, &amp;intf-&gt;MAC))
        debugf(<span class="enscript-string">&quot;NDP from self for %.16a&quot;</span>, &amp;ndp-&gt;target);
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// For Neighbor Advertisements we check the Target address field, not the actual IPv6 source address.
</span>        <span class="enscript-comment">// When a machine has both link-local and routable IPv6 addresses, it may send NDP packets making assertions
</span>        <span class="enscript-comment">// about its routable IPv6 address, using its link-local address as the source address for all NDP packets.
</span>        <span class="enscript-comment">// Hence it is the NDP target address we care about, not the actual packet source address.
</span>        <span class="enscript-keyword">if</span> (ndp-&gt;type == NDP_Adv) spa = &amp;ndp-&gt;target;
        <span class="enscript-keyword">if</span> (!mDNSSameIPv6Address(*spa, zerov6Addr))
            <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
                <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                    rr-&gt;AddressProxy.type == mDNSAddrType_IPv6 &amp;&amp; mDNSSameIPv6Address(rr-&gt;AddressProxy.ip.v6, *spa) &amp;&amp; (rr-&gt;ProbeRestartCount &lt; MAX_PROBE_RESTARTS))
                {
                    <span class="enscript-keyword">if</span> (mDNSSameEthAddress(&amp;zeroEthAddr, &amp;rr-&gt;WakeUp.HMAC))
                    {
                        LogSPS(<span class="enscript-string">&quot;%-7s NDP from %.6a %.16a for %.16a -- Invalid H-MAC %.6a I-MAC %.6a %s&quot;</span>, intf-&gt;ifname,
                                    sha, spa, &amp;ndp-&gt;target, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        RestartARPProbing(m, rr);
                        <span class="enscript-keyword">if</span> (mDNSSameEthAddress(sha, &amp;rr-&gt;WakeUp.IMAC))
                        {
                            LogSPS(<span class="enscript-string">&quot;%-7s NDP %s from owner %.6a %.16a for %.16a -- re-starting probing for %s&quot;</span>, intf-&gt;ifname,
                                    ndp-&gt;type == NDP_Sol ? <span class="enscript-string">&quot;Solicitation &quot;</span> : <span class="enscript-string">&quot;Advertisement&quot;</span>, sha, spa, &amp;ndp-&gt;target, ARDisplayString(m, rr));
                        }
                        <span class="enscript-keyword">else</span>
                        {
                            LogMsg(<span class="enscript-string">&quot;%-7s Conflicting NDP from %.6a %.16a for %.16a -- waking H-MAC %.6a I-MAC %.6a %s&quot;</span>, intf-&gt;ifname,
                                    sha, spa, &amp;ndp-&gt;target, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, rr));
                            ScheduleWakeup(m, rr-&gt;resrec.InterfaceID, &amp;rr-&gt;WakeUp.HMAC);
                        }
                    }
                }
    }

    mDNS_Unlock(m);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveRawTransportPacket</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> sha, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> src, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dst, <span class="enscript-type">const</span> mDNSu8 protocol,
                                                 <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> p, <span class="enscript-type">const</span> TransportLayerPacket *<span class="enscript-type">const</span> t, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> mDNSu16 len)
{
    <span class="enscript-type">const</span> mDNSIPPort port = (protocol == 0x06) ? t-&gt;tcp.dst : (protocol == 0x11) ? t-&gt;udp.dst : zeroIPPort;
    mDNSBool wake = mDNSfalse;
    mDNSBool kaWake = mDNSfalse;

    <span class="enscript-keyword">switch</span> (protocol)
    {
        #define XX wake ? <span class="enscript-string">&quot;Received&quot;</span> : <span class="enscript-string">&quot;Ignoring&quot;</span>, end-p
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0x01</span>:  LogSPS(<span class="enscript-string">&quot;Ignoring %d-byte ICMP from %#a to %#a&quot;</span>, end-p, src, dst);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">0x06</span>:  {
        AuthRecord *kr;
        mDNSu32 seq, ack;
                    #define TH_FIN  0x01
                    #define TH_SYN  0x02
                    #define TH_RST  0x04
                    #define TH_ACK  0x10

        kr = mDNS_MatchKeepaliveInfo(m, dst, src, port, t-&gt;tcp.src, &amp;seq, &amp;ack);
        <span class="enscript-keyword">if</span> (kr)
        {
            LogSPS(<span class="enscript-string">&quot;mDNSCoreReceiveRawTransportPacket: Found a Keepalive record from %#a:%d  to %#a:%d&quot;</span>, src, mDNSVal16(t-&gt;tcp.src), dst, mDNSVal16(port));
            <span class="enscript-comment">// Plan to wake if
</span>            <span class="enscript-comment">// (a) RST or FIN is set (the keepalive that we sent could have caused a reset)
</span>            <span class="enscript-comment">// (b) packet that contains new data and acks a sequence number higher than the one
</span>            <span class="enscript-comment">//     we have been sending in the keepalive
</span>
            wake = ((t-&gt;tcp.flags &amp; TH_RST) || (t-&gt;tcp.flags &amp; TH_FIN)) ;
            <span class="enscript-keyword">if</span> (!wake)
            {
                mDNSu8 *ptr;
                mDNSu32 pseq, pack;
                mDNSBool data = mDNSfalse;
                mDNSu8 tcphlen;

                <span class="enscript-comment">// Convert to host order
</span>                ptr = (mDNSu8 *)&amp;seq;
                seq = ptr[0] &lt;&lt; 24 | ptr[1] &lt;&lt; 16 | ptr[2] &lt;&lt; 8 | ptr[3];

                ptr = (mDNSu8 *)&amp;ack;
                ack = ptr[0] &lt;&lt; 24 | ptr[1] &lt;&lt; 16 | ptr[2] &lt;&lt; 8 | ptr[3];

                pseq = t-&gt;tcp.seq;
                ptr = (mDNSu8 *)&amp;pseq;
                pseq = ptr[0] &lt;&lt; 24 | ptr[1] &lt;&lt; 16 | ptr[2] &lt;&lt; 8 | ptr[3];

                pack = t-&gt;tcp.ack;
                ptr = (mDNSu8 *)&amp;pack;
                pack = ptr[0] &lt;&lt; 24 | ptr[1] &lt;&lt; 16 | ptr[2] &lt;&lt; 8 | ptr[3];

                <span class="enscript-comment">// If the other side is acking one more than our sequence number (keepalive is one
</span>                <span class="enscript-comment">// less than the last valid sequence sent) and it's sequence is more than what we
</span>                <span class="enscript-comment">// acked before
</span>                <span class="enscript-comment">//if (end - p - 34  - ((t-&gt;tcp.offset &gt;&gt; 4) * 4) &gt; 0) data = mDNStrue;
</span>                tcphlen = ((t-&gt;tcp.offset &gt;&gt; 4) * 4);
                <span class="enscript-keyword">if</span> (end - ((mDNSu8 *)t + tcphlen) &gt; 0) data = mDNStrue;
                wake = ((<span class="enscript-type">int</span>)(pack - seq) &gt; 0) &amp;&amp; ((<span class="enscript-type">int</span>)(pseq - ack) &gt;= 0) &amp;&amp; data;

                <span class="enscript-comment">// If we got a regular keepalive on a connection that was registed with the KeepAlive API, respond with an ACK
</span>                <span class="enscript-keyword">if</span> ((t-&gt;tcp.flags &amp; TH_ACK) &amp;&amp; (data == mDNSfalse) &amp;&amp;
                    ((<span class="enscript-type">int</span>)(ack - pseq) == 1))
                {
                    <span class="enscript-comment">// Send an ACK;
</span>                    mDNS_SendKeepaliveACK(m, kr);
                }
                LogSPS(<span class="enscript-string">&quot;mDNSCoreReceiveRawTransportPacket: End %p, hlen %d, Datalen %d, pack %u, seq %u, pseq %u, ack %u, wake %d&quot;</span>,
                       end, tcphlen, end - ((mDNSu8 *)t + tcphlen), pack, seq, pseq, ack, wake);
            }
            <span class="enscript-keyword">else</span> { LogSPS(<span class="enscript-string">&quot;mDNSCoreReceiveRawTransportPacket: waking because of RST or FIN th_flags %d&quot;</span>, t-&gt;tcp.flags); }
            kaWake = wake;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Plan to wake if
</span>            <span class="enscript-comment">// (a) RST is not set, AND
</span>            <span class="enscript-comment">// (b) packet is SYN, SYN+FIN, or plain data packet (no SYN or FIN). We won't wake for FIN alone.
</span>            wake = (!(t-&gt;tcp.flags &amp; TH_RST) &amp;&amp; (t-&gt;tcp.flags &amp; (TH_FIN|TH_SYN)) != TH_FIN);

            <span class="enscript-comment">// For now, to reduce spurious wakeups, we wake only for TCP SYN,
</span>            <span class="enscript-comment">// except for ssh connections, where we'll wake for plain data packets too
</span>            <span class="enscript-keyword">if</span>  (!mDNSSameIPPort(port, SSHPort) &amp;&amp; !(t-&gt;tcp.flags &amp; 2)) wake = mDNSfalse;

            LogSPS(<span class="enscript-string">&quot;%s %d-byte TCP from %#a:%d to %#a:%d%s%s%s&quot;</span>, XX,
                   src, mDNSVal16(t-&gt;tcp.src), dst, mDNSVal16(port),
                   (t-&gt;tcp.flags &amp; 2) ? <span class="enscript-string">&quot; SYN&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                   (t-&gt;tcp.flags &amp; 1) ? <span class="enscript-string">&quot; FIN&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                   (t-&gt;tcp.flags &amp; 4) ? <span class="enscript-string">&quot; RST&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
        }
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">case</span> <span class="enscript-reference">0x11</span>:  {
                    #define ARD_AsNumber 3283
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSIPPort ARD = { { ARD_AsNumber &gt;&gt; 8, ARD_AsNumber &amp; 0xFF } };
        <span class="enscript-type">const</span> mDNSu16 udplen = (mDNSu16)((mDNSu16)t-&gt;bytes[4] &lt;&lt; 8 | t-&gt;bytes[5]);                  <span class="enscript-comment">// Length *including* 8-byte UDP header
</span>        <span class="enscript-keyword">if</span> (udplen &gt;= <span class="enscript-keyword">sizeof</span>(UDPHeader))
        {
            <span class="enscript-type">const</span> mDNSu16 datalen = udplen - <span class="enscript-keyword">sizeof</span>(UDPHeader);
            wake = mDNStrue;

            <span class="enscript-comment">// For Back to My Mac UDP port 4500 (IPSEC) packets, we do some special handling
</span>            <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, IPSECPort))
            {
                <span class="enscript-comment">// Specifically ignore NAT keepalive packets
</span>                <span class="enscript-keyword">if</span> (datalen == 1 &amp;&amp; end &gt;= &amp;t-&gt;bytes[9] &amp;&amp; t-&gt;bytes[8] == 0xFF) wake = mDNSfalse;
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Skip over the Non-ESP Marker if present
</span>                    <span class="enscript-type">const</span> mDNSBool NonESP = (end &gt;= &amp;t-&gt;bytes[12] &amp;&amp; t-&gt;bytes[8] == 0 &amp;&amp; t-&gt;bytes[9] == 0 &amp;&amp; t-&gt;bytes[10] == 0 &amp;&amp; t-&gt;bytes[11] == 0);
                    <span class="enscript-type">const</span> IKEHeader *<span class="enscript-type">const</span> ike    = (IKEHeader *)(t + (NonESP ? 12 : 8));
                    <span class="enscript-type">const</span> mDNSu16 ikelen = datalen - (NonESP ? 4 : 0);
                    <span class="enscript-keyword">if</span> (ikelen &gt;= <span class="enscript-keyword">sizeof</span>(IKEHeader) &amp;&amp; end &gt;= ((mDNSu8 *)ike) + <span class="enscript-keyword">sizeof</span>(IKEHeader))
                        <span class="enscript-keyword">if</span> ((ike-&gt;Version &amp; 0x10) == 0x10)
                        {
                            <span class="enscript-comment">// ExchangeType ==  5 means 'Informational' &lt;<a href="http://www.ietf.org/rfc/rfc2408.txt">http://www.ietf.org/rfc/rfc2408.txt</a>&gt;
</span>                            <span class="enscript-comment">// ExchangeType == 34 means 'IKE_SA_INIT'   &lt;<a href="http://www.iana.org/assignments/ikev2-parameters">http://www.iana.org/assignments/ikev2-parameters</a>&gt;
</span>                            <span class="enscript-keyword">if</span> (ike-&gt;ExchangeType == 5 || ike-&gt;ExchangeType == 34) wake = mDNSfalse;
                            LogSPS(<span class="enscript-string">&quot;%s %d-byte IKE ExchangeType %d&quot;</span>, XX, ike-&gt;ExchangeType);
                        }
                }
            }

            <span class="enscript-comment">// For now, because we haven't yet worked out a clean elegant way to do this, we just special-case the
</span>            <span class="enscript-comment">// Apple Remote Desktop port number -- we ignore all packets to UDP 3283 (the &quot;Net Assistant&quot; port),
</span>            <span class="enscript-comment">// except for Apple Remote Desktop's explicit manual wakeup packet, which looks like this:
</span>            <span class="enscript-comment">// UDP header (8 bytes)
</span>            <span class="enscript-comment">// Payload: 13 88 00 6a 41 4e 41 20 (8 bytes) ffffffffffff (6 bytes) 16xMAC (96 bytes) = 110 bytes total
</span>            <span class="enscript-keyword">if</span> (mDNSSameIPPort(port, ARD)) wake = (datalen &gt;= 110 &amp;&amp; end &gt;= &amp;t-&gt;bytes[10] &amp;&amp; t-&gt;bytes[8] == 0x13 &amp;&amp; t-&gt;bytes[9] == 0x88);

            LogSPS(<span class="enscript-string">&quot;%s %d-byte UDP from %#a:%d to %#a:%d&quot;</span>, XX, src, mDNSVal16(t-&gt;udp.src), dst, mDNSVal16(port));
        }
    }
    <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">0x3A</span>:  <span class="enscript-keyword">if</span> (&amp;t-&gt;bytes[len] &lt;= end)
        {
            mDNSu16 checksum = IPv6CheckSum(&amp;src-&gt;ip.v6, &amp;dst-&gt;ip.v6, protocol, t-&gt;bytes, len);
            <span class="enscript-keyword">if</span> (!checksum) mDNSCoreReceiveRawND(m, sha, &amp;src-&gt;ip.v6, &amp;t-&gt;ndp, &amp;t-&gt;bytes[len], InterfaceID);
            <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;IPv6CheckSum bad %04X %02X%02X from %#a to %#a&quot;</span>, checksum, t-&gt;bytes[2], t-&gt;bytes[3], src, dst);
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:    LogSPS(<span class="enscript-string">&quot;Ignoring %d-byte IP packet unknown protocol %d from %#a to %#a&quot;</span>, end-p, protocol, src, dst);
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (wake)
    {
        AuthRecord *rr, *r2;

        mDNS_Lock(m);
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == InterfaceID &amp;&amp;
                rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                rr-&gt;AddressProxy.type &amp;&amp; mDNSSameAddress(&amp;rr-&gt;AddressProxy, dst))
            {
                <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> tp = (protocol == 6) ? (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\x4_tcp&quot;</span> : (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\x4_udp&quot;</span>;
                <span class="enscript-keyword">for</span> (r2 = m-&gt;ResourceRecords; r2; r2=r2-&gt;next)
                    <span class="enscript-keyword">if</span> (r2-&gt;resrec.InterfaceID == InterfaceID &amp;&amp; mDNSSameEthAddress(&amp;r2-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.HMAC) &amp;&amp;
                        r2-&gt;resrec.RecordType != kDNSRecordTypeDeregistering &amp;&amp;
                        r2-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; mDNSSameIPPort(r2-&gt;resrec.rdata-&gt;u.srv.port, port) &amp;&amp;
                        SameDomainLabel(ThirdLabel(r2-&gt;resrec.name)-&gt;c, tp))
                        <span class="enscript-keyword">break</span>;
                <span class="enscript-keyword">if</span> (!r2 &amp;&amp; mDNSSameIPPort(port, IPSECPort)) r2 = rr;    <span class="enscript-comment">// So that we wake for BTMM IPSEC packets, even without a matching SRV record
</span>                <span class="enscript-keyword">if</span> (!r2 &amp;&amp; kaWake) r2 = rr;                             <span class="enscript-comment">// So that we wake for keepalive packets, even without a matching SRV record
</span>                <span class="enscript-keyword">if</span> (r2)
                {
                    LogMsg(<span class="enscript-string">&quot;Waking host at %s %#a H-MAC %.6a I-MAC %.6a for %s&quot;</span>,
                           InterfaceNameForID(m, rr-&gt;resrec.InterfaceID), dst, &amp;rr-&gt;WakeUp.HMAC, &amp;rr-&gt;WakeUp.IMAC, ARDisplayString(m, r2));
                    ScheduleWakeup(m, rr-&gt;resrec.InterfaceID, &amp;rr-&gt;WakeUp.HMAC);
                }
                <span class="enscript-keyword">else</span>
                    LogSPS(<span class="enscript-string">&quot;Sleeping host at %s %#a %.6a has no service on %#s %d&quot;</span>,
                           InterfaceNameForID(m, rr-&gt;resrec.InterfaceID), dst, &amp;rr-&gt;WakeUp.HMAC, tp, mDNSVal16(port));
            }
        mDNS_Unlock(m);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreReceiveRawPacket</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> p, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 Ethertype_ARP  = { { 0x08, 0x06 } };  <span class="enscript-comment">// Ethertype 0x0806 = ARP
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 Ethertype_IPv4 = { { 0x08, 0x00 } };  <span class="enscript-comment">// Ethertype 0x0800 = IPv4
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 Ethertype_IPv6 = { { 0x86, 0xDD } };  <span class="enscript-comment">// Ethertype 0x86DD = IPv6
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 ARP_hrd_eth    = { { 0x00, 0x01 } };  <span class="enscript-comment">// Hardware address space (Ethernet = 1)
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSOpaque16 ARP_pro_ip     = { { 0x08, 0x00 } };  <span class="enscript-comment">// Protocol address space (IP = 0x0800)
</span>
    <span class="enscript-comment">// Note: BPF guarantees that the NETWORK LAYER header will be word aligned, not the link-layer header.
</span>    <span class="enscript-comment">// In other words, we can safely assume that pkt below (ARP, IPv4 or IPv6) is properly word aligned,
</span>    <span class="enscript-comment">// but if pkt is 4-byte aligned, that necessarily means that eth CANNOT also be 4-byte aligned
</span>    <span class="enscript-comment">// since it points to a an address 14 bytes before pkt.
</span>    <span class="enscript-type">const</span> EthernetHeader     *<span class="enscript-type">const</span> eth = (<span class="enscript-type">const</span> EthernetHeader *)p;
    <span class="enscript-type">const</span> NetworkLayerPacket *<span class="enscript-type">const</span> pkt = (<span class="enscript-type">const</span> NetworkLayerPacket *)(eth+1);
    mDNSAddr src, dst;
    #define RequiredCapLen(P) ((P)==0x01 ? 4 : (P)==0x06 ? 20 : (P)==0x11 ? 8 : (P)==0x3A ? 24 : 0)

    <span class="enscript-comment">// Is ARP? Length must be at least 14 + 28 = 42 bytes
</span>    <span class="enscript-keyword">if</span> (end &gt;= p+42 &amp;&amp; mDNSSameOpaque16(eth-&gt;ethertype, Ethertype_ARP) &amp;&amp; mDNSSameOpaque16(pkt-&gt;arp.hrd, ARP_hrd_eth) &amp;&amp; mDNSSameOpaque16(pkt-&gt;arp.pro, ARP_pro_ip))
        mDNSCoreReceiveRawARP(m, &amp;pkt-&gt;arp, InterfaceID);
    <span class="enscript-comment">// Is IPv4 with zero fragmentation offset? Length must be at least 14 + 20 = 34 bytes
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (end &gt;= p+34 &amp;&amp; mDNSSameOpaque16(eth-&gt;ethertype, Ethertype_IPv4) &amp;&amp; (pkt-&gt;v4.flagsfrags.b[0] &amp; 0x1F) == 0 &amp;&amp; pkt-&gt;v4.flagsfrags.b[1] == 0)
    {
        <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> trans = p + 14 + (pkt-&gt;v4.vlen &amp; 0xF) * 4;
        <span class="enscript-type">const</span> mDNSu8 * transEnd = p + 14 + mDNSVal16(pkt-&gt;v4.totlen);
        <span class="enscript-keyword">if</span> (transEnd &gt; end) transEnd = end;
        debugf(<span class="enscript-string">&quot;Got IPv4 %02X from %.4a to %.4a&quot;</span>, pkt-&gt;v4.protocol, &amp;pkt-&gt;v4.src.b, &amp;pkt-&gt;v4.dst.b);
        src.type = mDNSAddrType_IPv4; src.ip.v4 = pkt-&gt;v4.src;
        dst.type = mDNSAddrType_IPv4; dst.ip.v4 = pkt-&gt;v4.dst;
        <span class="enscript-keyword">if</span> (transEnd &gt;= trans + RequiredCapLen(pkt-&gt;v4.protocol))
            mDNSCoreReceiveRawTransportPacket(m, &amp;eth-&gt;src, &amp;src, &amp;dst, pkt-&gt;v4.protocol, p, (TransportLayerPacket*)trans, transEnd, InterfaceID, 0);
    }
    <span class="enscript-comment">// Is IPv6? Length must be at least 14 + 28 = 42 bytes
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (end &gt;= p+54 &amp;&amp; mDNSSameOpaque16(eth-&gt;ethertype, Ethertype_IPv6))
    {
        <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> trans = p + 54;
        debugf(<span class="enscript-string">&quot;Got IPv6  %02X from %.16a to %.16a&quot;</span>, pkt-&gt;v6.pro, &amp;pkt-&gt;v6.src.b, &amp;pkt-&gt;v6.dst.b);
        src.type = mDNSAddrType_IPv6; src.ip.v6 = pkt-&gt;v6.src;
        dst.type = mDNSAddrType_IPv6; dst.ip.v6 = pkt-&gt;v6.dst;
        <span class="enscript-keyword">if</span> (end &gt;= trans + RequiredCapLen(pkt-&gt;v6.pro))
            mDNSCoreReceiveRawTransportPacket(m, &amp;eth-&gt;src, &amp;src, &amp;dst, pkt-&gt;v6.pro, p, (TransportLayerPacket*)trans, end, InterfaceID,
                                              (mDNSu16)pkt-&gt;bytes[4] &lt;&lt; 8 | pkt-&gt;bytes[5]);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConstructSleepProxyServerName</span>(mDNS *<span class="enscript-type">const</span> m, domainlabel *name)
{
    name-&gt;c[0] = (mDNSu8)mDNS_snprintf((<span class="enscript-type">char</span>*)name-&gt;c+1, 62, <span class="enscript-string">&quot;%d-%d-%d-%d.%d %#s&quot;</span>,
                                       m-&gt;SPSType, m-&gt;SPSPortability, m-&gt;SPSMarginalPower, m-&gt;SPSTotalPower, m-&gt;SPSFeatureFlags, &amp;m-&gt;nicelabel);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SleepProxyServerCallback</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> srs, mStatus result)
{
    <span class="enscript-keyword">if</span> (result == mStatus_NameConflict)
        mDNS_RenameAndReregisterService(m, srs, mDNSNULL);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        <span class="enscript-keyword">if</span> (m-&gt;SleepState)
            m-&gt;SPSState = 3;
        <span class="enscript-keyword">else</span>
        {
            m-&gt;SPSState = (mDNSu8)(m-&gt;SPSSocket != mDNSNULL);
            <span class="enscript-keyword">if</span> (m-&gt;SPSState)
            {
                domainlabel name;
                ConstructSleepProxyServerName(m, &amp;name);
                mDNS_RegisterService(m, srs,
                                     &amp;name, &amp;SleepProxyServiceType, &amp;localdomain,
                                     mDNSNULL, m-&gt;SPSSocket-&gt;port, <span class="enscript-comment">// Host, port
</span>                                     mDNSNULL,
                                     (mDNSu8 *)<span class="enscript-string">&quot;&quot;</span>, 1,           <span class="enscript-comment">// TXT data, length
</span>                                     mDNSNULL, 0,               <span class="enscript-comment">// Subtypes (none)
</span>                                     mDNSInterface_Any,         <span class="enscript-comment">// Interface ID
</span>                                     SleepProxyServerCallback, mDNSNULL, 0); <span class="enscript-comment">// Callback, context, flags
</span>            }
            LogSPS(<span class="enscript-string">&quot;Sleep Proxy Server %#s %s&quot;</span>, srs-&gt;RR_SRV.resrec.name-&gt;c, m-&gt;SPSState ? <span class="enscript-string">&quot;started&quot;</span> : <span class="enscript-string">&quot;stopped&quot;</span>);
        }
    }
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Called with lock held
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreBeSleepProxyServer_internal</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu8 sps, mDNSu8 port, mDNSu8 marginalpower, mDNSu8 totpower, mDNSu8 features)
{
    <span class="enscript-comment">// This routine uses mDNS_DeregisterService and calls SleepProxyServerCallback, so we execute in user callback context
</span>    mDNS_DropLockBeforeCallback();

    <span class="enscript-comment">// If turning off SPS, close our socket
</span>    <span class="enscript-comment">// (Do this first, BEFORE calling mDNS_DeregisterService below)
</span>    <span class="enscript-keyword">if</span> (!sps &amp;&amp; m-&gt;SPSSocket) { mDNSPlatformUDPClose(m-&gt;SPSSocket); m-&gt;SPSSocket = mDNSNULL; }

    <span class="enscript-comment">// If turning off, or changing type, deregister old name
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
    <span class="enscript-keyword">if</span> (m-&gt;SPSState == 1 &amp;&amp; sps != m-&gt;SPSType)
    { m-&gt;SPSState = 2; mDNS_DeregisterService_drt(m, &amp;m-&gt;SPSRecords, sps ? mDNS_Dereg_rapid : mDNS_Dereg_normal); }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SPC_DISABLED</span>

    <span class="enscript-comment">// Record our new SPS parameters
</span>    m-&gt;SPSType          = sps;
    m-&gt;SPSPortability   = port;
    m-&gt;SPSMarginalPower = marginalpower;
    m-&gt;SPSTotalPower    = totpower;
    m-&gt;SPSFeatureFlags  = features;
    <span class="enscript-comment">// If turning on, open socket and advertise service
</span>    <span class="enscript-keyword">if</span> (sps)
    {
        <span class="enscript-keyword">if</span> (!m-&gt;SPSSocket)
        {
            m-&gt;SPSSocket = mDNSPlatformUDPSocket(zeroIPPort);
            <span class="enscript-keyword">if</span> (!m-&gt;SPSSocket) { LogMsg(<span class="enscript-string">&quot;mDNSCoreBeSleepProxyServer: Failed to allocate SPSSocket&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
        }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
        <span class="enscript-keyword">if</span> (m-&gt;SPSState == 0) SleepProxyServerCallback(m, &amp;m-&gt;SPSRecords, mStatus_MemFree);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SPC_DISABLED</span>
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;SPSState)
    {
        LogSPS(<span class="enscript-string">&quot;mDNSCoreBeSleepProxyServer turning off from state %d; will wake clients&quot;</span>, m-&gt;SPSState);
        m-&gt;NextScheduledSPS = m-&gt;timenow;
    }
<span class="enscript-reference">fail</span>:
    mDNS_ReclaimLockAfterCallback();
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Startup</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">Shutdown</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_GrowCache_internal</span>(mDNS *<span class="enscript-type">const</span> m, CacheEntity *storage, mDNSu32 numrecords)
{
    <span class="enscript-keyword">if</span> (storage &amp;&amp; numrecords)
    {
        mDNSu32 i;
        debugf(<span class="enscript-string">&quot;Adding cache storage for %d more records (%d bytes)&quot;</span>, numrecords, numrecords*<span class="enscript-keyword">sizeof</span>(CacheEntity));
        <span class="enscript-keyword">for</span> (i=0; i&lt;numrecords; i++) storage[i].next = &amp;storage[i+1];
        storage[numrecords-1].next = m-&gt;rrcache_free;
        m-&gt;rrcache_free = storage;
        m-&gt;rrcache_size += numrecords;
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_GrowCache</span>(mDNS *<span class="enscript-type">const</span> m, CacheEntity *storage, mDNSu32 numrecords)
{
    mDNS_Lock(m);
    mDNS_GrowCache_internal(m, storage, numrecords);
    mDNS_Unlock(m);
}

mDNSlocal mStatus <span class="enscript-function-name">mDNS_InitStorage</span>(mDNS *<span class="enscript-type">const</span> m, mDNS_PlatformSupport *<span class="enscript-type">const</span> p,
                                   CacheEntity *rrcachestorage, mDNSu32 rrcachesize,
                                   mDNSBool AdvertiseLocalAddresses, mDNSCallback *Callback, <span class="enscript-type">void</span> *Context)
{
    mDNSu32 slot;
    mDNSs32 timenow;
    mStatus result;

    <span class="enscript-keyword">if</span> (!rrcachestorage) rrcachesize = 0;

    m-&gt;next_request_id               = 1;
    m-&gt;p                             = p;
    m-&gt;NetworkChanged                = 0;
    m-&gt;CanReceiveUnicastOn5353       = mDNSfalse; <span class="enscript-comment">// Assume we can't receive unicasts on 5353, unless platform layer tells us otherwise
</span>    m-&gt;AdvertiseLocalAddresses       = AdvertiseLocalAddresses;
    m-&gt;DivertMulticastAdvertisements = mDNSfalse;
    m-&gt;mDNSPlatformStatus            = mStatus_Waiting;
    m-&gt;UnicastPort4                  = zeroIPPort;
    m-&gt;UnicastPort6                  = zeroIPPort;
    m-&gt;PrimaryMAC                    = zeroEthAddr;
    m-&gt;MainCallback                  = Callback;
    m-&gt;MainContext                   = Context;
    m-&gt;rec.r.resrec.RecordType       = 0;

    <span class="enscript-comment">// For debugging: To catch and report locking failures
</span>    m-&gt;mDNS_busy               = 0;
    m-&gt;mDNS_reentrancy         = 0;
    m-&gt;ShutdownTime            = 0;
    m-&gt;lock_rrcache            = 0;
    m-&gt;lock_Questions          = 0;
    m-&gt;lock_Records            = 0;

    <span class="enscript-comment">// Task Scheduling variables
</span>    result = mDNSPlatformTimeInit();
    <span class="enscript-keyword">if</span> (result != mStatus_NoError) <span class="enscript-keyword">return</span>(result);
    m-&gt;timenow_adjust = (mDNSs32)mDNSRandom(0xFFFFFFFF);
    timenow = mDNS_TimeNow_NoLock(m);

    m-&gt;timenow                 = 0;     <span class="enscript-comment">// MUST only be set within mDNS_Lock/mDNS_Unlock section
</span>    m-&gt;timenow_last            = timenow;
    m-&gt;NextScheduledEvent      = timenow;
    m-&gt;SuppressSending         = timenow;
    m-&gt;NextCacheCheck          = timenow + FutureTime;
    m-&gt;NextScheduledQuery      = timenow + FutureTime;
    m-&gt;NextScheduledProbe      = timenow + FutureTime;
    m-&gt;NextScheduledResponse   = timenow + FutureTime;
    m-&gt;NextScheduledNATOp      = timenow + FutureTime;
    m-&gt;NextScheduledSPS        = timenow + FutureTime;
    m-&gt;NextScheduledKA         = timenow + FutureTime;
    m-&gt;NextScheduledStopTime   = timenow + FutureTime;
    m-&gt;NextBLEServiceTime      = 0;    <span class="enscript-comment">// zero indicates inactive
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    m-&gt;NextBonjourDisableTime  = 0; <span class="enscript-comment">// Timer active when non zero.
</span>    m-&gt;BonjourEnabled          = 0; <span class="enscript-comment">// Set when Bonjour on Demand is enabled and Bonjour is currently enabled.  
</span>#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    m-&gt;NextSuspiciousTimeout   = 0;
#<span class="enscript-reference">endif</span>

    m-&gt;RandomQueryDelay        = 0;
    m-&gt;RandomReconfirmDelay    = 0;
    m-&gt;PktNum                  = 0;
    m-&gt;MPktNum                 = 0;
    m-&gt;LocalRemoveEvents       = mDNSfalse;
    m-&gt;SleepState              = SleepState_Awake;
    m-&gt;SleepSeqNum             = 0;
    m-&gt;SystemWakeOnLANEnabled  = mDNSfalse;
    m-&gt;AnnounceOwner           = NonZeroTime(timenow + 60 * mDNSPlatformOneSecond);
    m-&gt;DelaySleep              = 0;
    m-&gt;SleepLimit              = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    m-&gt;UnicastPacketsSent      = 0;
    m-&gt;MulticastPacketsSent    = 0;
    m-&gt;RemoteSubnet            = 0;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    <span class="enscript-comment">// These fields only required for mDNS Searcher...
</span>    m-&gt;Questions               = mDNSNULL;
    m-&gt;NewQuestions            = mDNSNULL;
    m-&gt;CurrentQuestion         = mDNSNULL;
    m-&gt;LocalOnlyQuestions      = mDNSNULL;
    m-&gt;NewLocalOnlyQuestions   = mDNSNULL;
    m-&gt;RestartQuestion         = mDNSNULL;
    m-&gt;ValidationQuestion      = mDNSNULL;
    m-&gt;rrcache_size            = 0;
    m-&gt;rrcache_totalused       = 0;
    m-&gt;rrcache_active          = 0;
    m-&gt;rrcache_report          = 10;
    m-&gt;rrcache_free            = mDNSNULL;

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; CACHE_HASH_SLOTS; slot++)
    {
        m-&gt;rrcache_hash[slot]      = mDNSNULL;
        m-&gt;rrcache_nextcheck[slot] = timenow + FutureTime;;
    }

    mDNS_GrowCache_internal(m, rrcachestorage, rrcachesize);
    m-&gt;rrauth.rrauth_free            = mDNSNULL;

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; AUTH_HASH_SLOTS; slot++)
        m-&gt;rrauth.rrauth_hash[slot] = mDNSNULL;

    <span class="enscript-comment">// Fields below only required for mDNS Responder...
</span>    m-&gt;hostlabel.c[0]          = 0;
    m-&gt;nicelabel.c[0]          = 0;
    m-&gt;MulticastHostname.c[0]  = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    m-&gt;RandomizedHostname.c[0] = 0;
#<span class="enscript-reference">endif</span>
    m-&gt;HIHardware.c[0]         = 0;
    m-&gt;HISoftware.c[0]         = 0;
    m-&gt;ResourceRecords         = mDNSNULL;
    m-&gt;DuplicateRecords        = mDNSNULL;
    m-&gt;NewLocalRecords         = mDNSNULL;
    m-&gt;NewLocalOnlyRecords     = mDNSfalse;
    m-&gt;CurrentRecord           = mDNSNULL;
    m-&gt;HostInterfaces          = mDNSNULL;
    m-&gt;ProbeFailTime           = 0;
    m-&gt;NumFailedProbes         = 0;
    m-&gt;SuppressProbes          = 0;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    m-&gt;NextuDNSEvent            = timenow + FutureTime;
    m-&gt;NextSRVUpdate            = timenow + FutureTime;

    m-&gt;DNSServers               = mDNSNULL;

    m-&gt;Router                   = zeroAddr;
    m-&gt;AdvertisedV4             = zeroAddr;
    m-&gt;AdvertisedV6             = zeroAddr;

    m-&gt;AuthInfoList             = mDNSNULL;

    m-&gt;ReverseMap.ThisQInterval = -1;
    m-&gt;StaticHostname.c[0]      = 0;
    m-&gt;FQDN.c[0]                = 0;
    m-&gt;Hostnames                = mDNSNULL;

    m-&gt;WABBrowseQueriesCount    = 0;
    m-&gt;WABLBrowseQueriesCount   = 0;
    m-&gt;WABRegQueriesCount       = 0;
    m-&gt;AutoTargetServices       = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    m-&gt;NumAllInterfaceRecords   = 0;
    m-&gt;NumAllInterfaceQuestions = 0;
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// NAT traversal fields
</span>    m-&gt;LLQNAT.clientCallback    = mDNSNULL;
    m-&gt;LLQNAT.clientContext     = mDNSNULL;
    m-&gt;NATTraversals            = mDNSNULL;
    m-&gt;CurrentNATTraversal      = mDNSNULL;
    m-&gt;retryIntervalGetAddr     = 0;    <span class="enscript-comment">// delta between time sent and retry
</span>    m-&gt;retryGetAddr             = timenow + FutureTime; <span class="enscript-comment">// absolute time when we retry
</span>    m-&gt;ExtAddress               = zerov4Addr;
    m-&gt;PCPNonce[0]              = mDNSRandom(-1);
    m-&gt;PCPNonce[1]              = mDNSRandom(-1);
    m-&gt;PCPNonce[2]              = mDNSRandom(-1);

    m-&gt;NATMcastRecvskt          = mDNSNULL;
    m-&gt;LastNATupseconds         = 0;
    m-&gt;LastNATReplyLocalTime    = timenow;
    m-&gt;LastNATMapResultCode     = NATErr_None;

    m-&gt;UPnPInterfaceID          = 0;
    m-&gt;SSDPSocket               = mDNSNULL;
    m-&gt;SSDPWANPPPConnection     = mDNSfalse;
    m-&gt;UPnPRouterPort           = zeroIPPort;
    m-&gt;UPnPSOAPPort             = zeroIPPort;
    m-&gt;UPnPRouterURL            = mDNSNULL;
    m-&gt;UPnPWANPPPConnection     = mDNSfalse;
    m-&gt;UPnPSOAPURL              = mDNSNULL;
    m-&gt;UPnPRouterAddressString  = mDNSNULL;
    m-&gt;UPnPSOAPAddressString    = mDNSNULL;
    m-&gt;SPSType                  = 0;
    m-&gt;SPSPortability           = 0;
    m-&gt;SPSMarginalPower         = 0;
    m-&gt;SPSTotalPower            = 0;
    m-&gt;SPSFeatureFlags          = 0;
    m-&gt;SPSState                 = 0;
    m-&gt;SPSProxyListChanged      = mDNSNULL;
    m-&gt;SPSSocket                = mDNSNULL;
    m-&gt;SPSBrowseCallback        = mDNSNULL;
    m-&gt;ProxyRecords             = 0;

    m-&gt;DNSPushServers           = mDNSNULL;
    m-&gt;DNSPushZones             = mDNSNULL;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">WEB_CONTENT_FILTER</span>)
    <span class="enscript-keyword">if</span> (WCFConnectionNew)
    {
        m-&gt;WCF = WCFConnectionNew();
        <span class="enscript-keyword">if</span> (!m-&gt;WCF) { LogMsg(<span class="enscript-string">&quot;WCFConnectionNew failed&quot;</span>); <span class="enscript-keyword">return</span> -1; }
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span>(result);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_Init</span>(mDNS *<span class="enscript-type">const</span> m, mDNS_PlatformSupport *<span class="enscript-type">const</span> p,
                             CacheEntity *rrcachestorage, mDNSu32 rrcachesize,
                             mDNSBool AdvertiseLocalAddresses, mDNSCallback *Callback, <span class="enscript-type">void</span> *Context)
{
    mStatus result = mDNS_InitStorage(m, p, rrcachestorage, rrcachesize, AdvertiseLocalAddresses, Callback, Context);
    <span class="enscript-keyword">if</span> (result != mStatus_NoError)
        <span class="enscript-keyword">return</span>(result);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
    <span class="enscript-type">static</span> mDNSListValidator lv;
    mDNSPlatformAddListValidator(&amp;lv, mDNS_ValidateLists, <span class="enscript-string">&quot;mDNS_ValidateLists&quot;</span>, m);
#<span class="enscript-reference">endif</span>
    result = mDNSPlatformInit(m);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-comment">// It's better to do this *after* the platform layer has set up the
</span>    <span class="enscript-comment">// interface list and security credentials
</span>    uDNS_SetupDNSConfig(m);                     <span class="enscript-comment">// Get initial DNS configuration
</span>#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span>(result);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_ConfigChanged</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-keyword">if</span> (m-&gt;SPSState == 1)
    {
        domainlabel name, newname;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
        domainname type, domain;
        DeconstructServiceName(m-&gt;SPSRecords.RR_SRV.resrec.name, &amp;name, &amp;type, &amp;domain);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SPC_DISABLED</span>
        ConstructSleepProxyServerName(m, &amp;newname);
        <span class="enscript-keyword">if</span> (!SameDomainLabelCS(name.c, newname.c))
        {
            LogSPS(<span class="enscript-string">&quot;Renaming SPS from %#s to %#s&quot;</span>, name.c, newname.c);
            <span class="enscript-comment">// When SleepProxyServerCallback gets the mStatus_MemFree message,
</span>            <span class="enscript-comment">// it will reregister the service under the new name
</span>            m-&gt;SPSState = 2;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
            mDNS_DeregisterService_drt(m, &amp;m-&gt;SPSRecords, mDNS_Dereg_rapid);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">SPC_DISABLED</span>
        }
    }

    <span class="enscript-keyword">if</span> (m-&gt;MainCallback)
        m-&gt;MainCallback(m, mStatus_ConfigChanged);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DynDNSHostNameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m;    <span class="enscript-comment">// unused
</span>    debugf(<span class="enscript-string">&quot;NameStatusCallback: result %d for registration of name %##s&quot;</span>, result, rr-&gt;resrec.name-&gt;c);
    mDNSPlatformDynDNSHostNameStatusChanged(rr-&gt;resrec.name, result);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PurgeOrReconfirmCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *cr)
{
    mDNSBool purge = cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative ||
                     cr-&gt;resrec.rrtype     == kDNSType_A ||
                     cr-&gt;resrec.rrtype     == kDNSType_AAAA ||
                     cr-&gt;resrec.rrtype     == kDNSType_SRV ||
                     cr-&gt;resrec.rrtype     == kDNSType_CNAME;

    debugf(<span class="enscript-string">&quot;PurgeOrReconfirmCacheRecord: %s cache record due to server %#a:%d (%##s): %s&quot;</span>,
           purge    ? <span class="enscript-string">&quot;purging&quot;</span>   : <span class="enscript-string">&quot;reconfirming&quot;</span>,
           cr-&gt;resrec.rDNSServer ? &amp;cr-&gt;resrec.rDNSServer-&gt;addr : mDNSNULL,
           cr-&gt;resrec.rDNSServer ? mDNSVal16(cr-&gt;resrec.rDNSServer-&gt;port) : -1,
           cr-&gt;resrec.rDNSServer ? cr-&gt;resrec.rDNSServer-&gt;domain.c : mDNSNULL, CRDisplayString(m, cr));

    <span class="enscript-keyword">if</span> (purge)
    {
        LogInfo(<span class="enscript-string">&quot;PurgeorReconfirmCacheRecord: Purging Resourcerecord %s, RecordType %x&quot;</span>, CRDisplayString(m, cr), cr-&gt;resrec.RecordType);
        cr-&gt;resrec.mortality = Mortality_Mortal;
        mDNS_PurgeCacheResourceRecord(m, cr);
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;PurgeorReconfirmCacheRecord: Reconfirming Resourcerecord %s, RecordType %x&quot;</span>, CRDisplayString(m, cr), cr-&gt;resrec.RecordType);
        mDNS_Reconfirm_internal(m, cr, kDefaultReconfirmTimeForNoAnswer);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_PurgeBeforeResolve</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    CacheRecord *rp;
    mDNSu8 validatingResponse = 0;

    <span class="enscript-comment">// For DNSSEC questions, purge the corresponding RRSIGs also.
</span>    <span class="enscript-keyword">if</span> (DNSSECQuestion(q))
    {
        validatingResponse = q-&gt;ValidatingResponse;
        q-&gt;ValidatingResponse = mDNStrue;
    }
    <span class="enscript-keyword">for</span> (rp = cg ? cg-&gt;members : mDNSNULL; rp; rp = rp-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(rp, q))
        {
            LogInfo(<span class="enscript-string">&quot;mDNS_PurgeBeforeResolve: Flushing %s&quot;</span>, CRDisplayString(m, rp));
            mDNS_PurgeCacheResourceRecord(m, rp);
        }
    }
    <span class="enscript-keyword">if</span> (DNSSECQuestion(q))
    {
        q-&gt;ValidatingResponse = validatingResponse;
    }
}

<span class="enscript-comment">// For DNSSEC question, we need the DNSSEC records also. If the cache does not
</span><span class="enscript-comment">// have the DNSSEC records, we need to re-issue the question with EDNS0/DO bit set.
</span><span class="enscript-comment">// Just re-issuing the question for RRSIGs does not work in practice as the response
</span><span class="enscript-comment">// may not contain the RRSIGs whose typeCovered field matches the question's qtype.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For negative responses, we need the NSECs to prove the non-existence. If we don't
</span><span class="enscript-comment">// have the cached NSECs, purge them. For positive responses, if we don't have the
</span><span class="enscript-comment">// RRSIGs and if we have not already issued the question with EDNS0/DO bit set, purge
</span><span class="enscript-comment">// them.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckForDNSSECRecords</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    CacheRecord *rp;

    <span class="enscript-keyword">for</span> (rp = cg ? cg-&gt;members : mDNSNULL; rp; rp = rp-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(rp, q))
        {
            <span class="enscript-keyword">if</span> (rp-&gt;resrec.RecordType != kDNSRecordTypePacketNegative || !rp-&gt;nsec)
            {
                <span class="enscript-keyword">if</span> (!rp-&gt;CRDNSSECQuestion)
                {
                    LogInfo(<span class="enscript-string">&quot;CheckForDNSSECRecords: Flushing %s&quot;</span>, CRDisplayString(m, rp));
                    mDNS_PurgeCacheResourceRecord(m, rp);
                }
            }
        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DNSServerChangeForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, DNSServer *new)
{
    DNSQuestion *qptr;

    (<span class="enscript-type">void</span>) m;

    <span class="enscript-keyword">if</span> (q-&gt;DuplicateOf)
        LogMsg(<span class="enscript-string">&quot;DNSServerChangeForQuestion: ERROR: Called for duplicate question %##s&quot;</span>, q-&gt;qname.c);

    <span class="enscript-comment">// Make sure all the duplicate questions point to the same DNSServer so that delivery
</span>    <span class="enscript-comment">// of events for all of them are consistent. Duplicates for a question are always inserted
</span>    <span class="enscript-comment">// after in the list.
</span>    q-&gt;qDNSServer = new;
    <span class="enscript-keyword">for</span> (qptr = q-&gt;next ; qptr; qptr = qptr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (qptr-&gt;DuplicateOf == q) { qptr-&gt;validDNSServers = q-&gt;validDNSServers; qptr-&gt;qDNSServer = new; }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetConfigState</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool delete)
{
    McastResolver *mr;
    DNSServer *ptr;

    <span class="enscript-keyword">if</span> (delete)
    {
        <span class="enscript-keyword">for</span> (ptr = m-&gt;DNSServers; ptr; ptr = ptr-&gt;next)
        {
            ptr-&gt;penaltyTime = 0;
            ptr-&gt;flags |= DNSServerFlag_Delete;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
            <span class="enscript-keyword">if</span> (ptr-&gt;flags &amp; DNSServerFlag_Unreachable)
                NumUnreachableDNSServers--;
#<span class="enscript-reference">endif</span>
        }
        <span class="enscript-comment">// We handle the mcast resolvers here itself as mDNSPlatformSetDNSConfig looks at
</span>        <span class="enscript-comment">// mcast resolvers. Today we get both mcast and ucast configuration using the same
</span>        <span class="enscript-comment">// API
</span>        <span class="enscript-keyword">for</span> (mr = m-&gt;McastResolvers; mr; mr = mr-&gt;next)
            mr-&gt;flags |= McastResolver_FlagDelete;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">for</span> (ptr = m-&gt;DNSServers; ptr; ptr = ptr-&gt;next)
        {
            ptr-&gt;penaltyTime = 0;
            ptr-&gt;flags &amp;= ~DNSServerFlag_Delete;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
            <span class="enscript-keyword">if</span> (ptr-&gt;flags &amp; DNSServerFlag_Unreachable)
                NumUnreachableDNSServers++;
#<span class="enscript-reference">endif</span>
        }
        <span class="enscript-keyword">for</span> (mr = m-&gt;McastResolvers; mr; mr = mr-&gt;next)
            mr-&gt;flags &amp;= ~McastResolver_FlagDelete;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetDynDNSHostNameIfChanged</span>(mDNS *<span class="enscript-type">const</span> m, domainname *<span class="enscript-type">const</span> fqdn)
{
    <span class="enscript-comment">// Did our FQDN change?
</span>    <span class="enscript-keyword">if</span> (!SameDomainName(fqdn, &amp;m-&gt;FQDN))
    {
        <span class="enscript-keyword">if</span> (m-&gt;FQDN.c[0]) mDNS_RemoveDynDNSHostName(m, &amp;m-&gt;FQDN);

        AssignDomainName(&amp;m-&gt;FQDN, fqdn);

        <span class="enscript-keyword">if</span> (m-&gt;FQDN.c[0])
        {
            mDNSPlatformDynDNSHostNameStatusChanged(&amp;m-&gt;FQDN, 1);
            mDNS_AddDynDNSHostName(m, &amp;m-&gt;FQDN, DynDNSHostNameCallback, mDNSNULL);
        }
    }
}

<span class="enscript-comment">// Even though this is called Setup it is not called just once at startup.
</span><span class="enscript-comment">// Its actually called multiple times, every time theres a configuration change.
</span>mDNSexport mStatus <span class="enscript-function-name">uDNS_SetupDNSConfig</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSu32 slot;
    CacheGroup *cg;
    CacheRecord *cr;
    mDNSAddr v4, v6, r;
    domainname fqdn;
    DNSServer   *ptr, **p = &amp;m-&gt;DNSServers;
    <span class="enscript-type">const</span> DNSServer *oldServers = m-&gt;DNSServers;
    DNSQuestion *q;
    McastResolver *mr, **mres = &amp;m-&gt;McastResolvers;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
    DNSPushNotificationServer **psp;
#<span class="enscript-reference">endif</span>
    
    debugf(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: entry&quot;</span>);

    <span class="enscript-comment">// Let the platform layer get the current DNS information and setup the WAB queries if needed.
</span>    uDNS_SetupWABQueries(m);

    mDNS_Lock(m);

    <span class="enscript-comment">// We need to first mark all the entries to be deleted. If the configuration changed, then
</span>    <span class="enscript-comment">// the entries would be undeleted appropriately. Otherwise, we need to clear them.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: The last argument to mDNSPlatformSetDNSConfig is &quot;mDNStrue&quot; which means ack the
</span>    <span class="enscript-comment">// configuration. We already processed search domains in uDNS_SetupWABQueries above and
</span>    <span class="enscript-comment">// hence we are ready to ack the configuration as this is the last call to mDNSPlatformSetConfig
</span>    <span class="enscript-comment">// for the dns configuration change notification.
</span>    SetConfigState(m, mDNStrue);
    <span class="enscript-keyword">if</span> (!mDNSPlatformSetDNSConfig(mDNStrue, mDNSfalse, &amp;fqdn, mDNSNULL, mDNSNULL, mDNStrue))
    {
        SetDynDNSHostNameIfChanged(m, &amp;fqdn);
        SetConfigState(m, mDNSfalse);
        mDNS_Unlock(m);
        LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: No configuration change&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_NoError;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    <span class="enscript-comment">// Reset suspicious mode on any DNS configuration change
</span>    m-&gt;NextSuspiciousTimeout = 0;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// For now, we just delete the mcast resolvers. We don't deal with cache or
</span>    <span class="enscript-comment">// questions here. Neither question nor cache point to mcast resolvers. Questions
</span>    <span class="enscript-comment">// do inherit the timeout values from mcast resolvers. But we don't bother
</span>    <span class="enscript-comment">// affecting them as they never change.
</span>    <span class="enscript-keyword">while</span> (*mres)
    {
        <span class="enscript-keyword">if</span> (((*mres)-&gt;flags &amp; McastResolver_FlagDelete) != 0)
        {
            mr = *mres;
            *mres = (*mres)-&gt;next;
            debugf(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: Deleting mcast resolver %##s&quot;</span>, mr, mr-&gt;domain.c);
            mDNSPlatformMemFree(mr);
        }
        <span class="enscript-keyword">else</span>
        {
            (*mres)-&gt;flags &amp;= ~McastResolver_FlagNew;
            mres = &amp;(*mres)-&gt;next;
        }
    }

    <span class="enscript-comment">// Update our qDNSServer pointers before we go and free the DNSServer object memory
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// All non-scoped resolvers share the same resGroupID. At no point in time a cache entry using DNSServer
</span>    <span class="enscript-comment">// from scoped resolver will be used to answer non-scoped questions and vice versa, as scoped and non-scoped
</span>    <span class="enscript-comment">// resolvers don't share the same resGroupID. A few examples to describe the interaction with how we pick
</span>    <span class="enscript-comment">// DNSServers and flush the cache.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - A non-scoped question picks DNSServer X, creates a cache entry with X. If a new resolver gets added later that
</span>    <span class="enscript-comment">//   is a better match, we pick the new DNSServer for the question and activate the unicast query. We may or may not
</span>    <span class="enscript-comment">//   flush the cache (See PurgeOrReconfirmCacheRecord). In either case, we don't change the cache record's DNSServer
</span>    <span class="enscript-comment">//   pointer immediately (qDNSServer and rDNSServer may be different but still share the same resGroupID). If we don't
</span>    <span class="enscript-comment">//   flush the cache immediately, the record's rDNSServer pointer will be updated (in mDNSCoreReceiveResponse)
</span>    <span class="enscript-comment">//   later when we get the response. If we purge the cache, we still deliver a RMV when it is purged even though
</span>    <span class="enscript-comment">//   we don't update the cache record's DNSServer pointer to match the question's DNSSever, as they both point to
</span>    <span class="enscript-comment">//   the same resGroupID.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">//   Note: If the new DNSServer comes back with a different response than what we have in the cache, we will deliver a RMV
</span>    <span class="enscript-comment">//   of the old followed by ADD of the new records.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - A non-scoped question picks DNSServer X,  creates a cache entry with X. If the resolver gets removed later, we will
</span>    <span class="enscript-comment">//   pick a new DNSServer for the question which may or may not be NULL and set the cache record's pointer to the same
</span>    <span class="enscript-comment">//   as in question's qDNSServer if the cache record is not flushed. If there is no active question, it will be set to NULL.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - Two questions scoped and non-scoped for the same name will pick two different DNSServer and will end up creating separate
</span>    <span class="enscript-comment">//   cache records and as the resGroupID is different, you can't use the cache record from the scoped DNSServer to answer the
</span>    <span class="enscript-comment">//   non-scoped question and vice versa.
</span>    <span class="enscript-comment">//
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    DNS64RestartQuestions(m);
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// First, restart questions whose suppression status will change. The suppression status of each question in a given
</span>    <span class="enscript-comment">// question set, i.e., a non-duplicate question and all of its duplicates, if any, may or may not change. For example,
</span>    <span class="enscript-comment">// a suppressed (or non-suppressed) question that is currently a duplicate of a suppressed (or non-suppressed) question
</span>    <span class="enscript-comment">// may become a non-suppressed (or suppressed) question, while the question that it's a duplicate of may remain
</span>    <span class="enscript-comment">// suppressed (or non-suppressed).
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
    {
        DNSServer *s;
        <span class="enscript-type">const</span> DNSServer *t;
        mDNSBool oldSuppressed;

        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">continue</span>;

        SetValidDNSServers(m, q);
        q-&gt;triedAllServersOnce = mDNSfalse;
        s = GetServerForQuestion(m, q);
        t = q-&gt;qDNSServer;
        <span class="enscript-keyword">if</span> (s != t)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_SetupDNSConfig: Updating DNS server from &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d (&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;) to &quot;</span>
                PRI_IP_ADDR <span class="enscript-string">&quot;:%d (&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;) for question &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) (scope:%p)&quot;</span>,
                q-&gt;request_id, mDNSVal16(q-&gt;TargetQID),
                t ? &amp;t-&gt;addr : mDNSNULL, mDNSVal16(t ? t-&gt;port : zeroIPPort), DM_NAME_PARAM(t ? t-&gt;domain.c : (mDNSu8*)<span class="enscript-string">&quot;&quot;</span>),
                s ? &amp;s-&gt;addr : mDNSNULL, mDNSVal16(s ? s-&gt;port : zeroIPPort), DM_NAME_PARAM(s ? s-&gt;domain.c : (mDNSu8*)<span class="enscript-string">&quot;&quot;</span>),
                DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), q-&gt;InterfaceID);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
            <span class="enscript-comment">// If this question had a DNS Push server associated with it, substitute the new server for the
</span>            <span class="enscript-comment">// old one.   If there is no new server, then we'll clean up the push server later.
</span>            <span class="enscript-keyword">if</span> (!q-&gt;DuplicateOf &amp;&amp; (q-&gt;dnsPushServer != mDNSNULL))
            {
                <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer-&gt;qDNSServer == t)
                {
                    q-&gt;dnsPushServer-&gt;qDNSServer = s; <span class="enscript-comment">// which might be null
</span>                }
                <span class="enscript-comment">// If it is null, do the accounting and drop the push server.
</span>                <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer-&gt;qDNSServer == mDNSNULL)
                {
                    DNSPushReconcileConnection(m, q);
                }
            }
#<span class="enscript-reference">endif</span>
        }
        oldSuppressed = q-&gt;Suppressed;
        q-&gt;Suppressed = ShouldSuppressUnicastQuery(q, s);
        <span class="enscript-keyword">if</span> (!q-&gt;Suppressed != !oldSuppressed) q-&gt;Restart = mDNStrue;
    }
    RestartUnicastQuestions(m);

    <span class="enscript-comment">// Now, change the server for each question set, if necessary. Note that questions whose suppression status changed
</span>    <span class="enscript-comment">// have already had their server changed by being restarted.
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
    {
        DNSServer *s;
        <span class="enscript-type">const</span> DNSServer *t;

        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID) || q-&gt;DuplicateOf) <span class="enscript-keyword">continue</span>;

        SetValidDNSServers(m, q);
        q-&gt;triedAllServersOnce = mDNSfalse;
        s = GetServerForQuestion(m, q);
        t = q-&gt;qDNSServer;
        DNSServerChangeForQuestion(m, q, s);
        <span class="enscript-keyword">if</span> (s == t) <span class="enscript-keyword">continue</span>;

        q-&gt;Suppressed = ShouldSuppressUnicastQuery(q, s);
        q-&gt;unansweredQueries = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
        q-&gt;LastTargetQID = q-&gt;TargetQID;
#<span class="enscript-reference">endif</span>
        q-&gt;TargetQID = mDNS_NewMessageID(m);
        <span class="enscript-keyword">if</span> (!q-&gt;Suppressed) ActivateUnicastQuery(m, q, mDNStrue);
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
    <span class="enscript-comment">// The above code may have found some DNS Push servers that are no longer valid.   Now that we
</span>    <span class="enscript-comment">// are done running through the code, we need to drop our connections to those servers.
</span>    <span class="enscript-comment">// When we get here, any such servers should have zero questions associated with them.
</span>    <span class="enscript-keyword">for</span> (psp = &amp;m-&gt;DNSPushServers; *psp != mDNSNULL; )
    {
        DNSPushNotificationServer *server = *psp;

        <span class="enscript-comment">// It's possible that a push server whose DNS server has been deleted could be still connected but
</span>        <span class="enscript-comment">// not referenced by any questions.  In this case, we just delete the push server rather than trying
</span>        <span class="enscript-comment">// to figure out with which DNS server (if any) to associate it.
</span>        <span class="enscript-keyword">if</span> (server-&gt;qDNSServer != mDNSNULL &amp;&amp; server-&gt;qDNSServer-&gt;flags &amp; DNSServerFlag_Delete)
        {
            server-&gt;qDNSServer = mDNSNULL;
        }

        <span class="enscript-keyword">if</span> (server-&gt;qDNSServer == mDNSNULL)
        {
            <span class="enscript-comment">// This would be a programming error, so should never happen.
</span>            <span class="enscript-keyword">if</span> (server-&gt;numberOfQuestions != 0)
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: deleting push server %##s that has questions.&quot;</span>, &amp;server-&gt;serverName);
            }
            DNSPushServerDrop(server);
            *psp = server-&gt;next;
            mDNSPlatformMemFree(server);
        }
        <span class="enscript-keyword">else</span>
        {
            psp = &amp;(*psp)-&gt;next;
        }
    }
#<span class="enscript-reference">endif</span>

    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID) <span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">// We already walked the questions and restarted/reactivated them if the dns server
</span>        <span class="enscript-comment">// change affected the question. That should take care of updating the cache. But
</span>        <span class="enscript-comment">// what if there is no active question at this point when the DNS server change
</span>        <span class="enscript-comment">// happened ? There could be old cache entries lying around and if we don't flush
</span>        <span class="enscript-comment">// them, a new question after the DNS server change could pick up these stale
</span>        <span class="enscript-comment">// entries and get a wrong answer.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// For cache entries that have active questions we might have skipped rescheduling
</span>        <span class="enscript-comment">// the questions if they were suppressed (see above). To keep it simple, we walk
</span>        <span class="enscript-comment">// all the cache entries to make sure that there are no stale entries. We use the
</span>        <span class="enscript-comment">// active question's InterfaceID/ServiceID for looking up the right DNS server.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Note: If GetServerForName returns NULL, it could either mean that there are no
</span>        <span class="enscript-comment">// DNS servers or no matching DNS servers for this question. In either case,
</span>        <span class="enscript-comment">// the cache should get purged below when we process deleted DNS servers.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// If it is a DNSSEC question, purge the cache as the DNSSEC capabilities of the
</span>        <span class="enscript-comment">// DNS server may have changed.
</span>
        <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion &amp;&amp; !DNSSECQuestion(cr-&gt;CRActiveQuestion))
        {
            <span class="enscript-comment">// Purge or Reconfirm if this cache entry would use the new DNS server
</span>            ptr = GetServerForName(m, cr-&gt;resrec.name, cr-&gt;CRActiveQuestion-&gt;InterfaceID, cr-&gt;CRActiveQuestion-&gt;ServiceID);
            <span class="enscript-keyword">if</span> (ptr &amp;&amp; (ptr != cr-&gt;resrec.rDNSServer))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: Purging/Reconfirming Resourcerecord %s, New DNS server %#a, Old DNS server %#a&quot;</span>,
                        CRDisplayString(m, cr), &amp;ptr-&gt;addr,
                        cr-&gt;resrec.rDNSServer ? &amp;cr-&gt;resrec.rDNSServer-&gt;addr : mDNSNULL);
                PurgeOrReconfirmCacheRecord(m, cr);
                
                <span class="enscript-comment">// If a cache record's DNSServer pointer is NULL, but its active question got a DNSServer in this DNS configuration
</span>                <span class="enscript-comment">// update, then use its DNSServer. This way, the active question and its duplicates don't miss out on RMV events.
</span>                <span class="enscript-keyword">if</span> (!cr-&gt;resrec.rDNSServer &amp;&amp; cr-&gt;CRActiveQuestion-&gt;qDNSServer)
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: Using active question's DNS server %#a for cache record %s&quot;</span>, &amp;cr-&gt;CRActiveQuestion-&gt;qDNSServer-&gt;addr, CRDisplayString(m, cr));
                    cr-&gt;resrec.rDNSServer = cr-&gt;CRActiveQuestion-&gt;qDNSServer;
                }
            }
            
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rDNSServer &amp;&amp; cr-&gt;resrec.rDNSServer-&gt;flags &amp; DNSServerFlag_Delete)
            {
                DNSQuestion *qptr = cr-&gt;CRActiveQuestion;
                <span class="enscript-keyword">if</span> (qptr-&gt;qDNSServer == cr-&gt;resrec.rDNSServer)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: ERROR!! Cache Record %s  Active question %##s (%s) (scope:%p) pointing to DNSServer Address %#a&quot;</span>
                           <span class="enscript-string">&quot; to be freed&quot;</span>, CRDisplayString(m, cr),
                           qptr-&gt;qname.c, DNSTypeName(qptr-&gt;qtype), qptr-&gt;InterfaceID,
                           &amp;cr-&gt;resrec.rDNSServer-&gt;addr);
                    qptr-&gt;validDNSServers = zeroOpaque128;
                    qptr-&gt;qDNSServer = mDNSNULL;
                    cr-&gt;resrec.rDNSServer = mDNSNULL;
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: Cache Record %s,  Active question %##s (%s) (scope:%p), pointing to DNSServer %#a (to be deleted),&quot;</span>
                            <span class="enscript-string">&quot; resetting to  question's DNSServer Address %#a&quot;</span>, CRDisplayString(m, cr),
                            qptr-&gt;qname.c, DNSTypeName(qptr-&gt;qtype), qptr-&gt;InterfaceID,
                            &amp;cr-&gt;resrec.rDNSServer-&gt;addr,
                            qptr-&gt;qDNSServer ? &amp;qptr-&gt;qDNSServer-&gt;addr : mDNSNULL);
                    cr-&gt;resrec.rDNSServer = qptr-&gt;qDNSServer;
                }
                PurgeOrReconfirmCacheRecord(m, cr);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!cr-&gt;resrec.rDNSServer || cr-&gt;resrec.rDNSServer-&gt;flags &amp; DNSServerFlag_Delete)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEBUG,
                <span class="enscript-string">&quot;uDNS_SetupDNSConfig: Purging Resourcerecord &quot;</span> PRI_S <span class="enscript-string">&quot;, DNS server &quot;</span> PUB_S <span class="enscript-string">&quot; &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot; &quot;</span> PUB_S,
                CRDisplayString(m, cr), !cr-&gt;resrec.rDNSServer ? <span class="enscript-string">&quot;(to be deleted)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                cr-&gt;resrec.rDNSServer ? &amp;cr-&gt;resrec.rDNSServer-&gt;addr : mDNSNULL,
                cr-&gt;resrec.rDNSServer ? DNSScopeToString(cr-&gt;resrec.rDNSServer-&gt;scopeType) : <span class="enscript-string">&quot;&quot;</span> );
            cr-&gt;resrec.rDNSServer = mDNSNULL;
            cr-&gt;resrec.mortality = Mortality_Mortal;
            mDNS_PurgeCacheResourceRecord(m, cr);
        }
    }

    <span class="enscript-comment">//  Delete all the DNS servers that are flagged for deletion
</span>    <span class="enscript-keyword">while</span> (*p)
    {
        <span class="enscript-keyword">if</span> (((*p)-&gt;flags &amp; DNSServerFlag_Delete) != 0)
        {
            ptr = *p;
            *p = (*p)-&gt;next;
            LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: Deleting server %p %#a:%d (%##s)&quot;</span>, ptr, &amp;ptr-&gt;addr, mDNSVal16(ptr-&gt;port), ptr-&gt;domain.c);
            mDNSPlatformMemFree(ptr);
        }
        <span class="enscript-keyword">else</span>
        {
            p = &amp;(*p)-&gt;next;
        }
    }
    LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: CountOfUnicastDNSServers %d&quot;</span>, CountOfUnicastDNSServers(m));

    <span class="enscript-comment">// If we now have no DNS servers at all and we used to have some, then immediately purge all unicast cache records (including for LLQs).
</span>    <span class="enscript-comment">// This is important for giving prompt remove events when the user disconnects the Ethernet cable or turns off wireless.
</span>    <span class="enscript-comment">// Otherwise, stale data lingers for 5-10 seconds, which is not the user-experience people expect from Bonjour.
</span>    <span class="enscript-comment">// Similarly, if we now have some DNS servers and we used to have none, we want to purge any fake negative results we may have generated.
</span>    <span class="enscript-keyword">if</span> ((m-&gt;DNSServers != mDNSNULL) != (oldServers != mDNSNULL))
    {
        <span class="enscript-type">int</span> count = 0;
        FORALL_CACHERECORDS(slot, cg, cr)
        {
            <span class="enscript-keyword">if</span> (!cr-&gt;resrec.InterfaceID)
            {
                mDNS_PurgeCacheResourceRecord(m, cr);
                count++;
            }
        }
        LogInfo(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: %s available; purged %d unicast DNS records from cache&quot;</span>,
                m-&gt;DNSServers ? <span class="enscript-string">&quot;DNS server became&quot;</span> : <span class="enscript-string">&quot;No DNS servers&quot;</span>, count);

        <span class="enscript-comment">// Force anything that needs to get zone data to get that information again
</span>        RestartRecordGetZoneData(m);
    }

    SetDynDNSHostNameIfChanged(m, &amp;fqdn);

    mDNS_Unlock(m);

    <span class="enscript-comment">// handle router and primary interface changes
</span>    v4 = v6 = r = zeroAddr;
    v4.type = r.type = mDNSAddrType_IPv4;

    <span class="enscript-keyword">if</span> (mDNSPlatformGetPrimaryInterface(&amp;v4, &amp;v6, &amp;r) == mStatus_NoError &amp;&amp; !mDNSv4AddressIsLinkLocal(&amp;v4.ip.v4))
    {
        mDNS_SetPrimaryInterfaceInfo(m,
                                     !mDNSIPv4AddressIsZero(v4.ip.v4) ? &amp;v4 : mDNSNULL,
                                     !mDNSIPv6AddressIsZero(v6.ip.v6) ? &amp;v6 : mDNSNULL,
                                     !mDNSIPv4AddressIsZero(r.ip.v4) ? &amp;r  : mDNSNULL);
    }
    <span class="enscript-keyword">else</span>
    {
        mDNS_SetPrimaryInterfaceInfo(m, mDNSNULL, mDNSNULL, mDNSNULL);
        <span class="enscript-keyword">if</span> (m-&gt;FQDN.c[0]) mDNSPlatformDynDNSHostNameStatusChanged(&amp;m-&gt;FQDN, 1); <span class="enscript-comment">// Set status to 1 to indicate temporary failure
</span>    }

    debugf(<span class="enscript-string">&quot;uDNS_SetupDNSConfig: number of unicast DNS servers %d&quot;</span>, CountOfUnicastDNSServers(m));
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreInitComplete</span>(mDNS *<span class="enscript-type">const</span> m, mStatus result)
{
    m-&gt;mDNSPlatformStatus = result;
    <span class="enscript-keyword">if</span> (m-&gt;MainCallback)
    {
        mDNS_Lock(m);
        mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>        m-&gt;MainCallback(m, mStatus_NoError);
        mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>        mDNS_Unlock(m);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeregLoop</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> start)
{
    m-&gt;CurrentRecord = start;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rr = m-&gt;CurrentRecord;
        LogInfo(<span class="enscript-string">&quot;DeregLoop: %s deregistration for %p %02X %s&quot;</span>,
                (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering) ? <span class="enscript-string">&quot;Initiating  &quot;</span> : <span class="enscript-string">&quot;Accelerating&quot;</span>,
                rr, rr-&gt;resrec.RecordType, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeDeregistering)
            mDNS_Deregister_internal(m, rr, mDNS_Dereg_rapid);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;AnnounceCount &gt; 1)
        {
            rr-&gt;AnnounceCount = 1;
            rr-&gt;LastAPTime = m-&gt;timenow - rr-&gt;ThisAPInterval;
        }
        <span class="enscript-comment">// Mustn't advance m-&gt;CurrentRecord until *after* mDNS_Deregister_internal, because
</span>        <span class="enscript-comment">// new records could have been added to the end of the list as a result of that call.
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord == rr) <span class="enscript-comment">// If m-&gt;CurrentRecord was not advanced for us, do it now
</span>            m-&gt;CurrentRecord = rr-&gt;next;
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_StartExit</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;

    mDNS_Lock(m);

    LogInfo(<span class="enscript-string">&quot;mDNS_StartExit&quot;</span>);
    m-&gt;ShutdownTime = NonZeroTime(m-&gt;timenow + mDNSPlatformOneSecond * 5);

    mDNSCoreBeSleepProxyServer_internal(m, 0, 0, 0, 0, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">WEB_CONTENT_FILTER</span>)
    <span class="enscript-keyword">if</span> (WCFConnectionDealloc)
    {
        <span class="enscript-keyword">if</span> (m-&gt;WCF) WCFConnectionDealloc(m-&gt;WCF);
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    {
        SearchListElem *s;
        SuspendLLQs(m);
        <span class="enscript-comment">// Don't need to do SleepRecordRegistrations() here
</span>        <span class="enscript-comment">// because we deregister all records and services later in this routine
</span>        <span class="enscript-keyword">while</span> (m-&gt;Hostnames) mDNS_RemoveDynDNSHostName(m, &amp;m-&gt;Hostnames-&gt;fqdn);

        <span class="enscript-comment">// For each member of our SearchList, deregister any records it may have created, and cut them from the list.
</span>        <span class="enscript-comment">// Otherwise they'll be forcibly deregistered for us (without being cut them from the appropriate list)
</span>        <span class="enscript-comment">// and we may crash because the list still contains dangling pointers.
</span>        <span class="enscript-keyword">for</span> (s = SearchList; s; s = s-&gt;next)
            <span class="enscript-keyword">while</span> (s-&gt;AuthRecs)
            {
                ARListElem *dereg = s-&gt;AuthRecs;
                s-&gt;AuthRecs = s-&gt;AuthRecs-&gt;next;
                mDNS_Deregister_internal(m, &amp;dereg-&gt;ar, mDNS_Dereg_normal); <span class="enscript-comment">// Memory will be freed in the FreeARElemCallback
</span>            }
    }
#<span class="enscript-reference">endif</span>

    DeadvertiseAllInterfaceRecords(m, kDeadvertiseFlag_All);

    <span class="enscript-comment">// Shut down all our active NAT Traversals
</span>    <span class="enscript-keyword">while</span> (m-&gt;NATTraversals)
    {
        NATTraversalInfo *t = m-&gt;NATTraversals;
        mDNS_StopNATOperation_internal(m, t);       <span class="enscript-comment">// This will cut 't' from the list, thereby advancing m-&gt;NATTraversals in the process
</span>
        <span class="enscript-comment">// After stopping the NAT Traversal, we zero out the fields.
</span>        <span class="enscript-comment">// This has particularly important implications for our AutoTunnel records --
</span>        <span class="enscript-comment">// when we deregister our AutoTunnel records below, we don't want their mStatus_MemFree
</span>        <span class="enscript-comment">// handlers to just turn around and attempt to re-register those same records.
</span>        <span class="enscript-comment">// Clearing t-&gt;ExternalPort/t-&gt;RequestedPort will cause the mStatus_MemFree callback handlers
</span>        <span class="enscript-comment">// to not do this.
</span>        t-&gt;ExternalAddress = zerov4Addr;
        t-&gt;NewAddress      = zerov4Addr;
        t-&gt;ExternalPort    = zeroIPPort;
        t-&gt;RequestedPort   = zeroIPPort;
        t-&gt;Lifetime        = 0;
        t-&gt;Result          = mStatus_NoError;
    }

    <span class="enscript-comment">// Make sure there are nothing but deregistering records remaining in the list
</span>    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;mDNS_StartExit: ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));

    <span class="enscript-comment">// We're in the process of shutting down, so queries, etc. are no longer available.
</span>    <span class="enscript-comment">// Consequently, determining certain information, e.g. the uDNS update server's IP
</span>    <span class="enscript-comment">// address, will not be possible.  The records on the main list are more likely to
</span>    <span class="enscript-comment">// already contain such information, so we deregister the duplicate records first.
</span>    LogInfo(<span class="enscript-string">&quot;mDNS_StartExit: Deregistering duplicate resource records&quot;</span>);
    DeregLoop(m, m-&gt;DuplicateRecords);
    LogInfo(<span class="enscript-string">&quot;mDNS_StartExit: Deregistering resource records&quot;</span>);
    DeregLoop(m, m-&gt;ResourceRecords);

    <span class="enscript-comment">// If we scheduled a response to send goodbye packets, we set NextScheduledResponse to now. Normally when deregistering records,
</span>    <span class="enscript-comment">// we allow up to 100ms delay (to help improve record grouping) but when shutting down we don't want any such delay.
</span>    <span class="enscript-keyword">if</span> (m-&gt;NextScheduledResponse - m-&gt;timenow &lt; mDNSPlatformOneSecond)
    {
        m-&gt;NextScheduledResponse = m-&gt;timenow;
        m-&gt;SuppressSending = 0;
    }

    <span class="enscript-keyword">if</span> (m-&gt;ResourceRecords) LogInfo(<span class="enscript-string">&quot;mDNS_StartExit: Sending final record deregistrations&quot;</span>);
    <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;mDNS_StartExit: No deregistering records remain&quot;</span>);

    <span class="enscript-keyword">for</span> (rr = m-&gt;DuplicateRecords; rr; rr = rr-&gt;next)
        LogMsg(<span class="enscript-string">&quot;mDNS_StartExit: Should not still have Duplicate Records remaining: %02X %s&quot;</span>, rr-&gt;resrec.RecordType, ARDisplayString(m, rr));

    <span class="enscript-comment">// If any deregistering records remain, send their deregistration announcements before we exit
</span>    <span class="enscript-keyword">if</span> (m-&gt;mDNSPlatformStatus != mStatus_NoError) DiscardDeregistrations(m);

    mDNS_Unlock(m);

    LogInfo(<span class="enscript-string">&quot;mDNS_StartExit: done&quot;</span>);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_FinalExit</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSu32 rrcache_active = 0;
    mDNSu32 rrcache_totalused = m-&gt;rrcache_totalused;
    mDNSu32 slot;
    AuthRecord *rr;

    LogInfo(<span class="enscript-string">&quot;mDNS_FinalExit: mDNSPlatformClose&quot;</span>);
    mDNSPlatformClose(m);

    <span class="enscript-keyword">for</span> (slot = 0; slot &lt; CACHE_HASH_SLOTS; slot++)
    {
        <span class="enscript-keyword">while</span> (m-&gt;rrcache_hash[slot])
        {
            CacheGroup *cg = m-&gt;rrcache_hash[slot];
            <span class="enscript-keyword">while</span> (cg-&gt;members)
            {
                CacheRecord *cr = cg-&gt;members;
                cg-&gt;members = cg-&gt;members-&gt;next;
                <span class="enscript-keyword">if</span> (cr-&gt;CRActiveQuestion) rrcache_active++;
                ReleaseCacheRecord(m, cr);
            }
            cg-&gt;rrcache_tail = &amp;cg-&gt;members;
            ReleaseCacheGroup(m, &amp;m-&gt;rrcache_hash[slot]);
        }
    }
    debugf(<span class="enscript-string">&quot;mDNS_FinalExit: RR Cache was using %ld records, %lu active&quot;</span>, rrcache_totalused, rrcache_active);
    <span class="enscript-keyword">if</span> (rrcache_active != m-&gt;rrcache_active)
        LogMsg(<span class="enscript-string">&quot;*** ERROR *** rrcache_totalused %lu; rrcache_active %lu != m-&gt;rrcache_active %lu&quot;</span>, rrcache_totalused, rrcache_active, m-&gt;rrcache_active);

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
        LogMsg(<span class="enscript-string">&quot;mDNS_FinalExit failed to send goodbye for: %p %02X %s&quot;</span>, rr, rr-&gt;resrec.RecordType, ARDisplayString(m, rr));

    LogInfo(<span class="enscript-string">&quot;mDNS_FinalExit: done&quot;</span>);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">UNIT_TEST</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../unittests/mdns_ut.c&quot;</span>
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>