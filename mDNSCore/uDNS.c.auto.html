<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uDNS.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uDNS.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="uDNS.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

 * To Do:
 * Elimate all mDNSPlatformMemAllocate/mDNSPlatformMemFree from this code -- the core code
 * is supposed to be malloc-free so that it runs in constant memory determined at compile-time.
 * Any dynamic run-time requirements should be handled by the platform layer below or client layer above
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;uDNS.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Metrics.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SymptomReporter.h&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>))
<span class="enscript-comment">// Disable &quot;assignment within conditional expression&quot;.
</span><span class="enscript-comment">// Other compilers understand the convention that if you place the assignment expression within an extra pair
</span><span class="enscript-comment">// of parentheses, this signals to the compiler that you really intended an assignment and no warning is necessary.
</span><span class="enscript-comment">// The Microsoft compiler doesn't understand this convention, so in the absense of any other way to signal
</span><span class="enscript-comment">// to the compiler that the assignment is intentional, we have to just turn this warning off completely.
</span>    #pragma warning(disable:4706)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// For domain enumeration and automatic browsing
</span><span class="enscript-comment">// This is the user's DNS search list.
</span><span class="enscript-comment">// In each of these domains we search for our special pointer records (lb._dns-sd._udp.&lt;domain&gt;, etc.)
</span><span class="enscript-comment">// to discover recommended domains for domain enumeration (browse, default browse, registration,
</span><span class="enscript-comment">// default registration) and possibly one or more recommended automatic browsing domains.
</span>mDNSexport SearchListElem *SearchList = mDNSNULL;

<span class="enscript-comment">// The value can be set to true by the Platform code e.g., MacOSX uses the plist mechanism
</span>mDNSBool StrictUnicastOrdering = mDNSfalse;

<span class="enscript-type">extern</span> mDNS mDNSStorage;

<span class="enscript-comment">// We keep track of the number of unicast DNS servers and log a message when we exceed 64.
</span><span class="enscript-comment">// Currently the unicast queries maintain a 128 bit map to track the valid DNS servers for that
</span><span class="enscript-comment">// question. Bit position is the index into the DNS server list. This is done so to try all
</span><span class="enscript-comment">// the servers exactly once before giving up. If we could allocate memory in the core, then
</span><span class="enscript-comment">// arbitrary limitation of 128 DNSServers can be removed.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_UNICAST_DNS_SERVERS</span> 128

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SetNextuDNSEvent</span>(m, rr) { \
        if ((m)-&gt;NextuDNSEvent - ((rr)-&gt;LastAPTime + (rr)-&gt;ThisAPInterval) &gt;= 0)                                                                              \
            (m)-&gt;NextuDNSEvent = ((rr)-&gt;LastAPTime + (rr)-&gt;ThisAPInterval);                                                                         \
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// set retry timestamp for record with exponential backoff
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetRecordRetry</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNSu32 random)
{
    rr-&gt;LastAPTime = m-&gt;timenow;

    <span class="enscript-keyword">if</span> (rr-&gt;expire &amp;&amp; rr-&gt;refreshCount &lt; MAX_UPDATE_REFRESH_COUNT)
    {
        mDNSs32 remaining = rr-&gt;expire - m-&gt;timenow;
        rr-&gt;refreshCount++;
        <span class="enscript-keyword">if</span> (remaining &gt; MIN_UPDATE_REFRESH_TIME)
        {
            <span class="enscript-comment">// Refresh at 70% + random (currently it is 0 to 10%)
</span>            rr-&gt;ThisAPInterval =  7 * (remaining/10) + (random ? random : mDNSRandom(remaining/10));
            <span class="enscript-comment">// Don't update more often than 5 minutes
</span>            <span class="enscript-keyword">if</span> (rr-&gt;ThisAPInterval &lt; MIN_UPDATE_REFRESH_TIME)
                rr-&gt;ThisAPInterval = MIN_UPDATE_REFRESH_TIME;
            LogInfo(<span class="enscript-string">&quot;SetRecordRetry refresh in %d of %d for %s&quot;</span>,
                    rr-&gt;ThisAPInterval/mDNSPlatformOneSecond, (rr-&gt;expire - m-&gt;timenow)/mDNSPlatformOneSecond, ARDisplayString(m, rr));
        }
        <span class="enscript-keyword">else</span>
        {
            rr-&gt;ThisAPInterval = MIN_UPDATE_REFRESH_TIME;
            LogInfo(<span class="enscript-string">&quot;SetRecordRetry clamping to min refresh in %d of %d for %s&quot;</span>,
                    rr-&gt;ThisAPInterval/mDNSPlatformOneSecond, (rr-&gt;expire - m-&gt;timenow)/mDNSPlatformOneSecond, ARDisplayString(m, rr));
        }
        <span class="enscript-keyword">return</span>;
    }

    rr-&gt;expire = 0;

    rr-&gt;ThisAPInterval = rr-&gt;ThisAPInterval * QuestionIntervalStep; <span class="enscript-comment">// Same Retry logic as Unicast Queries
</span>    <span class="enscript-keyword">if</span> (rr-&gt;ThisAPInterval &lt; INIT_RECORD_REG_INTERVAL)
        rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
    <span class="enscript-keyword">if</span> (rr-&gt;ThisAPInterval &gt; MAX_RECORD_REG_INTERVAL)
        rr-&gt;ThisAPInterval = MAX_RECORD_REG_INTERVAL;

    LogInfo(<span class="enscript-string">&quot;SetRecordRetry retry in %d ms for %s&quot;</span>, rr-&gt;ThisAPInterval, ARDisplayString(m, rr));
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Name</span> <span class="enscript-variable-name">Server</span> <span class="enscript-variable-name">List</span> <span class="enscript-variable-name">Management</span>
#<span class="enscript-reference">endif</span>

mDNSexport DNSServer *<span class="enscript-function-name">mDNS_AddDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> mDNSInterfaceID interface,
    <span class="enscript-type">const</span> mDNSs32 serviceID, <span class="enscript-type">const</span> mDNSAddr *addr, <span class="enscript-type">const</span> mDNSIPPort port, ScopeType scopeType, mDNSu32 timeout,
    mDNSBool isCell, mDNSBool isExpensive, mDNSBool isConstrained, mDNSBool isCLAT46, mDNSu32 resGroupID,
    mDNSBool usableA, mDNSBool usableAAAA, mDNSBool reqDO)
{
    DNSServer **p;
    DNSServer *server;
    <span class="enscript-type">int</span>       dnsCount = CountOfUnicastDNSServers(m);
    <span class="enscript-keyword">if</span> (dnsCount &gt;= MAX_UNICAST_DNS_SERVERS)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_AddDNSServer: DNS server count of %d reached, not adding this server&quot;</span>, dnsCount);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }

    <span class="enscript-keyword">if</span> (!domain) domain = (<span class="enscript-type">const</span> domainname *)<span class="enscript-string">&quot;&quot;</span>;

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;mDNS_AddDNSServer(%d): Adding &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot; for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; interface &quot;</span> PUB_S <span class="enscript-string">&quot; (%p), serviceID %u, &quot;</span>
        <span class="enscript-string">&quot;scopeType %d, resGroupID %u&quot;</span> PUB_S PUB_S PUB_S PUB_S PUB_S PUB_S PUB_S,
        dnsCount + 1, addr, DM_NAME_PARAM(domain), InterfaceNameForID(&amp;mDNSStorage, interface), interface, serviceID,
        (<span class="enscript-type">int</span>)scopeType, resGroupID,
        usableA       ? <span class="enscript-string">&quot;, usableA&quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
        usableAAAA    ? <span class="enscript-string">&quot;, usableAAAA&quot;</span>  : <span class="enscript-string">&quot;&quot;</span>,
        isCell        ? <span class="enscript-string">&quot;, cell&quot;</span>        : <span class="enscript-string">&quot;&quot;</span>,
        isExpensive   ? <span class="enscript-string">&quot;, expensive&quot;</span>   : <span class="enscript-string">&quot;&quot;</span>,
        isConstrained ? <span class="enscript-string">&quot;, constrained&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        isCLAT46      ? <span class="enscript-string">&quot;, CLAT46&quot;</span>      : <span class="enscript-string">&quot;&quot;</span>,
        reqDO         ? <span class="enscript-string">&quot;, reqDO&quot;</span>       : <span class="enscript-string">&quot;&quot;</span>);

    mDNS_CheckLock(m);

    <span class="enscript-comment">// Scan our existing list to see if we already have a matching record for this DNS resolver
</span>    <span class="enscript-keyword">for</span> (p = &amp;m-&gt;DNSServers; (server = *p) != mDNSNULL; p = &amp;server-&gt;next)
    {
        <span class="enscript-keyword">if</span> (server-&gt;interface       != interface)       <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (server-&gt;serviceID       != serviceID)       <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!mDNSSameAddress(&amp;server-&gt;addr, addr))      <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!mDNSSameIPPort(server-&gt;port, port))        <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!SameDomainName(&amp;server-&gt;domain, domain))   <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (server-&gt;scopeType       != scopeType)       <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (server-&gt;timeout         != timeout)         <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!server-&gt;usableA        != !usableA)        <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!server-&gt;usableAAAA     != !usableAAAA)     <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!server-&gt;isCell         != !isCell)         <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!server-&gt;req_DO         != !reqDO)          <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (!(server-&gt;flags &amp; DNSServerFlag_Delete))
        {
            debugf(<span class="enscript-string">&quot;Note: DNS Server %#a:%d for domain %##s (%p) registered more than once&quot;</span>,
                addr, mDNSVal16(port), domain-&gt;c, interface);
        }
        <span class="enscript-comment">// If we found a matching record, cut it from the list
</span>        <span class="enscript-comment">// (and if we’re *not* resurrecting a record that was marked for deletion, it’s a duplicate,
</span>        <span class="enscript-comment">// and the debugf message signifies that we’re collapsing duplicate entries into one)
</span>        *p = server-&gt;next;
        server-&gt;next = mDNSNULL;
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-comment">// If we broke out because we found an existing matching record, advance our pointer to the end of the list
</span>    <span class="enscript-keyword">while</span> (*p)
    {
        p = &amp;(*p)-&gt;next;
    }

    <span class="enscript-keyword">if</span> (server)
    {
        <span class="enscript-keyword">if</span> (server-&gt;flags &amp; DNSServerFlag_Delete)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
            server-&gt;flags &amp;= ~DNSServerFlag_Unreachable;
#<span class="enscript-reference">endif</span>
            server-&gt;flags &amp;= ~DNSServerFlag_Delete;
        }
        server-&gt;isExpensive   = isExpensive;
        server-&gt;isConstrained = isConstrained;
        server-&gt;isCLAT46      = isCLAT46;
        *p = server;    <span class="enscript-comment">// Append resurrected record at end of list
</span>    }
    <span class="enscript-keyword">else</span>
    {
        server = (DNSServer *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*server));
        <span class="enscript-keyword">if</span> (!server)
        {
            LogMsg(<span class="enscript-string">&quot;Error: mDNS_AddDNSServer - malloc&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            server-&gt;interface     = interface;
            server-&gt;serviceID     = serviceID;
            server-&gt;addr          = *addr;
            server-&gt;port          = port;
            server-&gt;scopeType     = scopeType;
            server-&gt;timeout       = timeout;
            server-&gt;usableA       = usableA;
            server-&gt;usableAAAA    = usableAAAA;
            server-&gt;isCell        = isCell;
            server-&gt;isExpensive   = isExpensive;
            server-&gt;isConstrained = isConstrained;
            server-&gt;isCLAT46      = isCLAT46;
            server-&gt;req_DO        = reqDO;
            <span class="enscript-comment">// We start off assuming that the DNS server is not DNSSEC aware and
</span>            <span class="enscript-comment">// when we receive the first response to a DNSSEC question, we set
</span>            <span class="enscript-comment">// it to true.
</span>            server-&gt;DNSSECAware = mDNSfalse;
            server-&gt;retransDO = 0;
            AssignDomainName(&amp;server-&gt;domain, domain);
            *p = server; <span class="enscript-comment">// Append new record at end of list
</span>        }
    }
    <span class="enscript-keyword">if</span> (server)
    {
        server-&gt;penaltyTime = 0;
        <span class="enscript-comment">// We always update the ID (not just when we allocate a new instance) because we want
</span>        <span class="enscript-comment">// all the resGroupIDs for a particular domain to match.
</span>        server-&gt;resGroupID  = resGroupID;
    }
    <span class="enscript-keyword">return</span>(server);
}

<span class="enscript-comment">// PenalizeDNSServer is called when the number of queries to the unicast
</span><span class="enscript-comment">// DNS server exceeds MAX_UCAST_UNANSWERED_QUERIES or when we receive an
</span><span class="enscript-comment">// error e.g., SERV_FAIL from DNS server.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">PenalizeDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSOpaque16 responseFlags)
{
    DNSServer *new;
    DNSServer *orig = q-&gt;qDNSServer;
    mDNSu8 rcode = <span class="enscript-string">'\0'</span>;

    mDNS_CheckLock(m);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
              <span class="enscript-string">&quot;PenalizeDNSServer: Penalizing DNS server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot; question for question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) SuppressUnusable %d&quot;</span>,
              (q-&gt;qDNSServer ? &amp;q-&gt;qDNSServer-&gt;addr : mDNSNULL), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), q-&gt;SuppressUnusable);

    <span class="enscript-comment">// If we get error from any DNS server, remember the error. If all of the servers,
</span>    <span class="enscript-comment">// return the error, then return the first error. 
</span>    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;responseFlags))
        q-&gt;responseFlags = responseFlags;

    rcode = (mDNSu8)(responseFlags.b[1] &amp; kDNSFlag1_RC_Mask);

    <span class="enscript-comment">// After we reset the qDNSServer to NULL, we could get more SERV_FAILS that might end up
</span>    <span class="enscript-comment">// penalizing again.
</span>    <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

    <span class="enscript-comment">// If strict ordering of unicast servers needs to be preserved, we just lookup
</span>    <span class="enscript-comment">// the next best match server below
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// If strict ordering is not required which is the default behavior, we penalize the server
</span>    <span class="enscript-comment">// for DNSSERVER_PENALTY_TIME. We may also use additional logic e.g., don't penalize for PTR
</span>    <span class="enscript-comment">// in the future.
</span>
    <span class="enscript-keyword">if</span> (!StrictUnicastOrdering)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;PenalizeDNSServer: Strict Unicast Ordering is FALSE&quot;</span>);
        <span class="enscript-comment">// We penalize the server so that new queries don't pick this server for DNSSERVER_PENALTY_TIME
</span>        <span class="enscript-comment">// XXX Include other logic here to see if this server should really be penalized
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-keyword">if</span> (q-&gt;qtype == kDNSType_PTR)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;PenalizeDNSServer: Not Penalizing PTR question&quot;</span>);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rcode == kDNSFlag1_RC_FormErr) || (rcode == kDNSFlag1_RC_ServFail) || (rcode == kDNSFlag1_RC_NotImpl) || (rcode == kDNSFlag1_RC_Refused))
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                      <span class="enscript-string">&quot;PenalizeDNSServer: Not Penalizing DNS Server since it at least responded with rcode %d&quot;</span>, rcode);
        }
        <span class="enscript-keyword">else</span>
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;PenalizeDNSServer: Penalizing question type %d&quot;</span>, q-&gt;qtype);
            q-&gt;qDNSServer-&gt;penaltyTime = NonZeroTime(m-&gt;timenow + DNSSERVER_PENALTY_TIME);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT, <span class="enscript-string">&quot;PenalizeDNSServer: Strict Unicast Ordering is TRUE&quot;</span>);
    }

<span class="enscript-reference">end</span>:
    new = GetServerForQuestion(m, q);

    <span class="enscript-keyword">if</span> (new == orig)
    {
        <span class="enscript-keyword">if</span> (new)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                      <span class="enscript-string">&quot;PenalizeDNSServer: ERROR!! GetServerForQuestion returned the same server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d&quot;</span>,
                      &amp;new-&gt;addr, mDNSVal16(new-&gt;port));
            q-&gt;ThisQInterval = 0;   <span class="enscript-comment">// Inactivate this question so that we dont bombard the network
</span>        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// When we have no more DNS servers, we might end up calling PenalizeDNSServer multiple
</span>            <span class="enscript-comment">// times when we receive SERVFAIL from delayed packets in the network e.g., DNS server
</span>            <span class="enscript-comment">// is slow in responding and we have sent three queries. When we repeatedly call, it is
</span>            <span class="enscript-comment">// okay to receive the same NULL DNS server. Next time we try to send the query, we will
</span>            <span class="enscript-comment">// realize and re-initialize the DNS servers.
</span>            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO, <span class="enscript-string">&quot;PenalizeDNSServer: GetServerForQuestion returned the same server NULL&quot;</span>);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// The new DNSServer is set in DNSServerChangeForQuestion
</span>        DNSServerChangeForQuestion(m, q, new);

        <span class="enscript-keyword">if</span> (new)
        {
            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                      <span class="enscript-string">&quot;PenalizeDNSServer: Server for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) changed to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d (&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;)&quot;</span>,
                      DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), &amp;q-&gt;qDNSServer-&gt;addr, mDNSVal16(q-&gt;qDNSServer-&gt;port), DM_NAME_PARAM(q-&gt;qDNSServer-&gt;domain.c));
            <span class="enscript-comment">// We want to try the next server immediately. As the question may already have backed off, reset
</span>            <span class="enscript-comment">// the interval. We do this only the first time when we try all the DNS servers. Once we reached the end of
</span>            <span class="enscript-comment">// list and retrying all the servers again e.g., at least one server failed to respond in the previous try, we
</span>            <span class="enscript-comment">// use the normal backoff which is done in uDNS_CheckCurrentQuestion when we send the packet out.
</span>            <span class="enscript-keyword">if</span> (!q-&gt;triedAllServersOnce)
            {
                q-&gt;ThisQInterval = InitialQuestionInterval;
                q-&gt;LastQTime  = m-&gt;timenow - q-&gt;ThisQInterval;
                SetNextQueryTime(m, q);
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// We don't have any more DNS servers for this question. If some server in the list did not return
</span>            <span class="enscript-comment">// any response, we need to keep retrying till we get a response. uDNS_CheckCurrentQuestion handles
</span>            <span class="enscript-comment">// this case.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// If all servers responded with a negative response, We need to do two things. First, generate a
</span>            <span class="enscript-comment">// negative response so that applications get a reply. We also need to reinitialize the DNS servers
</span>            <span class="enscript-comment">// so that when the cache expires, we can restart the query.  We defer this up until we generate
</span>            <span class="enscript-comment">// a negative cache response in uDNS_CheckCurrentQuestion.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Be careful not to touch the ThisQInterval here. For a normal question, when we answer the question
</span>            <span class="enscript-comment">// in AnswerCurrentQuestionWithResourceRecord will set ThisQInterval to MaxQuestionInterval and hence
</span>            <span class="enscript-comment">// the next query will not happen until cache expiry. If it is a long lived question,
</span>            <span class="enscript-comment">// AnswerCurrentQuestionWithResourceRecord will not set it to MaxQuestionInterval. In that case,
</span>            <span class="enscript-comment">// we want the normal backoff to work.
</span>            LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                      <span class="enscript-string">&quot;PenalizeDNSServer: Server for %p, &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) changed to NULL, Interval %d&quot;</span>,
                      q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), q-&gt;ThisQInterval);
        }
        q-&gt;unansweredQueries = 0;

    }
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">authorization</span> <span class="enscript-variable-name">management</span>
#<span class="enscript-reference">endif</span>

mDNSlocal DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName_direct</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">const</span> domainname *n = name;
    <span class="enscript-keyword">while</span> (n-&gt;c[0])
    {
        DomainAuthInfo *ptr;
        <span class="enscript-keyword">for</span> (ptr = m-&gt;AuthInfoList; ptr; ptr = ptr-&gt;next)
            <span class="enscript-keyword">if</span> (SameDomainName(&amp;ptr-&gt;domain, n))
            {
                debugf(<span class="enscript-string">&quot;GetAuthInfoForName %##s Matched %##s Key name %##s&quot;</span>, name-&gt;c, ptr-&gt;domain.c, ptr-&gt;keyname.c);
                <span class="enscript-keyword">return</span>(ptr);
            }
        n = (<span class="enscript-type">const</span> domainname *)(n-&gt;c + 1 + n-&gt;c[0]);
    }
    <span class="enscript-comment">//LogInfo(&quot;GetAuthInfoForName none found for %##s&quot;, name-&gt;c);
</span>    <span class="enscript-keyword">return</span> mDNSNULL;
}

<span class="enscript-comment">// MUST be called with lock held
</span>mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName_internal</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    DomainAuthInfo **p = &amp;m-&gt;AuthInfoList;

    mDNS_CheckLock(m);

    <span class="enscript-comment">// First purge any dead keys from the list
</span>    <span class="enscript-keyword">while</span> (*p)
    {
        <span class="enscript-keyword">if</span> ((*p)-&gt;deltime &amp;&amp; m-&gt;timenow - (*p)-&gt;deltime &gt;= 0)
        {
            DNSQuestion *q;
            DomainAuthInfo *info = *p;
            LogInfo(<span class="enscript-string">&quot;GetAuthInfoForName_internal deleting expired key %##s %##s&quot;</span>, info-&gt;domain.c, info-&gt;keyname.c);
            *p = info-&gt;next;    <span class="enscript-comment">// Cut DomainAuthInfo from list *before* scanning our question list updating AuthInfo pointers
</span>            <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
                <span class="enscript-keyword">if</span> (q-&gt;AuthInfo == info)
                {
                    q-&gt;AuthInfo = GetAuthInfoForName_direct(m, &amp;q-&gt;qname);
                    debugf(<span class="enscript-string">&quot;GetAuthInfoForName_internal updated q-&gt;AuthInfo from %##s to %##s for %##s (%s)&quot;</span>,
                           info-&gt;domain.c, q-&gt;AuthInfo ? q-&gt;AuthInfo-&gt;domain.c : mDNSNULL, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                }

            <span class="enscript-comment">// Probably not essential, but just to be safe, zero out the secret key data
</span>            <span class="enscript-comment">// so we don't leave it hanging around in memory
</span>            <span class="enscript-comment">// (where it could potentially get exposed via some other bug)
</span>            mDNSPlatformMemZero(info, <span class="enscript-keyword">sizeof</span>(*info));
            mDNSPlatformMemFree(info);
        }
        <span class="enscript-keyword">else</span>
            p = &amp;(*p)-&gt;next;
    }

    <span class="enscript-keyword">return</span>(GetAuthInfoForName_direct(m, name));
}

mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    DomainAuthInfo *d;
    mDNS_Lock(m);
    d = GetAuthInfoForName_internal(m, name);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(d);
}

<span class="enscript-comment">// MUST be called with the lock held
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_SetSecretForDomain</span>(mDNS *m, DomainAuthInfo *info,
                                           <span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> domainname *keyname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64keydata, <span class="enscript-type">const</span> domainname *hostname, mDNSIPPort *port)
{
    DNSQuestion *q;
    DomainAuthInfo **p = &amp;m-&gt;AuthInfoList;
    <span class="enscript-keyword">if</span> (!info || !b64keydata) { LogMsg(<span class="enscript-string">&quot;mDNS_SetSecretForDomain: ERROR: info %p b64keydata %p&quot;</span>, info, b64keydata); <span class="enscript-keyword">return</span>(mStatus_BadParamErr); }

    LogInfo(<span class="enscript-string">&quot;mDNS_SetSecretForDomain: domain %##s key %##s&quot;</span>, domain-&gt;c, keyname-&gt;c);

    AssignDomainName(&amp;info-&gt;domain,  domain);
    AssignDomainName(&amp;info-&gt;keyname, keyname);
    <span class="enscript-keyword">if</span> (hostname)
        AssignDomainName(&amp;info-&gt;hostname, hostname);
    <span class="enscript-keyword">else</span>
        info-&gt;hostname.c[0] = 0;
    <span class="enscript-keyword">if</span> (port)
        info-&gt;port = *port;
    <span class="enscript-keyword">else</span>
        info-&gt;port = zeroIPPort;
    mDNS_snprintf(info-&gt;b64keydata, <span class="enscript-keyword">sizeof</span>(info-&gt;b64keydata), <span class="enscript-string">&quot;%s&quot;</span>, b64keydata);

    <span class="enscript-keyword">if</span> (DNSDigest_ConstructHMACKeyfromBase64(info, b64keydata) &lt; 0)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_SetSecretForDomain: ERROR: Could not convert shared secret from base64: domain %##s key %##s %s&quot;</span>, domain-&gt;c, keyname-&gt;c, mDNS_LoggingEnabled ? b64keydata : <span class="enscript-string">&quot;&quot;</span>);
        <span class="enscript-keyword">return</span>(mStatus_BadParamErr);
    }

    <span class="enscript-comment">// Don't clear deltime until after we've ascertained that b64keydata is valid
</span>    info-&gt;deltime = 0;

    <span class="enscript-keyword">while</span> (*p &amp;&amp; (*p) != info) p=&amp;(*p)-&gt;next;
    <span class="enscript-keyword">if</span> (*p) {LogInfo(<span class="enscript-string">&quot;mDNS_SetSecretForDomain: Domain %##s Already in list&quot;</span>, (*p)-&gt;domain.c); <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);}

    info-&gt;next = mDNSNULL;
    *p = info;

    <span class="enscript-comment">// Check to see if adding this new DomainAuthInfo has changed the credentials for any of our questions
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q=q-&gt;next)
    {
        DomainAuthInfo *newinfo = GetAuthInfoForQuestion(m, q);
        <span class="enscript-keyword">if</span> (q-&gt;AuthInfo != newinfo)
        {
            debugf(<span class="enscript-string">&quot;mDNS_SetSecretForDomain updating q-&gt;AuthInfo from %##s to %##s for %##s (%s)&quot;</span>,
                   q-&gt;AuthInfo ? q-&gt;AuthInfo-&gt;domain.c : mDNSNULL,
                   newinfo     ? newinfo-&gt;domain.c : mDNSNULL, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            q-&gt;AuthInfo = newinfo;
        }
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">NAT</span> <span class="enscript-variable-name">Traversal</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Keep track of when to request/refresh the external address using NAT-PMP or UPnP/IGD,
</span><span class="enscript-comment">// and do so when necessary
</span>mDNSlocal mStatus <span class="enscript-function-name">uDNS_RequestAddress</span>(mDNS *m)
{
    mStatus err = mStatus_NoError;

    <span class="enscript-keyword">if</span> (!m-&gt;NATTraversals)
    {
        m-&gt;retryGetAddr = NonZeroTime(m-&gt;timenow + FutureTime);
        LogInfo(<span class="enscript-string">&quot;uDNS_RequestAddress: Setting retryGetAddr to future&quot;</span>);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;retryGetAddr &gt;= 0)
    {
        <span class="enscript-keyword">if</span> (mDNSv4AddrIsRFC1918(&amp;m-&gt;Router.ip.v4))
        {
            <span class="enscript-type">static</span> NATAddrRequest req = {NATMAP_VERS, NATOp_AddrRequest};
            <span class="enscript-type">static</span> mDNSu8* start = (mDNSu8*)&amp;req;
            mDNSu8* end = start + <span class="enscript-keyword">sizeof</span>(NATAddrRequest);
            err = mDNSPlatformSendUDP(m, start, end, 0, mDNSNULL, &amp;m-&gt;Router, NATPMPPort, mDNSfalse);
            debugf(<span class="enscript-string">&quot;uDNS_RequestAddress: Sent NAT-PMP external address request %d&quot;</span>, err);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
            <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;UPnPRouterPort) || mDNSIPPortIsZero(m-&gt;UPnPSOAPPort))
            {
                LNT_SendDiscoveryMsg(m);
                debugf(<span class="enscript-string">&quot;uDNS_RequestAddress: LNT_SendDiscoveryMsg&quot;</span>);
            }
            <span class="enscript-keyword">else</span>
            {
                mStatus lnterr = LNT_GetExternalAddress(m);
                <span class="enscript-keyword">if</span> (lnterr)
                    LogMsg(<span class="enscript-string">&quot;uDNS_RequestAddress: LNT_GetExternalAddress returned error %d&quot;</span>, lnterr);

                err = err ? err : lnterr; <span class="enscript-comment">// NAT-PMP error takes precedence
</span>            }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
        }

        <span class="enscript-comment">// Always update the interval and retry time, so that even if we fail to send the
</span>        <span class="enscript-comment">// packet, we won't spin in an infinite loop repeatedly failing to send the packet
</span>        <span class="enscript-keyword">if</span> (m-&gt;retryIntervalGetAddr &lt; NATMAP_INIT_RETRY)
        {
            m-&gt;retryIntervalGetAddr = NATMAP_INIT_RETRY;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;retryIntervalGetAddr &lt; NATMAP_MAX_RETRY_INTERVAL / 2)
        {
            m-&gt;retryIntervalGetAddr *= 2;
        }
        <span class="enscript-keyword">else</span>
        {
            m-&gt;retryIntervalGetAddr = NATMAP_MAX_RETRY_INTERVAL;
        }

        m-&gt;retryGetAddr = NonZeroTime(m-&gt;timenow + m-&gt;retryIntervalGetAddr);
    }
    <span class="enscript-keyword">else</span>
    {
        debugf(<span class="enscript-string">&quot;uDNS_RequestAddress: Not time to send address request&quot;</span>);
    }

    <span class="enscript-comment">// Always update NextScheduledNATOp, even if we didn't change retryGetAddr, so we'll
</span>    <span class="enscript-comment">// be called when we need to send the request(s)
</span>    <span class="enscript-keyword">if</span> (m-&gt;NextScheduledNATOp - m-&gt;retryGetAddr &gt; 0)
        m-&gt;NextScheduledNATOp = m-&gt;retryGetAddr;

    <span class="enscript-keyword">return</span> err;
}

mDNSlocal mStatus <span class="enscript-function-name">uDNS_SendNATMsg</span>(mDNS *m, NATTraversalInfo *info, mDNSBool usePCP, mDNSBool unmapping)
{
    mStatus err = mStatus_NoError;

    <span class="enscript-keyword">if</span> (!info)
    {
        LogMsg(<span class="enscript-string">&quot;uDNS_SendNATMsg called unexpectedly with NULL info&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    <span class="enscript-comment">// send msg if the router's address is private (which means it's non-zero)
</span>    <span class="enscript-keyword">if</span> (mDNSv4AddrIsRFC1918(&amp;m-&gt;Router.ip.v4))
    {
        <span class="enscript-keyword">if</span> (!usePCP)
        {
            <span class="enscript-keyword">if</span> (!info-&gt;sentNATPMP)
            {
                <span class="enscript-keyword">if</span> (info-&gt;Protocol)
                {
                    <span class="enscript-type">static</span> NATPortMapRequest NATPortReq;
                    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSu8* end = (mDNSu8 *)&amp;NATPortReq + <span class="enscript-keyword">sizeof</span>(NATPortMapRequest);
                    mDNSu8 *p = (mDNSu8 *)&amp;NATPortReq.NATReq_lease;

                    NATPortReq.vers    = NATMAP_VERS;
                    NATPortReq.opcode  = info-&gt;Protocol;
                    NATPortReq.unused  = zeroID;
                    NATPortReq.intport = info-&gt;IntPort;
                    NATPortReq.extport = info-&gt;RequestedPort;
                    p[0] = (mDNSu8)((info-&gt;NATLease &gt;&gt; 24) &amp;  0xFF);
                    p[1] = (mDNSu8)((info-&gt;NATLease &gt;&gt; 16) &amp;  0xFF);
                    p[2] = (mDNSu8)((info-&gt;NATLease &gt;&gt;  8) &amp;  0xFF);
                    p[3] = (mDNSu8)( info-&gt;NATLease        &amp;  0xFF);

                    err = mDNSPlatformSendUDP(m, (mDNSu8 *)&amp;NATPortReq, end, 0, mDNSNULL, &amp;m-&gt;Router, NATPMPPort, mDNSfalse);
                    debugf(<span class="enscript-string">&quot;uDNS_SendNATMsg: Sent NAT-PMP mapping request %d&quot;</span>, err);
                }

                <span class="enscript-comment">// In case the address request already went out for another NAT-T,
</span>                <span class="enscript-comment">// set the NewAddress to the currently known global external address, so
</span>                <span class="enscript-comment">// Address-only operations will get the callback immediately
</span>                info-&gt;NewAddress = m-&gt;ExtAddress;

                <span class="enscript-comment">// Remember that we just sent a NAT-PMP packet, so we won't resend one later.
</span>                <span class="enscript-comment">// We do this because the NAT-PMP &quot;Unsupported Version&quot; response has no
</span>                <span class="enscript-comment">// information about the (PCP) request that triggered it, so we must send
</span>                <span class="enscript-comment">// NAT-PMP requests for all operations. Without this, we'll send n PCP
</span>                <span class="enscript-comment">// requests for n operations, receive n NAT-PMP &quot;Unsupported Version&quot;
</span>                <span class="enscript-comment">// responses, and send n NAT-PMP requests for each of those responses,
</span>                <span class="enscript-comment">// resulting in (n + n^2) packets sent. We only want to send 2n packets:
</span>                <span class="enscript-comment">// n PCP requests followed by n NAT-PMP requests.
</span>                info-&gt;sentNATPMP = mDNStrue;
            }
        }
        <span class="enscript-keyword">else</span>
        {
            PCPMapRequest req;
            mDNSu8* start = (mDNSu8*)&amp;req;
            mDNSu8* end = start + <span class="enscript-keyword">sizeof</span>(req);
            mDNSu8* p = (mDNSu8*)&amp;req.lifetime;

            req.version = PCP_VERS;
            req.opCode = PCPOp_Map;
            req.reserved = zeroID;

            p[0] = (mDNSu8)((info-&gt;NATLease &gt;&gt; 24) &amp;  0xFF);
            p[1] = (mDNSu8)((info-&gt;NATLease &gt;&gt; 16) &amp;  0xFF);
            p[2] = (mDNSu8)((info-&gt;NATLease &gt;&gt;  8) &amp;  0xFF);
            p[3] = (mDNSu8)( info-&gt;NATLease        &amp;  0xFF);

            mDNSAddrMapIPv4toIPv6(&amp;m-&gt;AdvertisedV4.ip.v4, &amp;req.clientAddr);

            req.nonce[0] = m-&gt;PCPNonce[0];
            req.nonce[1] = m-&gt;PCPNonce[1];
            req.nonce[2] = m-&gt;PCPNonce[2];

            req.protocol = (info-&gt;Protocol == NATOp_MapUDP ? PCPProto_UDP : PCPProto_TCP);

            req.reservedMapOp[0] = 0;
            req.reservedMapOp[1] = 0;
            req.reservedMapOp[2] = 0;

            req.intPort = info-&gt;Protocol ? info-&gt;IntPort : DiscardPort;
            req.extPort = info-&gt;RequestedPort;

            <span class="enscript-comment">// Since we only support IPv4, even if using the all-zeros address, map it, so
</span>            <span class="enscript-comment">// the PCP gateway will give us an IPv4 address &amp; not an IPv6 address.
</span>            mDNSAddrMapIPv4toIPv6(&amp;info-&gt;NewAddress, &amp;req.extAddress);

            err = mDNSPlatformSendUDP(m, start, end, 0, mDNSNULL, &amp;m-&gt;Router, NATPMPPort, mDNSfalse);
            debugf(<span class="enscript-string">&quot;uDNS_SendNATMsg: Sent PCP Mapping request %d&quot;</span>, err);

            <span class="enscript-comment">// Unset the sentNATPMP flag, so that we'll send a NAT-PMP packet if we
</span>            <span class="enscript-comment">// receive a NAT-PMP &quot;Unsupported Version&quot; packet. This will result in every
</span>            <span class="enscript-comment">// renewal, retransmission, etc. being tried first as PCP, then if a NAT-PMP
</span>            <span class="enscript-comment">// &quot;Unsupported Version&quot; response is received, fall-back &amp; send the request
</span>            <span class="enscript-comment">// using NAT-PMP.
</span>            info-&gt;sentNATPMP = mDNSfalse;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
            <span class="enscript-comment">// If an unmapping is being performed, then don't send an LNT discovery message or an LNT port map request.
</span>            <span class="enscript-keyword">if</span> (!unmapping)
            {
                <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;UPnPRouterPort) || mDNSIPPortIsZero(m-&gt;UPnPSOAPPort))
                {
                    LNT_SendDiscoveryMsg(m);
                    debugf(<span class="enscript-string">&quot;uDNS_SendNATMsg: LNT_SendDiscoveryMsg&quot;</span>);
                }
                <span class="enscript-keyword">else</span>
                {
                    mStatus lnterr = LNT_MapPort(m, info);
                    <span class="enscript-keyword">if</span> (lnterr)
                        LogMsg(<span class="enscript-string">&quot;uDNS_SendNATMsg: LNT_MapPort returned error %d&quot;</span>, lnterr);

                    err = err ? err : lnterr; <span class="enscript-comment">// PCP error takes precedence
</span>                }
            }
#<span class="enscript-reference">else</span>
            (<span class="enscript-type">void</span>)unmapping; <span class="enscript-comment">// Unused
</span>#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
        }
    }

    <span class="enscript-keyword">return</span>(err);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RecreateNATMappings</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 waitTicks)
{
    mDNSu32 when = NonZeroTime(m-&gt;timenow + waitTicks);
    NATTraversalInfo *n;
    <span class="enscript-keyword">for</span> (n = m-&gt;NATTraversals; n; n=n-&gt;next)
    {
        n-&gt;ExpiryTime    = 0;       <span class="enscript-comment">// Mark this mapping as expired
</span>        n-&gt;retryInterval = NATMAP_INIT_RETRY;
        n-&gt;retryPortMap  = when;
        n-&gt;lastSuccessfulProtocol = NATTProtocolNone;
        <span class="enscript-keyword">if</span> (!n-&gt;Protocol) n-&gt;NewResult = mStatus_NoError;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
        <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.sock) { mDNSPlatformTCPCloseConnection(n-&gt;tcpInfo.sock); n-&gt;tcpInfo.sock = mDNSNULL; }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    }

    m-&gt;PCPNonce[0] = mDNSRandom(-1);
    m-&gt;PCPNonce[1] = mDNSRandom(-1);
    m-&gt;PCPNonce[2] = mDNSRandom(-1);
    m-&gt;retryIntervalGetAddr = 0;
    m-&gt;retryGetAddr = when;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    LNT_ClearState(m);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

    m-&gt;NextScheduledNATOp = m-&gt;timenow;     <span class="enscript-comment">// Need to send packets immediately
</span>}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">natTraversalHandleAddressReply</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu16 err, mDNSv4Addr ExtAddr)
{
    <span class="enscript-type">static</span> mDNSu16 last_err = 0;
    NATTraversalInfo *n;

    <span class="enscript-keyword">if</span> (err)
    {
        <span class="enscript-keyword">if</span> (err != last_err) LogMsg(<span class="enscript-string">&quot;Error getting external address %d&quot;</span>, err);
        ExtAddr = zerov4Addr;
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;Received external IP address %.4a from NAT&quot;</span>, &amp;ExtAddr);
        <span class="enscript-keyword">if</span> (mDNSv4AddrIsRFC1918(&amp;ExtAddr))
            LogMsg(<span class="enscript-string">&quot;Double NAT (external NAT gateway address %.4a is also a private RFC 1918 address)&quot;</span>, &amp;ExtAddr);
        <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(ExtAddr))
            err = NATErr_NetFail; <span class="enscript-comment">// fake error to handle routers that pathologically report success with the zero address
</span>    }

    <span class="enscript-comment">// Globally remember the most recently discovered address, so it can be used in each
</span>    <span class="enscript-comment">// new NATTraversal structure
</span>    m-&gt;ExtAddress = ExtAddr;

    <span class="enscript-keyword">if</span> (!err) <span class="enscript-comment">// Success, back-off to maximum interval
</span>        m-&gt;retryIntervalGetAddr = NATMAP_MAX_RETRY_INTERVAL;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!last_err) <span class="enscript-comment">// Failure after success, retry quickly (then back-off exponentially)
</span>        m-&gt;retryIntervalGetAddr = NATMAP_INIT_RETRY;
    <span class="enscript-comment">// else back-off normally in case of pathological failures
</span>
    m-&gt;retryGetAddr = m-&gt;timenow + m-&gt;retryIntervalGetAddr;
    <span class="enscript-keyword">if</span> (m-&gt;NextScheduledNATOp - m-&gt;retryGetAddr &gt; 0)
        m-&gt;NextScheduledNATOp = m-&gt;retryGetAddr;

    last_err = err;

    <span class="enscript-keyword">for</span> (n = m-&gt;NATTraversals; n; n=n-&gt;next)
    {
        <span class="enscript-comment">// We should change n-&gt;NewAddress only when n is one of:
</span>        <span class="enscript-comment">// 1) a mapping operation that most recently succeeded using NAT-PMP or UPnP/IGD,
</span>        <span class="enscript-comment">//    because such an operation needs the update now. If the lastSuccessfulProtocol
</span>        <span class="enscript-comment">//    is currently none, then natTraversalHandlePortMapReplyWithAddress() will be
</span>        <span class="enscript-comment">//    called should NAT-PMP or UPnP/IGD succeed in the future.
</span>        <span class="enscript-comment">// 2) an address-only operation that did not succeed via PCP, because when such an
</span>        <span class="enscript-comment">//    operation succeeds via PCP, it's for the TCP discard port just to learn the
</span>        <span class="enscript-comment">//    address. And that address may be different than the external address
</span>        <span class="enscript-comment">//    discovered via NAT-PMP or UPnP/IGD. If the lastSuccessfulProtocol
</span>        <span class="enscript-comment">//    is currently none, we must update the NewAddress as PCP may not succeed.
</span>        <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(n-&gt;NewAddress, ExtAddr) &amp;&amp;
             (n-&gt;Protocol ?
               (n-&gt;lastSuccessfulProtocol == NATTProtocolNATPMP || n-&gt;lastSuccessfulProtocol == NATTProtocolUPNPIGD) :
               (n-&gt;lastSuccessfulProtocol != NATTProtocolPCP)))
        {
            <span class="enscript-comment">// Needs an update immediately
</span>            n-&gt;NewAddress    = ExtAddr;
            n-&gt;ExpiryTime    = 0;
            n-&gt;retryInterval = NATMAP_INIT_RETRY;
            n-&gt;retryPortMap  = m-&gt;timenow;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
            <span class="enscript-keyword">if</span> (n-&gt;tcpInfo.sock) { mDNSPlatformTCPCloseConnection(n-&gt;tcpInfo.sock); n-&gt;tcpInfo.sock = mDNSNULL; }
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

            m-&gt;NextScheduledNATOp = m-&gt;timenow;     <span class="enscript-comment">// Need to send packets immediately
</span>        }
    }
}

<span class="enscript-comment">// Both places that call NATSetNextRenewalTime() update m-&gt;NextScheduledNATOp correctly afterwards
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">NATSetNextRenewalTime</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *n)
{
    n-&gt;retryInterval = (n-&gt;ExpiryTime - m-&gt;timenow)/2;
    <span class="enscript-keyword">if</span> (n-&gt;retryInterval &lt; NATMAP_MIN_RETRY_INTERVAL)   <span class="enscript-comment">// Min retry interval is 2 seconds
</span>        n-&gt;retryInterval = NATMAP_MIN_RETRY_INTERVAL;
    n-&gt;retryPortMap = m-&gt;timenow + n-&gt;retryInterval;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">natTraversalHandlePortMapReplyWithAddress</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *n, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu16 err, mDNSv4Addr extaddr, mDNSIPPort extport, mDNSu32 lease, NATTProtocol protocol)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *prot = n-&gt;Protocol == 0 ? <span class="enscript-string">&quot;Add&quot;</span> : n-&gt;Protocol == NATOp_MapUDP ? <span class="enscript-string">&quot;UDP&quot;</span> : n-&gt;Protocol == NATOp_MapTCP ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;???&quot;</span>;
    (<span class="enscript-type">void</span>)prot;
    n-&gt;NewResult = err;
    <span class="enscript-keyword">if</span> (err || lease == 0 || mDNSIPPortIsZero(extport))
    {
        LogInfo(<span class="enscript-string">&quot;natTraversalHandlePortMapReplyWithAddress: %p Response %s Port %5d External %.4a:%d lease %d error %d&quot;</span>,
                n, prot, mDNSVal16(n-&gt;IntPort), &amp;extaddr, mDNSVal16(extport), lease, err);
        n-&gt;retryInterval = NATMAP_MAX_RETRY_INTERVAL;
        n-&gt;retryPortMap = m-&gt;timenow + NATMAP_MAX_RETRY_INTERVAL;
        <span class="enscript-comment">// No need to set m-&gt;NextScheduledNATOp here, since we're only ever extending the m-&gt;retryPortMap time
</span>        <span class="enscript-keyword">if</span>      (err == NATErr_Refused) n-&gt;NewResult = mStatus_NATPortMappingDisabled;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err &gt; NATErr_None &amp;&amp; err &lt;= NATErr_Opcode) n-&gt;NewResult = mStatus_NATPortMappingUnsupported;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (lease &gt; 999999999UL / mDNSPlatformOneSecond)
            lease = 999999999UL / mDNSPlatformOneSecond;
        n-&gt;ExpiryTime = NonZeroTime(m-&gt;timenow + lease * mDNSPlatformOneSecond);

        <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(n-&gt;NewAddress, extaddr) || !mDNSSameIPPort(n-&gt;RequestedPort, extport))
            LogInfo(<span class="enscript-string">&quot;natTraversalHandlePortMapReplyWithAddress: %p %s Response %s Port %5d External %.4a:%d changed to %.4a:%d lease %d&quot;</span>,
                    n,
                    (n-&gt;lastSuccessfulProtocol == NATTProtocolNone    ? <span class="enscript-string">&quot;None    &quot;</span> :
                     n-&gt;lastSuccessfulProtocol == NATTProtocolNATPMP  ? <span class="enscript-string">&quot;NAT-PMP &quot;</span> :
                     n-&gt;lastSuccessfulProtocol == NATTProtocolUPNPIGD ? <span class="enscript-string">&quot;UPnP/IGD&quot;</span> :
                     n-&gt;lastSuccessfulProtocol == NATTProtocolPCP     ? <span class="enscript-string">&quot;PCP     &quot;</span> :
                     <span class="enscript-comment">/* else */</span>                                         <span class="enscript-string">&quot;Unknown &quot;</span> ),
                    prot, mDNSVal16(n-&gt;IntPort), &amp;n-&gt;NewAddress, mDNSVal16(n-&gt;RequestedPort),
                    &amp;extaddr, mDNSVal16(extport), lease);

        n-&gt;InterfaceID   = InterfaceID;
        n-&gt;NewAddress    = extaddr;
        <span class="enscript-keyword">if</span> (n-&gt;Protocol) n-&gt;RequestedPort = extport; <span class="enscript-comment">// Don't report the (PCP) external port to address-only operations
</span>        n-&gt;lastSuccessfulProtocol = protocol;

        NATSetNextRenewalTime(m, n);            <span class="enscript-comment">// Got our port mapping; now set timer to renew it at halfway point
</span>        m-&gt;NextScheduledNATOp = m-&gt;timenow;     <span class="enscript-comment">// May need to invoke client callback immediately
</span>    }
}

<span class="enscript-comment">// To be called for NAT-PMP or UPnP/IGD mappings, to use currently discovered (global) address
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">natTraversalHandlePortMapReply</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *n, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu16 err, mDNSIPPort extport, mDNSu32 lease, NATTProtocol protocol)
{
    natTraversalHandlePortMapReplyWithAddress(m, n, InterfaceID, err, m-&gt;ExtAddress, extport, lease, protocol);
}

<span class="enscript-comment">// Must be called with the mDNS_Lock held
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_StartNATOperation_internal</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal)
{
    NATTraversalInfo **n;

    LogInfo(<span class="enscript-string">&quot;mDNS_StartNATOperation_internal %p Protocol %d IntPort %d RequestedPort %d NATLease %d&quot;</span>, traversal,
            traversal-&gt;Protocol, mDNSVal16(traversal-&gt;IntPort), mDNSVal16(traversal-&gt;RequestedPort), traversal-&gt;NATLease);

    <span class="enscript-comment">// Note: It important that new traversal requests are appended at the *end* of the list, not prepended at the start
</span>    <span class="enscript-keyword">for</span> (n = &amp;m-&gt;NATTraversals; *n; n=&amp;(*n)-&gt;next)
    {
        <span class="enscript-keyword">if</span> (traversal == *n)
        {
            LogFatalError(<span class="enscript-string">&quot;Error! Tried to add a NAT traversal that's already in the active list: request %p Prot %d Int %d TTL %d&quot;</span>,
                   traversal, traversal-&gt;Protocol, mDNSVal16(traversal-&gt;IntPort), traversal-&gt;NATLease);
            <span class="enscript-keyword">return</span>(mStatus_AlreadyRegistered);
        }
        <span class="enscript-keyword">if</span> (traversal-&gt;Protocol &amp;&amp; traversal-&gt;Protocol == (*n)-&gt;Protocol &amp;&amp; mDNSSameIPPort(traversal-&gt;IntPort, (*n)-&gt;IntPort) &amp;&amp;
            !mDNSSameIPPort(traversal-&gt;IntPort, SSHPort))
            LogMsg(<span class="enscript-string">&quot;Warning: Created port mapping request %p Prot %d Int %d TTL %d &quot;</span>
                   <span class="enscript-string">&quot;duplicates existing port mapping request %p Prot %d Int %d TTL %d&quot;</span>,
                   traversal, traversal-&gt;Protocol, mDNSVal16(traversal-&gt;IntPort), traversal-&gt;NATLease,
                   *n,        (*n)-&gt;Protocol, mDNSVal16((*n)-&gt;IntPort), (*n)-&gt;NATLease);
    }

    <span class="enscript-comment">// Initialize necessary fields
</span>    traversal-&gt;next            = mDNSNULL;
    traversal-&gt;ExpiryTime      = 0;
    traversal-&gt;retryInterval   = NATMAP_INIT_RETRY;
    traversal-&gt;retryPortMap    = m-&gt;timenow;
    traversal-&gt;NewResult       = mStatus_NoError;
    traversal-&gt;lastSuccessfulProtocol = NATTProtocolNone;
    traversal-&gt;sentNATPMP      = mDNSfalse;
    traversal-&gt;ExternalAddress = onesIPv4Addr;
    traversal-&gt;NewAddress      = zerov4Addr;
    traversal-&gt;ExternalPort    = zeroIPPort;
    traversal-&gt;Lifetime        = 0;
    traversal-&gt;Result          = mStatus_NoError;

    <span class="enscript-comment">// set default lease if necessary
</span>    <span class="enscript-keyword">if</span> (!traversal-&gt;NATLease) traversal-&gt;NATLease = NATMAP_DEFAULT_LEASE;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    mDNSPlatformMemZero(&amp;traversal-&gt;tcpInfo, <span class="enscript-keyword">sizeof</span>(traversal-&gt;tcpInfo));
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

    <span class="enscript-keyword">if</span> (!m-&gt;NATTraversals)      <span class="enscript-comment">// If this is our first NAT request, kick off an address request too
</span>    {
        m-&gt;retryGetAddr         = m-&gt;timenow;
        m-&gt;retryIntervalGetAddr = NATMAP_INIT_RETRY;
    }

    <span class="enscript-comment">// If this is an address-only operation, initialize to the current global address,
</span>    <span class="enscript-comment">// or (in non-PCP environments) we won't know the address until the next external
</span>    <span class="enscript-comment">// address request/response.
</span>    <span class="enscript-keyword">if</span> (!traversal-&gt;Protocol)
    {
        traversal-&gt;NewAddress = m-&gt;ExtAddress;
    }

    m-&gt;NextScheduledNATOp = m-&gt;timenow; <span class="enscript-comment">// This will always trigger sending the packet ASAP, and generate client callback if necessary
</span>
    *n = traversal;     <span class="enscript-comment">// Append new NATTraversalInfo to the end of our list
</span>
    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

<span class="enscript-comment">// Must be called with the mDNS_Lock held
</span>mDNSexport mStatus <span class="enscript-function-name">mDNS_StopNATOperation_internal</span>(mDNS *m, NATTraversalInfo *traversal)
{
    mDNSBool unmap = mDNStrue;
    NATTraversalInfo *p;
    NATTraversalInfo **ptr = &amp;m-&gt;NATTraversals;

    <span class="enscript-keyword">while</span> (*ptr &amp;&amp; *ptr != traversal) ptr=&amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (*ptr) *ptr = (*ptr)-&gt;next;      <span class="enscript-comment">// If we found it, cut this NATTraversalInfo struct from our list
</span>    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_StopNATOperation_internal: NATTraversalInfo %p not found in list&quot;</span>, traversal);
        <span class="enscript-keyword">return</span>(mStatus_BadReferenceErr);
    }

    LogInfo(<span class="enscript-string">&quot;mDNS_StopNATOperation_internal %p %d %d %d %d&quot;</span>, traversal,
            traversal-&gt;Protocol, mDNSVal16(traversal-&gt;IntPort), mDNSVal16(traversal-&gt;RequestedPort), traversal-&gt;NATLease);

    <span class="enscript-keyword">if</span> (m-&gt;CurrentNATTraversal == traversal)
        m-&gt;CurrentNATTraversal = m-&gt;CurrentNATTraversal-&gt;next;

    <span class="enscript-comment">// If there is a match for the operation being stopped, don't send a deletion request (unmap)
</span>    <span class="enscript-keyword">for</span> (p = m-&gt;NATTraversals; p; p=p-&gt;next)
    {
        <span class="enscript-keyword">if</span> (traversal-&gt;Protocol ?
            ((traversal-&gt;Protocol == p-&gt;Protocol &amp;&amp; mDNSSameIPPort(traversal-&gt;IntPort, p-&gt;IntPort)) ||
             (!p-&gt;Protocol &amp;&amp; traversal-&gt;Protocol == NATOp_MapTCP &amp;&amp; mDNSSameIPPort(traversal-&gt;IntPort, DiscardPort))) :
            (!p-&gt;Protocol || (p-&gt;Protocol == NATOp_MapTCP &amp;&amp; mDNSSameIPPort(p-&gt;IntPort, DiscardPort))))
        {
            LogInfo(<span class="enscript-string">&quot;Warning: Removed port mapping request %p Prot %d Int %d TTL %d &quot;</span>
                    <span class="enscript-string">&quot;duplicates existing port mapping request %p Prot %d Int %d TTL %d&quot;</span>,
                    traversal, traversal-&gt;Protocol, mDNSVal16(traversal-&gt;IntPort), traversal-&gt;NATLease,
                            p,         p-&gt;Protocol, mDNSVal16(        p-&gt;IntPort),         p-&gt;NATLease);
            unmap = mDNSfalse;
        }
    }

    <span class="enscript-comment">// Even if we DIDN'T make a successful UPnP mapping yet, we might still have a partially-open TCP connection we need to clean up
</span>    <span class="enscript-comment">// Before zeroing traversal-&gt;RequestedPort below, perform the LNT unmapping, which requires the mapping's external port,
</span>    <span class="enscript-comment">// held by the traversal-&gt;RequestedPort variable.
</span>    #ifdef _LEGACY_NAT_TRAVERSAL_
    {
        mStatus err = LNT_UnmapPort(m, traversal);
        <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;Legacy NAT Traversal - unmap request failed with error %d&quot;</span>, err);
    }
    #endif <span class="enscript-comment">// _LEGACY_NAT_TRAVERSAL_
</span>
    <span class="enscript-keyword">if</span> (traversal-&gt;ExpiryTime &amp;&amp; unmap)
    {
        traversal-&gt;NATLease = 0;
        traversal-&gt;retryInterval = 0;

        <span class="enscript-comment">// In case we most recently sent NAT-PMP, we need to set sentNATPMP to false so
</span>        <span class="enscript-comment">// that we'll send a NAT-PMP request to destroy the mapping. We do this because
</span>        <span class="enscript-comment">// the NATTraversal struct has already been cut from the list, and the client
</span>        <span class="enscript-comment">// layer will destroy the memory upon returning from this function, so we can't
</span>        <span class="enscript-comment">// try PCP first and then fall-back to NAT-PMP. That is, if we most recently
</span>        <span class="enscript-comment">// created/renewed the mapping using NAT-PMP, we need to destroy it using NAT-PMP
</span>        <span class="enscript-comment">// now, because we won't get a chance later.
</span>        traversal-&gt;sentNATPMP = mDNSfalse;

        <span class="enscript-comment">// Both NAT-PMP &amp; PCP RFCs state that the suggested port in deletion requests
</span>        <span class="enscript-comment">// should be zero. And for PCP, the suggested external address should also be
</span>        <span class="enscript-comment">// zero, specifically, the all-zeros IPv4-mapped address, since we would only
</span>        <span class="enscript-comment">// would have requested an IPv4 address.
</span>        traversal-&gt;RequestedPort = zeroIPPort;
        traversal-&gt;NewAddress = zerov4Addr;

        uDNS_SendNATMsg(m, traversal, traversal-&gt;lastSuccessfulProtocol != NATTProtocolNATPMP, mDNStrue);
    }

    <span class="enscript-keyword">return</span>(mStatus_NoError);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_StartNATOperation_internal(m, traversal);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StopNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal)
{
    mStatus status;
    mDNS_Lock(m);
    status = mDNS_StopNATOperation_internal(m, traversal);
    mDNS_Unlock(m);
    <span class="enscript-keyword">return</span>(status);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Long</span>-<span class="enscript-variable-name">Lived</span> <span class="enscript-variable-name">Queries</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Lock must be held -- otherwise m-&gt;timenow is undefined
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">StartLLQPolling</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    debugf(<span class="enscript-string">&quot;StartLLQPolling: %##s&quot;</span>, q-&gt;qname.c);
    q-&gt;state = LLQ_Poll;
    q-&gt;ThisQInterval = INIT_UCAST_POLL_INTERVAL;
    <span class="enscript-comment">// We want to send our poll query ASAP, but the &quot;+ 1&quot; is because if we set the time to now,
</span>    <span class="enscript-comment">// we risk causing spurious &quot;SendQueries didn't send all its queries&quot; log messages
</span>    q-&gt;LastQTime     = m-&gt;timenow - q-&gt;ThisQInterval + 1;
    SetNextQueryTime(m, q);
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">putLLQ</span>(DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> question, <span class="enscript-type">const</span> LLQOptData *<span class="enscript-type">const</span> data)
{
    AuthRecord rr;
    ResourceRecord *opt = &amp;rr.resrec;
    rdataOPT *optRD;

    <span class="enscript-comment">//!!!KRS when we implement multiple llqs per message, we'll need to memmove anything past the question section
</span>    ptr = putQuestion(msg, ptr, msg-&gt;data + AbsoluteMaxDNSMessageData, &amp;question-&gt;qname, question-&gt;qtype, question-&gt;qclass);
    <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;ERROR: putLLQ - putQuestion&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }

    <span class="enscript-comment">// locate OptRR if it exists, set pointer to end
</span>    <span class="enscript-comment">// !!!KRS implement me
</span>
    <span class="enscript-comment">// format opt rr (fields not specified are zero-valued)
</span>    mDNS_SetupResourceRecord(&amp;rr, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    opt-&gt;rrclass    = NormalMaxDNSMessageData;
    opt-&gt;rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT); <span class="enscript-comment">// One option in this OPT record
</span>    opt-&gt;rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);

    optRD = &amp;rr.resrec.rdata-&gt;u.opt[0];
    optRD-&gt;opt = kDNSOpt_LLQ;
    optRD-&gt;u.llq = *data;
    ptr = PutResourceRecordTTLJumbo(msg, ptr, &amp;msg-&gt;h.numAdditionals, opt, 0);
    <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;ERROR: putLLQ - PutResourceRecordTTLJumbo&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }

    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">// Normally we'd just request event packets be sent directly to m-&gt;LLQNAT.ExternalPort, except...
</span><span class="enscript-comment">// with LLQs over TLS/TCP we're doing a weird thing where instead of requesting packets be sent to ExternalAddress:ExternalPort
</span><span class="enscript-comment">// we're requesting that packets be sent to ExternalPort, but at the source address of our outgoing TCP connection.
</span><span class="enscript-comment">// Normally, after going through the NAT gateway, the source address of our outgoing TCP connection is the same as ExternalAddress,
</span><span class="enscript-comment">// so this is fine, except when the TCP connection ends up going over a VPN tunnel instead.
</span><span class="enscript-comment">// To work around this, if we find that the source address for our TCP connection is not a private address, we tell the Dot Mac
</span><span class="enscript-comment">// LLQ server to send events to us directly at port 5353 on that address, instead of at our mapped external NAT port.
</span>
mDNSlocal mDNSu16 <span class="enscript-function-name">GetLLQEventPort</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dst)
{
    mDNSAddr src;
    mDNSPlatformSourceAddrForDest(&amp;src, dst);
    <span class="enscript-comment">//LogMsg(&quot;GetLLQEventPort: src %#a for dst %#a (%d)&quot;, &amp;src, dst, mDNSv4AddrIsRFC1918(&amp;src.ip.v4) ? mDNSVal16(m-&gt;LLQNAT.ExternalPort) : 0);
</span>    <span class="enscript-keyword">return</span>(mDNSv4AddrIsRFC1918(&amp;src.ip.v4) ? mDNSVal16(m-&gt;LLQNAT.ExternalPort) : mDNSVal16(MulticastDNSPort));
}

<span class="enscript-comment">// Normally called with llq set.
</span><span class="enscript-comment">// May be called with llq NULL, when retransmitting a lost Challenge Response
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">sendChallengeResponse</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> LLQOptData *llq)
{
    mDNSu8 *responsePtr = m-&gt;omsg.data;
    LLQOptData llqBuf;

    <span class="enscript-keyword">if</span> (q-&gt;tcp) { LogMsg(<span class="enscript-string">&quot;sendChallengeResponse: ERROR!!: question %##s (%s) tcp non-NULL&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (q-&gt;ntries++ == kLLQ_MAX_TRIES)
    {
        LogMsg(<span class="enscript-string">&quot;sendChallengeResponse: %d failed attempts for LLQ %##s&quot;</span>, kLLQ_MAX_TRIES, q-&gt;qname.c);
        StartLLQPolling(m,q);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (!llq)       <span class="enscript-comment">// Retransmission: need to make a new LLQOptData
</span>    {
        llqBuf.vers     = kLLQ_Vers;
        llqBuf.llqOp    = kLLQOp_Setup;
        llqBuf.err      = LLQErr_NoError;   <span class="enscript-comment">// Don't need to tell server UDP notification port when sending over UDP
</span>        llqBuf.id       = q-&gt;id;
        llqBuf.llqlease = q-&gt;ReqLease;
        llq = &amp;llqBuf;
    }

    q-&gt;LastQTime     = m-&gt;timenow;
    q-&gt;ThisQInterval = q-&gt;tcp ? 0 : (kLLQ_INIT_RESEND * q-&gt;ntries * mDNSPlatformOneSecond);     <span class="enscript-comment">// If using TCP, don't need to retransmit
</span>    SetNextQueryTime(m, q);

    <span class="enscript-comment">// To simulate loss of challenge response packet, uncomment line below
</span>    <span class="enscript-comment">//if (q-&gt;ntries == 1) return;
</span>
    InitializeDNSMessage(&amp;m-&gt;omsg.h, q-&gt;TargetQID, uQueryFlags);
    responsePtr = putLLQ(&amp;m-&gt;omsg, responsePtr, q, llq);
    <span class="enscript-keyword">if</span> (responsePtr)
    {
        mStatus err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, responsePtr, mDNSInterface_Any, mDNSNULL, q-&gt;LocalSocket, &amp;q-&gt;servAddr, q-&gt;servPort, mDNSNULL, mDNSfalse);
        <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;sendChallengeResponse: mDNSSendDNSMessage%s failed: %d&quot;</span>, q-&gt;tcp ? <span class="enscript-string">&quot; (TCP)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, err); }
    }
    <span class="enscript-keyword">else</span> StartLLQPolling(m,q);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetLLQTimer</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> LLQOptData *<span class="enscript-type">const</span> llq)
{
    mDNSs32 lease = (mDNSs32)llq-&gt;llqlease * mDNSPlatformOneSecond;
    q-&gt;ReqLease      = llq-&gt;llqlease;
    q-&gt;LastQTime     = m-&gt;timenow;
    q-&gt;expire        = m-&gt;timenow + lease;
    q-&gt;ThisQInterval = lease/2 + mDNSRandom(lease/10);
    debugf(<span class="enscript-string">&quot;SetLLQTimer setting %##s (%s) to %d %d&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), lease/mDNSPlatformOneSecond, q-&gt;ThisQInterval/mDNSPlatformOneSecond);
    SetNextQueryTime(m, q);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">recvSetupResponse</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu8 rcode, DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> LLQOptData *<span class="enscript-type">const</span> llq)
{
    <span class="enscript-keyword">if</span> (rcode &amp;&amp; rcode != kDNSFlag1_RC_NXDomain)
    { LogMsg(<span class="enscript-string">&quot;ERROR: recvSetupResponse %##s (%s) - rcode &amp;&amp; rcode != kDNSFlag1_RC_NXDomain&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (llq-&gt;llqOp != kLLQOp_Setup)
    { LogMsg(<span class="enscript-string">&quot;ERROR: recvSetupResponse %##s (%s) - bad op %d&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), llq-&gt;llqOp); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (llq-&gt;vers != kLLQ_Vers)
    { LogMsg(<span class="enscript-string">&quot;ERROR: recvSetupResponse %##s (%s) - bad vers %d&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), llq-&gt;vers); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (q-&gt;state == LLQ_InitialRequest)
    {
        <span class="enscript-comment">//LogInfo(&quot;Got LLQ_InitialRequest&quot;);
</span>
        <span class="enscript-keyword">if</span> (llq-&gt;err) { LogMsg(<span class="enscript-string">&quot;recvSetupResponse - received llq-&gt;err %d from server&quot;</span>, llq-&gt;err); StartLLQPolling(m,q); <span class="enscript-keyword">return</span>; }

        <span class="enscript-keyword">if</span> (q-&gt;ReqLease != llq-&gt;llqlease)
            debugf(<span class="enscript-string">&quot;recvSetupResponse: requested lease %lu, granted lease %lu&quot;</span>, q-&gt;ReqLease, llq-&gt;llqlease);

        <span class="enscript-comment">// cache expiration in case we go to sleep before finishing setup
</span>        q-&gt;ReqLease = llq-&gt;llqlease;
        q-&gt;expire = m-&gt;timenow + ((mDNSs32)llq-&gt;llqlease * mDNSPlatformOneSecond);

        <span class="enscript-comment">// update state
</span>        q-&gt;state  = LLQ_SecondaryRequest;
        q-&gt;id     = llq-&gt;id;
        q-&gt;ntries = 0; <span class="enscript-comment">// first attempt to send response
</span>        sendChallengeResponse(m, q, llq);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q-&gt;state == LLQ_SecondaryRequest)
    {
        <span class="enscript-keyword">if</span> (llq-&gt;err) { LogMsg(<span class="enscript-string">&quot;ERROR: recvSetupResponse %##s (%s) code %d from server&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), llq-&gt;err); StartLLQPolling(m,q); <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">if</span> (!mDNSSameOpaque64(&amp;q-&gt;id, &amp;llq-&gt;id))
        { LogMsg(<span class="enscript-string">&quot;recvSetupResponse - ID changed.  discarding&quot;</span>); <span class="enscript-keyword">return</span>; }     <span class="enscript-comment">// this can happen rarely (on packet loss + reordering)
</span>        q-&gt;state         = LLQ_Established;
        q-&gt;ntries        = 0;
        SetLLQTimer(m, q, llq);
    }
}

mDNSexport uDNS_LLQType <span class="enscript-function-name">uDNS_recvLLQResponse</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                             <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, DNSQuestion **matchQuestion)
{
    DNSQuestion pktQ, *q;
    <span class="enscript-keyword">if</span> (msg-&gt;h.numQuestions &amp;&amp; getQuestion(msg, msg-&gt;data, end, 0, &amp;pktQ))
    {
        <span class="enscript-type">const</span> rdataOPT *opt = GetLLQOptData(m, msg, end);

        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;TargetQID) &amp;&amp; q-&gt;LongLived &amp;&amp; q-&gt;qtype == pktQ.qtype &amp;&amp; q-&gt;qnamehash == pktQ.qnamehash &amp;&amp; SameDomainName(&amp;q-&gt;qname, &amp;pktQ.qname))
            {
                debugf(<span class="enscript-string">&quot;uDNS_recvLLQResponse found %##s (%s) %d %#a %#a %X %X %X %X %d&quot;</span>,
                       q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;state, srcaddr, &amp;q-&gt;servAddr,
                       opt ? opt-&gt;u.llq.id.l[0] : 0, opt ? opt-&gt;u.llq.id.l[1] : 0, q-&gt;id.l[0], q-&gt;id.l[1], opt ? opt-&gt;u.llq.llqOp : 0);
                <span class="enscript-keyword">if</span> (q-&gt;state == LLQ_Poll) debugf(<span class="enscript-string">&quot;uDNS_LLQ_Events: q-&gt;state == LLQ_Poll msg-&gt;h.id %d q-&gt;TargetQID %d&quot;</span>, mDNSVal16(msg-&gt;h.id), mDNSVal16(q-&gt;TargetQID));
                <span class="enscript-keyword">if</span> (q-&gt;state == LLQ_Poll &amp;&amp; mDNSSameOpaque16(msg-&gt;h.id, q-&gt;TargetQID))
                {
                    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>
                    <span class="enscript-comment">// Don't reset the state to IntialRequest as we may write that to the dynamic store
</span>                    <span class="enscript-comment">// and PrefPane might wrongly think that we are &quot;Starting&quot; instead of &quot;Polling&quot;. If
</span>                    <span class="enscript-comment">// we are in polling state because of PCP/NAT-PMP disabled or DoubleNAT, next LLQNATCallback
</span>                    <span class="enscript-comment">// would kick us back to LLQInitialRequest. So, resetting the state here may not be useful.
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// If we have a good NAT (neither PCP/NAT-PMP disabled nor Double-NAT), then we should not be
</span>                    <span class="enscript-comment">// possibly in polling state. To be safe, we want to retry from the start in that case
</span>                    <span class="enscript-comment">// as there may not be another LLQNATCallback
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// NOTE: We can be in polling state if we cannot resolve the SOA record i.e, servAddr is set to
</span>                    <span class="enscript-comment">// all ones. In that case, we would set it in LLQ_InitialRequest as it overrides the PCP/NAT-PMP or
</span>                    <span class="enscript-comment">// Double-NAT state.
</span>                    <span class="enscript-keyword">if</span> (!mDNSAddressIsOnes(&amp;q-&gt;servAddr) &amp;&amp; !mDNSIPPortIsZero(m-&gt;LLQNAT.ExternalPort) &amp;&amp;
                        !m-&gt;LLQNAT.Result)
                    {
                        debugf(<span class="enscript-string">&quot;uDNS_recvLLQResponse got poll response; moving to LLQ_InitialRequest for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
                        q-&gt;state         = LLQ_InitialRequest;
                    }
                    q-&gt;servPort      = zeroIPPort;      <span class="enscript-comment">// Clear servPort so that startLLQHandshake will retry the GetZoneData processing
</span>                    q-&gt;ThisQInterval = LLQ_POLL_INTERVAL + mDNSRandom(LLQ_POLL_INTERVAL/10);    <span class="enscript-comment">// Retry LLQ setup in approx 15 minutes
</span>                    q-&gt;LastQTime     = m-&gt;timenow;
                    SetNextQueryTime(m, q);
                    *matchQuestion = q;
                    <span class="enscript-keyword">return</span> uDNS_LLQ_Entire;     <span class="enscript-comment">// uDNS_LLQ_Entire means flush stale records; assume a large effective TTL
</span>                }
                <span class="enscript-comment">// Note: In LLQ Event packets, the msg-&gt;h.id does not match our q-&gt;TargetQID, because in that case the msg-&gt;h.id nonce is selected by the server
</span>                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opt &amp;&amp; q-&gt;state == LLQ_Established &amp;&amp; opt-&gt;u.llq.llqOp == kLLQOp_Event &amp;&amp; mDNSSameOpaque64(&amp;opt-&gt;u.llq.id, &amp;q-&gt;id))
                {
                    mDNSu8 *ackEnd;
                    <span class="enscript-comment">//debugf(&quot;Sending LLQ ack for %##s (%s)&quot;, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
</span>                    InitializeDNSMessage(&amp;m-&gt;omsg.h, msg-&gt;h.id, ResponseFlags);
                    ackEnd = putLLQ(&amp;m-&gt;omsg, m-&gt;omsg.data, q, &amp;opt-&gt;u.llq);
                    <span class="enscript-keyword">if</span> (ackEnd) mDNSSendDNSMessage(m, &amp;m-&gt;omsg, ackEnd, mDNSInterface_Any, mDNSNULL, q-&gt;LocalSocket, srcaddr, srcport, mDNSNULL, mDNSfalse);
                    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                    debugf(<span class="enscript-string">&quot;uDNS_LLQ_Events: q-&gt;state == LLQ_Established msg-&gt;h.id %d q-&gt;TargetQID %d&quot;</span>, mDNSVal16(msg-&gt;h.id), mDNSVal16(q-&gt;TargetQID));
                    *matchQuestion = q;
                    <span class="enscript-keyword">return</span> uDNS_LLQ_Events;
                }
                <span class="enscript-keyword">if</span> (opt &amp;&amp; mDNSSameOpaque16(msg-&gt;h.id, q-&gt;TargetQID))
                {
                    <span class="enscript-keyword">if</span> (q-&gt;state == LLQ_Established &amp;&amp; opt-&gt;u.llq.llqOp == kLLQOp_Refresh &amp;&amp; mDNSSameOpaque64(&amp;opt-&gt;u.llq.id, &amp;q-&gt;id) &amp;&amp; msg-&gt;h.numAdditionals &amp;&amp; !msg-&gt;h.numAnswers)
                    {
                        <span class="enscript-keyword">if</span> (opt-&gt;u.llq.err != LLQErr_NoError) LogMsg(<span class="enscript-string">&quot;recvRefreshReply: received error %d from server&quot;</span>, opt-&gt;u.llq.err);
                        <span class="enscript-keyword">else</span>
                        {
                            <span class="enscript-comment">//LogInfo(&quot;Received refresh confirmation ntries %d for %##s (%s)&quot;, q-&gt;ntries, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
</span>                            <span class="enscript-comment">// If we're waiting to go to sleep, then this LLQ deletion may have been the thing
</span>                            <span class="enscript-comment">// we were waiting for, so schedule another check to see if we can sleep now.
</span>                            <span class="enscript-keyword">if</span> (opt-&gt;u.llq.llqlease == 0 &amp;&amp; m-&gt;SleepLimit) m-&gt;NextScheduledSPRetry = m-&gt;timenow;
                            GrantCacheExtensions(m, q, opt-&gt;u.llq.llqlease);
                            SetLLQTimer(m, q, &amp;opt-&gt;u.llq);
                            q-&gt;ntries = 0;
                        }
                        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                        *matchQuestion = q;
                        <span class="enscript-keyword">return</span> uDNS_LLQ_Ignore;
                    }
                    <span class="enscript-keyword">if</span> (q-&gt;state &lt; LLQ_Established &amp;&amp; mDNSSameAddress(srcaddr, &amp;q-&gt;servAddr))
                    {
                        LLQ_State oldstate = q-&gt;state;
                        recvSetupResponse(m, msg-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask, q, &amp;opt-&gt;u.llq);
                        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                        <span class="enscript-comment">// We have a protocol anomaly here in the LLQ definition.
</span>                        <span class="enscript-comment">// Both the challenge packet from the server and the ack+answers packet have opt-&gt;u.llq.llqOp == kLLQOp_Setup.
</span>                        <span class="enscript-comment">// However, we need to treat them differently:
</span>                        <span class="enscript-comment">// The challenge packet has no answers in it, and tells us nothing about whether our cache entries
</span>                        <span class="enscript-comment">// are still valid, so this packet should not cause us to do anything that messes with our cache.
</span>                        <span class="enscript-comment">// The ack+answers packet gives us the whole truth, so we should handle it by updating our cache
</span>                        <span class="enscript-comment">// to match the answers in the packet, and only the answers in the packet.
</span>                        *matchQuestion = q;
                        <span class="enscript-keyword">return</span> (oldstate == LLQ_SecondaryRequest ? uDNS_LLQ_Entire : uDNS_LLQ_Ignore);
                    }
                }
            }
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }
    *matchQuestion = mDNSNULL;
    <span class="enscript-keyword">return</span> uDNS_LLQ_Not;
}

<span class="enscript-comment">// Stub definition of TCPSocket_struct so we can access flags field. (Rest of TCPSocket_struct is platform-dependent.)
</span><span class="enscript-type">struct</span> TCPSocket_struct { mDNSIPPort port; TCPSocketFlags flags; <span class="enscript-comment">/* ... */</span> };

<span class="enscript-comment">// tcpCallback is called to handle events (e.g. connection opening and data reception) on TCP connections for
</span><span class="enscript-comment">// Private DNS operations -- private queries, private LLQs, private record updates and private service updates
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">tcpCallback</span>(TCPSocket *sock, <span class="enscript-type">void</span> *context, mDNSBool ConnectionEstablished, mStatus err)
{
    tcpInfo_t *tcpInfo = (tcpInfo_t *)context;
    mDNSBool closed  = mDNSfalse;
    mDNS      *m       = tcpInfo-&gt;m;
    DNSQuestion *<span class="enscript-type">const</span> q = tcpInfo-&gt;question;
    tcpInfo_t **backpointer =
        q                 ? &amp;q-&gt;tcp :
        tcpInfo-&gt;rr       ? &amp;tcpInfo-&gt;rr-&gt;tcp : mDNSNULL;
    <span class="enscript-keyword">if</span> (backpointer &amp;&amp; *backpointer != tcpInfo)
        LogMsg(<span class="enscript-string">&quot;tcpCallback: %d backpointer %p incorrect tcpInfo %p question %p rr %p&quot;</span>,
               mDNSPlatformTCPGetFD(tcpInfo-&gt;sock), *backpointer, tcpInfo, q, tcpInfo-&gt;rr);

    <span class="enscript-keyword">if</span> (err) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">if</span> (ConnectionEstablished)
    {
        mDNSu8    *end = ((mDNSu8*) &amp;tcpInfo-&gt;request) + tcpInfo-&gt;requestLen;
        DomainAuthInfo *AuthInfo;

        <span class="enscript-comment">// Defensive coding for &lt;rdar://problem/5546824&gt; Crash in mDNSResponder at GetAuthInfoForName_internal + 366
</span>        <span class="enscript-comment">// Don't know yet what's causing this, but at least we can be cautious and try to avoid crashing if we find our pointers in an unexpected state
</span>        <span class="enscript-keyword">if</span> (tcpInfo-&gt;rr &amp;&amp; tcpInfo-&gt;rr-&gt;resrec.name != &amp;tcpInfo-&gt;rr-&gt;namestorage)
            LogMsg(<span class="enscript-string">&quot;tcpCallback: ERROR: tcpInfo-&gt;rr-&gt;resrec.name %p != &amp;tcpInfo-&gt;rr-&gt;namestorage %p&quot;</span>,
                   tcpInfo-&gt;rr-&gt;resrec.name, &amp;tcpInfo-&gt;rr-&gt;namestorage);
        <span class="enscript-keyword">if</span> (tcpInfo-&gt;rr  &amp;&amp; tcpInfo-&gt;rr-&gt;resrec.name != &amp;tcpInfo-&gt;rr-&gt;namestorage) <span class="enscript-keyword">return</span>;

        AuthInfo =  tcpInfo-&gt;rr  ? GetAuthInfoForName(m, tcpInfo-&gt;rr-&gt;resrec.name)         : mDNSNULL;

        <span class="enscript-comment">// connection is established - send the message
</span>        <span class="enscript-keyword">if</span> (q &amp;&amp; q-&gt;LongLived &amp;&amp; q-&gt;state == LLQ_Established)
        {
            <span class="enscript-comment">// Lease renewal over TCP, resulting from opening a TCP connection in sendLLQRefresh
</span>            end = ((mDNSu8*) &amp;tcpInfo-&gt;request) + tcpInfo-&gt;requestLen;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q &amp;&amp; q-&gt;LongLived &amp;&amp; q-&gt;state != LLQ_Poll &amp;&amp; !mDNSIPPortIsZero(m-&gt;LLQNAT.ExternalPort) &amp;&amp; !mDNSIPPortIsZero(q-&gt;servPort))
        {
            <span class="enscript-comment">// Notes:
</span>            <span class="enscript-comment">// If we have a NAT port mapping, ExternalPort is the external port
</span>            <span class="enscript-comment">// If we have a routable address so we don't need a port mapping, ExternalPort is the same as our own internal port
</span>            <span class="enscript-comment">// If we need a NAT port mapping but can't get one, then ExternalPort is zero
</span>            LLQOptData llqData;         <span class="enscript-comment">// set llq rdata
</span>            llqData.vers  = kLLQ_Vers;
            llqData.llqOp = kLLQOp_Setup;
            llqData.err   = GetLLQEventPort(m, &amp;tcpInfo-&gt;Addr); <span class="enscript-comment">// We're using TCP; tell server what UDP port to send notifications to
</span>            LogInfo(<span class="enscript-string">&quot;tcpCallback: eventPort %d&quot;</span>, llqData.err);
            llqData.id    = zeroOpaque64;
            llqData.llqlease = kLLQ_DefLease;
            InitializeDNSMessage(&amp;tcpInfo-&gt;request.h, q-&gt;TargetQID, uQueryFlags);
            end = putLLQ(&amp;tcpInfo-&gt;request, tcpInfo-&gt;request.data, q, &amp;llqData);
            <span class="enscript-keyword">if</span> (!end) { LogMsg(<span class="enscript-string">&quot;ERROR: tcpCallback - putLLQ&quot;</span>); err = mStatus_UnknownErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
            AuthInfo = q-&gt;AuthInfo;     <span class="enscript-comment">// Need to add TSIG to this message
</span>            q-&gt;ntries = 0; <span class="enscript-comment">// Reset ntries so that tcp/tls connection failures don't affect sendChallengeResponse failures
</span>        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (q)
        {
            <span class="enscript-comment">// LLQ Polling mode or non-LLQ uDNS over TCP
</span>            InitializeDNSMessage(&amp;tcpInfo-&gt;request.h, q-&gt;TargetQID, (DNSSECQuestion(q) ? DNSSecQFlags : uQueryFlags));
            end = putQuestion(&amp;tcpInfo-&gt;request, tcpInfo-&gt;request.data, tcpInfo-&gt;request.data + AbsoluteMaxDNSMessageData, &amp;q-&gt;qname, q-&gt;qtype, q-&gt;qclass);
            <span class="enscript-keyword">if</span> (DNSSECQuestion(q) &amp;&amp; q-&gt;qDNSServer &amp;&amp; !q-&gt;qDNSServer-&gt;isCell)
            {
                <span class="enscript-keyword">if</span> (q-&gt;ProxyQuestion)
                    end = DNSProxySetAttributes(q, &amp;tcpInfo-&gt;request.h, &amp;tcpInfo-&gt;request, end, tcpInfo-&gt;request.data + AbsoluteMaxDNSMessageData);
                <span class="enscript-keyword">else</span>
                    end = putDNSSECOption(&amp;tcpInfo-&gt;request, end, tcpInfo-&gt;request.data + AbsoluteMaxDNSMessageData);
            }

            AuthInfo = q-&gt;AuthInfo;     <span class="enscript-comment">// Need to add TSIG to this message
</span>        }

        err = mDNSSendDNSMessage(m, &amp;tcpInfo-&gt;request, end, mDNSInterface_Any, sock, mDNSNULL, &amp;tcpInfo-&gt;Addr, tcpInfo-&gt;Port, AuthInfo, mDNSfalse);
        <span class="enscript-keyword">if</span> (err) { debugf(<span class="enscript-string">&quot;ERROR: tcpCallback: mDNSSendDNSMessage - %d&quot;</span>, err); err = mStatus_UnknownErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
        <span class="enscript-keyword">if</span> (mDNSSameIPPort(tcpInfo-&gt;Port, UnicastDNSPort))
        {
            MetricsUpdateDNSQuerySize((mDNSu32)(end - (mDNSu8 *)&amp;tcpInfo-&gt;request));
        }
#<span class="enscript-reference">endif</span>

        <span class="enscript-comment">// Record time we sent this question
</span>        <span class="enscript-keyword">if</span> (q)
        {
            mDNS_Lock(m);
            q-&gt;LastQTime = m-&gt;timenow;
            <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &lt; (256 * mDNSPlatformOneSecond))   <span class="enscript-comment">// Now we have a TCP connection open, make sure we wait at least 256 seconds before retrying
</span>                q-&gt;ThisQInterval = (256 * mDNSPlatformOneSecond);
            SetNextQueryTime(m, q);
            mDNS_Unlock(m);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">long</span> n;
        <span class="enscript-type">const</span> mDNSBool Read_replylen = (tcpInfo-&gt;nread &lt; 2);  <span class="enscript-comment">// Do we need to read the replylen field first?
</span>        <span class="enscript-keyword">if</span> (Read_replylen)         <span class="enscript-comment">// First read the two-byte length preceeding the DNS message
</span>        {
            mDNSu8 *lenptr = (mDNSu8 *)&amp;tcpInfo-&gt;replylen;
            n = mDNSPlatformReadTCP(sock, lenptr + tcpInfo-&gt;nread, 2 - tcpInfo-&gt;nread, &amp;closed);
            <span class="enscript-keyword">if</span> (n &lt; 0)
            {
                LogMsg(<span class="enscript-string">&quot;ERROR: tcpCallback - attempt to read message length failed (%d)&quot;</span>, n);
                err = mStatus_ConnFailed;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (closed)
            {
                <span class="enscript-comment">// It's perfectly fine for this socket to close after the first reply. The server might
</span>                <span class="enscript-comment">// be sending gratuitous replies using UDP and doesn't have a need to leave the TCP socket open.
</span>                <span class="enscript-comment">// We'll only log this event if we've never received a reply before.
</span>                <span class="enscript-comment">// BIND 9 appears to close an idle connection after 30 seconds.
</span>                <span class="enscript-keyword">if</span> (tcpInfo-&gt;numReplies == 0)
                {
                    LogMsg(<span class="enscript-string">&quot;ERROR: socket closed prematurely tcpInfo-&gt;nread = %d&quot;</span>, tcpInfo-&gt;nread);
                    err = mStatus_ConnFailed;
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Note that we may not be doing the best thing if an error occurs after we've sent a second request
</span>                    <span class="enscript-comment">// over this tcp connection.  That is, we only track whether we've received at least one response
</span>                    <span class="enscript-comment">// which may have been to a previous request sent over this tcp connection.
</span>                    <span class="enscript-keyword">if</span> (backpointer) *backpointer = mDNSNULL; <span class="enscript-comment">// Clear client backpointer FIRST so we don't risk double-disposing our tcpInfo_t
</span>                    DisposeTCPConn(tcpInfo);
                    <span class="enscript-keyword">return</span>;
                }
            }

            tcpInfo-&gt;nread += n;
            <span class="enscript-keyword">if</span> (tcpInfo-&gt;nread &lt; 2) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

            tcpInfo-&gt;replylen = (mDNSu16)((mDNSu16)lenptr[0] &lt;&lt; 8 | lenptr[1]);
            <span class="enscript-keyword">if</span> (tcpInfo-&gt;replylen &lt; <span class="enscript-keyword">sizeof</span>(DNSMessageHeader))
            { LogMsg(<span class="enscript-string">&quot;ERROR: tcpCallback - length too short (%d bytes)&quot;</span>, tcpInfo-&gt;replylen); err = mStatus_UnknownErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }

            tcpInfo-&gt;reply = (DNSMessage *) mDNSPlatformMemAllocate(tcpInfo-&gt;replylen);
            <span class="enscript-keyword">if</span> (!tcpInfo-&gt;reply) { LogMsg(<span class="enscript-string">&quot;ERROR: tcpCallback - malloc failed&quot;</span>); err = mStatus_NoMemoryErr; <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; }
        }

        n = mDNSPlatformReadTCP(sock, ((<span class="enscript-type">char</span> *)tcpInfo-&gt;reply) + (tcpInfo-&gt;nread - 2), tcpInfo-&gt;replylen - (tcpInfo-&gt;nread - 2), &amp;closed);

        <span class="enscript-keyword">if</span> (n &lt; 0)
        {
            <span class="enscript-comment">// If this is our only read for this invokation, and it fails, then that's bad.
</span>            <span class="enscript-comment">// But if we did successfully read some or all of the replylen field this time through,
</span>            <span class="enscript-comment">// and this is now our second read from the socket, then it's expected that sometimes
</span>            <span class="enscript-comment">// there may be no more data present, and that's perfectly okay.
</span>            <span class="enscript-comment">// Assuming failure of the second read is a problem is what caused this bug:
</span>            <span class="enscript-comment">// &lt;rdar://problem/15043194&gt; mDNSResponder fails to read DNS over TCP packet correctly
</span>            <span class="enscript-keyword">if</span> (!Read_replylen) { LogMsg(<span class="enscript-string">&quot;ERROR: tcpCallback - read returned %d&quot;</span>, n); err = mStatus_ConnFailed; }
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (closed)
        {
            <span class="enscript-keyword">if</span> (tcpInfo-&gt;numReplies == 0)
            {
                LogMsg(<span class="enscript-string">&quot;ERROR: socket closed prematurely tcpInfo-&gt;nread = %d&quot;</span>, tcpInfo-&gt;nread);
                err = mStatus_ConnFailed;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Note that we may not be doing the best thing if an error occurs after we've sent a second request
</span>                <span class="enscript-comment">// over this tcp connection.  That is, we only track whether we've received at least one response
</span>                <span class="enscript-comment">// which may have been to a previous request sent over this tcp connection.
</span>                <span class="enscript-keyword">if</span> (backpointer) *backpointer = mDNSNULL; <span class="enscript-comment">// Clear client backpointer FIRST so we don't risk double-disposing our tcpInfo_t
</span>                DisposeTCPConn(tcpInfo);
                <span class="enscript-keyword">return</span>;
            }
        }

        tcpInfo-&gt;nread += n;

        <span class="enscript-keyword">if</span> ((tcpInfo-&gt;nread - 2) == tcpInfo-&gt;replylen)
        {
            mDNSBool tls;
            DNSMessage *reply = tcpInfo-&gt;reply;
            mDNSu8     *end   = (mDNSu8 *)tcpInfo-&gt;reply + tcpInfo-&gt;replylen;
            mDNSAddr Addr  = tcpInfo-&gt;Addr;
            mDNSIPPort Port  = tcpInfo-&gt;Port;
            mDNSIPPort srcPort = zeroIPPort;
            tcpInfo-&gt;numReplies++;
            tcpInfo-&gt;reply    = mDNSNULL;   <span class="enscript-comment">// Detach reply buffer from tcpInfo_t, to make sure client callback can't cause it to be disposed
</span>            tcpInfo-&gt;nread    = 0;
            tcpInfo-&gt;replylen = 0;

            <span class="enscript-comment">// If we're going to dispose this connection, do it FIRST, before calling client callback
</span>            <span class="enscript-comment">// Note: Sleep code depends on us clearing *backpointer here -- it uses the clearing of rr-&gt;tcp
</span>            <span class="enscript-comment">// as the signal that the DNS deregistration operation with the server has completed, and the machine may now sleep
</span>            <span class="enscript-comment">// If we clear the tcp pointer in the question, mDNSCoreReceiveResponse cannot find a matching question. Hence
</span>            <span class="enscript-comment">// we store the minimal information i.e., the source port of the connection in the question itself.
</span>            <span class="enscript-comment">// Dereference sock before it is disposed in DisposeTCPConn below.
</span>
            <span class="enscript-keyword">if</span> (sock-&gt;flags &amp; kTCPSocketFlags_UseTLS) tls = mDNStrue;
            <span class="enscript-keyword">else</span> tls = mDNSfalse;

            <span class="enscript-keyword">if</span> (q &amp;&amp; q-&gt;tcp) {srcPort = q-&gt;tcp-&gt;SrcPort; q-&gt;tcpSrcPort = srcPort;}

            <span class="enscript-keyword">if</span> (backpointer)
                <span class="enscript-keyword">if</span> (!q || !q-&gt;LongLived || m-&gt;SleepState)
                { *backpointer = mDNSNULL; DisposeTCPConn(tcpInfo); }

            mDNSCoreReceive(m, reply, end, &amp;Addr, Port, tls ? (mDNSAddr *)1 : mDNSNULL, srcPort, 0);
            <span class="enscript-comment">// USE CAUTION HERE: Invoking mDNSCoreReceive may have caused the environment to change, including canceling this operation itself
</span>
            mDNSPlatformMemFree(reply);
            <span class="enscript-keyword">return</span>;
        }
    }

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">if</span> (err)
    {
        <span class="enscript-comment">// Clear client backpointer FIRST -- that way if one of the callbacks cancels its operation
</span>        <span class="enscript-comment">// we won't end up double-disposing our tcpInfo_t
</span>        <span class="enscript-keyword">if</span> (backpointer) *backpointer = mDNSNULL;

        mDNS_Lock(m);       <span class="enscript-comment">// Need to grab the lock to get m-&gt;timenow
</span>
        <span class="enscript-keyword">if</span> (q)
        {
            <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval == 0)
            {
                <span class="enscript-comment">// We get here when we fail to establish a new TCP/TLS connection that would have been used for a new LLQ request or an LLQ renewal.
</span>                <span class="enscript-comment">// Note that ThisQInterval is also zero when sendChallengeResponse resends the LLQ request on an extant TCP/TLS connection.
</span>                q-&gt;LastQTime = m-&gt;timenow;
                <span class="enscript-keyword">if</span> (q-&gt;LongLived)
                {
                    <span class="enscript-comment">// We didn't get the chance to send our request packet before the TCP/TLS connection failed.
</span>                    <span class="enscript-comment">// We want to retry quickly, but want to back off exponentially in case the server is having issues.
</span>                    <span class="enscript-comment">// Since ThisQInterval was 0, we can't just multiply by QuestionIntervalStep, we must track the number
</span>                    <span class="enscript-comment">// of TCP/TLS connection failures using ntries.
</span>                    mDNSu32 count = q-&gt;ntries + 1; <span class="enscript-comment">// want to wait at least 1 second before retrying
</span>
                    q-&gt;ThisQInterval = InitialQuestionInterval;

                    <span class="enscript-keyword">for</span> (; count; count--)
                        q-&gt;ThisQInterval *= QuestionIntervalStep;

                    <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &gt; LLQ_POLL_INTERVAL)
                        q-&gt;ThisQInterval = LLQ_POLL_INTERVAL;
                    <span class="enscript-keyword">else</span>
                        q-&gt;ntries++;

                    LogMsg(<span class="enscript-string">&quot;tcpCallback: stream connection for LLQ %##s (%s) failed %d times, retrying in %d ms&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;ntries, q-&gt;ThisQInterval);
                }
                <span class="enscript-keyword">else</span>
                {
                    q-&gt;ThisQInterval = MAX_UCAST_POLL_INTERVAL;
                    LogMsg(<span class="enscript-string">&quot;tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;ThisQInterval);
                }
                SetNextQueryTime(m, q);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NextQSendTime(q) - m-&gt;timenow &gt; (q-&gt;LongLived ? LLQ_POLL_INTERVAL : MAX_UCAST_POLL_INTERVAL))
            {
                <span class="enscript-comment">// If we get an error and our next scheduled query for this question is more than the max interval from now,
</span>                <span class="enscript-comment">// reset the next query to ensure we wait no longer the maximum interval from now before trying again.
</span>                q-&gt;LastQTime     = m-&gt;timenow;
                q-&gt;ThisQInterval = q-&gt;LongLived ? LLQ_POLL_INTERVAL : MAX_UCAST_POLL_INTERVAL;
                SetNextQueryTime(m, q);
                LogMsg(<span class="enscript-string">&quot;tcpCallback: stream connection for %##s (%s) failed, retrying in %d ms&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;ThisQInterval);
            }

            <span class="enscript-comment">// We're about to dispose of the TCP connection, so we must reset the state to retry over TCP/TLS
</span>            <span class="enscript-comment">// because sendChallengeResponse will send the query via UDP if we don't have a tcp pointer.
</span>            <span class="enscript-comment">// Resetting to LLQ_InitialRequest will cause uDNS_CheckCurrentQuestion to call startLLQHandshake, which
</span>            <span class="enscript-comment">// will attempt to establish a new tcp connection.
</span>            <span class="enscript-keyword">if</span> (q-&gt;LongLived &amp;&amp; q-&gt;state == LLQ_SecondaryRequest)
                q-&gt;state = LLQ_InitialRequest;

            <span class="enscript-comment">// ConnFailed may happen if the server sends a TCP reset or TLS fails, in which case we want to retry establishing the LLQ
</span>            <span class="enscript-comment">// quickly rather than switching to polling mode.  This case is handled by the above code to set q-&gt;ThisQInterval just above.
</span>            <span class="enscript-comment">// If the error isn't ConnFailed, then the LLQ is in bad shape, so we switch to polling mode.
</span>            <span class="enscript-keyword">if</span> (err != mStatus_ConnFailed)
            {
                <span class="enscript-keyword">if</span> (q-&gt;LongLived &amp;&amp; q-&gt;state != LLQ_Poll) StartLLQPolling(m, q);
            }
        }

        mDNS_Unlock(m);

        DisposeTCPConn(tcpInfo);
    }
}

mDNSlocal tcpInfo_t *<span class="enscript-function-name">MakeTCPConn</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                 TCPSocketFlags flags, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> Addr, <span class="enscript-type">const</span> mDNSIPPort Port, domainname *hostname,
                                 DNSQuestion *<span class="enscript-type">const</span> question, AuthRecord *<span class="enscript-type">const</span> rr)
{
    mStatus err;
    mDNSIPPort srcport = zeroIPPort;
    tcpInfo_t *info;
    mDNSBool useBackgroundTrafficClass;

    useBackgroundTrafficClass = question ? question-&gt;UseBackgroundTraffic : mDNSfalse;

    <span class="enscript-keyword">if</span> ((flags &amp; kTCPSocketFlags_UseTLS) &amp;&amp; (!hostname || !hostname-&gt;c[0]))
    { LogMsg(<span class="enscript-string">&quot;MakeTCPConn: TLS connection being setup with NULL hostname&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }

    info = (tcpInfo_t *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*info));
    <span class="enscript-keyword">if</span> (!info) { LogMsg(<span class="enscript-string">&quot;ERROR: MakeTCP - memallocate failed&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    info-&gt;m          = m;
    info-&gt;sock       = mDNSPlatformTCPSocket(flags, Addr-&gt;type, &amp;srcport, hostname, useBackgroundTrafficClass);
    info-&gt;requestLen = 0;
    info-&gt;question   = question;
    info-&gt;rr         = rr;
    info-&gt;Addr       = *Addr;
    info-&gt;Port       = Port;
    info-&gt;reply      = mDNSNULL;
    info-&gt;replylen   = 0;
    info-&gt;nread      = 0;
    info-&gt;numReplies = 0;
    info-&gt;SrcPort = srcport;

    <span class="enscript-keyword">if</span> (msg)
    {
        info-&gt;requestLen = (<span class="enscript-type">int</span>) (end - ((mDNSu8*)msg));
        mDNSPlatformMemCopy(&amp;info-&gt;request, msg, info-&gt;requestLen);
    }

    <span class="enscript-keyword">if</span> (!info-&gt;sock) { LogMsg(<span class="enscript-string">&quot;MakeTCPConn: unable to create TCP socket&quot;</span>); mDNSPlatformMemFree(info); <span class="enscript-keyword">return</span>(mDNSNULL); }
    mDNSPlatformSetSocktOpt(info-&gt;sock, mDNSTransport_TCP, Addr-&gt;type, question);
    err = mDNSPlatformTCPConnect(info-&gt;sock, Addr, Port, (question ? question-&gt;InterfaceID : mDNSNULL), tcpCallback, info);

    <span class="enscript-comment">// Probably suboptimal here.
</span>    <span class="enscript-comment">// Instead of returning mDNSNULL here on failure, we should probably invoke the callback with an error code.
</span>    <span class="enscript-comment">// That way clients can put all the error handling and retry/recovery code in one place,
</span>    <span class="enscript-comment">// instead of having to handle immediate errors in one place and async errors in another.
</span>    <span class="enscript-comment">// Also: &quot;err == mStatus_ConnEstablished&quot; probably never happens.
</span>
    <span class="enscript-comment">// Don't need to log &quot;connection failed&quot; in customer builds -- it happens quite often during sleep, wake, configuration changes, etc.
</span>    <span class="enscript-keyword">if</span>      (err == mStatus_ConnEstablished) { tcpCallback(info-&gt;sock, info, mDNStrue, mStatus_NoError); }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err != mStatus_ConnPending    ) { LogInfo(<span class="enscript-string">&quot;MakeTCPConn: connection failed&quot;</span>); DisposeTCPConn(info); <span class="enscript-keyword">return</span>(mDNSNULL); }
    <span class="enscript-keyword">return</span>(info);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DisposeTCPConn</span>(<span class="enscript-type">struct</span> tcpInfo_t *tcp)
{
    mDNSPlatformTCPCloseConnection(tcp-&gt;sock);
    <span class="enscript-keyword">if</span> (tcp-&gt;reply) mDNSPlatformMemFree(tcp-&gt;reply);
    mDNSPlatformMemFree(tcp);
}

<span class="enscript-comment">// Lock must be held
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">startLLQHandshake</span>(mDNS *m, DNSQuestion *q)
{
    <span class="enscript-comment">// States prior to LLQ_InitialRequest should not react to NAT Mapping changes.
</span>    <span class="enscript-comment">// startLLQHandshake is never called with q-&gt;state &lt; LLQ_InitialRequest except
</span>    <span class="enscript-comment">// from LLQNATCallback.   When we are actually trying to do LLQ, then q-&gt;state will
</span>    <span class="enscript-comment">// be equal to or greater than LLQ_InitialRequest when LLQNATCallback calls
</span>    <span class="enscript-comment">// startLLQHandshake.
</span>    <span class="enscript-keyword">if</span> (q-&gt;state &lt; LLQ_InitialRequest)
    {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (m-&gt;LLQNAT.clientContext != mDNSNULL) <span class="enscript-comment">// LLQNAT just started, give it some time
</span>    {
        LogInfo(<span class="enscript-string">&quot;startLLQHandshake: waiting for NAT status for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        q-&gt;ThisQInterval = LLQ_POLL_INTERVAL + mDNSRandom(LLQ_POLL_INTERVAL/10);    <span class="enscript-comment">// Retry in approx 15 minutes
</span>        q-&gt;LastQTime = m-&gt;timenow;
        SetNextQueryTime(m, q);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Either we don't have {PCP, NAT-PMP, UPnP/IGD} support (ExternalPort is zero) or behind a Double NAT that may or
</span>    <span class="enscript-comment">// may not have {PCP, NAT-PMP, UPnP/IGD} support (NATResult is non-zero)
</span>    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(m-&gt;LLQNAT.ExternalPort) || m-&gt;LLQNAT.Result)
    {
        LogInfo(<span class="enscript-string">&quot;startLLQHandshake: Cannot receive inbound packets; will poll for %##s (%s) External Port %d, NAT Result %d&quot;</span>,
                q-&gt;qname.c, DNSTypeName(q-&gt;qtype), mDNSVal16(m-&gt;LLQNAT.ExternalPort), m-&gt;LLQNAT.Result);
        StartLLQPolling(m, q);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(q-&gt;servPort))
    {
        debugf(<span class="enscript-string">&quot;startLLQHandshake: StartGetZoneData for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        q-&gt;ThisQInterval = LLQ_POLL_INTERVAL + mDNSRandom(LLQ_POLL_INTERVAL/10);    <span class="enscript-comment">// Retry in approx 15 minutes
</span>        q-&gt;LastQTime     = m-&gt;timenow;
        SetNextQueryTime(m, q);
        q-&gt;servAddr = zeroAddr;
        <span class="enscript-comment">// We know q-&gt;servPort is zero because of check above
</span>        <span class="enscript-keyword">if</span> (q-&gt;nta) CancelGetZoneData(m, q-&gt;nta);
        q-&gt;nta = StartGetZoneData(m, &amp;q-&gt;qname, ZoneServiceLLQ, LLQGotZoneData, q);
        <span class="enscript-keyword">return</span>;
    }

    debugf(<span class="enscript-string">&quot;startLLQHandshake: m-&gt;AdvertisedV4 %#a%s Server %#a:%d%s %##s (%s)&quot;</span>,
           &amp;m-&gt;AdvertisedV4,                     mDNSv4AddrIsRFC1918(&amp;m-&gt;AdvertisedV4.ip.v4) ? <span class="enscript-string">&quot; (RFC 1918)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
           &amp;q-&gt;servAddr, mDNSVal16(q-&gt;servPort), mDNSAddrIsRFC1918(&amp;q-&gt;servAddr)             ? <span class="enscript-string">&quot; (RFC 1918)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
           q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

    <span class="enscript-keyword">if</span> (q-&gt;ntries++ &gt;= kLLQ_MAX_TRIES)
    {
        LogMsg(<span class="enscript-string">&quot;startLLQHandshake: %d failed attempts for LLQ %##s Polling.&quot;</span>, kLLQ_MAX_TRIES, q-&gt;qname.c);
        StartLLQPolling(m, q);
    }
    <span class="enscript-keyword">else</span>
    {
        mDNSu8 *end;
        LLQOptData llqData;

        <span class="enscript-comment">// set llq rdata
</span>        llqData.vers  = kLLQ_Vers;
        llqData.llqOp = kLLQOp_Setup;
        llqData.err   = LLQErr_NoError; <span class="enscript-comment">// Don't need to tell server UDP notification port when sending over UDP
</span>        llqData.id    = zeroOpaque64;
        llqData.llqlease = kLLQ_DefLease;

        InitializeDNSMessage(&amp;m-&gt;omsg.h, q-&gt;TargetQID, uQueryFlags);
        end = putLLQ(&amp;m-&gt;omsg, m-&gt;omsg.data, q, &amp;llqData);
        <span class="enscript-keyword">if</span> (!end) { LogMsg(<span class="enscript-string">&quot;ERROR: startLLQHandshake - putLLQ&quot;</span>); StartLLQPolling(m,q); <span class="enscript-keyword">return</span>; }

        mDNSSendDNSMessage(m, &amp;m-&gt;omsg, end, mDNSInterface_Any, mDNSNULL, q-&gt;LocalSocket, &amp;q-&gt;servAddr, q-&gt;servPort , mDNSNULL, mDNSfalse);

        <span class="enscript-comment">// update question state
</span>        q-&gt;state         = LLQ_InitialRequest;
        q-&gt;ReqLease      = kLLQ_DefLease;
        q-&gt;ThisQInterval = (kLLQ_INIT_RESEND * mDNSPlatformOneSecond);
        q-&gt;LastQTime     = m-&gt;timenow;
        SetNextQueryTime(m, q);
    }
}


<span class="enscript-comment">// forward declaration so GetServiceTarget can do reverse lookup if needed
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetStaticHostname</span>(mDNS *m);

mDNSexport <span class="enscript-type">const</span> domainname *<span class="enscript-function-name">GetServiceTarget</span>(mDNS *m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    debugf(<span class="enscript-string">&quot;GetServiceTarget %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);

    <span class="enscript-keyword">if</span> (!rr-&gt;AutoTarget)        <span class="enscript-comment">// If not automatically tracking this host's current name, just return the existing target
</span>        <span class="enscript-keyword">return</span>(&amp;rr-&gt;resrec.rdata-&gt;u.srv.target);
    <span class="enscript-keyword">else</span>
    {
        {
            <span class="enscript-type">const</span> <span class="enscript-type">int</span> srvcount = CountLabels(rr-&gt;resrec.name);
            HostnameInfo *besthi = mDNSNULL, *hi;
            <span class="enscript-type">int</span> best = 0;
            <span class="enscript-keyword">for</span> (hi = m-&gt;Hostnames; hi; hi = hi-&gt;next)
                <span class="enscript-keyword">if</span> (hi-&gt;arv4.state == regState_Registered || hi-&gt;arv4.state == regState_Refresh ||
                    hi-&gt;arv6.state == regState_Registered || hi-&gt;arv6.state == regState_Refresh)
                {
                    <span class="enscript-type">int</span> x, hostcount = CountLabels(&amp;hi-&gt;fqdn);
                    <span class="enscript-keyword">for</span> (x = hostcount &lt; srvcount ? hostcount : srvcount; x &gt; 0 &amp;&amp; x &gt; best; x--)
                        <span class="enscript-keyword">if</span> (SameDomainName(SkipLeadingLabels(rr-&gt;resrec.name, srvcount - x), SkipLeadingLabels(&amp;hi-&gt;fqdn, hostcount - x)))
                        { best = x; besthi = hi; }
                }

            <span class="enscript-keyword">if</span> (besthi) <span class="enscript-keyword">return</span>(&amp;besthi-&gt;fqdn);
        }
        <span class="enscript-keyword">if</span> (m-&gt;StaticHostname.c[0]) <span class="enscript-keyword">return</span>(&amp;m-&gt;StaticHostname);
        <span class="enscript-keyword">else</span> GetStaticHostname(m); <span class="enscript-comment">// asynchronously do reverse lookup for primary IPv4 address
</span>        LogInfo(<span class="enscript-string">&quot;GetServiceTarget: Returning NULL for %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }
}

mDNSlocal <span class="enscript-type">const</span> domainname *PUBLIC_UPDATE_SERVICE_TYPE         = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x0B_dns-update&quot;</span>     <span class="enscript-string">&quot;\x04_udp&quot;</span>;
mDNSlocal <span class="enscript-type">const</span> domainname *PUBLIC_LLQ_SERVICE_TYPE            = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x08_dns-llq&quot;</span>        <span class="enscript-string">&quot;\x04_udp&quot;</span>;

mDNSlocal <span class="enscript-type">const</span> domainname *PRIVATE_UPDATE_SERVICE_TYPE        = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x0F_dns-update-tls&quot;</span> <span class="enscript-string">&quot;\x04_tcp&quot;</span>;
mDNSlocal <span class="enscript-type">const</span> domainname *PRIVATE_QUERY_SERVICE_TYPE         = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x0E_dns-query-tls&quot;</span>  <span class="enscript-string">&quot;\x04_tcp&quot;</span>;
mDNSlocal <span class="enscript-type">const</span> domainname *PRIVATE_LLQ_SERVICE_TYPE           = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x0C_dns-llq-tls&quot;</span>    <span class="enscript-string">&quot;\x04_tcp&quot;</span>;
mDNSlocal <span class="enscript-type">const</span> domainname *DNS_PUSH_NOTIFICATION_SERVICE_TYPE = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x0D_dns-push-tls&quot;</span>   <span class="enscript-string">&quot;\x04_tcp&quot;</span>;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ZoneDataSRV</span>(X) ( \
        (X)-&gt;ZoneService == ZoneServiceUpdate  ? ((X)-&gt;ZonePrivate ? PRIVATE_UPDATE_SERVICE_TYPE : PUBLIC_UPDATE_SERVICE_TYPE) : \
        (X)-&gt;ZoneService == ZoneServiceQuery   ? ((X)-&gt;ZonePrivate ? PRIVATE_QUERY_SERVICE_TYPE  : (const domainname*)<span class="enscript-string">&quot;&quot;</span>     ) : \
        (X)-&gt;ZoneService == ZoneServiceLLQ     ? ((X)-&gt;ZonePrivate ? PRIVATE_LLQ_SERVICE_TYPE    : PUBLIC_LLQ_SERVICE_TYPE   ) : \
        (X)-&gt;ZoneService == ZoneServiceDNSPush ? DNS_PUSH_NOTIFICATION_SERVICE_TYPE : (const domainname*)<span class="enscript-string">&quot;&quot;</span>)

<span class="enscript-comment">// Forward reference: GetZoneData_StartQuery references GetZoneData_QuestionCallback, and
</span><span class="enscript-comment">// GetZoneData_QuestionCallback calls GetZoneData_StartQuery
</span>mDNSlocal mStatus <span class="enscript-function-name">GetZoneData_StartQuery</span>(mDNS *<span class="enscript-type">const</span> m, ZoneData *zd, mDNSu16 qtype);

<span class="enscript-comment">// GetZoneData_QuestionCallback is called from normal client callback context (core API calls allowed)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetZoneData_QuestionCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    ZoneData *zd = (ZoneData*)question-&gt;QuestionContext;

    debugf(<span class="enscript-string">&quot;GetZoneData_QuestionCallback: %s %s&quot;</span>, AddRecord ? <span class="enscript-string">&quot;Add&quot;</span> : <span class="enscript-string">&quot;Rmv&quot;</span>, RRDisplayString(m, answer));

    <span class="enscript-keyword">if</span> (!AddRecord) <span class="enscript-keyword">return</span>;                                             <span class="enscript-comment">// Don't care about REMOVE events
</span>    <span class="enscript-keyword">if</span> (AddRecord == QC_addnocache &amp;&amp; answer-&gt;rdlength == 0) <span class="enscript-keyword">return</span>;    <span class="enscript-comment">// Don't care about transient failure indications
</span>    <span class="enscript-keyword">if</span> (answer-&gt;rrtype != question-&gt;qtype) <span class="enscript-keyword">return</span>;                      <span class="enscript-comment">// Don't care about CNAMEs
</span>
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_SOA)
    {
        debugf(<span class="enscript-string">&quot;GetZoneData GOT SOA %s&quot;</span>, RRDisplayString(m, answer));
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (question-&gt;ThisQInterval != -1)
            LogMsg(<span class="enscript-string">&quot;GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype), question-&gt;ThisQInterval);
        <span class="enscript-keyword">if</span> (answer-&gt;rdlength)
        {
            AssignDomainName(&amp;zd-&gt;ZoneName, answer-&gt;name);
            zd-&gt;ZoneClass = answer-&gt;rrclass;
            GetZoneData_StartQuery(m, zd, kDNSType_SRV);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zd-&gt;CurrentSOA-&gt;c[0])
        {
            zd-&gt;CurrentSOA = (domainname *)(zd-&gt;CurrentSOA-&gt;c + zd-&gt;CurrentSOA-&gt;c[0]+1);
            AssignDomainName(&amp;zd-&gt;question.qname, zd-&gt;CurrentSOA);
            GetZoneData_StartQuery(m, zd, kDNSType_SOA);
        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;GetZoneData recursed to root label of %##s without finding SOA&quot;</span>, zd-&gt;ChildName.c);
            zd-&gt;ZoneDataCallback(m, mStatus_NoSuchNameErr, zd);
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_SRV)
    {
        debugf(<span class="enscript-string">&quot;GetZoneData GOT SRV %s&quot;</span>, RRDisplayString(m, answer));
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (question-&gt;ThisQInterval != -1)
            LogMsg(<span class="enscript-string">&quot;GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype), question-&gt;ThisQInterval);
<span class="enscript-comment">// Right now we don't want to fail back to non-encrypted operations
</span><span class="enscript-comment">// If the AuthInfo has the AutoTunnel field set, then we want private or nothing
</span><span class="enscript-comment">// &lt;rdar://problem/5687667&gt; BTMM: Don't fallback to unencrypted operations when SRV lookup fails
</span>#<span class="enscript-reference">if</span> 0
        <span class="enscript-keyword">if</span> (!answer-&gt;rdlength &amp;&amp; zd-&gt;ZonePrivate &amp;&amp; zd-&gt;ZoneService != ZoneServiceQuery)
        {
            zd-&gt;ZonePrivate = mDNSfalse;    <span class="enscript-comment">// Causes ZoneDataSRV() to yield a different SRV name when building the query
</span>            GetZoneData_StartQuery(m, zd, kDNSType_SRV);        <span class="enscript-comment">// Try again, non-private this time
</span>        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        {
            <span class="enscript-keyword">if</span> (answer-&gt;rdlength)
            {
                AssignDomainName(&amp;zd-&gt;Host, &amp;answer-&gt;rdata-&gt;u.srv.target);
                zd-&gt;Port = answer-&gt;rdata-&gt;u.srv.port;
                <span class="enscript-comment">// The MakeTCPConn path, which is used by everything but DNS Push, won't work at all for
</span>                <span class="enscript-comment">// IPv6.  This should be fixed for all cases we care about, but for now we make an exception
</span>                <span class="enscript-comment">// for Push notifications: we do not look up the a record here, but rather rely on the DSO
</span>                <span class="enscript-comment">// infrastructure to do a GetAddrInfo call on the name and try each IP address in sequence
</span>                <span class="enscript-comment">// until one connects.  We can't do this for the other use cases because this is in the DSO
</span>                <span class="enscript-comment">// code, not in MakeTCPConn.  Ultimately the fix for this is to use Network Framework to do
</span>                <span class="enscript-comment">// the connection establishment for all of these use cases.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// One implication of this is that if two different zones have DNS push server SRV records
</span>                <span class="enscript-comment">// pointing to the same server using a different domain name, we will not see these as being
</span>                <span class="enscript-comment">// the same server, and will not share the connection.   This isn't something we can easily
</span>                <span class="enscript-comment">// fix, and so the advice if someone runs into this and considers it a problem should be to
</span>                <span class="enscript-comment">// use the same name.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// Another issue with this code is that at present, we do not wait for more than one SRV
</span>                <span class="enscript-comment">// record--we cancel the query as soon as the first one comes in.   This isn't ideal: it
</span>                <span class="enscript-comment">// would be better to wait until we've gotten all our answers and then pick the one with
</span>                <span class="enscript-comment">// the highest priority.   Of course, this is unlikely to cause an operational problem in
</span>                <span class="enscript-comment">// practice, and as with the previous point, the fix is easy: figure out which server you
</span>                <span class="enscript-comment">// want people to use and don't list any other servers.   Fully switching to Network
</span>                <span class="enscript-comment">// Framework for this would (I think!) address this problem, or at least make it someone
</span>                <span class="enscript-comment">// else's problem.
</span>                <span class="enscript-keyword">if</span> (zd-&gt;ZoneService != ZoneServiceDNSPush)
                {
                    AssignDomainName(&amp;zd-&gt;question.qname, &amp;zd-&gt;Host);
                    GetZoneData_StartQuery(m, zd, kDNSType_A);
                }
                <span class="enscript-keyword">else</span>
                {
                    zd-&gt;ZoneDataCallback(m, mStatus_NoError, zd);
                }                    
            }
            <span class="enscript-keyword">else</span>
            {
                zd-&gt;ZonePrivate = mDNSfalse;
                zd-&gt;Host.c[0] = 0;
                zd-&gt;Port = zeroIPPort;
                zd-&gt;Addr = zeroAddr;
                zd-&gt;ZoneDataCallback(m, mStatus_NoError, zd);
            }
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_A)
    {
        debugf(<span class="enscript-string">&quot;GetZoneData GOT A %s&quot;</span>, RRDisplayString(m, answer));
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (question-&gt;ThisQInterval != -1)
            LogMsg(<span class="enscript-string">&quot;GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype), question-&gt;ThisQInterval);
        zd-&gt;Addr.type  = mDNSAddrType_IPv4;
        zd-&gt;Addr.ip.v4 = (answer-&gt;rdlength == 4) ? answer-&gt;rdata-&gt;u.ipv4 : zerov4Addr;
        <span class="enscript-comment">// In order to simulate firewalls blocking our outgoing TCP connections, returning immediate ICMP errors or TCP resets,
</span>        <span class="enscript-comment">// the code below will make us try to connect to loopback, resulting in an immediate &quot;port unreachable&quot; failure.
</span>        <span class="enscript-comment">// This helps us test to make sure we handle this case gracefully
</span>        <span class="enscript-comment">// &lt;rdar://problem/5607082&gt; BTMM: mDNSResponder taking 100 percent CPU after upgrading to 10.5.1
</span>#<span class="enscript-reference">if</span> 0
        zd-&gt;Addr.ip.v4.b[0] = 127;
        zd-&gt;Addr.ip.v4.b[1] = 0;
        zd-&gt;Addr.ip.v4.b[2] = 0;
        zd-&gt;Addr.ip.v4.b[3] = 1;
#<span class="enscript-reference">endif</span>
        <span class="enscript-comment">// The caller needs to free the memory when done with zone data
</span>        zd-&gt;ZoneDataCallback(m, mStatus_NoError, zd);
    }
}

<span class="enscript-comment">// GetZoneData_StartQuery is called from normal client context (lock not held, or client callback)
</span>mDNSlocal mStatus <span class="enscript-function-name">GetZoneData_StartQuery</span>(mDNS *<span class="enscript-type">const</span> m, ZoneData *zd, mDNSu16 qtype)
{
    <span class="enscript-keyword">if</span> (qtype == kDNSType_SRV)
    {
        AssignDomainName(&amp;zd-&gt;question.qname, ZoneDataSRV(zd));
        AppendDomainName(&amp;zd-&gt;question.qname, &amp;zd-&gt;ZoneName);
        debugf(<span class="enscript-string">&quot;lookupDNSPort %##s&quot;</span>, zd-&gt;question.qname.c);
    }

    <span class="enscript-comment">// CancelGetZoneData can get called at any time. We should stop the question if it has not been
</span>    <span class="enscript-comment">// stopped already. A value of -1 for ThisQInterval indicates that the question is not active
</span>    <span class="enscript-comment">// yet.
</span>    zd-&gt;question.ThisQInterval       = -1;
    zd-&gt;question.InterfaceID         = mDNSInterface_Any;
    zd-&gt;question.flags               = 0;
    <span class="enscript-comment">//zd-&gt;question.qname.c[0]        = 0;           // Already set
</span>    zd-&gt;question.qtype               = qtype;
    zd-&gt;question.qclass              = kDNSClass_IN;
    zd-&gt;question.LongLived           = mDNSfalse;
    zd-&gt;question.ExpectUnique        = mDNStrue;
    zd-&gt;question.ForceMCast          = mDNSfalse;
    zd-&gt;question.ReturnIntermed      = mDNStrue;
    zd-&gt;question.SuppressUnusable    = mDNSfalse;
    zd-&gt;question.AppendSearchDomains = 0;
    zd-&gt;question.TimeoutQuestion     = 0;
    zd-&gt;question.WakeOnResolve       = 0;
    zd-&gt;question.UseBackgroundTraffic = mDNSfalse;
    zd-&gt;question.ValidationRequired = 0;
    zd-&gt;question.ValidatingResponse = 0;
    zd-&gt;question.ProxyQuestion      = 0;
    zd-&gt;question.pid                 = mDNSPlatformGetPID();
    zd-&gt;question.euid                = 0;
    zd-&gt;question.QuestionCallback    = GetZoneData_QuestionCallback;
    zd-&gt;question.QuestionContext     = zd;

    <span class="enscript-comment">//LogMsg(&quot;GetZoneData_StartQuery %##s (%s) %p&quot;, zd-&gt;question.qname.c, DNSTypeName(zd-&gt;question.qtype), zd-&gt;question.Private);
</span>    <span class="enscript-keyword">return</span>(mDNS_StartQuery(m, &amp;zd-&gt;question));
}

<span class="enscript-comment">// StartGetZoneData is an internal routine (i.e. must be called with the lock already held)
</span>mDNSexport ZoneData *<span class="enscript-function-name">StartGetZoneData</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> ZoneService target, ZoneDataCallback callback, <span class="enscript-type">void</span> *ZoneDataContext)
{
    ZoneData *zd = (ZoneData*) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*zd));
    <span class="enscript-keyword">if</span> (!zd) { LogMsg(<span class="enscript-string">&quot;ERROR: StartGetZoneData - mDNSPlatformMemAllocateClear failed&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }
    AssignDomainName(&amp;zd-&gt;ChildName, name);
    zd-&gt;ZoneService      = target;
    zd-&gt;CurrentSOA       = &amp;zd-&gt;ChildName;
    zd-&gt;ZoneName.c[0]    = 0;
    zd-&gt;ZoneClass        = 0;
    zd-&gt;Host.c[0]        = 0;
    zd-&gt;Port             = zeroIPPort;
    zd-&gt;Addr             = zeroAddr;
    zd-&gt;ZonePrivate      = mDNSfalse;
    zd-&gt;ZoneDataCallback = callback;
    zd-&gt;ZoneDataContext  = ZoneDataContext;

    zd-&gt;question.QuestionContext = zd;

    mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// GetZoneData_StartQuery expects to be called from a normal callback, so we emulate that here
</span>    AssignDomainName(&amp;zd-&gt;question.qname, zd-&gt;CurrentSOA);
    GetZoneData_StartQuery(m, zd, kDNSType_SOA);
    mDNS_ReclaimLockAfterCallback();

    <span class="enscript-keyword">return</span> zd;
}

<span class="enscript-comment">// Returns if the question is a GetZoneData question. These questions are special in
</span><span class="enscript-comment">// that they are created internally while resolving a private query or LLQs.
</span>mDNSexport mDNSBool <span class="enscript-function-name">IsGetZoneDataQuestion</span>(DNSQuestion *q)
{
    <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback == GetZoneData_QuestionCallback) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(mDNSfalse);
}

<span class="enscript-comment">// GetZoneData queries are a special case -- even if we have a key for them, we don't do them privately,
</span><span class="enscript-comment">// because that would result in an infinite loop (i.e. to do a private query we first need to get
</span><span class="enscript-comment">// the _dns-query-tls SRV record for the zone, and we can't do *that* privately because to do so
</span><span class="enscript-comment">// we'd need to already know the _dns-query-tls SRV record.
</span><span class="enscript-comment">// Also, as a general rule, we never do SOA queries privately
</span>mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForQuestion</span>(mDNS *m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)  <span class="enscript-comment">// Must be called with lock held
</span>{
    <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback == GetZoneData_QuestionCallback) <span class="enscript-keyword">return</span>(mDNSNULL);
    <span class="enscript-keyword">if</span> (q-&gt;qtype            == kDNSType_SOA                ) <span class="enscript-keyword">return</span>(mDNSNULL);
    <span class="enscript-keyword">return</span>(GetAuthInfoForName_internal(m, &amp;q-&gt;qname));
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">host</span> <span class="enscript-variable-name">name</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">interface</span> <span class="enscript-variable-name">management</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendRecordRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendRecordDeregistration</span>(mDNS *m, AuthRecord *rr);
mDNSlocal mDNSBool <span class="enscript-function-name">IsRecordMergeable</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNSs32 time);

<span class="enscript-comment">// When this function is called, service record is already deregistered. We just
</span><span class="enscript-comment">// have to deregister the PTR and TXT records.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateAllServiceRecords</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNSBool reg)
{
    AuthRecord *r, *srvRR;

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype != kDNSType_SRV) { LogMsg(<span class="enscript-string">&quot;UpdateAllServiceRecords:ERROR!! ResourceRecord not a service record %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (reg &amp;&amp; rr-&gt;state == regState_NoTarget) { LogMsg(<span class="enscript-string">&quot;UpdateAllServiceRecords:ERROR!! SRV record %s in noTarget state during registration&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    LogInfo(<span class="enscript-string">&quot;UpdateAllServiceRecords: ResourceRecord %s&quot;</span>, ARDisplayString(m, rr));

    <span class="enscript-keyword">for</span> (r = m-&gt;ResourceRecords; r; r=r-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(r)) <span class="enscript-keyword">continue</span>;
        srvRR = mDNSNULL;
        <span class="enscript-keyword">if</span> (r-&gt;resrec.rrtype == kDNSType_PTR)
            srvRR = r-&gt;Additional1;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;resrec.rrtype == kDNSType_TXT)
            srvRR = r-&gt;DependentOn;
        <span class="enscript-keyword">if</span> (srvRR &amp;&amp; srvRR-&gt;resrec.rrtype != kDNSType_SRV)
            LogMsg(<span class="enscript-string">&quot;UpdateAllServiceRecords: ERROR!! Resource record %s wrong, expecting SRV type&quot;</span>, ARDisplayString(m, srvRR));
        <span class="enscript-keyword">if</span> (srvRR == rr)
        {
            <span class="enscript-keyword">if</span> (!reg)
            {
                LogInfo(<span class="enscript-string">&quot;UpdateAllServiceRecords: deregistering %s&quot;</span>, ARDisplayString(m, r));
                r-&gt;SRVChanged = mDNStrue;
                r-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
                r-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
                r-&gt;state = regState_DeregPending;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Clearing SRVchanged is a safety measure. If our pevious dereg never
</span>                <span class="enscript-comment">// came back and we had a target change, we are starting fresh
</span>                r-&gt;SRVChanged = mDNSfalse;
                <span class="enscript-comment">// if it is already registered or in the process of registering, then don't
</span>                <span class="enscript-comment">// bother re-registering. This happens today for non-BTMM domains where the
</span>                <span class="enscript-comment">// TXT and PTR get registered before SRV records because of the delay in
</span>                <span class="enscript-comment">// getting the port mapping. There is no point in re-registering the TXT
</span>                <span class="enscript-comment">// and PTR records.
</span>                <span class="enscript-keyword">if</span> ((r-&gt;state == regState_Registered) ||
                    (r-&gt;state == regState_Pending &amp;&amp; r-&gt;nta &amp;&amp; !mDNSIPv4AddressIsZero(r-&gt;nta-&gt;Addr.ip.v4)))
                    LogInfo(<span class="enscript-string">&quot;UpdateAllServiceRecords: not registering %s, state %d&quot;</span>, ARDisplayString(m, r), r-&gt;state);
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;UpdateAllServiceRecords: registering %s, state %d&quot;</span>, ARDisplayString(m, r), r-&gt;state);
                    ActivateUnicastRegistration(m, r);
                }
            }
        }
    }
}

<span class="enscript-comment">// Called in normal client context (lock not held)
</span><span class="enscript-comment">// Currently only supports SRV records for nat mapping
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CompleteRecordNatMap</span>(mDNS *m, NATTraversalInfo *n)
{
    <span class="enscript-type">const</span> domainname *target;
    domainname *srvt;
    AuthRecord *rr = (AuthRecord *)n-&gt;clientContext;
    debugf(<span class="enscript-string">&quot;SRVNatMap complete %.4a IntPort %u ExternalPort %u NATLease %u&quot;</span>, &amp;n-&gt;ExternalAddress, mDNSVal16(n-&gt;IntPort), mDNSVal16(n-&gt;ExternalPort), n-&gt;NATLease);

    <span class="enscript-keyword">if</span> (!rr) { LogMsg(<span class="enscript-string">&quot;CompleteRecordNatMap called with unknown AuthRecord object&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (!n-&gt;NATLease) { LogMsg(<span class="enscript-string">&quot;CompleteRecordNatMap No NATLease for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype != kDNSType_SRV) {LogMsg(<span class="enscript-string">&quot;CompleteRecordNatMap: Not a service record %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) { LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap called for %s, Service deregistering&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_DeregPending) { LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap called for %s, record in DeregPending&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// As we free the zone info after registering/deregistering with the server (See hndlRecordUpdateReply),
</span>    <span class="enscript-comment">// we need to restart the get zone data and nat mapping request to get the latest mapping result as we can't handle it
</span>    <span class="enscript-comment">// at this moment. Restart from the beginning.
</span>    <span class="enscript-keyword">if</span> (!rr-&gt;nta || mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4))
    {
        LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap called for %s but no zone information!&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-comment">// We need to clear out the NATinfo state so that it will result in re-acquiring the mapping
</span>        <span class="enscript-comment">// and hence this callback called again.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext)
        {
            mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
            rr-&gt;NATinfo.clientContext = mDNSNULL;
        }
        rr-&gt;state = regState_Pending;
        rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
        rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
        <span class="enscript-keyword">return</span>;
    }

    mDNS_Lock(m);
    <span class="enscript-comment">// Reevaluate the target always as Target could have changed while
</span>    <span class="enscript-comment">// we were getting the port mapping (See UpdateOneSRVRecord)
</span>    target = GetServiceTarget(m, rr);
    srvt = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
    <span class="enscript-keyword">if</span> (!target || target-&gt;c[0] == 0 || mDNSIPPortIsZero(n-&gt;ExternalPort))
    {
        <span class="enscript-keyword">if</span> (target &amp;&amp; target-&gt;c[0])
            LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d&quot;</span>, target-&gt;c, rr-&gt;resrec.name-&gt;c, mDNSVal16(n-&gt;ExternalPort));
        <span class="enscript-keyword">else</span>
            LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap - no target for %##s, ExternalPort %d&quot;</span>, rr-&gt;resrec.name-&gt;c, mDNSVal16(n-&gt;ExternalPort));
        <span class="enscript-keyword">if</span> (srvt) srvt-&gt;c[0] = 0;
        rr-&gt;state = regState_NoTarget;
        rr-&gt;resrec.rdlength = rr-&gt;resrec.rdestimate = 0;
        mDNS_Unlock(m);
        UpdateAllServiceRecords(m, rr, mDNSfalse);
        <span class="enscript-keyword">return</span>;
    }
    LogInfo(<span class="enscript-string">&quot;CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d&quot;</span>, target-&gt;c, rr-&gt;resrec.name-&gt;c, mDNSVal16(n-&gt;ExternalPort));
    <span class="enscript-comment">// This function might get called multiple times during a network transition event. Previosuly, we could
</span>    <span class="enscript-comment">// have put the SRV record in NoTarget state above and deregistered all the other records. When this
</span>    <span class="enscript-comment">// function gets called again with a non-zero ExternalPort, we need to set the target and register the
</span>    <span class="enscript-comment">// other records again.
</span>    <span class="enscript-keyword">if</span> (srvt &amp;&amp; !SameDomainName(srvt, target))
    {
        AssignDomainName(srvt, target);
        SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);      <span class="enscript-comment">// Update rdlength, rdestimate, rdatahash
</span>    }

    <span class="enscript-comment">// SRVChanged is set when when the target of the SRV record changes (See UpdateOneSRVRecord).
</span>    <span class="enscript-comment">// As a result of the target change, we might register just that SRV Record if it was
</span>    <span class="enscript-comment">// previously registered and we have a new target OR deregister SRV (and the associated
</span>    <span class="enscript-comment">// PTR/TXT records) if we don't have a target anymore. When we get a response from the server,
</span>    <span class="enscript-comment">// SRVChanged state tells that we registered/deregistered because of a target change
</span>    <span class="enscript-comment">// and hence handle accordingly e.g., if we deregistered, put the records in NoTarget state OR
</span>    <span class="enscript-comment">// if we registered then put it in Registered state.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Here, we are registering all the records again from the beginning. Treat this as first time
</span>    <span class="enscript-comment">// registration rather than a temporary target change.
</span>    rr-&gt;SRVChanged = mDNSfalse;

    <span class="enscript-comment">// We want IsRecordMergeable to check whether it is a record whose update can be
</span>    <span class="enscript-comment">// sent with others. We set the time before we call IsRecordMergeable, so that
</span>    <span class="enscript-comment">// it does not fail this record based on time. We are interested in other checks
</span>    <span class="enscript-comment">// at this time
</span>    rr-&gt;state = regState_Pending;
    rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
    rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
    <span class="enscript-keyword">if</span> (IsRecordMergeable(m, rr, m-&gt;timenow + MERGE_DELAY_TIME))
        <span class="enscript-comment">// Delay the record registration by MERGE_DELAY_TIME so that we can merge them
</span>        <span class="enscript-comment">// into one update
</span>        rr-&gt;LastAPTime += MERGE_DELAY_TIME;
    mDNS_Unlock(m);
    <span class="enscript-comment">// We call this always even though it may not be necessary always e.g., normal registration
</span>    <span class="enscript-comment">// process where TXT and PTR gets registered followed by the SRV record after it gets
</span>    <span class="enscript-comment">// the port mapping. In that case, UpdateAllServiceRecords handles the optimization. The
</span>    <span class="enscript-comment">// update of TXT and PTR record is required if we entered noTargetState before as explained
</span>    <span class="enscript-comment">// above.
</span>    UpdateAllServiceRecords(m, rr, mDNStrue);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">StartRecordNatMap</span>(mDNS *m, AuthRecord *rr)
{
    <span class="enscript-type">const</span> mDNSu8 *p;
    mDNSu8 protocol;

    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype != kDNSType_SRV)
    {
        LogInfo(<span class="enscript-string">&quot;StartRecordNatMap: Resource Record %##s type %d, not supported&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;resrec.rrtype);
        <span class="enscript-keyword">return</span>;
    }
    p = rr-&gt;resrec.name-&gt;c;
    <span class="enscript-comment">//Assume &lt;Service Instance&gt;.&lt;App Protocol&gt;.&lt;Transport protocol&gt;.&lt;Name&gt;
</span>    <span class="enscript-comment">// Skip the first two labels to get to the transport protocol
</span>    <span class="enscript-keyword">if</span> (p[0]) p += 1 + p[0];
    <span class="enscript-keyword">if</span> (p[0]) p += 1 + p[0];
    <span class="enscript-keyword">if</span>      (SameDomainLabel(p, (mDNSu8 *)<span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_tcp&quot;</span>)) protocol = NATOp_MapTCP;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SameDomainLabel(p, (mDNSu8 *)<span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_udp&quot;</span>)) protocol = NATOp_MapUDP;
    <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;StartRecordNatMap: could not determine transport protocol of service %##s&quot;</span>, rr-&gt;resrec.name-&gt;c); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">//LogMsg(&quot;StartRecordNatMap: clientContext %p IntPort %d srv.port %d %s&quot;,
</span>    <span class="enscript-comment">//  rr-&gt;NATinfo.clientContext, mDNSVal16(rr-&gt;NATinfo.IntPort), mDNSVal16(rr-&gt;resrec.rdata-&gt;u.srv.port), ARDisplayString(m, rr));
</span>    <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext) mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
    rr-&gt;NATinfo.Protocol       = protocol;

    <span class="enscript-comment">// Shouldn't be trying to set IntPort here --
</span>    <span class="enscript-comment">// BuildUpdateMessage overwrites srs-&gt;RR_SRV.resrec.rdata-&gt;u.srv.port with external (mapped) port number
</span>    rr-&gt;NATinfo.IntPort        = rr-&gt;resrec.rdata-&gt;u.srv.port;
    rr-&gt;NATinfo.RequestedPort  = rr-&gt;resrec.rdata-&gt;u.srv.port;
    rr-&gt;NATinfo.NATLease       = 0;     <span class="enscript-comment">// Request default lease
</span>    rr-&gt;NATinfo.clientCallback = CompleteRecordNatMap;
    rr-&gt;NATinfo.clientContext  = rr;
    mDNS_StartNATOperation_internal(m, &amp;rr-&gt;NATinfo);
}

<span class="enscript-comment">// Unlink an Auth Record from the m-&gt;ResourceRecords list.
</span><span class="enscript-comment">// When a resource record enters regState_NoTarget initially, mDNS_Register_internal
</span><span class="enscript-comment">// does not initialize completely e.g., it cannot check for duplicates etc. The resource
</span><span class="enscript-comment">// record is temporarily left in the ResourceRecords list so that we can initialize later
</span><span class="enscript-comment">// when the target is resolvable. Similarly, when host name changes, we enter regState_NoTarget
</span><span class="enscript-comment">// and we do the same.
</span>
<span class="enscript-comment">// This UnlinkResourceRecord routine is very worrying. It bypasses all the normal cleanup performed
</span><span class="enscript-comment">// by mDNS_Deregister_internal and just unceremoniously cuts the record from the active list.
</span><span class="enscript-comment">// This is why re-regsitering this record was producing syslog messages like this:
</span><span class="enscript-comment">// &quot;Error! Tried to add a NAT traversal that's already in the active list&quot;
</span><span class="enscript-comment">// Right now UnlinkResourceRecord is fortunately only called by RegisterAllServiceRecords,
</span><span class="enscript-comment">// which then immediately calls mDNS_Register_internal to re-register the record, which probably
</span><span class="enscript-comment">// masked more serious problems. Any other use of UnlinkResourceRecord is likely to lead to crashes.
</span><span class="enscript-comment">// For now we'll workaround that specific problem by explicitly calling mDNS_StopNATOperation_internal,
</span><span class="enscript-comment">// but long-term we should either stop cancelling the record registration and then re-registering it,
</span><span class="enscript-comment">// or if we really do need to do this for some reason it should be done via the usual
</span><span class="enscript-comment">// mDNS_Deregister_internal path instead of just cutting the record from the list.
</span>
mDNSlocal mStatus <span class="enscript-function-name">UnlinkResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    AuthRecord **list = &amp;m-&gt;ResourceRecords;
    <span class="enscript-keyword">while</span> (*list &amp;&amp; *list != rr) list = &amp;(*list)-&gt;next;
    <span class="enscript-keyword">if</span> (*list)
    {
        *list = rr-&gt;next;
        rr-&gt;next = mDNSNULL;

        <span class="enscript-comment">// Temporary workaround to cancel any active NAT mapping operation
</span>        <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext)
        {
            mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
            rr-&gt;NATinfo.clientContext = mDNSNULL;
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV) rr-&gt;resrec.rdata-&gt;u.srv.port = rr-&gt;NATinfo.IntPort;
        }

        <span class="enscript-keyword">return</span>(mStatus_NoError);
    }
    LogMsg(<span class="enscript-string">&quot;UnlinkResourceRecord:ERROR!! - no such active record %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);
    <span class="enscript-keyword">return</span>(mStatus_NoSuchRecord);
}

<span class="enscript-comment">// We need to go through mDNS_Register again as we did not complete the
</span><span class="enscript-comment">// full initialization last time e.g., duplicate checks.
</span><span class="enscript-comment">// After we register, we will be in regState_GetZoneData.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RegisterAllServiceRecords</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    LogInfo(<span class="enscript-string">&quot;RegisterAllServiceRecords: Service Record %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);
    <span class="enscript-comment">// First Register the service record, we do this differently from other records because
</span>    <span class="enscript-comment">// when it entered NoTarget state, it did not go through complete initialization
</span>    rr-&gt;SRVChanged = mDNSfalse;
    UnlinkResourceRecord(m, rr);
    mDNS_Register_internal(m, rr);
    <span class="enscript-comment">// Register the other records
</span>    UpdateAllServiceRecords(m, rr, mDNStrue);
}

<span class="enscript-comment">// Called with lock held
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateOneSRVRecord</span>(mDNS *m, AuthRecord *rr)
{
    <span class="enscript-comment">// Target change if:
</span>    <span class="enscript-comment">// We have a target and were previously waiting for one, or
</span>    <span class="enscript-comment">// We had a target and no longer do, or
</span>    <span class="enscript-comment">// The target has changed
</span>
    domainname *curtarget = &amp;rr-&gt;resrec.rdata-&gt;u.srv.target;
    <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> nt = GetServiceTarget(m, rr);
    <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> newtarget = nt ? nt : (domainname*)<span class="enscript-string">&quot;&quot;</span>;
    mDNSBool TargetChanged = (newtarget-&gt;c[0] &amp;&amp; rr-&gt;state == regState_NoTarget) || !SameDomainName(curtarget, newtarget);
    mDNSBool HaveZoneData  = rr-&gt;nta &amp;&amp; !mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4);

    <span class="enscript-comment">// Nat state change if:
</span>    <span class="enscript-comment">// We were behind a NAT, and now we are behind a new NAT, or
</span>    <span class="enscript-comment">// We're not behind a NAT but our port was previously mapped to a different external port
</span>    <span class="enscript-comment">// We were not behind a NAT and now we are
</span>
    mDNSIPPort port        = rr-&gt;resrec.rdata-&gt;u.srv.port;
    mDNSBool NowNeedNATMAP = (rr-&gt;AutoTarget == Target_AutoHostAndNATMAP &amp;&amp; !mDNSIPPortIsZero(port) &amp;&amp; mDNSv4AddrIsRFC1918(&amp;m-&gt;AdvertisedV4.ip.v4) &amp;&amp; rr-&gt;nta &amp;&amp; !mDNSAddrIsRFC1918(&amp;rr-&gt;nta-&gt;Addr));
    mDNSBool WereBehindNAT = (rr-&gt;NATinfo.clientContext != mDNSNULL);
    mDNSBool PortWasMapped = (rr-&gt;NATinfo.clientContext &amp;&amp; !mDNSSameIPPort(rr-&gt;NATinfo.RequestedPort, port));       <span class="enscript-comment">// I think this is always false -- SC Sept 07
</span>    mDNSBool NATChanged    = (!WereBehindNAT &amp;&amp; NowNeedNATMAP) || (!NowNeedNATMAP &amp;&amp; PortWasMapped);

    (<span class="enscript-type">void</span>)HaveZoneData; <span class="enscript-comment">//unused
</span>
    LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: Resource Record %s TargetChanged %d, NewTarget %##s&quot;</span>, ARDisplayString(m, rr), TargetChanged, nt-&gt;c);

    debugf(<span class="enscript-string">&quot;UpdateOneSRVRecord: %##s newtarget %##s TargetChanged %d HaveZoneData %d port %d NowNeedNATMAP %d WereBehindNAT %d PortWasMapped %d NATChanged %d&quot;</span>,
           rr-&gt;resrec.name-&gt;c, newtarget,
           TargetChanged, HaveZoneData, mDNSVal16(port), NowNeedNATMAP, WereBehindNAT, PortWasMapped, NATChanged);

    mDNS_CheckLock(m);

    <span class="enscript-keyword">if</span> (!TargetChanged &amp;&amp; !NATChanged) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// If we are deregistering the record, then ignore any NAT/Target change.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering)
    {
        LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: Deregistering record, Ignoring TargetChanged %d, NATChanged %d for %##s, state %d&quot;</span>, TargetChanged, NATChanged,
                rr-&gt;resrec.name-&gt;c, rr-&gt;state);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (newtarget)
        LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: TargetChanged %d, NATChanged %d for %##s, state %d, newtarget %##s&quot;</span>, TargetChanged, NATChanged, rr-&gt;resrec.name-&gt;c, rr-&gt;state, newtarget-&gt;c);
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: TargetChanged %d, NATChanged %d for %##s, state %d, null newtarget&quot;</span>, TargetChanged, NATChanged, rr-&gt;resrec.name-&gt;c, rr-&gt;state);
    <span class="enscript-keyword">switch</span>(rr-&gt;state)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATMap</span>:
        <span class="enscript-comment">// In these states, the SRV has either not yet been registered (it will get up-to-date information when it is)
</span>        <span class="enscript-comment">// or is in the process of, or has already been, deregistered. This assumes that whenever we transition out
</span>        <span class="enscript-comment">// of this state, we need to look at the target again.
</span>        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_UpdatePending</span>:
        <span class="enscript-comment">// We are getting a Target change/NAT change while the SRV record is being updated ?
</span>        <span class="enscript-comment">// let us not do anything for now.
</span>        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATError</span>:
        <span class="enscript-keyword">if</span> (!NATChanged) <span class="enscript-keyword">return</span>;
        fallthrough();
    <span class="enscript-comment">// if nat changed, register if we have a target (below)
</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NoTarget</span>:
        <span class="enscript-keyword">if</span> (!newtarget-&gt;c[0])
        {
            LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: No target yet for Resource Record %s&quot;</span>, ARDisplayString(m, rr));
            <span class="enscript-keyword">return</span>;
        }
        RegisterAllServiceRecords(m, rr);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_DeregPending</span>:
    <span class="enscript-comment">// We are in DeregPending either because the service was deregistered from above or we handled
</span>    <span class="enscript-comment">// a NAT/Target change before and sent the deregistration below. There are a few race conditions
</span>    <span class="enscript-comment">// possible
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. We are handling a second NAT/Target change while the first dereg is in progress. It is possible
</span>    <span class="enscript-comment">//    that first dereg never made it through because there was no network connectivity e.g., disconnecting
</span>    <span class="enscript-comment">//    from network triggers this function due to a target change and later connecting to the network
</span>    <span class="enscript-comment">//    retriggers this function but the deregistration never made it through yet. Just fall through.
</span>    <span class="enscript-comment">//    If there is a target register otherwise deregister.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. While we sent the dereg during a previous NAT/Target change, uDNS_DeregisterRecord gets
</span>    <span class="enscript-comment">//    called as part of service deregistration. When the response comes back, we call
</span>    <span class="enscript-comment">//    CompleteDeregistration rather than handle NAT/Target change because the record is in
</span>    <span class="enscript-comment">//    kDNSRecordTypeDeregistering state.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 3. If the upper layer deregisters the service, we check for kDNSRecordTypeDeregistering both
</span>    <span class="enscript-comment">//    here in this function to avoid handling NAT/Target change and in hndlRecordUpdateReply to call
</span>    <span class="enscript-comment">//    CompleteDeregistration instead of handling NAT/Target change. Hence, we are not concerned
</span>    <span class="enscript-comment">//    about that case here.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We just handle case (1) by falling through
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Pending</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Refresh</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Registered</span>:
        <span class="enscript-comment">// target or nat changed.  deregister service.  upon completion, we'll look for a new target
</span>        rr-&gt;SRVChanged = mDNStrue;
        rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
        rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
        <span class="enscript-keyword">if</span> (newtarget-&gt;c[0])
        {
            LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: SRV record changed for service %##s, registering with new target %##s&quot;</span>,
                    rr-&gt;resrec.name-&gt;c, newtarget-&gt;c);
            rr-&gt;state = regState_Pending;
        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;UpdateOneSRVRecord: SRV record changed for service %##s de-registering&quot;</span>, rr-&gt;resrec.name-&gt;c);
            rr-&gt;state = regState_DeregPending;
            UpdateAllServiceRecords(m, rr, mDNSfalse);
        }
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Unregistered</span>:
    <span class="enscript-reference">default</span>: LogMsg(<span class="enscript-string">&quot;UpdateOneSRVRecord: Unknown state %d for %##s&quot;</span>, rr-&gt;state, rr-&gt;resrec.name-&gt;c);
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateAllSRVRecords</span>(mDNS *m)
{
    m-&gt;NextSRVUpdate = 0;
    LogInfo(<span class="enscript-string">&quot;UpdateAllSRVRecords %d&quot;</span>, m-&gt;SleepState);

    <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
        LogMsg(<span class="enscript-string">&quot;UpdateAllSRVRecords ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
    m-&gt;CurrentRecord = m-&gt;ResourceRecords;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
    {
        AuthRecord *rptr = m-&gt;CurrentRecord;
        m-&gt;CurrentRecord = m-&gt;CurrentRecord-&gt;next;
        <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rptr) &amp;&amp; rptr-&gt;resrec.rrtype == kDNSType_SRV)
            UpdateOneSRVRecord(m, rptr);
    }
}

<span class="enscript-comment">// Forward reference: AdvertiseHostname references HostnameCallback, and HostnameCallback calls AdvertiseHostname
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HostnameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);

<span class="enscript-comment">// Called in normal client context (lock not held)
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">hostnameGetPublicAddressCallback</span>(mDNS *m, NATTraversalInfo *n)
{
    HostnameInfo *h = (HostnameInfo *)n-&gt;clientContext;

    <span class="enscript-keyword">if</span> (!h) { LogMsg(<span class="enscript-string">&quot;RegisterHostnameRecord: registration cancelled&quot;</span>); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">if</span> (!n-&gt;Result)
    {
        <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(n-&gt;ExternalAddress) || mDNSv4AddrIsRFC1918(&amp;n-&gt;ExternalAddress)) <span class="enscript-keyword">return</span>;

        <span class="enscript-keyword">if</span> (h-&gt;arv4.resrec.RecordType)
        {
            <span class="enscript-keyword">if</span> (mDNSSameIPv4Address(h-&gt;arv4.resrec.rdata-&gt;u.ipv4, n-&gt;ExternalAddress)) <span class="enscript-keyword">return</span>;  <span class="enscript-comment">// If address unchanged, do nothing
</span>            LogInfo(<span class="enscript-string">&quot;Updating hostname %p %##s IPv4 from %.4a to %.4a (NAT gateway's external address)&quot;</span>,n,
                    h-&gt;arv4.resrec.name-&gt;c, &amp;h-&gt;arv4.resrec.rdata-&gt;u.ipv4, &amp;n-&gt;ExternalAddress);
            mDNS_Deregister(m, &amp;h-&gt;arv4);   <span class="enscript-comment">// mStatus_MemFree callback will re-register with new address
</span>        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;Advertising hostname %##s IPv4 %.4a (NAT gateway's external address)&quot;</span>, h-&gt;arv4.resrec.name-&gt;c, &amp;n-&gt;ExternalAddress);
            h-&gt;arv4.resrec.RecordType = kDNSRecordTypeKnownUnique;
            h-&gt;arv4.resrec.rdata-&gt;u.ipv4 = n-&gt;ExternalAddress;
            mDNS_Register(m, &amp;h-&gt;arv4);
        }
    }
}

<span class="enscript-comment">// register record or begin NAT traversal
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">AdvertiseHostname</span>(mDNS *m, HostnameInfo *h)
{
    <span class="enscript-keyword">if</span> (!mDNSIPv4AddressIsZero(m-&gt;AdvertisedV4.ip.v4) &amp;&amp; h-&gt;arv4.resrec.RecordType == kDNSRecordTypeUnregistered)
    {
        mDNS_SetupResourceRecord(&amp;h-&gt;arv4, mDNSNULL, mDNSInterface_Any, kDNSType_A, kHostNameTTL, kDNSRecordTypeUnregistered, AuthRecordAny, HostnameCallback, h);
        AssignDomainName(&amp;h-&gt;arv4.namestorage, &amp;h-&gt;fqdn);
        h-&gt;arv4.resrec.rdata-&gt;u.ipv4 = m-&gt;AdvertisedV4.ip.v4;
        h-&gt;arv4.state = regState_Unregistered;
        <span class="enscript-keyword">if</span> (mDNSv4AddrIsRFC1918(&amp;m-&gt;AdvertisedV4.ip.v4))
        {
            <span class="enscript-comment">// If we already have a NAT query active, stop it and restart it to make sure we get another callback
</span>            <span class="enscript-keyword">if</span> (h-&gt;natinfo.clientContext) mDNS_StopNATOperation_internal(m, &amp;h-&gt;natinfo);
            h-&gt;natinfo.Protocol         = 0;
            h-&gt;natinfo.IntPort          = zeroIPPort;
            h-&gt;natinfo.RequestedPort    = zeroIPPort;
            h-&gt;natinfo.NATLease         = 0;
            h-&gt;natinfo.clientCallback   = hostnameGetPublicAddressCallback;
            h-&gt;natinfo.clientContext    = h;
            mDNS_StartNATOperation_internal(m, &amp;h-&gt;natinfo);
        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;Advertising hostname %##s IPv4 %.4a&quot;</span>, h-&gt;arv4.resrec.name-&gt;c, &amp;m-&gt;AdvertisedV4.ip.v4);
            h-&gt;arv4.resrec.RecordType = kDNSRecordTypeKnownUnique;
            mDNS_Register_internal(m, &amp;h-&gt;arv4);
        }
    }

    <span class="enscript-keyword">if</span> (!mDNSIPv6AddressIsZero(m-&gt;AdvertisedV6.ip.v6) &amp;&amp; h-&gt;arv6.resrec.RecordType == kDNSRecordTypeUnregistered)
    {
        mDNS_SetupResourceRecord(&amp;h-&gt;arv6, mDNSNULL, mDNSInterface_Any, kDNSType_AAAA, kHostNameTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, HostnameCallback, h);
        AssignDomainName(&amp;h-&gt;arv6.namestorage, &amp;h-&gt;fqdn);
        h-&gt;arv6.resrec.rdata-&gt;u.ipv6 = m-&gt;AdvertisedV6.ip.v6;
        h-&gt;arv6.state = regState_Unregistered;
        LogInfo(<span class="enscript-string">&quot;Advertising hostname %##s IPv6 %.16a&quot;</span>, h-&gt;arv6.resrec.name-&gt;c, &amp;m-&gt;AdvertisedV6.ip.v6);
        mDNS_Register_internal(m, &amp;h-&gt;arv6);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">HostnameCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    HostnameInfo *hi = (HostnameInfo *)rr-&gt;RecordContext;

    <span class="enscript-keyword">if</span> (result == mStatus_MemFree)
    {
        <span class="enscript-keyword">if</span> (hi)
        {
            <span class="enscript-comment">// If we're still in the Hostnames list, update to new address
</span>            HostnameInfo *i;
            LogInfo(<span class="enscript-string">&quot;HostnameCallback: Got mStatus_MemFree for %p %p %s&quot;</span>, hi, rr, ARDisplayString(m, rr));
            <span class="enscript-keyword">for</span> (i = m-&gt;Hostnames; i; i = i-&gt;next)
                <span class="enscript-keyword">if</span> (rr == &amp;i-&gt;arv4 || rr == &amp;i-&gt;arv6)
                { mDNS_Lock(m); AdvertiseHostname(m, i); mDNS_Unlock(m); <span class="enscript-keyword">return</span>; }

            <span class="enscript-comment">// Else, we're not still in the Hostnames list, so free the memory
</span>            <span class="enscript-keyword">if</span> (hi-&gt;arv4.resrec.RecordType == kDNSRecordTypeUnregistered &amp;&amp;
                hi-&gt;arv6.resrec.RecordType == kDNSRecordTypeUnregistered)
            {
                <span class="enscript-keyword">if</span> (hi-&gt;natinfo.clientContext) mDNS_StopNATOperation_internal(m, &amp;hi-&gt;natinfo);
                hi-&gt;natinfo.clientContext = mDNSNULL;
                mDNSPlatformMemFree(hi);    <span class="enscript-comment">// free hi when both v4 and v6 AuthRecs deallocated
</span>            }
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (result)
    {
        <span class="enscript-comment">// don't unlink or free - we can retry when we get a new address/router
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_A)
            LogMsg(<span class="enscript-string">&quot;HostnameCallback: Error %d for registration of %##s IP %.4a&quot;</span>, result, rr-&gt;resrec.name-&gt;c, &amp;rr-&gt;resrec.rdata-&gt;u.ipv4);
        <span class="enscript-keyword">else</span>
            LogMsg(<span class="enscript-string">&quot;HostnameCallback: Error %d for registration of %##s IP %.16a&quot;</span>, result, rr-&gt;resrec.name-&gt;c, &amp;rr-&gt;resrec.rdata-&gt;u.ipv6);
        <span class="enscript-keyword">if</span> (!hi) { mDNSPlatformMemFree(rr); <span class="enscript-keyword">return</span>; }
        <span class="enscript-keyword">if</span> (rr-&gt;state != regState_Unregistered) LogMsg(<span class="enscript-string">&quot;Error: HostnameCallback invoked with error code for record not in regState_Unregistered!&quot;</span>);

        <span class="enscript-keyword">if</span> (hi-&gt;arv4.state == regState_Unregistered &amp;&amp;
            hi-&gt;arv6.state == regState_Unregistered)
        {
            <span class="enscript-comment">// only deliver status if both v4 and v6 fail
</span>            rr-&gt;RecordContext = (<span class="enscript-type">void</span> *)hi-&gt;StatusContext;
            <span class="enscript-keyword">if</span> (hi-&gt;StatusCallback)
                hi-&gt;StatusCallback(m, rr, result); <span class="enscript-comment">// client may NOT make API calls here
</span>            rr-&gt;RecordContext = (<span class="enscript-type">void</span> *)hi;
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// register any pending services that require a target
</span>    mDNS_Lock(m);
    m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow);
    mDNS_Unlock(m);

    <span class="enscript-comment">// Deliver success to client
</span>    <span class="enscript-keyword">if</span> (!hi) { LogMsg(<span class="enscript-string">&quot;HostnameCallback invoked with orphaned address record&quot;</span>); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_A)
        LogInfo(<span class="enscript-string">&quot;Registered hostname %##s IP %.4a&quot;</span>, rr-&gt;resrec.name-&gt;c, &amp;rr-&gt;resrec.rdata-&gt;u.ipv4);
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;Registered hostname %##s IP %.16a&quot;</span>, rr-&gt;resrec.name-&gt;c, &amp;rr-&gt;resrec.rdata-&gt;u.ipv6);

    rr-&gt;RecordContext = (<span class="enscript-type">void</span> *)hi-&gt;StatusContext;
    <span class="enscript-keyword">if</span> (hi-&gt;StatusCallback)
        hi-&gt;StatusCallback(m, rr, result); <span class="enscript-comment">// client may NOT make API calls here
</span>    rr-&gt;RecordContext = (<span class="enscript-type">void</span> *)hi;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FoundStaticHostname</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    <span class="enscript-type">const</span> domainname *pktname = &amp;answer-&gt;rdata-&gt;u.name;
    domainname *storedname = &amp;m-&gt;StaticHostname;
    HostnameInfo *h = m-&gt;Hostnames;

    (<span class="enscript-type">void</span>)question;

    <span class="enscript-keyword">if</span> (answer-&gt;rdlength != 0)
        LogInfo(<span class="enscript-string">&quot;FoundStaticHostname: question %##s -&gt; answer %##s (%s)&quot;</span>, question-&gt;qname.c, answer-&gt;rdata-&gt;u.name.c, AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>);
    <span class="enscript-keyword">else</span>
        LogInfo(<span class="enscript-string">&quot;FoundStaticHostname: question %##s -&gt; answer NULL (%s)&quot;</span>, question-&gt;qname.c, AddRecord ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;RMV&quot;</span>);

    <span class="enscript-keyword">if</span> (AddRecord &amp;&amp; answer-&gt;rdlength != 0 &amp;&amp; !SameDomainName(pktname, storedname))
    {
        AssignDomainName(storedname, pktname);
        <span class="enscript-keyword">while</span> (h)
        {
            <span class="enscript-keyword">if</span> (h-&gt;arv4.state == regState_Pending || h-&gt;arv4.state == regState_NATMap || h-&gt;arv6.state == regState_Pending)
            {
                <span class="enscript-comment">// if we're in the process of registering a dynamic hostname, delay SRV update so we don't have to reregister services if the dynamic name succeeds
</span>                m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow + 5 * mDNSPlatformOneSecond);
                debugf(<span class="enscript-string">&quot;FoundStaticHostname: NextSRVUpdate in %d %d&quot;</span>, m-&gt;NextSRVUpdate - m-&gt;timenow, m-&gt;timenow);
                <span class="enscript-keyword">return</span>;
            }
            h = h-&gt;next;
        }
        mDNS_Lock(m);
        m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow);
        mDNS_Unlock(m);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!AddRecord &amp;&amp; SameDomainName(pktname, storedname))
    {
        mDNS_Lock(m);
        storedname-&gt;c[0] = 0;
        m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow);
        mDNS_Unlock(m);
    }
}

<span class="enscript-comment">// Called with lock held
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">GetStaticHostname</span>(mDNS *m)
{
    <span class="enscript-type">char</span> buf[MAX_REVERSE_MAPPING_NAME_V4];
    DNSQuestion *q = &amp;m-&gt;ReverseMap;
    mDNSu8 *ip = m-&gt;AdvertisedV4.ip.v4.b;
    mStatus err;

    <span class="enscript-keyword">if</span> (m-&gt;ReverseMap.ThisQInterval != -1) <span class="enscript-keyword">return</span>; <span class="enscript-comment">// already running
</span>    <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(m-&gt;AdvertisedV4.ip.v4)) <span class="enscript-keyword">return</span>;

    mDNSPlatformMemZero(q, <span class="enscript-keyword">sizeof</span>(*q));
    <span class="enscript-comment">// Note: This is reverse order compared to a normal dotted-decimal IP address, so we can't use our customary &quot;%.4a&quot; format code
</span>    mDNS_snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;%d.%d.%d.%d.in-addr.arpa.&quot;</span>, ip[3], ip[2], ip[1], ip[0]);
    <span class="enscript-keyword">if</span> (!MakeDomainNameFromDNSNameString(&amp;q-&gt;qname, buf)) { LogMsg(<span class="enscript-string">&quot;Error: GetStaticHostname - bad name %s&quot;</span>, buf); <span class="enscript-keyword">return</span>; }

    q-&gt;InterfaceID      = mDNSInterface_Any;
    q-&gt;flags            = 0;
    q-&gt;qtype            = kDNSType_PTR;
    q-&gt;qclass           = kDNSClass_IN;
    q-&gt;LongLived        = mDNSfalse;
    q-&gt;ExpectUnique     = mDNSfalse;
    q-&gt;ForceMCast       = mDNSfalse;
    q-&gt;ReturnIntermed   = mDNStrue;
    q-&gt;SuppressUnusable = mDNSfalse;
    q-&gt;AppendSearchDomains = 0;
    q-&gt;TimeoutQuestion  = 0;
    q-&gt;WakeOnResolve    = 0;
    q-&gt;UseBackgroundTraffic = mDNSfalse;
    q-&gt;ValidationRequired = 0;
    q-&gt;ValidatingResponse = 0;
    q-&gt;ProxyQuestion      = 0;
    q-&gt;pid              = mDNSPlatformGetPID();
    q-&gt;euid             = 0;
    q-&gt;QuestionCallback = FoundStaticHostname;
    q-&gt;QuestionContext  = mDNSNULL;

    LogInfo(<span class="enscript-string">&quot;GetStaticHostname: %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
    err = mDNS_StartQuery_internal(m, q);
    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;Error: GetStaticHostname - StartQuery returned error %d&quot;</span>, err);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn, mDNSRecordCallback *StatusCallback, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *StatusContext)
{
    HostnameInfo **ptr = &amp;m-&gt;Hostnames;

    LogInfo(<span class="enscript-string">&quot;mDNS_AddDynDNSHostName %##s&quot;</span>, fqdn);

    <span class="enscript-keyword">while</span> (*ptr &amp;&amp; !SameDomainName(fqdn, &amp;(*ptr)-&gt;fqdn)) ptr = &amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (*ptr) { LogMsg(<span class="enscript-string">&quot;DynDNSHostName %##s already in list&quot;</span>, fqdn-&gt;c); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// allocate and format new address record
</span>    *ptr = (HostnameInfo *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(**ptr));
    <span class="enscript-keyword">if</span> (!*ptr) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNS_AddDynDNSHostName - malloc&quot;</span>); <span class="enscript-keyword">return</span>; }

    AssignDomainName(&amp;(*ptr)-&gt;fqdn, fqdn);
    (*ptr)-&gt;arv4.state     = regState_Unregistered;
    (*ptr)-&gt;arv6.state     = regState_Unregistered;
    (*ptr)-&gt;StatusCallback = StatusCallback;
    (*ptr)-&gt;StatusContext  = StatusContext;

    AdvertiseHostname(m, *ptr);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RemoveDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn)
{
    HostnameInfo **ptr = &amp;m-&gt;Hostnames;

    LogInfo(<span class="enscript-string">&quot;mDNS_RemoveDynDNSHostName %##s&quot;</span>, fqdn);

    <span class="enscript-keyword">while</span> (*ptr &amp;&amp; !SameDomainName(fqdn, &amp;(*ptr)-&gt;fqdn)) ptr = &amp;(*ptr)-&gt;next;
    <span class="enscript-keyword">if</span> (!*ptr) LogMsg(<span class="enscript-string">&quot;mDNS_RemoveDynDNSHostName: no such domainname %##s&quot;</span>, fqdn-&gt;c);
    <span class="enscript-keyword">else</span>
    {
        HostnameInfo *hi = *ptr;
        <span class="enscript-comment">// We do it this way because, if we have no active v6 record, the &quot;mDNS_Deregister_internal(m, &amp;hi-&gt;arv4);&quot;
</span>        <span class="enscript-comment">// below could free the memory, and we have to make sure we don't touch hi fields after that.
</span>        mDNSBool f4 = hi-&gt;arv4.resrec.RecordType != kDNSRecordTypeUnregistered &amp;&amp; hi-&gt;arv4.state != regState_Unregistered;
        mDNSBool f6 = hi-&gt;arv6.resrec.RecordType != kDNSRecordTypeUnregistered &amp;&amp; hi-&gt;arv6.state != regState_Unregistered;
        *ptr = (*ptr)-&gt;next; <span class="enscript-comment">// unlink
</span>        <span class="enscript-keyword">if</span> (f4 || f6)
        {
            <span class="enscript-keyword">if</span> (f4)
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_RemoveDynDNSHostName removing v4 %##s&quot;</span>, fqdn);
                mDNS_Deregister_internal(m, &amp;hi-&gt;arv4, mDNS_Dereg_normal);
            }
            <span class="enscript-keyword">if</span> (f6)
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_RemoveDynDNSHostName removing v6 %##s&quot;</span>, fqdn);
                mDNS_Deregister_internal(m, &amp;hi-&gt;arv6, mDNS_Dereg_normal);
            }
            <span class="enscript-comment">// When both deregistrations complete we'll free the memory in the mStatus_MemFree callback
</span>        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (hi-&gt;natinfo.clientContext)
            {
                mDNS_StopNATOperation_internal(m, &amp;hi-&gt;natinfo);
                hi-&gt;natinfo.clientContext = mDNSNULL;
            }
            mDNSPlatformMemFree(hi);
        }
    }
    mDNS_CheckLock(m);
    m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow);
}

<span class="enscript-comment">// Currently called without holding the lock
</span><span class="enscript-comment">// Maybe we should change that?
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetPrimaryInterfaceInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSAddr *v4addr, <span class="enscript-type">const</span> mDNSAddr *v6addr, <span class="enscript-type">const</span> mDNSAddr *router)
{
    mDNSBool v4Changed, v6Changed, RouterChanged;

    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy != m-&gt;mDNS_reentrancy)
        LogMsg(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo: mDNS_busy (%ld) != mDNS_reentrancy (%ld)&quot;</span>, m-&gt;mDNS_busy, m-&gt;mDNS_reentrancy);

    <span class="enscript-keyword">if</span> (v4addr &amp;&amp; v4addr-&gt;type != mDNSAddrType_IPv4) { LogMsg(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo v4 address - incorrect type.  Discarding. %#a&quot;</span>, v4addr); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (v6addr &amp;&amp; v6addr-&gt;type != mDNSAddrType_IPv6) { LogMsg(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo v6 address - incorrect type.  Discarding. %#a&quot;</span>, v6addr); <span class="enscript-keyword">return</span>; }
    <span class="enscript-keyword">if</span> (router &amp;&amp; router-&gt;type != mDNSAddrType_IPv4) { LogMsg(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo passed non-v4 router.  Discarding. %#a&quot;</span>,        router); <span class="enscript-keyword">return</span>; }

    mDNS_Lock(m);

    v4Changed     = !mDNSSameIPv4Address(m-&gt;AdvertisedV4.ip.v4, v4addr ? v4addr-&gt;ip.v4 : zerov4Addr);
    v6Changed     = !mDNSSameIPv6Address(m-&gt;AdvertisedV6.ip.v6, v6addr ? v6addr-&gt;ip.v6 : zerov6Addr);
    RouterChanged = !mDNSSameIPv4Address(m-&gt;Router.ip.v4,       router ? router-&gt;ip.v4 : zerov4Addr);

    <span class="enscript-keyword">if</span> (v4addr &amp;&amp; (v4Changed || RouterChanged))
        debugf(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo: address changed from %#a to %#a&quot;</span>, &amp;m-&gt;AdvertisedV4, v4addr);

    <span class="enscript-keyword">if</span> (v4addr) m-&gt;AdvertisedV4 = *v4addr;<span class="enscript-keyword">else</span> m-&gt;AdvertisedV4.ip.v4 = zerov4Addr;
    <span class="enscript-keyword">if</span> (v6addr) m-&gt;AdvertisedV6 = *v6addr;<span class="enscript-keyword">else</span> m-&gt;AdvertisedV6.ip.v6 = zerov6Addr;
    <span class="enscript-keyword">if</span> (router) m-&gt;Router       = *router;<span class="enscript-keyword">else</span> m-&gt;Router.ip.v4 = zerov4Addr;
    <span class="enscript-comment">// setting router to zero indicates that nat mappings must be reestablished when router is reset
</span>
    <span class="enscript-keyword">if</span> (v4Changed || RouterChanged || v6Changed)
    {
        HostnameInfo *i;
        LogInfo(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo: %s%s%s%#a %#a %#a&quot;</span>,
                v4Changed     ? <span class="enscript-string">&quot;v4Changed &quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
                RouterChanged ? <span class="enscript-string">&quot;RouterChanged &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                v6Changed     ? <span class="enscript-string">&quot;v6Changed &quot;</span>     : <span class="enscript-string">&quot;&quot;</span>, v4addr, v6addr, router);

        <span class="enscript-keyword">for</span> (i = m-&gt;Hostnames; i; i = i-&gt;next)
        {
            LogInfo(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo updating host name registrations for %##s&quot;</span>, i-&gt;fqdn.c);

            <span class="enscript-keyword">if</span> (i-&gt;arv4.resrec.RecordType &gt; kDNSRecordTypeDeregistering &amp;&amp;
                !mDNSSameIPv4Address(i-&gt;arv4.resrec.rdata-&gt;u.ipv4, m-&gt;AdvertisedV4.ip.v4))
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo deregistering %s&quot;</span>, ARDisplayString(m, &amp;i-&gt;arv4));
                mDNS_Deregister_internal(m, &amp;i-&gt;arv4, mDNS_Dereg_normal);
            }

            <span class="enscript-keyword">if</span> (i-&gt;arv6.resrec.RecordType &gt; kDNSRecordTypeDeregistering &amp;&amp;
                !mDNSSameIPv6Address(i-&gt;arv6.resrec.rdata-&gt;u.ipv6, m-&gt;AdvertisedV6.ip.v6))
            {
                LogInfo(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo deregistering %s&quot;</span>, ARDisplayString(m, &amp;i-&gt;arv6));
                mDNS_Deregister_internal(m, &amp;i-&gt;arv6, mDNS_Dereg_normal);
            }

            <span class="enscript-comment">// AdvertiseHostname will only register new address records.
</span>            <span class="enscript-comment">// For records still in the process of deregistering it will ignore them, and let the mStatus_MemFree callback handle them.
</span>            AdvertiseHostname(m, i);
        }

        <span class="enscript-keyword">if</span> (v4Changed || RouterChanged)
        {
            <span class="enscript-comment">// If we have a non-zero IPv4 address, we should try immediately to see if we have a NAT gateway
</span>            <span class="enscript-comment">// If we have no IPv4 address, we don't want to be in quite such a hurry to report failures to our clients
</span>            <span class="enscript-comment">// &lt;rdar://problem/6935929&gt; Sleeping server sometimes briefly disappears over Back to My Mac after it wakes up
</span>            mDNSu32 waitSeconds = v4addr ? 0 : 5;
            NATTraversalInfo *n;
            m-&gt;ExtAddress           = zerov4Addr;
            m-&gt;LastNATMapResultCode = NATErr_None;

            RecreateNATMappings(m, mDNSPlatformOneSecond * waitSeconds);

            <span class="enscript-keyword">for</span> (n = m-&gt;NATTraversals; n; n=n-&gt;next)
                n-&gt;NewAddress = zerov4Addr;

            LogInfo(<span class="enscript-string">&quot;mDNS_SetPrimaryInterfaceInfo:%s%s: recreating NAT mappings in %d seconds&quot;</span>,
                    v4Changed     ? <span class="enscript-string">&quot; v4Changed&quot;</span>     : <span class="enscript-string">&quot;&quot;</span>,
                    RouterChanged ? <span class="enscript-string">&quot; RouterChanged&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
                    waitSeconds);
        }

        <span class="enscript-keyword">if</span> (m-&gt;ReverseMap.ThisQInterval != -1) mDNS_StopQuery_internal(m, &amp;m-&gt;ReverseMap);
        m-&gt;StaticHostname.c[0] = 0;

        m-&gt;NextSRVUpdate = NonZeroTime(m-&gt;timenow);
    }

    mDNS_Unlock(m);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Incoming</span> <span class="enscript-variable-name">Message</span> <span class="enscript-variable-name">Processing</span>
#<span class="enscript-reference">endif</span>

mDNSlocal mStatus <span class="enscript-function-name">ParseTSIGError</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> displayname)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr;
    mStatus err = mStatus_NoError;
    <span class="enscript-type">int</span> i;

    ptr = LocateAdditionals(msg, end);
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;h.numAdditionals; i++)
    {
        ptr = GetLargeResourceRecord(m, msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        <span class="enscript-keyword">if</span> (m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_TSIG)
        {
            mDNSu32 macsize;
            mDNSu8 *rd = m-&gt;rec.r.resrec.rdata-&gt;u.data;
            mDNSu8 *rdend = rd + m-&gt;rec.r.resrec.rdlength;
            <span class="enscript-type">int</span> alglen = DomainNameLengthLimit(&amp;m-&gt;rec.r.resrec.rdata-&gt;u.name, rdend);
            <span class="enscript-keyword">if</span> (alglen &gt; MAX_DOMAIN_NAME) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            rd += alglen;                                       <span class="enscript-comment">// algorithm name
</span>            <span class="enscript-keyword">if</span> (rd + 6 &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            rd += 6;                                            <span class="enscript-comment">// 48-bit timestamp
</span>            <span class="enscript-keyword">if</span> (rd + <span class="enscript-keyword">sizeof</span>(mDNSOpaque16) &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            rd += <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);                         <span class="enscript-comment">// fudge
</span>            <span class="enscript-keyword">if</span> (rd + <span class="enscript-keyword">sizeof</span>(mDNSOpaque16) &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            macsize = mDNSVal16(*(mDNSOpaque16 *)rd);
            rd += <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);                         <span class="enscript-comment">// MAC size
</span>            <span class="enscript-keyword">if</span> (rd + macsize &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            rd += macsize;
            <span class="enscript-keyword">if</span> (rd + <span class="enscript-keyword">sizeof</span>(mDNSOpaque16) &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            rd += <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);                         <span class="enscript-comment">// orig id
</span>            <span class="enscript-keyword">if</span> (rd + <span class="enscript-keyword">sizeof</span>(mDNSOpaque16) &gt; rdend) <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            err = mDNSVal16(*(mDNSOpaque16 *)rd);               <span class="enscript-comment">// error code
</span>
            <span class="enscript-keyword">if</span>      (err == TSIG_ErrBadSig)  { LogMsg(<span class="enscript-string">&quot;%##s: bad signature&quot;</span>, displayname-&gt;c);              err = mStatus_BadSig;     }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err == TSIG_ErrBadKey)  { LogMsg(<span class="enscript-string">&quot;%##s: bad key&quot;</span>, displayname-&gt;c);                    err = mStatus_BadKey;     }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err == TSIG_ErrBadTime) { LogMsg(<span class="enscript-string">&quot;%##s: bad time&quot;</span>, displayname-&gt;c);                   err = mStatus_BadTime;    }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err)                    { LogMsg(<span class="enscript-string">&quot;%##s: unknown tsig error %d&quot;</span>, displayname-&gt;c, err); err = mStatus_UnknownErr; }
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }

<span class="enscript-reference">finish</span>:
    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    <span class="enscript-keyword">return</span> err;
}

mDNSlocal mStatus <span class="enscript-function-name">checkUpdateResult</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> displayname, <span class="enscript-type">const</span> mDNSu8 rcode, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    (<span class="enscript-type">void</span>)msg;  <span class="enscript-comment">// currently unused, needed for TSIG errors
</span>    <span class="enscript-keyword">if</span> (!rcode) <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_YXDomain)
    {
        debugf(<span class="enscript-string">&quot;name in use: %##s&quot;</span>, displayname-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_NameConflict;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_Refused)
    {
        LogMsg(<span class="enscript-string">&quot;Update %##s refused&quot;</span>, displayname-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_Refused;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_NXRRSet)
    {
        LogMsg(<span class="enscript-string">&quot;Reregister refused (NXRRSET): %##s&quot;</span>, displayname-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_NotAuth)
    {
        <span class="enscript-comment">// TSIG errors should come with FormErr as per RFC 2845, but BIND 9 sends them with NotAuth so we look here too
</span>        mStatus tsigerr = ParseTSIGError(m, msg, end, displayname);
        <span class="enscript-keyword">if</span> (!tsigerr)
        {
            LogMsg(<span class="enscript-string">&quot;Permission denied (NOAUTH): %##s&quot;</span>, displayname-&gt;c);
            <span class="enscript-keyword">return</span> mStatus_UnknownErr;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> tsigerr;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_FormErr)
    {
        mStatus tsigerr = ParseTSIGError(m, msg, end, displayname);
        <span class="enscript-keyword">if</span> (!tsigerr)
        {
            LogMsg(<span class="enscript-string">&quot;Format Error: %##s&quot;</span>, displayname-&gt;c);
            <span class="enscript-keyword">return</span> mStatus_UnknownErr;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> tsigerr;
    }
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;Update %##s failed with rcode %d&quot;</span>, displayname-&gt;c, rcode);
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;
    }
}

mDNSlocal mDNSu32 <span class="enscript-function-name">RRAdditionalSize</span>(DomainAuthInfo *AuthInfo)
{
    mDNSu32 leaseSize, tsigSize;
    mDNSu32 rr_base_size = 10; <span class="enscript-comment">// type (2) class (2) TTL (4) rdlength (2)
</span>
    <span class="enscript-comment">// OPT RR : Emptyname(.) + base size + rdataOPT
</span>    leaseSize = 1 + rr_base_size + <span class="enscript-keyword">sizeof</span>(rdataOPT);

    <span class="enscript-comment">//TSIG: Resource Record Name + base size + RDATA
</span>    <span class="enscript-comment">// RDATA:
</span>    <span class="enscript-comment">//  Algorithm name: hmac-md5.sig-alg.reg.int (8+7+3+3 + 5 bytes for length = 26 bytes)
</span>    <span class="enscript-comment">//  Time: 6 bytes
</span>    <span class="enscript-comment">//  Fudge: 2 bytes
</span>    <span class="enscript-comment">//  Mac Size: 2 bytes
</span>    <span class="enscript-comment">//  Mac: 16 bytes
</span>    <span class="enscript-comment">//  ID: 2 bytes
</span>    <span class="enscript-comment">//  Error: 2 bytes
</span>    <span class="enscript-comment">//  Len: 2 bytes
</span>    <span class="enscript-comment">//  Total: 58 bytes
</span>    tsigSize = 0;
    <span class="enscript-keyword">if</span> (AuthInfo) tsigSize = DomainNameLength(&amp;AuthInfo-&gt;keyname) + rr_base_size + 58;

    <span class="enscript-keyword">return</span> (leaseSize + tsigSize);
}

<span class="enscript-comment">//Note: Make sure that RREstimatedSize is updated accordingly if anything that is done here
</span><span class="enscript-comment">//would modify rdlength/rdestimate
</span>mDNSlocal mDNSu8* <span class="enscript-function-name">BuildUpdateMessage</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu8 *ptr, AuthRecord *rr, mDNSu8 *limit)
{
    <span class="enscript-comment">//If this record is deregistering, then just send the deletion record
</span>    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_DeregPending)
    {
        rr-&gt;expire = 0;     <span class="enscript-comment">// Indicate that we have no active registration any more
</span>        ptr = putDeletionRecordWithLimit(&amp;m-&gt;omsg, ptr, &amp;rr-&gt;resrec, limit);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        <span class="enscript-keyword">return</span> ptr;
    }

    <span class="enscript-comment">// This is a common function to both sending an update in a group or individual
</span>    <span class="enscript-comment">// records separately. Hence, we change the state here.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Registered) rr-&gt;state = regState_Refresh;
    <span class="enscript-keyword">if</span> (rr-&gt;state != regState_Refresh &amp;&amp; rr-&gt;state != regState_UpdatePending)
        rr-&gt;state = regState_Pending;

    <span class="enscript-comment">// For Advisory records like e.g., _services._dns-sd, which is shared, don't send goodbyes as multiple
</span>    <span class="enscript-comment">// host might be registering records and deregistering from one does not make sense
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeAdvisory) rr-&gt;RequireGoodbye = mDNStrue;

    <span class="enscript-keyword">if</span> ((rr-&gt;resrec.rrtype == kDNSType_SRV) &amp;&amp; (rr-&gt;AutoTarget == Target_AutoHostAndNATMAP) &amp;&amp;
        !mDNSIPPortIsZero(rr-&gt;NATinfo.ExternalPort))
    {
        rr-&gt;resrec.rdata-&gt;u.srv.port = rr-&gt;NATinfo.ExternalPort;
    }

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_UpdatePending)
    {
        <span class="enscript-comment">// delete old RData
</span>        SetNewRData(&amp;rr-&gt;resrec, rr-&gt;OrigRData, rr-&gt;OrigRDLen);
        <span class="enscript-keyword">if</span> (!(ptr = putDeletionRecordWithLimit(&amp;m-&gt;omsg, ptr, &amp;rr-&gt;resrec, limit))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; <span class="enscript-comment">// delete old rdata
</span>
        <span class="enscript-comment">// add new RData
</span>        SetNewRData(&amp;rr-&gt;resrec, rr-&gt;InFlightRData, rr-&gt;InFlightRDLen);
        <span class="enscript-keyword">if</span> (!(ptr = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, ptr, &amp;m-&gt;omsg.h.mDNS_numUpdates, &amp;rr-&gt;resrec, rr-&gt;resrec.rroriginalttl, limit))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeKnownUnique || rr-&gt;resrec.RecordType == kDNSRecordTypeVerified)
        {
            <span class="enscript-comment">// KnownUnique : Delete any previous value
</span>            <span class="enscript-comment">// For Unicast registrations, we don't verify that it is unique, but set to verified and hence we want to
</span>            <span class="enscript-comment">// delete any previous value
</span>            ptr = putDeleteRRSetWithLimit(&amp;m-&gt;omsg, ptr, rr-&gt;resrec.name, rr-&gt;resrec.rrtype, limit);
            <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType != kDNSRecordTypeShared)
        {
            <span class="enscript-comment">// For now don't do this, until we have the logic for intelligent grouping of individual records into logical service record sets
</span>            <span class="enscript-comment">//ptr = putPrereqNameNotInUse(rr-&gt;resrec.name, &amp;m-&gt;omsg, ptr, end);
</span>            <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }

        ptr = PutResourceRecordTTLWithLimit(&amp;m-&gt;omsg, ptr, &amp;m-&gt;omsg.h.mDNS_numUpdates, &amp;rr-&gt;resrec, rr-&gt;resrec.rroriginalttl, limit);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">return</span> ptr;
<span class="enscript-reference">exit</span>:
    LogMsg(<span class="enscript-string">&quot;BuildUpdateMessage: Error formatting message for %s&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-keyword">return</span> mDNSNULL;
}

<span class="enscript-comment">// Called with lock held
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendRecordRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    mDNSu8 *ptr = m-&gt;omsg.data;
    mStatus err = mStatus_UnknownErr;
    mDNSu8 *limit;
    DomainAuthInfo *AuthInfo;

    <span class="enscript-comment">// For the ability to register large TXT records, we limit the single record registrations
</span>    <span class="enscript-comment">// to AbsoluteMaxDNSMessageData
</span>    limit = ptr + AbsoluteMaxDNSMessageData;

    AuthInfo = GetAuthInfoForName_internal(m, rr-&gt;resrec.name);
    limit -= RRAdditionalSize(AuthInfo);

    mDNS_CheckLock(m);

    <span class="enscript-keyword">if</span> (!rr-&gt;nta || mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4))
    {
        <span class="enscript-comment">// We never call this function when there is no zone information . Log a message if it ever happens.
</span>        LogMsg(<span class="enscript-string">&quot;SendRecordRegistration: No Zone information, should not happen %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">return</span>;
    }

    rr-&gt;updateid = mDNS_NewMessageID(m);
    InitializeDNSMessage(&amp;m-&gt;omsg.h, rr-&gt;updateid, UpdateReqFlags);

    <span class="enscript-comment">// set zone
</span>    ptr = putZone(&amp;m-&gt;omsg, ptr, limit, rr-&gt;zone, mDNSOpaque16fromIntVal(rr-&gt;resrec.rrclass));
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">if</span> (!(ptr = BuildUpdateMessage(m, ptr, rr, limit))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">if</span> (rr-&gt;uselease)
    {
        ptr = putUpdateLeaseWithLimit(&amp;m-&gt;omsg, ptr, DEFAULT_UPDATE_LEASE, limit);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    <span class="enscript-keyword">if</span> (rr-&gt;Private)
    {
        LogInfo(<span class="enscript-string">&quot;SendRecordRegistration TCP %p %s&quot;</span>, rr-&gt;tcp, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (rr-&gt;tcp) LogInfo(<span class="enscript-string">&quot;SendRecordRegistration: Disposing existing TCP connection for %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp); rr-&gt;tcp = mDNSNULL; }
        <span class="enscript-keyword">if</span> (!rr-&gt;nta) { LogMsg(<span class="enscript-string">&quot;SendRecordRegistration:Private:ERROR!! nta is NULL for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }
        rr-&gt;tcp = MakeTCPConn(m, &amp;m-&gt;omsg, ptr, kTCPSocketFlags_UseTLS, &amp;rr-&gt;nta-&gt;Addr, rr-&gt;nta-&gt;Port, &amp;rr-&gt;nta-&gt;Host, mDNSNULL, rr);
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;SendRecordRegistration UDP %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (!rr-&gt;nta) { LogMsg(<span class="enscript-string">&quot;SendRecordRegistration:ERROR!! nta is NULL for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }
        err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, ptr, mDNSInterface_Any, mDNSNULL, mDNSNULL, &amp;rr-&gt;nta-&gt;Addr, rr-&gt;nta-&gt;Port, GetAuthInfoForName_internal(m, rr-&gt;resrec.name), mDNSfalse);
        <span class="enscript-keyword">if</span> (err) debugf(<span class="enscript-string">&quot;ERROR: SendRecordRegistration - mDNSSendDNSMessage - %d&quot;</span>, err);
    }

    SetRecordRetry(m, rr, 0);
    <span class="enscript-keyword">return</span>;
<span class="enscript-reference">exit</span>:
    LogMsg(<span class="enscript-string">&quot;SendRecordRegistration: Error formatting message for %s, disabling further updates&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-comment">// Disable this record from future updates
</span>    rr-&gt;state = regState_NoTarget;
}

<span class="enscript-comment">// Is the given record &quot;rr&quot; eligible for merging ?
</span>mDNSlocal mDNSBool <span class="enscript-function-name">IsRecordMergeable</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNSs32 time)
{
    DomainAuthInfo *info;
    <span class="enscript-comment">// A record is eligible for merge, if the following properties are met.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. uDNS Resource Record
</span>    <span class="enscript-comment">// 2. It is time to send them now
</span>    <span class="enscript-comment">// 3. It is in proper state
</span>    <span class="enscript-comment">// 4. Update zone has been resolved
</span>    <span class="enscript-comment">// 5. if DomainAuthInfo exists for the zone, it should not be soon deleted
</span>    <span class="enscript-comment">// 6. Zone information is present
</span>    <span class="enscript-comment">// 7. Update server is not zero
</span>    <span class="enscript-comment">// 8. It has a non-null zone
</span>    <span class="enscript-comment">// 9. It uses a lease option
</span>    <span class="enscript-comment">// 10. DontMerge is not set
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Following code is implemented as separate &quot;if&quot; statements instead of one &quot;if&quot; statement
</span>    <span class="enscript-comment">// is for better debugging purposes e.g., we know exactly what failed if debugging turned on.
</span>
    <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr)) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval - time &gt; 0)
    { debugf(<span class="enscript-string">&quot;IsRecordMergeable: Time %d not reached for %s&quot;</span>, rr-&gt;LastAPTime + rr-&gt;ThisAPInterval - m-&gt;timenow, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span> mDNSfalse; }

    <span class="enscript-keyword">if</span> (!rr-&gt;zone) <span class="enscript-keyword">return</span> mDNSfalse;

    info = GetAuthInfoForName_internal(m, rr-&gt;zone);

    <span class="enscript-keyword">if</span> (info &amp;&amp; info-&gt;deltime &amp;&amp; m-&gt;timenow - info-&gt;deltime &gt;= 0) {debugf(<span class="enscript-string">&quot;IsRecordMergeable: Domain %##s will be deleted soon&quot;</span>, info-&gt;domain.c); <span class="enscript-keyword">return</span> mDNSfalse;}

    <span class="enscript-keyword">if</span> (rr-&gt;state != regState_DeregPending &amp;&amp; rr-&gt;state != regState_Pending &amp;&amp; rr-&gt;state != regState_Registered &amp;&amp; rr-&gt;state != regState_Refresh &amp;&amp; rr-&gt;state != regState_UpdatePending)
    { debugf(<span class="enscript-string">&quot;IsRecordMergeable: state %d not right  %s&quot;</span>, rr-&gt;state, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span> mDNSfalse; }

    <span class="enscript-keyword">if</span> (!rr-&gt;nta || mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4)) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (!rr-&gt;uselease) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (rr-&gt;mState == mergeState_DontMerge) {debugf(<span class="enscript-string">&quot;IsRecordMergeable Dontmerge true %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span> mDNSfalse;}
    debugf(<span class="enscript-string">&quot;IsRecordMergeable: Returning true for %s&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// Is the resource record &quot;rr&quot; eligible to merge to with &quot;currentRR&quot; ?
</span>mDNSlocal mDNSBool <span class="enscript-function-name">AreRecordsMergeable</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *currentRR, AuthRecord *rr, mDNSs32 time)
{
    <span class="enscript-comment">// A record is eligible to merge with another record as long it is eligible for merge in itself
</span>    <span class="enscript-comment">// and it has the same zone information as the other record
</span>    <span class="enscript-keyword">if</span> (!IsRecordMergeable(m, rr, time)) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (!SameDomainName(currentRR-&gt;zone, rr-&gt;zone))
    { debugf(<span class="enscript-string">&quot;AreRecordMergeable zone mismatch current rr Zone %##s, rr zone  %##s&quot;</span>, currentRR-&gt;zone-&gt;c, rr-&gt;zone-&gt;c); <span class="enscript-keyword">return</span> mDNSfalse; }

    <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(currentRR-&gt;nta-&gt;Addr.ip.v4, rr-&gt;nta-&gt;Addr.ip.v4)) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (!mDNSSameIPPort(currentRR-&gt;nta-&gt;Port, rr-&gt;nta-&gt;Port)) <span class="enscript-keyword">return</span> mDNSfalse;

    debugf(<span class="enscript-string">&quot;AreRecordsMergeable: Returning true for %s&quot;</span>, ARDisplayString(m, rr));
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// If we can't build the message successfully because of problems in pre-computing
</span><span class="enscript-comment">// the space, we disable merging for all the current records
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">RRMergeFailure</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
    {
        rr-&gt;mState = mergeState_DontMerge;
        rr-&gt;SendRNow = mDNSNULL;
        <span class="enscript-comment">// Restarting the registration is much simpler than saving and restoring
</span>        <span class="enscript-comment">// the exact time
</span>        ActivateUnicastRegistration(m, rr);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendGroupRRMessage</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *anchorRR, mDNSu8 *ptr, DomainAuthInfo *info)
{
    mDNSu8 *limit;
    <span class="enscript-keyword">if</span> (!anchorRR) {debugf(<span class="enscript-string">&quot;SendGroupRRMessage: Could not merge records&quot;</span>); <span class="enscript-keyword">return</span>;}

    limit = m-&gt;omsg.data + NormalMaxDNSMessageData;

    <span class="enscript-comment">// This has to go in the additional section and hence need to be done last
</span>    ptr = putUpdateLeaseWithLimit(&amp;m-&gt;omsg, ptr, DEFAULT_UPDATE_LEASE, limit);
    <span class="enscript-keyword">if</span> (!ptr)
    {
        LogMsg(<span class="enscript-string">&quot;SendGroupRRMessage: ERROR: Could not put lease option, failing the group registration&quot;</span>);
        <span class="enscript-comment">// if we can't put the lease, we need to undo the merge
</span>        RRMergeFailure(m);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (anchorRR-&gt;Private)
    {
        <span class="enscript-keyword">if</span> (anchorRR-&gt;tcp) debugf(<span class="enscript-string">&quot;SendGroupRRMessage: Disposing existing TCP connection for %s&quot;</span>, ARDisplayString(m, anchorRR));
        <span class="enscript-keyword">if</span> (anchorRR-&gt;tcp) { DisposeTCPConn(anchorRR-&gt;tcp); anchorRR-&gt;tcp = mDNSNULL; }
        <span class="enscript-keyword">if</span> (!anchorRR-&gt;nta) { LogMsg(<span class="enscript-string">&quot;SendGroupRRMessage:ERROR!! nta is NULL for %s&quot;</span>, ARDisplayString(m, anchorRR)); <span class="enscript-keyword">return</span>; }
        anchorRR-&gt;tcp = MakeTCPConn(m, &amp;m-&gt;omsg, ptr, kTCPSocketFlags_UseTLS, &amp;anchorRR-&gt;nta-&gt;Addr, anchorRR-&gt;nta-&gt;Port, &amp;anchorRR-&gt;nta-&gt;Host, mDNSNULL, anchorRR);
        <span class="enscript-keyword">if</span> (!anchorRR-&gt;tcp) LogInfo(<span class="enscript-string">&quot;SendGroupRRMessage: Cannot establish TCP connection for %s&quot;</span>, ARDisplayString(m, anchorRR));
        <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;SendGroupRRMessage: Sent a group update ID: %d start %p, end %p, limit %p&quot;</span>, mDNSVal16(m-&gt;omsg.h.id), m-&gt;omsg.data, ptr, limit);
    }
    <span class="enscript-keyword">else</span>
    {
        mStatus err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, ptr, mDNSInterface_Any, mDNSNULL, mDNSNULL, &amp;anchorRR-&gt;nta-&gt;Addr, anchorRR-&gt;nta-&gt;Port, info, mDNSfalse);
        <span class="enscript-keyword">if</span> (err) LogInfo(<span class="enscript-string">&quot;SendGroupRRMessage: Cannot send UDP message for %s&quot;</span>, ARDisplayString(m, anchorRR));
        <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;SendGroupRRMessage: Sent a group UDP update ID: %d start %p, end %p, limit %p&quot;</span>, mDNSVal16(m-&gt;omsg.h.id), m-&gt;omsg.data, ptr, limit);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// As we always include the zone information and the resource records contain zone name
</span><span class="enscript-comment">// at the end, it will get compressed. Hence, we subtract zoneSize and add two bytes for
</span><span class="enscript-comment">// the compression pointer
</span>mDNSlocal mDNSu32 <span class="enscript-function-name">RREstimatedSize</span>(AuthRecord *rr, <span class="enscript-type">int</span> zoneSize)
{
    <span class="enscript-type">int</span> rdlength;

    <span class="enscript-comment">// Note: Estimation of the record size has to mirror the logic in BuildUpdateMessage, otherwise estimation
</span>    <span class="enscript-comment">// would be wrong. Currently BuildUpdateMessage calls SetNewRData in UpdatePending case. Hence, we need
</span>    <span class="enscript-comment">// to account for that here. Otherwise, we might under estimate the size.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_UpdatePending)
        <span class="enscript-comment">// old RData that will be deleted
</span>        <span class="enscript-comment">// new RData that will be added
</span>        rdlength = rr-&gt;OrigRDLen + rr-&gt;InFlightRDLen;
    <span class="enscript-keyword">else</span>
        rdlength = rr-&gt;resrec.rdestimate;

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_DeregPending)
    {
        debugf(<span class="enscript-string">&quot;RREstimatedSize: ResourceRecord %##s (%s), DomainNameLength %d, zoneSize %d, rdestimate %d&quot;</span>,
               rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), DomainNameLength(rr-&gt;resrec.name), zoneSize, rdlength);
        <span class="enscript-keyword">return</span> DomainNameLength(rr-&gt;resrec.name) - zoneSize + 2 + 10 + rdlength;
    }

    <span class="enscript-comment">// For SRV, TXT, AAAA etc. that are Unique/Verified, we also send a Deletion Record
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeKnownUnique || rr-&gt;resrec.RecordType == kDNSRecordTypeVerified)
    {
        <span class="enscript-comment">// Deletion Record: Resource Record Name + Base size (10) + 0
</span>        <span class="enscript-comment">// Record: Resource Record Name (Compressed = 2) + Base size (10) + rdestimate
</span>
        debugf(<span class="enscript-string">&quot;RREstimatedSize: ResourceRecord %##s (%s), DomainNameLength %d, zoneSize %d, rdestimate %d&quot;</span>,
               rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), DomainNameLength(rr-&gt;resrec.name), zoneSize, rdlength);
        <span class="enscript-keyword">return</span> DomainNameLength(rr-&gt;resrec.name) - zoneSize + 2 + 10 + 2 + 10 + rdlength;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">return</span> DomainNameLength(rr-&gt;resrec.name) - zoneSize + 2 + 10 + rdlength;
    }
}

mDNSlocal AuthRecord *<span class="enscript-function-name">MarkRRForSending</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    AuthRecord *firstRR = mDNSNULL;

    <span class="enscript-comment">// Look for records that needs to be sent in the next two seconds (MERGE_DELAY_TIME is set to 1 second).
</span>    <span class="enscript-comment">// The logic is as follows.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. Record 1 finishes getting zone data and its registration gets delayed by 1 second
</span>    <span class="enscript-comment">// 2. Record 2 comes 0.1 second later, finishes getting its zone data and its registration is also delayed by
</span>    <span class="enscript-comment">//    1 second which is now scheduled at 1.1 second
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// By looking for 1 second into the future (m-&gt;timenow + MERGE_DELAY_TIME below does that) we have merged both
</span>    <span class="enscript-comment">// of the above records. Note that we can't look for records too much into the future as this will affect the
</span>    <span class="enscript-comment">// retry logic. The first retry is scheduled at 3 seconds. Hence, we should always look smaller than that.
</span>    <span class="enscript-comment">// Anything more than one second will affect the first retry to happen sooner.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: As a side effect of looking one second into the future to facilitate merging, the retries happen
</span>    <span class="enscript-comment">// one second sooner.
</span>    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!firstRR)
        {
            <span class="enscript-keyword">if</span> (!IsRecordMergeable(m, rr, m-&gt;timenow + MERGE_DELAY_TIME)) <span class="enscript-keyword">continue</span>;
            firstRR = rr;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!AreRecordsMergeable(m, firstRR, rr, m-&gt;timenow + MERGE_DELAY_TIME)) <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (rr-&gt;SendRNow) LogMsg(<span class="enscript-string">&quot;MarkRRForSending: Resourcerecord %s already marked for sending&quot;</span>, ARDisplayString(m, rr));
        rr-&gt;SendRNow = uDNSInterfaceMark;
    }

    <span class="enscript-comment">// We parsed through all records and found something to send. The services/records might
</span>    <span class="enscript-comment">// get registered at different times but we want the refreshes to be all merged and sent
</span>    <span class="enscript-comment">// as one update. Hence, we accelerate some of the records so that they will sync up in
</span>    <span class="enscript-comment">// the future. Look at the records excluding the ones that we have already sent in the
</span>    <span class="enscript-comment">// previous pass. If it half way through its scheduled refresh/retransmit, merge them
</span>    <span class="enscript-comment">// into this packet.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note that we only look at Registered/Refresh state to keep it simple. As we don't know
</span>    <span class="enscript-comment">// whether the current update will fit into one or more packets, merging a resource record
</span>    <span class="enscript-comment">// (which is in a different state) that has been scheduled for retransmit would trigger
</span>    <span class="enscript-comment">// sending more packets.
</span>    <span class="enscript-keyword">if</span> (firstRR)
    {
        <span class="enscript-type">int</span> acc = 0;
        <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> ((rr-&gt;state != regState_Registered &amp;&amp; rr-&gt;state != regState_Refresh) ||
                (rr-&gt;SendRNow == uDNSInterfaceMark) ||
                (!AreRecordsMergeable(m, firstRR, rr, m-&gt;timenow + rr-&gt;ThisAPInterval/2)))
                <span class="enscript-keyword">continue</span>;
            rr-&gt;SendRNow = uDNSInterfaceMark;
            acc++;
        }
        <span class="enscript-keyword">if</span> (acc) LogInfo(<span class="enscript-string">&quot;MarkRRForSending: Accelereated %d records&quot;</span>, acc);
    }
    <span class="enscript-keyword">return</span> firstRR;
}

mDNSlocal mDNSBool <span class="enscript-function-name">SendGroupUpdates</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSOpaque16 msgid;
    mDNSs32 spaceleft = 0;
    mDNSs32 zoneSize, rrSize;
    mDNSu8 *oldnext; <span class="enscript-comment">// for debugging
</span>    mDNSu8 *next = m-&gt;omsg.data;
    AuthRecord *rr;
    AuthRecord *anchorRR = mDNSNULL;
    <span class="enscript-type">int</span> nrecords = 0;
    AuthRecord *startRR = m-&gt;ResourceRecords;
    mDNSu8 *limit = mDNSNULL;
    DomainAuthInfo *AuthInfo = mDNSNULL;
    mDNSBool sentallRecords = mDNStrue;


    <span class="enscript-comment">// We try to fit as many ResourceRecords as possible in AbsoluteNormal/MaxDNSMessageData. Before we start
</span>    <span class="enscript-comment">// putting in resource records, we need to reserve space for a few things. Every group/packet should
</span>    <span class="enscript-comment">// have the following.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) Needs space for the Zone information (which needs to be at the beginning)
</span>    <span class="enscript-comment">// 2) Additional section MUST have space for lease option, HINFO and TSIG option (which needs to
</span>    <span class="enscript-comment">//    to be at the end)
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// In future we need to reserve space for the pre-requisites which also goes at the beginning.
</span>    <span class="enscript-comment">// To accomodate pre-requisites in the future, first we walk the whole list marking records
</span>    <span class="enscript-comment">// that can be sent in this packet and computing the space needed for these records.
</span>    <span class="enscript-comment">// For TXT and SRV records, we delete the previous record if any by sending the same
</span>    <span class="enscript-comment">// resource record with ANY RDATA and zero rdlen. Hence, we need to have space for both of them.
</span>
    <span class="enscript-keyword">while</span> (startRR)
    {
        AuthInfo = mDNSNULL;
        anchorRR = mDNSNULL;
        nrecords = 0;
        zoneSize = 0;
        <span class="enscript-keyword">for</span> (rr = startRR; rr; rr = rr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;SendRNow != uDNSInterfaceMark) <span class="enscript-keyword">continue</span>;

            rr-&gt;SendRNow = mDNSNULL;

            <span class="enscript-keyword">if</span> (!anchorRR)
            {
                AuthInfo = GetAuthInfoForName_internal(m, rr-&gt;zone);

                <span class="enscript-comment">// Though we allow single record registrations for UDP to be AbsoluteMaxDNSMessageData (See
</span>                <span class="enscript-comment">// SendRecordRegistration) to handle large TXT records, to avoid fragmentation we limit UDP
</span>                <span class="enscript-comment">// message to NormalMaxDNSMessageData
</span>                spaceleft = NormalMaxDNSMessageData;

                next = m-&gt;omsg.data;
                spaceleft -= RRAdditionalSize(AuthInfo);
                <span class="enscript-keyword">if</span> (spaceleft &lt;= 0)
                {
                    LogMsg(<span class="enscript-string">&quot;SendGroupUpdates: ERROR!!: spaceleft is zero at the beginning&quot;</span>);
                    RRMergeFailure(m);
                    <span class="enscript-keyword">return</span> mDNSfalse;
                }
                limit = next + spaceleft;

                <span class="enscript-comment">// Build the initial part of message before putting in the other records
</span>                msgid = mDNS_NewMessageID(m);
                InitializeDNSMessage(&amp;m-&gt;omsg.h, msgid, UpdateReqFlags);

                <span class="enscript-comment">// We need zone information at the beginning of the packet. Length: ZNAME, ZTYPE(2), ZCLASS(2)
</span>                <span class="enscript-comment">// zone has to be non-NULL for a record to be mergeable, hence it is safe to set/ examine zone
</span>                <span class="enscript-comment">//without checking for NULL.
</span>                zoneSize = DomainNameLength(rr-&gt;zone) + 4;
                spaceleft -= zoneSize;
                <span class="enscript-keyword">if</span> (spaceleft &lt;= 0)
                {
                    LogMsg(<span class="enscript-string">&quot;SendGroupUpdates: ERROR no space for zone information, disabling merge&quot;</span>);
                    RRMergeFailure(m);
                    <span class="enscript-keyword">return</span> mDNSfalse;
                }
                next = putZone(&amp;m-&gt;omsg, next, limit, rr-&gt;zone, mDNSOpaque16fromIntVal(rr-&gt;resrec.rrclass));
                <span class="enscript-keyword">if</span> (!next)
                {
                    LogMsg(<span class="enscript-string">&quot;SendGroupUpdates: ERROR! Cannot put zone, disabling merge&quot;</span>);
                    RRMergeFailure(m);
                    <span class="enscript-keyword">return</span> mDNSfalse;
                }
                anchorRR = rr;
            }

            rrSize = RREstimatedSize(rr, zoneSize - 4);

            <span class="enscript-keyword">if</span> ((spaceleft - rrSize) &lt; 0)
            {
                <span class="enscript-comment">// If we can't fit even a single message, skip it, it will be sent separately
</span>                <span class="enscript-comment">// in CheckRecordUpdates
</span>                <span class="enscript-keyword">if</span> (!nrecords)
                {
                    LogInfo(<span class="enscript-string">&quot;SendGroupUpdates: Skipping message %s, spaceleft %d, rrSize %d&quot;</span>, ARDisplayString(m, rr), spaceleft, rrSize);
                    <span class="enscript-comment">// Mark this as not sent so that the caller knows about it
</span>                    rr-&gt;SendRNow = uDNSInterfaceMark;
                    <span class="enscript-comment">// We need to remove the merge delay so that we can send it immediately
</span>                    rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
                    rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
                    rr = rr-&gt;next;
                    anchorRR = mDNSNULL;
                    sentallRecords = mDNSfalse;
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;SendGroupUpdates:1: Parsed %d records and sending using %s, spaceleft %d, rrSize %d&quot;</span>, nrecords, ARDisplayString(m, anchorRR), spaceleft, rrSize);
                    SendGroupRRMessage(m, anchorRR, next, AuthInfo);
                }
                <span class="enscript-keyword">break</span>;      <span class="enscript-comment">// breaks out of for loop
</span>            }
            spaceleft -= rrSize;
            oldnext = next;
            LogInfo(<span class="enscript-string">&quot;SendGroupUpdates: Building a message with resource record %s, next %p, state %d, ttl %d&quot;</span>, ARDisplayString(m, rr), next, rr-&gt;state, rr-&gt;resrec.rroriginalttl);
            <span class="enscript-keyword">if</span> (!(next = BuildUpdateMessage(m, next, rr, limit)))
            {
                <span class="enscript-comment">// We calculated the space and if we can't fit in, we had some bug in the calculation,
</span>                <span class="enscript-comment">// disable merge completely.
</span>                LogMsg(<span class="enscript-string">&quot;SendGroupUpdates: ptr NULL while building message with %s&quot;</span>, ARDisplayString(m, rr));
                RRMergeFailure(m);
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
            <span class="enscript-comment">// If our estimate was higher, adjust to the actual size
</span>            <span class="enscript-keyword">if</span> ((next - oldnext) &gt; rrSize)
                LogMsg(<span class="enscript-string">&quot;SendGroupUpdates: ERROR!! Record size estimation is wrong for %s, Estimate %d, Actual %d, state %d&quot;</span>, ARDisplayString(m, rr), rrSize, next - oldnext, rr-&gt;state);
            <span class="enscript-keyword">else</span> { spaceleft += rrSize; spaceleft -= (next - oldnext); }

            nrecords++;
            <span class="enscript-comment">// We could have sent an update earlier with this &quot;rr&quot; as anchorRR for which we never got a response.
</span>            <span class="enscript-comment">// To preserve ordering, we blow away the previous connection before sending this.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp); rr-&gt;tcp = mDNSNULL;}
            rr-&gt;updateid = msgid;

            <span class="enscript-comment">// By setting the retry time interval here, we will not be looking at these records
</span>            <span class="enscript-comment">// again when we return to CheckGroupRecordUpdates.
</span>            SetRecordRetry(m, rr, 0);
        }
        <span class="enscript-comment">// Either we have parsed all the records or stopped at &quot;rr&quot; above due to lack of space
</span>        startRR = rr;
    }

    <span class="enscript-keyword">if</span> (anchorRR)
    {
        LogInfo(<span class="enscript-string">&quot;SendGroupUpdates: Parsed %d records and sending using %s&quot;</span>, nrecords, ARDisplayString(m, anchorRR));
        SendGroupRRMessage(m, anchorRR, next, AuthInfo);
    }
    <span class="enscript-keyword">return</span> sentallRecords;
}

<span class="enscript-comment">// Merge the record registrations and send them as a group only if they
</span><span class="enscript-comment">// have same DomainAuthInfo and hence the same key to put the TSIG
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckGroupRecordUpdates</span>(mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr, *nextRR;
    <span class="enscript-comment">// Keep sending as long as there is at least one record to be sent
</span>    <span class="enscript-keyword">while</span> (MarkRRForSending(m))
    {
        <span class="enscript-keyword">if</span> (!SendGroupUpdates(m))
        {
            <span class="enscript-comment">// if everything that was marked was not sent, send them out individually
</span>            <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = nextRR)
            {
                <span class="enscript-comment">// SendRecordRegistrtion might delete the rr from list, hence
</span>                <span class="enscript-comment">// dereference nextRR before calling the function
</span>                nextRR = rr-&gt;next;
                <span class="enscript-keyword">if</span> (rr-&gt;SendRNow == uDNSInterfaceMark)
                {
                    <span class="enscript-comment">// Any records marked for sending should be eligible to be sent out
</span>                    <span class="enscript-comment">// immediately. Just being cautious
</span>                    <span class="enscript-keyword">if</span> (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval - m-&gt;timenow &gt; 0)
                    { LogMsg(<span class="enscript-string">&quot;CheckGroupRecordUpdates: ERROR!! Resourcerecord %s not ready&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">continue</span>; }
                    rr-&gt;SendRNow = mDNSNULL;
                    SendRecordRegistration(m, rr);
                }
            }
        }
    }

    debugf(<span class="enscript-string">&quot;CheckGroupRecordUpdates: No work, returning&quot;</span>);
    <span class="enscript-keyword">return</span>;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">hndlSRVChanged</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr)
{
    <span class="enscript-comment">// Reevaluate the target always as NAT/Target could have changed while
</span>    <span class="enscript-comment">// we were registering/deeregistering
</span>    domainname *dt;
    <span class="enscript-type">const</span> domainname *target = GetServiceTarget(m, rr);
    <span class="enscript-keyword">if</span> (!target || target-&gt;c[0] == 0)
    {
        <span class="enscript-comment">// we don't have a target, if we just derregistered, then we don't have to do anything
</span>        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_DeregPending)
        {
            LogInfo(<span class="enscript-string">&quot;hndlSRVChanged: SRVChanged, No Target, SRV Deregistered for %##s, state %d&quot;</span>, rr-&gt;resrec.name-&gt;c,
                    rr-&gt;state);
            rr-&gt;SRVChanged = mDNSfalse;
            dt = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
            <span class="enscript-keyword">if</span> (dt) dt-&gt;c[0] = 0;
            rr-&gt;state = regState_NoTarget;  <span class="enscript-comment">// Wait for the next target change
</span>            rr-&gt;resrec.rdlength = rr-&gt;resrec.rdestimate = 0;
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// we don't have a target, if we just registered, we need to deregister
</span>        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Pending)
        {
            LogInfo(<span class="enscript-string">&quot;hndlSRVChanged: SRVChanged, No Target, Deregistering again %##s, state %d&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;state);
            rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
            rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
            rr-&gt;state = regState_DeregPending;
            <span class="enscript-keyword">return</span>;
        }
        LogInfo(<span class="enscript-string">&quot;hndlSRVChanged: Not in DeregPending or RegPending state %##s, state %d&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;state);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// If we were in registered state and SRV changed to NULL, we deregister and come back here
</span>        <span class="enscript-comment">// if we have a target, we need to register again.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// if we just registered check to see if it is same. If it is different just re-register the
</span>        <span class="enscript-comment">// SRV and its assoicated records
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// UpdateOneSRVRecord takes care of re-registering all service records
</span>        <span class="enscript-keyword">if</span> ((rr-&gt;state == regState_DeregPending) ||
            (rr-&gt;state == regState_Pending &amp;&amp; !SameDomainName(target, &amp;rr-&gt;resrec.rdata-&gt;u.srv.target)))
        {
            dt = GetRRDomainNameTarget(&amp;rr-&gt;resrec);
            <span class="enscript-keyword">if</span> (dt) dt-&gt;c[0] = 0;
            rr-&gt;state = regState_NoTarget;  <span class="enscript-comment">// NoTarget will allow us to pick up new target OR nat traversal state
</span>            rr-&gt;resrec.rdlength = rr-&gt;resrec.rdestimate = 0;
            LogInfo(<span class="enscript-string">&quot;hndlSRVChanged: SRVChanged, Valid Target %##s, Registering all records for %##s, state %d&quot;</span>,
                    target-&gt;c, rr-&gt;resrec.name-&gt;c, rr-&gt;state);
            rr-&gt;SRVChanged = mDNSfalse;
            UpdateOneSRVRecord(m, rr);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// Target did not change while this record was registering. Hence, we go to
</span>        <span class="enscript-comment">// Registered state - the state we started from.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Pending) rr-&gt;state = regState_Registered;
    }

    rr-&gt;SRVChanged = mDNSfalse;
}

<span class="enscript-comment">// Called with lock held
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">hndlRecordUpdateReply</span>(mDNS *m, AuthRecord *rr, mStatus err, mDNSu32 random)
{
    mDNSBool InvokeCallback = mDNStrue;
    mDNSIPPort UpdatePort = zeroIPPort;

    mDNS_CheckLock(m);

    LogInfo(<span class="enscript-string">&quot;hndlRecordUpdateReply: err %d ID %d state %d %s(%p)&quot;</span>, err, mDNSVal16(rr-&gt;updateid), rr-&gt;state, ARDisplayString(m, rr), rr);

    rr-&gt;updateError = err;

    SetRecordRetry(m, rr, random);

    rr-&gt;updateid = zeroID;  <span class="enscript-comment">// Make sure that this is not considered as part of a group anymore
</span>    <span class="enscript-comment">// Later when need to send an update, we will get the zone data again. Thus we avoid
</span>    <span class="enscript-comment">// using stale information.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: By clearing out the zone info here, it also helps better merging of records
</span>    <span class="enscript-comment">// in some cases. For example, when we get out regState_NoTarget state e.g., move out
</span>    <span class="enscript-comment">// of Double NAT, we want all the records to be in one update. Some BTMM records like
</span>    <span class="enscript-comment">// _autotunnel6 and host records are registered/deregistered when NAT state changes.
</span>    <span class="enscript-comment">// As they are re-registered the zone information is cleared out. To merge with other
</span>    <span class="enscript-comment">// records that might be possibly going out, clearing out the information here helps
</span>    <span class="enscript-comment">// as all of them try to get the zone data.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;nta)
    {
        <span class="enscript-comment">// We always expect the question to be stopped when we get a valid response from the server.
</span>        <span class="enscript-comment">// If the zone info tries to change during this time, updateid would be different and hence
</span>        <span class="enscript-comment">// this response should not have been accepted.
</span>        <span class="enscript-keyword">if</span> (rr-&gt;nta-&gt;question.ThisQInterval != -1)
            LogMsg(<span class="enscript-string">&quot;hndlRecordUpdateReply: ResourceRecord %s, zone info question %##s (%s) interval %d not -1&quot;</span>,
                   ARDisplayString(m, rr), rr-&gt;nta-&gt;question.qname.c, DNSTypeName(rr-&gt;nta-&gt;question.qtype), rr-&gt;nta-&gt;question.ThisQInterval);
        UpdatePort = rr-&gt;nta-&gt;Port;
        CancelGetZoneData(m, rr-&gt;nta);
        rr-&gt;nta = mDNSNULL;
    }

    <span class="enscript-comment">// If we are deregistering the record, then complete the deregistration. Ignore any NAT/SRV change
</span>    <span class="enscript-comment">// that could have happened during that time.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering &amp;&amp; rr-&gt;state == regState_DeregPending)
    {
        debugf(<span class="enscript-string">&quot;hndlRecordUpdateReply: Received reply for deregister record %##s type %d&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;resrec.rrtype);
        <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;ERROR: Deregistration of record %##s type %d failed with error %d&quot;</span>,
                        rr-&gt;resrec.name-&gt;c, rr-&gt;resrec.rrtype, err);
        rr-&gt;state = regState_Unregistered;
        CompleteDeregistration(m, rr);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// We are returning early without updating the state. When we come back from sleep we will re-register after
</span>    <span class="enscript-comment">// re-initializing all the state as though it is a first registration. If the record can't be registered e.g.,
</span>    <span class="enscript-comment">// no target, it will be deregistered. Hence, the updating to the right state should not matter when going
</span>    <span class="enscript-comment">// to sleep.
</span>    <span class="enscript-keyword">if</span> (m-&gt;SleepState)
    {
        <span class="enscript-comment">// Need to set it to NoTarget state so that RecordReadyForSleep knows that
</span>        <span class="enscript-comment">// we are done
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; rr-&gt;state == regState_DeregPending)
            rr-&gt;state = regState_NoTarget;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_UpdatePending)
    {
        <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;Update record failed for %##s (err %d)&quot;</span>, rr-&gt;resrec.name-&gt;c, err);
        rr-&gt;state = regState_Registered;
        <span class="enscript-comment">// deallocate old RData
</span>        <span class="enscript-keyword">if</span> (rr-&gt;UpdateCallback) rr-&gt;UpdateCallback(m, rr, rr-&gt;OrigRData, rr-&gt;OrigRDLen);
        SetNewRData(&amp;rr-&gt;resrec, rr-&gt;InFlightRData, rr-&gt;InFlightRDLen);
        rr-&gt;OrigRData = mDNSNULL;
        rr-&gt;InFlightRData = mDNSNULL;
    }

    <span class="enscript-keyword">if</span> (rr-&gt;SRVChanged)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_SRV)
            hndlSRVChanged(m, rr);
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;hndlRecordUpdateReply: Deregistered %##s (%s), state %d&quot;</span>, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype), rr-&gt;state);
            rr-&gt;SRVChanged = mDNSfalse;
            <span class="enscript-keyword">if</span> (rr-&gt;state != regState_DeregPending) LogMsg(<span class="enscript-string">&quot;hndlRecordUpdateReply: ResourceRecord %s not in DeregPending state %d&quot;</span>, ARDisplayString(m, rr), rr-&gt;state);
            rr-&gt;state = regState_NoTarget;  <span class="enscript-comment">// Wait for the next target change
</span>        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Pending || rr-&gt;state == regState_Refresh)
    {
        <span class="enscript-keyword">if</span> (!err)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Refresh) InvokeCallback = mDNSfalse;
            rr-&gt;state = regState_Registered;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Retry without lease only for non-Private domains
</span>            LogMsg(<span class="enscript-string">&quot;hndlRecordUpdateReply: Registration of record %##s type %d failed with error %d&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;resrec.rrtype, err);
            <span class="enscript-keyword">if</span> (!rr-&gt;Private &amp;&amp; rr-&gt;uselease &amp;&amp; err == mStatus_UnknownErr &amp;&amp; mDNSSameIPPort(UpdatePort, UnicastDNSPort))
            {
                LogMsg(<span class="enscript-string">&quot;hndlRecordUpdateReply: Will retry update of record %##s without lease option&quot;</span>, rr-&gt;resrec.name-&gt;c);
                rr-&gt;uselease = mDNSfalse;
                rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
                rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
                SetNextuDNSEvent(m, rr);
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-comment">// Communicate the error to the application in the callback below
</span>        }
    }

    <span class="enscript-keyword">if</span> (rr-&gt;QueuedRData &amp;&amp; rr-&gt;state == regState_Registered)
    {
        rr-&gt;state = regState_UpdatePending;
        rr-&gt;InFlightRData = rr-&gt;QueuedRData;
        rr-&gt;InFlightRDLen = rr-&gt;QueuedRDLen;
        rr-&gt;OrigRData = rr-&gt;resrec.rdata;
        rr-&gt;OrigRDLen = rr-&gt;resrec.rdlength;
        rr-&gt;QueuedRData = mDNSNULL;
        rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
        rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
        SetNextuDNSEvent(m, rr);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Don't invoke the callback on error as this may not be useful to the client.
</span>    <span class="enscript-comment">// The client may potentially delete the resource record on error which we normally
</span>    <span class="enscript-comment">// delete during deregistration
</span>    <span class="enscript-keyword">if</span> (!err &amp;&amp; InvokeCallback &amp;&amp; rr-&gt;RecordCallback)
    {
        LogInfo(<span class="enscript-string">&quot;hndlRecordUpdateReply: Calling record callback on %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);
        mDNS_DropLockBeforeCallback();
        rr-&gt;RecordCallback(m, rr, err);
        mDNS_ReclaimLockAfterCallback();
    }
    <span class="enscript-comment">// CAUTION: MUST NOT do anything more with rr after calling rr-&gt;Callback(), because the client's callback function
</span>    <span class="enscript-comment">// is allowed to do anything, including starting/stopping queries, registering/deregistering records, etc.
</span>}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_ReceiveNATPMPPacket</span>(mDNS *m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu8 *pkt, mDNSu16 len)
{
    NATTraversalInfo *ptr;
    NATAddrReply     *AddrReply    = (NATAddrReply    *)pkt;
    NATPortMapReply  *PortMapReply = (NATPortMapReply *)pkt;
    mDNSu32 nat_elapsed, our_elapsed;

    <span class="enscript-comment">// Minimum NAT-PMP packet is vers (1) opcode (1) + err (2) = 4 bytes
</span>    <span class="enscript-keyword">if</span> (len &lt; 4) { LogMsg(<span class="enscript-string">&quot;NAT-PMP message too short (%d bytes)&quot;</span>, len); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// Read multi-byte error value (field is identical in a NATPortMapReply)
</span>    AddrReply-&gt;err = (mDNSu16) ((mDNSu16)pkt[2] &lt;&lt; 8 | pkt[3]);

    <span class="enscript-keyword">if</span> (AddrReply-&gt;err == NATErr_Vers)
    {
        NATTraversalInfo *n;
        LogInfo(<span class="enscript-string">&quot;NAT-PMP version unsupported message received&quot;</span>);
        <span class="enscript-keyword">for</span> (n = m-&gt;NATTraversals; n; n=n-&gt;next)
        {
            <span class="enscript-comment">// Send a NAT-PMP request for this operation as needed
</span>            <span class="enscript-comment">// and update the state variables
</span>            uDNS_SendNATMsg(m, n, mDNSfalse, mDNSfalse);
        }

        m-&gt;NextScheduledNATOp = m-&gt;timenow;

        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// The minimum reasonable NAT-PMP packet length is vers (1) + opcode (1) + err (2) + upseconds (4) = 8 bytes
</span>    <span class="enscript-comment">// If it's not at least this long, bail before we byte-swap the upseconds field &amp; overrun our buffer.
</span>    <span class="enscript-comment">// The retry timer will ensure we converge to correctness.
</span>    <span class="enscript-keyword">if</span> (len &lt; 8)
    {
        LogMsg(<span class="enscript-string">&quot;NAT-PMP message too short (%d bytes) 0x%X 0x%X&quot;</span>, len, AddrReply-&gt;opcode, AddrReply-&gt;err);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Read multi-byte upseconds value (field is identical in a NATPortMapReply)
</span>    AddrReply-&gt;upseconds = (mDNSs32) ((mDNSs32)pkt[4] &lt;&lt; 24 | (mDNSs32)pkt[5] &lt;&lt; 16 | (mDNSs32)pkt[6] &lt;&lt; 8 | pkt[7]);

    nat_elapsed = AddrReply-&gt;upseconds - m-&gt;LastNATupseconds;
    our_elapsed = (m-&gt;timenow - m-&gt;LastNATReplyLocalTime) / mDNSPlatformOneSecond;
    debugf(<span class="enscript-string">&quot;uDNS_ReceiveNATPMPPacket %X upseconds %u nat_elapsed %d our_elapsed %d&quot;</span>, AddrReply-&gt;opcode, AddrReply-&gt;upseconds, nat_elapsed, our_elapsed);

    <span class="enscript-comment">// We compute a conservative estimate of how much the NAT gateways's clock should have advanced
</span>    <span class="enscript-comment">// 1. We subtract 12.5% from our own measured elapsed time, to allow for NAT gateways that have an inacurate clock that runs slowly
</span>    <span class="enscript-comment">// 2. We add a two-second safety margin to allow for rounding errors: e.g.
</span>    <span class="enscript-comment">//    -- if NAT gateway sends a packet at t=2.000 seconds, then one at t=7.999, that's approximately 6 real seconds,
</span>    <span class="enscript-comment">//       but based on the values in the packet (2,7) the apparent difference according to the packet is only 5 seconds
</span>    <span class="enscript-comment">//    -- if we're slow handling packets and/or we have coarse clock granularity,
</span>    <span class="enscript-comment">//       we could receive the t=2 packet at our t=1.999 seconds, which we round down to 1
</span>    <span class="enscript-comment">//       and the t=7.999 packet at our t=8.000 seconds, which we record as 8,
</span>    <span class="enscript-comment">//       giving an apparent local time difference of 7 seconds
</span>    <span class="enscript-comment">//    The two-second safety margin coves this possible calculation discrepancy
</span>    <span class="enscript-keyword">if</span> (AddrReply-&gt;upseconds &lt; m-&gt;LastNATupseconds || nat_elapsed + 2 &lt; our_elapsed - our_elapsed/8)
    { LogMsg(<span class="enscript-string">&quot;NAT-PMP epoch time check failed: assuming NAT gateway %#a rebooted&quot;</span>, &amp;m-&gt;Router); RecreateNATMappings(m, 0); }

    m-&gt;LastNATupseconds      = AddrReply-&gt;upseconds;
    m-&gt;LastNATReplyLocalTime = m-&gt;timenow;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    LNT_ClearState(m);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

    <span class="enscript-keyword">if</span> (AddrReply-&gt;opcode == NATOp_AddrResponse)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        LogInfo(<span class="enscript-string">&quot;uDNS_ReceiveNATPMPPacket: AddressRequest %s error %d&quot;</span>, AddrReply-&gt;err ? <span class="enscript-string">&quot;failure&quot;</span> : <span class="enscript-string">&quot;success&quot;</span>, AddrReply-&gt;err);
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (!AddrReply-&gt;err &amp;&amp; len &lt; <span class="enscript-keyword">sizeof</span>(NATAddrReply)) { LogMsg(<span class="enscript-string">&quot;NAT-PMP AddrResponse message too short (%d bytes)&quot;</span>, len); <span class="enscript-keyword">return</span>; }
        natTraversalHandleAddressReply(m, AddrReply-&gt;err, AddrReply-&gt;ExtAddr);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (AddrReply-&gt;opcode == NATOp_MapUDPResponse || AddrReply-&gt;opcode == NATOp_MapTCPResponse)
    {
        mDNSu8 Protocol = AddrReply-&gt;opcode &amp; 0x7F;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
        LogInfo(<span class="enscript-string">&quot;uDNS_ReceiveNATPMPPacket: PortMapRequest %s %s - error %d&quot;</span>,
            PortMapReply-&gt;err ? <span class="enscript-string">&quot;failure&quot;</span> : <span class="enscript-string">&quot;success&quot;</span>, (AddrReply-&gt;opcode == NATOp_MapUDPResponse) ? <span class="enscript-string">&quot;UDP&quot;</span> : <span class="enscript-string">&quot;TCP&quot;</span>, PortMapReply-&gt;err);
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (!PortMapReply-&gt;err)
        {
            <span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(NATPortMapReply)) { LogMsg(<span class="enscript-string">&quot;NAT-PMP PortMapReply message too short (%d bytes)&quot;</span>, len); <span class="enscript-keyword">return</span>; }
            PortMapReply-&gt;NATRep_lease = (mDNSu32) ((mDNSu32)pkt[12] &lt;&lt; 24 | (mDNSu32)pkt[13] &lt;&lt; 16 | (mDNSu32)pkt[14] &lt;&lt; 8 | pkt[15]);
        }

        <span class="enscript-comment">// Since some NAT-PMP server implementations don't return the requested internal port in
</span>        <span class="enscript-comment">// the reply, we can't associate this reply with a particular NATTraversalInfo structure.
</span>        <span class="enscript-comment">// We globally keep track of the most recent error code for mappings.
</span>        m-&gt;LastNATMapResultCode = PortMapReply-&gt;err;

        <span class="enscript-keyword">for</span> (ptr = m-&gt;NATTraversals; ptr; ptr=ptr-&gt;next)
            <span class="enscript-keyword">if</span> (ptr-&gt;Protocol == Protocol &amp;&amp; mDNSSameIPPort(ptr-&gt;IntPort, PortMapReply-&gt;intport))
                natTraversalHandlePortMapReply(m, ptr, InterfaceID, PortMapReply-&gt;err, PortMapReply-&gt;extport, PortMapReply-&gt;NATRep_lease, NATTProtocolNATPMP);
    }
    <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;Received NAT-PMP response with unknown opcode 0x%X&quot;</span>, AddrReply-&gt;opcode); <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// Don't need an SSDP socket if we get a NAT-PMP packet
</span>    <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket) { debugf(<span class="enscript-string">&quot;uDNS_ReceiveNATPMPPacket destroying SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); mDNSPlatformUDPClose(m-&gt;SSDPSocket); m-&gt;SSDPSocket = mDNSNULL; }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_ReceivePCPPacket</span>(mDNS *m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu8 *pkt, mDNSu16 len)
{
    NATTraversalInfo *ptr;
    PCPMapReply *reply = (PCPMapReply*)pkt;
    mDNSu32 client_delta, server_delta;
    mDNSBool checkEpochValidity = m-&gt;LastNATupseconds != 0;
    mDNSu8 strippedOpCode;
    mDNSv4Addr mappedAddress = zerov4Addr;
    mDNSu8 protocol = 0;
    mDNSIPPort intport = zeroIPPort;
    mDNSIPPort extport = zeroIPPort;

    <span class="enscript-comment">// Minimum PCP packet is 24 bytes
</span>    <span class="enscript-keyword">if</span> (len &lt; 24)
    {
        LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: message too short (%d bytes)&quot;</span>, len);
        <span class="enscript-keyword">return</span>;
    }

    strippedOpCode = reply-&gt;opCode &amp; 0x7f;

    <span class="enscript-keyword">if</span> ((reply-&gt;opCode &amp; 0x80) == 0x00 || (strippedOpCode != PCPOp_Announce &amp;&amp; strippedOpCode != PCPOp_Map))
    {
        LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: unhandled opCode %u&quot;</span>, reply-&gt;opCode);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Read multi-byte values
</span>    reply-&gt;lifetime = (mDNSs32)((mDNSs32)pkt[4] &lt;&lt; 24 | (mDNSs32)pkt[5] &lt;&lt; 16 | (mDNSs32)pkt[ 6] &lt;&lt; 8 | pkt[ 7]);
    reply-&gt;epoch    = (mDNSs32)((mDNSs32)pkt[8] &lt;&lt; 24 | (mDNSs32)pkt[9] &lt;&lt; 16 | (mDNSs32)pkt[10] &lt;&lt; 8 | pkt[11]);

    client_delta = (m-&gt;timenow - m-&gt;LastNATReplyLocalTime) / mDNSPlatformOneSecond;
    server_delta = reply-&gt;epoch - m-&gt;LastNATupseconds;
    debugf(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: %X %X upseconds %u client_delta %d server_delta %d&quot;</span>, reply-&gt;opCode, reply-&gt;result, reply-&gt;epoch, client_delta, server_delta);

    <span class="enscript-comment">// If seconds since the epoch is 0, use 1 so we'll check epoch validity next time
</span>    m-&gt;LastNATupseconds      = reply-&gt;epoch ? reply-&gt;epoch : 1;
    m-&gt;LastNATReplyLocalTime = m-&gt;timenow;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    LNT_ClearState(m);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

    <span class="enscript-comment">// Don't need an SSDP socket if we get a PCP packet
</span>    <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket) { debugf(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: destroying SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); mDNSPlatformUDPClose(m-&gt;SSDPSocket); m-&gt;SSDPSocket = mDNSNULL; }

    <span class="enscript-keyword">if</span> (checkEpochValidity &amp;&amp; (client_delta + 2 &lt; server_delta - server_delta / 16 || server_delta + 2 &lt; client_delta - client_delta / 16))
    {
        <span class="enscript-comment">// If this is an ANNOUNCE packet, wait a random interval up to 5 seconds
</span>        <span class="enscript-comment">// otherwise, refresh immediately
</span>        mDNSu32 waitTicks = strippedOpCode ? 0 : mDNSRandom(PCP_WAITSECS_AFTER_EPOCH_INVALID * mDNSPlatformOneSecond);
        LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: Epoch invalid, %#a likely rebooted, waiting %u ticks&quot;</span>, &amp;m-&gt;Router, waitTicks);
        RecreateNATMappings(m, waitTicks);
        <span class="enscript-comment">// we can ignore the rest of this packet, as new requests are about to go out
</span>        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (strippedOpCode == PCPOp_Announce)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// We globally keep track of the most recent error code for mappings.
</span>    <span class="enscript-comment">// This seems bad to do with PCP, but best not change it now.
</span>    m-&gt;LastNATMapResultCode = reply-&gt;result;

    <span class="enscript-keyword">if</span> (!reply-&gt;result)
    {
        <span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(PCPMapReply))
        {
            LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: mapping response too short (%d bytes)&quot;</span>, len);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// Check the nonce
</span>        <span class="enscript-keyword">if</span> (reply-&gt;nonce[0] != m-&gt;PCPNonce[0] || reply-&gt;nonce[1] != m-&gt;PCPNonce[1] || reply-&gt;nonce[2] != m-&gt;PCPNonce[2])
        {
            LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: invalid nonce, ignoring. received { %x %x %x } expected { %x %x %x }&quot;</span>,
                   reply-&gt;nonce[0], reply-&gt;nonce[1], reply-&gt;nonce[2],
                    m-&gt;PCPNonce[0],  m-&gt;PCPNonce[1],  m-&gt;PCPNonce[2]);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// Get the values
</span>        protocol = reply-&gt;protocol;
        intport = reply-&gt;intPort;
        extport = reply-&gt;extPort;

        <span class="enscript-comment">// Get the external address, which should be mapped, since we only support IPv4
</span>        <span class="enscript-keyword">if</span> (!mDNSAddrIPv4FromMappedIPv6(&amp;reply-&gt;extAddress, &amp;mappedAddress))
        {
            LogMsg(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: unexpected external address: %.16a&quot;</span>, &amp;reply-&gt;extAddress);
            reply-&gt;result = NATErr_NetFail;
            <span class="enscript-comment">// fall through to report the error
</span>        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mDNSIPv4AddressIsZero(mappedAddress))
        {
            <span class="enscript-comment">// If this is the deletion case, we will have sent the zero IPv4-mapped address
</span>            <span class="enscript-comment">// in our request, and the server should reflect it in the response, so we
</span>            <span class="enscript-comment">// should not log about receiving a zero address. And in this case, we no
</span>            <span class="enscript-comment">// longer have a NATTraversal to report errors back to, so it's ok to set the
</span>            <span class="enscript-comment">// result here.
</span>            <span class="enscript-comment">// In other cases, a zero address is an error, and we will have a NATTraversal
</span>            <span class="enscript-comment">// to report back to, so set an error and fall through to report it.
</span>            <span class="enscript-comment">// CheckNATMappings will log the error.
</span>            reply-&gt;result = NATErr_NetFail;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        LogInfo(<span class="enscript-string">&quot;uDNS_ReceivePCPPacket: error received from server. opcode %X result %X lifetime %X epoch %X&quot;</span>,
                reply-&gt;opCode, reply-&gt;result, reply-&gt;lifetime, reply-&gt;epoch);

        <span class="enscript-comment">// If the packet is long enough, get the protocol &amp; intport for matching to report
</span>        <span class="enscript-comment">// the error
</span>        <span class="enscript-keyword">if</span> (len &gt;= <span class="enscript-keyword">sizeof</span>(PCPMapReply))
        {
            protocol = reply-&gt;protocol;
            intport = reply-&gt;intPort;
        }
    }

    <span class="enscript-keyword">for</span> (ptr = m-&gt;NATTraversals; ptr; ptr=ptr-&gt;next)
    {
        mDNSu8 ptrProtocol = ((ptr-&gt;Protocol &amp; NATOp_MapTCP) == NATOp_MapTCP ? PCPProto_TCP : PCPProto_UDP);
        <span class="enscript-keyword">if</span> ((protocol == ptrProtocol &amp;&amp; mDNSSameIPPort(ptr-&gt;IntPort, intport)) ||
            (!ptr-&gt;Protocol &amp;&amp; protocol == PCPProto_TCP &amp;&amp; mDNSSameIPPort(DiscardPort, intport)))
        {
            natTraversalHandlePortMapReplyWithAddress(m, ptr, InterfaceID, reply-&gt;result ? NATErr_NetFail : NATErr_None, mappedAddress, extport, reply-&gt;lifetime, NATTProtocolPCP);
        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_ReceiveNATPacket</span>(mDNS *m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu8 *pkt, mDNSu16 len)
{
    <span class="enscript-keyword">if</span> (len == 0)
        LogMsg(<span class="enscript-string">&quot;uDNS_ReceiveNATPacket: zero length packet&quot;</span>);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pkt[0] == PCP_VERS)
        uDNS_ReceivePCPPacket(m, InterfaceID, pkt, len);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pkt[0] == NATMAP_VERS)
        uDNS_ReceiveNATPMPPacket(m, InterfaceID, pkt, len);
    <span class="enscript-keyword">else</span>
        LogMsg(<span class="enscript-string">&quot;uDNS_ReceiveNATPacket: packet with version %u (expected %u or %u)&quot;</span>, pkt[0], PCP_VERS, NATMAP_VERS);
}

<span class="enscript-comment">// Called from mDNSCoreReceive with the lock held
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_ReceiveMsg</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport)
{
    DNSQuestion *qptr;
    mStatus err = mStatus_NoError;

    mDNSu8 StdR    = kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery;
    mDNSu8 UpdateR = kDNSFlag0_QR_Response | kDNSFlag0_OP_Update;
    mDNSu8 QR_OP   = (mDNSu8)(msg-&gt;h.flags.b[0] &amp; kDNSFlag0_QROP_Mask);
    mDNSu8 rcode   = (mDNSu8)(msg-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask);

    (<span class="enscript-type">void</span>)srcport; <span class="enscript-comment">// Unused
</span>
    debugf(<span class="enscript-string">&quot;uDNS_ReceiveMsg from %#-15a with &quot;</span>
           <span class="enscript-string">&quot;%2d Question%s %2d Answer%s %2d Authorit%s %2d Additional%s %d bytes&quot;</span>,
           srcaddr,
           msg-&gt;h.numQuestions,   msg-&gt;h.numQuestions   == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           msg-&gt;h.numAnswers,     msg-&gt;h.numAnswers     == 1 ? <span class="enscript-string">&quot;, &quot;</span>   : <span class="enscript-string">&quot;s,&quot;</span>,
           msg-&gt;h.numAuthorities, msg-&gt;h.numAuthorities == 1 ? <span class="enscript-string">&quot;y,  &quot;</span> : <span class="enscript-string">&quot;ies,&quot;</span>,
           msg-&gt;h.numAdditionals, msg-&gt;h.numAdditionals == 1 ? <span class="enscript-string">&quot;&quot;</span>     : <span class="enscript-string">&quot;s&quot;</span>, end - msg-&gt;data);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
    <span class="enscript-keyword">if</span> (NumUnreachableDNSServers &gt; 0)
        SymptomReporterDNSServerReachable(m, srcaddr);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (QR_OP == StdR)
    {
        <span class="enscript-comment">//if (srcaddr &amp;&amp; recvLLQResponse(m, msg, end, srcaddr, srcport)) return;
</span>        <span class="enscript-keyword">for</span> (qptr = m-&gt;Questions; qptr; qptr = qptr-&gt;next)
            <span class="enscript-keyword">if</span> (msg-&gt;h.flags.b[0] &amp; kDNSFlag0_TC &amp;&amp; mDNSSameOpaque16(qptr-&gt;TargetQID, msg-&gt;h.id) &amp;&amp; m-&gt;timenow - qptr-&gt;LastQTime &lt; RESPONSE_WINDOW)
            {
                <span class="enscript-keyword">if</span> (!srcaddr) LogMsg(<span class="enscript-string">&quot;uDNS_ReceiveMsg: TCP DNS response had TC bit set: ignoring&quot;</span>);
                <span class="enscript-keyword">else</span>
                {
                    uDNS_RestartQuestionAsTCP(m, qptr, srcaddr, srcport);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                    qptr-&gt;metrics.dnsOverTCPState = DNSOverTCP_Truncated;
#<span class="enscript-reference">endif</span>
                }
            }
    }

    <span class="enscript-keyword">if</span> (QR_OP == UpdateR)
    {
        mDNSu32 pktlease = 0;
        mDNSBool gotlease = GetPktLease(m, msg, end, &amp;pktlease);
        mDNSu32 lease = gotlease ? pktlease : 60 * 60; <span class="enscript-comment">// If lease option missing, assume one hour
</span>        mDNSs32 expire = m-&gt;timenow + (mDNSs32)lease * mDNSPlatformOneSecond;
        mDNSu32 random = mDNSRandom((mDNSs32)lease * mDNSPlatformOneSecond/10);

        <span class="enscript-comment">//rcode = kDNSFlag1_RC_ServFail;    // Simulate server failure (rcode 2)
</span>
        <span class="enscript-comment">// Walk through all the records that matches the messageID. There could be multiple
</span>        <span class="enscript-comment">// records if we had sent them in a group
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentRecord)
            LogMsg(<span class="enscript-string">&quot;uDNS_ReceiveMsg ERROR m-&gt;CurrentRecord already set %s&quot;</span>, ARDisplayString(m, m-&gt;CurrentRecord));
        m-&gt;CurrentRecord = m-&gt;ResourceRecords;
        <span class="enscript-keyword">while</span> (m-&gt;CurrentRecord)
        {
            AuthRecord *rptr = m-&gt;CurrentRecord;
            m-&gt;CurrentRecord = m-&gt;CurrentRecord-&gt;next;
            <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rptr) &amp;&amp; mDNSSameOpaque16(rptr-&gt;updateid, msg-&gt;h.id))
            {
                err = checkUpdateResult(m, rptr-&gt;resrec.name, rcode, msg, end);
                <span class="enscript-keyword">if</span> (!err &amp;&amp; rptr-&gt;uselease &amp;&amp; lease)
                    <span class="enscript-keyword">if</span> (rptr-&gt;expire - expire &gt;= 0 || rptr-&gt;state != regState_UpdatePending)
                    {
                        rptr-&gt;expire = expire;
                        rptr-&gt;refreshCount = 0;
                    }
                <span class="enscript-comment">// We pass the random value to make sure that if we update multiple
</span>                <span class="enscript-comment">// records, they all get the same random value
</span>                hndlRecordUpdateReply(m, rptr, err, random);
            }
        }
    }
    debugf(<span class="enscript-string">&quot;Received unexpected response: ID %d matches no active records&quot;</span>, mDNSVal16(msg-&gt;h.id));
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Query</span> <span class="enscript-variable-name">Routines</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">sendLLQRefresh</span>(mDNS *m, DNSQuestion *q)
{
    mDNSu8 *end;
    LLQOptData llq;

    <span class="enscript-keyword">if</span> (q-&gt;ReqLease)
        <span class="enscript-keyword">if</span> ((q-&gt;state == LLQ_Established &amp;&amp; q-&gt;ntries &gt;= kLLQ_MAX_TRIES) || q-&gt;expire - m-&gt;timenow &lt; 0)
        {
            LogMsg(<span class="enscript-string">&quot;Unable to refresh LLQ %##s (%s) - will retry in %d seconds&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), LLQ_POLL_INTERVAL / mDNSPlatformOneSecond);
            StartLLQPolling(m,q);
            <span class="enscript-keyword">return</span>;
        }

    llq.vers     = kLLQ_Vers;
    llq.llqOp    = kLLQOp_Refresh;
    llq.err      = q-&gt;tcp ? GetLLQEventPort(m, &amp;q-&gt;servAddr) : LLQErr_NoError;  <span class="enscript-comment">// If using TCP tell server what UDP port to send notifications to
</span>    llq.id       = q-&gt;id;
    llq.llqlease = q-&gt;ReqLease;

    InitializeDNSMessage(&amp;m-&gt;omsg.h, q-&gt;TargetQID, uQueryFlags);
    end = putLLQ(&amp;m-&gt;omsg, m-&gt;omsg.data, q, &amp;llq);
    <span class="enscript-keyword">if</span> (!end) { LogMsg(<span class="enscript-string">&quot;sendLLQRefresh: putLLQ failed %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype)); <span class="enscript-keyword">return</span>; }

    {
        mStatus err;

        LogInfo(<span class="enscript-string">&quot;sendLLQRefresh: using existing UDP session %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

        err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, end, mDNSInterface_Any, q-&gt;tcp ? q-&gt;tcp-&gt;sock : mDNSNULL, q-&gt;LocalSocket, &amp;q-&gt;servAddr, q-&gt;servPort, mDNSNULL, mDNSfalse);
        <span class="enscript-keyword">if</span> (err)
        {
            LogMsg(<span class="enscript-string">&quot;sendLLQRefresh: mDNSSendDNSMessage%s failed: %d&quot;</span>, q-&gt;tcp ? <span class="enscript-string">&quot; (TCP)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, err);
            <span class="enscript-keyword">if</span> (q-&gt;tcp) { DisposeTCPConn(q-&gt;tcp); q-&gt;tcp = mDNSNULL; }
        }
    }

    q-&gt;ntries++;

    debugf(<span class="enscript-string">&quot;sendLLQRefresh ntries %d %##s (%s)&quot;</span>, q-&gt;ntries, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

    q-&gt;LastQTime = m-&gt;timenow;
    SetNextQueryTime(m, q);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">LLQGotZoneData</span>(mDNS *<span class="enscript-type">const</span> m, mStatus err, <span class="enscript-type">const</span> ZoneData *zoneInfo)
{
    DNSQuestion *q = (DNSQuestion *)zoneInfo-&gt;ZoneDataContext;

    mDNS_Lock(m);

    <span class="enscript-comment">// If we get here it means that the GetZoneData operation has completed.
</span>    <span class="enscript-comment">// We hold on to the zone data if it is AutoTunnel as we use the hostname
</span>    <span class="enscript-comment">// in zoneInfo during the TLS connection setup.
</span>    q-&gt;servAddr = zeroAddr;
    q-&gt;servPort = zeroIPPort;

    <span class="enscript-keyword">if</span> (!err &amp;&amp; !mDNSIPPortIsZero(zoneInfo-&gt;Port) &amp;&amp; !mDNSAddressIsZero(&amp;zoneInfo-&gt;Addr) &amp;&amp; zoneInfo-&gt;Host.c[0])
    {
        q-&gt;servAddr = zoneInfo-&gt;Addr;
        q-&gt;servPort = zoneInfo-&gt;Port;
        <span class="enscript-comment">// We don't need the zone data as we use it only for the Host information which we
</span>        <span class="enscript-comment">// don't need if we are not going to use TLS connections.
</span>        <span class="enscript-keyword">if</span> (q-&gt;nta)
        {
            <span class="enscript-keyword">if</span> (q-&gt;nta != zoneInfo) LogMsg(<span class="enscript-string">&quot;LLQGotZoneData: nta (%p) != zoneInfo (%p)  %##s (%s)&quot;</span>, q-&gt;nta, zoneInfo, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            CancelGetZoneData(m, q-&gt;nta);
            q-&gt;nta = mDNSNULL;
        }
        q-&gt;ntries = 0;
        debugf(<span class="enscript-string">&quot;LLQGotZoneData %#a:%d&quot;</span>, &amp;q-&gt;servAddr, mDNSVal16(q-&gt;servPort));
        startLLQHandshake(m, q);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (q-&gt;nta)
        {
            <span class="enscript-keyword">if</span> (q-&gt;nta != zoneInfo) LogMsg(<span class="enscript-string">&quot;LLQGotZoneData: nta (%p) != zoneInfo (%p)  %##s (%s)&quot;</span>, q-&gt;nta, zoneInfo, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            CancelGetZoneData(m, q-&gt;nta);
            q-&gt;nta = mDNSNULL;
        }
        StartLLQPolling(m,q);
        <span class="enscript-keyword">if</span> (err == mStatus_NoSuchNameErr)
        {
            <span class="enscript-comment">// this actually failed, so mark it by setting address to all ones
</span>            q-&gt;servAddr.type = mDNSAddrType_IPv4;
            q-&gt;servAddr.ip.v4 = onesIPv4Addr;
        }
    }

    mDNS_Unlock(m);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushNotificationGotZoneData</span>(mDNS *<span class="enscript-type">const</span> m, mStatus err, <span class="enscript-type">const</span> ZoneData *zoneInfo)
{
    DNSQuestion *q = (DNSQuestion *)zoneInfo-&gt;ZoneDataContext;
    mDNS_Lock(m);

    <span class="enscript-comment">// If we get here it means that the GetZoneData operation has completed.
</span>    q-&gt;servAddr = zeroAddr;
    q-&gt;servPort = zeroIPPort;
    <span class="enscript-keyword">if</span> (!err &amp;&amp; zoneInfo &amp;&amp; !mDNSIPPortIsZero(zoneInfo-&gt;Port) &amp;&amp; zoneInfo-&gt;Host.c[0])
    {
        q-&gt;state = LLQ_DNSPush_Connecting;
        LogInfo(<span class="enscript-string">&quot;DNSPushNotificationGotZoneData %##s%%%d&quot;</span>, &amp;zoneInfo-&gt;Host, ntohs(zoneInfo-&gt;Port.NotAnInteger));
        q-&gt;dnsPushServer = SubscribeToDNSPushNotificationServer(m, q);
        <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer == mDNSNULL || (q-&gt;dnsPushServer-&gt;connectState != DNSPushServerConnectionInProgress &amp;&amp;
                                             q-&gt;dnsPushServer-&gt;connectState != DNSPushServerConnected &amp;&amp;
                                             q-&gt;dnsPushServer-&gt;connectState != DNSPushServerSessionEstablished))
        {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">noServer</span>;
        }
    }
    <span class="enscript-keyword">else</span>
    {
    <span class="enscript-reference">noServer</span>:
        q-&gt;state = LLQ_InitialRequest;
        startLLQHandshake(m,q);
    }
    mDNS_Unlock(m);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Dynamic</span> <span class="enscript-variable-name">Updates</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Called in normal callback context (i.e. mDNS_busy and mDNS_reentrancy are both 1)
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RecordRegistrationGotZoneData</span>(mDNS *<span class="enscript-type">const</span> m, mStatus err, <span class="enscript-type">const</span> ZoneData *zoneData)
{
    AuthRecord *newRR;
    AuthRecord *ptr;
    <span class="enscript-type">int</span> c1, c2;

    <span class="enscript-keyword">if</span> (!zoneData) { LogMsg(<span class="enscript-string">&quot;ERROR: RecordRegistrationGotZoneData invoked with NULL result and no error&quot;</span>); <span class="enscript-keyword">return</span>; }
    
    newRR = (AuthRecord*)zoneData-&gt;ZoneDataContext;

    <span class="enscript-keyword">if</span> (newRR-&gt;nta != zoneData)
        LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: nta (%p) != zoneData (%p)  %##s (%s)&quot;</span>, newRR-&gt;nta, zoneData, newRR-&gt;resrec.name-&gt;c, DNSTypeName(newRR-&gt;resrec.rrtype));

    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy != m-&gt;mDNS_reentrancy)
        LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: mDNS_busy (%ld) != mDNS_reentrancy (%ld)&quot;</span>, m-&gt;mDNS_busy, m-&gt;mDNS_reentrancy);

    <span class="enscript-comment">// make sure record is still in list (!!!)
</span>    <span class="enscript-keyword">for</span> (ptr = m-&gt;ResourceRecords; ptr; ptr = ptr-&gt;next) <span class="enscript-keyword">if</span> (ptr == newRR) <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">if</span> (!ptr)
    {
        LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData - RR no longer in list.  Discarding.&quot;</span>);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// check error/result
</span>    <span class="enscript-keyword">if</span> (err)
    {
        <span class="enscript-keyword">if</span> (err != mStatus_NoSuchNameErr) LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: error %d&quot;</span>, err);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (newRR-&gt;resrec.rrclass != zoneData-&gt;ZoneClass)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: New resource record's class (%d) does not match zone class (%d)&quot;</span>, newRR-&gt;resrec.rrclass, zoneData-&gt;ZoneClass);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Don't try to do updates to the root name server.
</span>    <span class="enscript-comment">// We might be tempted also to block updates to any single-label name server (e.g. com, edu, net, etc.) but some
</span>    <span class="enscript-comment">// organizations use their own private pseudo-TLD, like &quot;.home&quot;, etc, and we don't want to block that.
</span>    <span class="enscript-keyword">if</span> (zoneData-&gt;ZoneName.c[0] == 0)
    {
        LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: No name server found claiming responsibility for \&quot;%##s\&quot;!&quot;</span>, newRR-&gt;resrec.name-&gt;c);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Store discovered zone data
</span>    c1 = CountLabels(newRR-&gt;resrec.name);
    c2 = CountLabels(&amp;zoneData-&gt;ZoneName);
    <span class="enscript-keyword">if</span> (c2 &gt; c1)
    {
        LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: Zone \&quot;%##s\&quot; is longer than \&quot;%##s\&quot;&quot;</span>, zoneData-&gt;ZoneName.c, newRR-&gt;resrec.name-&gt;c);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }
    newRR-&gt;zone = SkipLeadingLabels(newRR-&gt;resrec.name, c1-c2);
    <span class="enscript-keyword">if</span> (!SameDomainName(newRR-&gt;zone, &amp;zoneData-&gt;ZoneName))
    {
        LogMsg(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: Zone \&quot;%##s\&quot; does not match \&quot;%##s\&quot; for \&quot;%##s\&quot;&quot;</span>, newRR-&gt;zone-&gt;c, zoneData-&gt;ZoneName.c, newRR-&gt;resrec.name-&gt;c);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (mDNSIPPortIsZero(zoneData-&gt;Port) || mDNSAddressIsZero(&amp;zoneData-&gt;Addr) || !zoneData-&gt;Host.c[0])
    {
        LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: No _dns-update._udp service found for \&quot;%##s\&quot;!&quot;</span>, newRR-&gt;resrec.name-&gt;c);
        CancelGetZoneData(m, newRR-&gt;nta);
        newRR-&gt;nta = mDNSNULL;
        <span class="enscript-keyword">return</span>;
    }

    newRR-&gt;Private      = zoneData-&gt;ZonePrivate;
    debugf(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: Set zone information for %##s %##s to %#a:%d&quot;</span>,
           newRR-&gt;resrec.name-&gt;c, zoneData-&gt;ZoneName.c, &amp;zoneData-&gt;Addr, mDNSVal16(zoneData-&gt;Port));

    <span class="enscript-comment">// If we are deregistering, uDNS_DeregisterRecord will do that as it has the zone data now.
</span>    <span class="enscript-keyword">if</span> (newRR-&gt;state == regState_DeregPending)
    {
        mDNS_Lock(m);
        uDNS_DeregisterRecord(m, newRR);
        mDNS_Unlock(m);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (newRR-&gt;resrec.rrtype == kDNSType_SRV)
    {
        <span class="enscript-type">const</span> domainname *target;
        <span class="enscript-comment">// Reevaluate the target always as NAT/Target could have changed while
</span>        <span class="enscript-comment">// we were fetching zone data.
</span>        mDNS_Lock(m);
        target = GetServiceTarget(m, newRR);
        mDNS_Unlock(m);
        <span class="enscript-keyword">if</span> (!target || target-&gt;c[0] == 0)
        {
            domainname *t = GetRRDomainNameTarget(&amp;newRR-&gt;resrec);
            LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData - no target for %##s&quot;</span>, newRR-&gt;resrec.name-&gt;c);
            <span class="enscript-keyword">if</span> (t) t-&gt;c[0] = 0;
            newRR-&gt;resrec.rdlength = newRR-&gt;resrec.rdestimate = 0;
            newRR-&gt;state = regState_NoTarget;
            CancelGetZoneData(m, newRR-&gt;nta);
            newRR-&gt;nta = mDNSNULL;
            <span class="enscript-keyword">return</span>;
        }
    }
    <span class="enscript-comment">// If we have non-zero service port (always?)
</span>    <span class="enscript-comment">// and a private address, and update server is non-private
</span>    <span class="enscript-comment">// and this service is AutoTarget
</span>    <span class="enscript-comment">// then initiate a NAT mapping request. On completion it will do SendRecordRegistration() for us
</span>    <span class="enscript-keyword">if</span> (newRR-&gt;resrec.rrtype == kDNSType_SRV &amp;&amp; !mDNSIPPortIsZero(newRR-&gt;resrec.rdata-&gt;u.srv.port) &amp;&amp;
        mDNSv4AddrIsRFC1918(&amp;m-&gt;AdvertisedV4.ip.v4) &amp;&amp; newRR-&gt;nta &amp;&amp; !mDNSAddrIsRFC1918(&amp;newRR-&gt;nta-&gt;Addr) &amp;&amp;
        newRR-&gt;AutoTarget == Target_AutoHostAndNATMAP)
    {
        <span class="enscript-comment">// During network transitions, we are called multiple times in different states. Setup NAT
</span>        <span class="enscript-comment">// state just once for this record.
</span>        <span class="enscript-keyword">if</span> (!newRR-&gt;NATinfo.clientContext)
        {
            LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData StartRecordNatMap %s&quot;</span>, ARDisplayString(m, newRR));
            newRR-&gt;state = regState_NATMap;
            StartRecordNatMap(m, newRR);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">else</span> LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: StartRecordNatMap for %s, state %d, context %p&quot;</span>, ARDisplayString(m, newRR), newRR-&gt;state, newRR-&gt;NATinfo.clientContext);
    }
    mDNS_Lock(m);
    <span class="enscript-comment">// We want IsRecordMergeable to check whether it is a record whose update can be
</span>    <span class="enscript-comment">// sent with others. We set the time before we call IsRecordMergeable, so that
</span>    <span class="enscript-comment">// it does not fail this record based on time. We are interested in other checks
</span>    <span class="enscript-comment">// at this time. If a previous update resulted in error, then don't reset the
</span>    <span class="enscript-comment">// interval. Preserve the back-off so that we don't keep retrying aggressively.
</span>    <span class="enscript-keyword">if</span> (newRR-&gt;updateError == mStatus_NoError)
    {
        newRR-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
        newRR-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
    }
    <span class="enscript-keyword">if</span> (IsRecordMergeable(m, newRR, m-&gt;timenow + MERGE_DELAY_TIME))
    {
        <span class="enscript-comment">// Delay the record registration by MERGE_DELAY_TIME so that we can merge them
</span>        <span class="enscript-comment">// into one update
</span>        LogInfo(<span class="enscript-string">&quot;RecordRegistrationGotZoneData: Delayed registration for %s&quot;</span>, ARDisplayString(m, newRR));
        newRR-&gt;LastAPTime += MERGE_DELAY_TIME;
    }
    mDNS_Unlock(m);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SendRecordDeregistration</span>(mDNS *m, AuthRecord *rr)
{
    mDNSu8 *ptr = m-&gt;omsg.data;
    mDNSu8 *limit;
    DomainAuthInfo *AuthInfo;

    mDNS_CheckLock(m);

    <span class="enscript-keyword">if</span> (!rr-&gt;nta || mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4))
    {
        LogMsg(<span class="enscript-string">&quot;SendRecordDeRegistration: No zone info for Resource record %s RecordType %d&quot;</span>, ARDisplayString(m, rr), rr-&gt;resrec.RecordType);
        <span class="enscript-keyword">return</span>;
    }

    limit = ptr + AbsoluteMaxDNSMessageData;
    AuthInfo = GetAuthInfoForName_internal(m, rr-&gt;resrec.name);
    limit -= RRAdditionalSize(AuthInfo);

    rr-&gt;updateid = mDNS_NewMessageID(m);
    InitializeDNSMessage(&amp;m-&gt;omsg.h, rr-&gt;updateid, UpdateReqFlags);

    <span class="enscript-comment">// set zone
</span>    ptr = putZone(&amp;m-&gt;omsg, ptr, limit, rr-&gt;zone, mDNSOpaque16fromIntVal(rr-&gt;resrec.rrclass));
    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    ptr = BuildUpdateMessage(m, ptr, rr, limit);

    <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">if</span> (rr-&gt;Private)
    {
        LogInfo(<span class="enscript-string">&quot;SendRecordDeregistration TCP %p %s&quot;</span>, rr-&gt;tcp, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (rr-&gt;tcp) LogInfo(<span class="enscript-string">&quot;SendRecordDeregistration: Disposing existing TCP connection for %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp); rr-&gt;tcp = mDNSNULL; }
        <span class="enscript-keyword">if</span> (!rr-&gt;nta) { LogMsg(<span class="enscript-string">&quot;SendRecordDeregistration:Private:ERROR!! nta is NULL for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }
        rr-&gt;tcp = MakeTCPConn(m, &amp;m-&gt;omsg, ptr, kTCPSocketFlags_UseTLS, &amp;rr-&gt;nta-&gt;Addr, rr-&gt;nta-&gt;Port, &amp;rr-&gt;nta-&gt;Host, mDNSNULL, rr);
    }
    <span class="enscript-keyword">else</span>
    {
        mStatus err;
        LogInfo(<span class="enscript-string">&quot;SendRecordDeregistration UDP %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">if</span> (!rr-&gt;nta) { LogMsg(<span class="enscript-string">&quot;SendRecordDeregistration:ERROR!! nta is NULL for %s&quot;</span>, ARDisplayString(m, rr)); <span class="enscript-keyword">return</span>; }
        err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, ptr, mDNSInterface_Any, mDNSNULL, mDNSNULL, &amp;rr-&gt;nta-&gt;Addr, rr-&gt;nta-&gt;Port, GetAuthInfoForName_internal(m, rr-&gt;resrec.name), mDNSfalse);
        <span class="enscript-keyword">if</span> (err) debugf(<span class="enscript-string">&quot;ERROR: SendRecordDeregistration - mDNSSendDNSMessage - %d&quot;</span>, err);
        <span class="enscript-comment">//if (rr-&gt;state == regState_DeregPending) CompleteDeregistration(m, rr);        // Don't touch rr after this
</span>    }
    SetRecordRetry(m, rr, 0);
    <span class="enscript-keyword">return</span>;
<span class="enscript-reference">exit</span>:
    LogMsg(<span class="enscript-string">&quot;SendRecordDeregistration: Error formatting message for %s&quot;</span>, ARDisplayString(m, rr));
}

mDNSexport mStatus <span class="enscript-function-name">uDNS_DeregisterRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    DomainAuthInfo *info;

    LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: Resource Record %s, state %d&quot;</span>, ARDisplayString(m, rr), rr-&gt;state);

    <span class="enscript-keyword">switch</span> (rr-&gt;state)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Refresh</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Pending</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_UpdatePending</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Registered</span>: <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_DeregPending</span>: <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATError</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATMap</span>:
    <span class="enscript-comment">// A record could be in NoTarget to start with if the corresponding SRV record could not find a target.
</span>    <span class="enscript-comment">// It is also possible to reenter the NoTarget state when we move to a network with a NAT that has
</span>    <span class="enscript-comment">// no {PCP, NAT-PMP, UPnP/IGD} support. In that case before we entered NoTarget, we already deregistered with
</span>    <span class="enscript-comment">// the server.
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NoTarget</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Unregistered</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Zero</span>:
    <span class="enscript-reference">default</span>:
        LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: State %d for %##s type %s&quot;</span>, rr-&gt;state, rr-&gt;resrec.name-&gt;c, DNSTypeName(rr-&gt;resrec.rrtype));
        <span class="enscript-comment">// This function may be called during sleep when there are no sleep proxy servers
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypeDeregistering) CompleteDeregistration(m, rr);
        <span class="enscript-keyword">return</span> mStatus_NoError;
    }

    <span class="enscript-comment">// if unsent rdata is queued, free it.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// The data may be queued in QueuedRData or InFlightRData.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) If the record is in Registered state, we store it in InFlightRData and copy the same in &quot;rdata&quot;
</span>    <span class="enscript-comment">//   *just* before sending the update to the server. Till we get the response, InFlightRData and &quot;rdata&quot;
</span>    <span class="enscript-comment">//   in the resource record are same. We don't want to free in that case. It will be freed when &quot;rdata&quot;
</span>    <span class="enscript-comment">//   is freed. If they are not same, the update has not been sent and we should free it here.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2) If the record is in UpdatePending state, we queue the update in QueuedRData. When the previous update
</span>    <span class="enscript-comment">//   comes back from the server, we copy it from QueuedRData to InFlightRData and repeat (1). This implies
</span>    <span class="enscript-comment">//   that QueuedRData can never be same as &quot;rdata&quot; in the resource record. As long as we have something
</span>    <span class="enscript-comment">//   left in QueuedRData, we should free it here.
</span>
    <span class="enscript-keyword">if</span> (rr-&gt;InFlightRData &amp;&amp; rr-&gt;UpdateCallback)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;InFlightRData != rr-&gt;resrec.rdata)
        {
            LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: Freeing InFlightRData for %s&quot;</span>, ARDisplayString(m, rr));
            rr-&gt;UpdateCallback(m, rr, rr-&gt;InFlightRData, rr-&gt;InFlightRDLen);
            rr-&gt;InFlightRData = mDNSNULL;
        }
        <span class="enscript-keyword">else</span>
            LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: InFlightRData same as rdata for %s&quot;</span>, ARDisplayString(m, rr));
    }

    <span class="enscript-keyword">if</span> (rr-&gt;QueuedRData &amp;&amp; rr-&gt;UpdateCallback)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;QueuedRData == rr-&gt;resrec.rdata)
            LogMsg(<span class="enscript-string">&quot;uDNS_DeregisterRecord: ERROR!! QueuedRData same as rdata for %s&quot;</span>, ARDisplayString(m, rr));
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: Freeing QueuedRData for %s&quot;</span>, ARDisplayString(m, rr));
            rr-&gt;UpdateCallback(m, rr, rr-&gt;QueuedRData, rr-&gt;QueuedRDLen);
            rr-&gt;QueuedRData = mDNSNULL;
        }
    }

    <span class="enscript-comment">// If a current group registration is pending, we can't send this deregisration till that registration
</span>    <span class="enscript-comment">// has reached the server i.e., the ordering is important. Previously, if we did not send this
</span>    <span class="enscript-comment">// registration in a group, then the previous connection will be torn down as part of sending the
</span>    <span class="enscript-comment">// deregistration. If we send this in a group, we need to locate the resource record that was used
</span>    <span class="enscript-comment">// to send this registration and terminate that connection. This means all the updates on that might
</span>    <span class="enscript-comment">// be lost (assuming the response is not waiting for us at the socket) and the retry will send the
</span>    <span class="enscript-comment">// update again sometime in the near future.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// NOTE: SSL handshake failures normally free the TCP connection immediately. Hence, you may not
</span>    <span class="enscript-comment">// find the TCP below there. This case can happen only when tcp is trying to actively retransmit
</span>    <span class="enscript-comment">// the request or SSL negotiation taking time i.e resource record is actively trying to get the
</span>    <span class="enscript-comment">// message to the server. During that time a deregister has to happen.
</span>
    <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(rr-&gt;updateid))
    {
        AuthRecord *anchorRR;
        mDNSBool found = mDNSfalse;
        <span class="enscript-keyword">for</span> (anchorRR = m-&gt;ResourceRecords; anchorRR; anchorRR = anchorRR-&gt;next)
        {
            <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr) &amp;&amp; mDNSSameOpaque16(anchorRR-&gt;updateid, rr-&gt;updateid) &amp;&amp; anchorRR-&gt;tcp)
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_DeregisterRecord: Found Anchor RR %s terminated&quot;</span>, ARDisplayString(m, anchorRR));
                <span class="enscript-keyword">if</span> (found)
                    LogMsg(<span class="enscript-string">&quot;uDNS_DeregisterRecord: ERROR: Another anchorRR %s found&quot;</span>, ARDisplayString(m, anchorRR));
                DisposeTCPConn(anchorRR-&gt;tcp);
                anchorRR-&gt;tcp = mDNSNULL;
                found = mDNStrue;
            }
        }
        <span class="enscript-keyword">if</span> (!found) LogInfo(<span class="enscript-string">&quot;uDNSDeregisterRecord: Cannot find the anchor Resource Record for %s, not an error&quot;</span>, ARDisplayString(m, rr));
    }

    <span class="enscript-comment">// Retry logic for deregistration should be no different from sending registration the first time.
</span>    <span class="enscript-comment">// Currently ThisAPInterval most likely is set to the refresh interval
</span>    rr-&gt;state          = regState_DeregPending;
    rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
    rr-&gt;LastAPTime     = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
    info = GetAuthInfoForName_internal(m, rr-&gt;resrec.name);
    <span class="enscript-keyword">if</span> (IsRecordMergeable(m, rr, m-&gt;timenow + MERGE_DELAY_TIME))
    {
        <span class="enscript-comment">// Delay the record deregistration by MERGE_DELAY_TIME so that we can merge them
</span>        <span class="enscript-comment">// into one update. If the domain is being deleted, delay by 2 * MERGE_DELAY_TIME
</span>        <span class="enscript-comment">// so that we can merge all the AutoTunnel records and the service records in
</span>        <span class="enscript-comment">// one update (they get deregistered a little apart)
</span>        <span class="enscript-keyword">if</span> (info &amp;&amp; info-&gt;deltime) rr-&gt;LastAPTime += (2 * MERGE_DELAY_TIME);
        <span class="enscript-keyword">else</span> rr-&gt;LastAPTime += MERGE_DELAY_TIME;
    }
    <span class="enscript-comment">// IsRecordMergeable could have returned false for several reasons e.g., DontMerge is set or
</span>    <span class="enscript-comment">// no zone information. Most likely it is the latter, CheckRecordUpdates will fetch the zone
</span>    <span class="enscript-comment">// data when it encounters this record.
</span>
    <span class="enscript-keyword">if</span> (m-&gt;NextuDNSEvent - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt;= 0)
        m-&gt;NextuDNSEvent = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);

    <span class="enscript-keyword">return</span> mStatus_NoError;
}

mDNSexport mStatus <span class="enscript-function-name">uDNS_UpdateRecord</span>(mDNS *m, AuthRecord *rr)
{
    LogInfo(<span class="enscript-string">&quot;uDNS_UpdateRecord: Resource Record %##s, state %d&quot;</span>, rr-&gt;resrec.name-&gt;c, rr-&gt;state);
    <span class="enscript-keyword">switch</span>(rr-&gt;state)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_DeregPending</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Unregistered</span>:
        <span class="enscript-comment">// not actively registered
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unreg_error</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATMap</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NoTarget</span>:
        <span class="enscript-comment">// change rdata directly since it hasn't been sent yet
</span>        <span class="enscript-keyword">if</span> (rr-&gt;UpdateCallback) rr-&gt;UpdateCallback(m, rr, rr-&gt;resrec.rdata, rr-&gt;resrec.rdlength);
        SetNewRData(&amp;rr-&gt;resrec, rr-&gt;NewRData, rr-&gt;newrdlength);
        rr-&gt;NewRData = mDNSNULL;
        <span class="enscript-keyword">return</span> mStatus_NoError;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Pending</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Refresh</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_UpdatePending</span>:
        <span class="enscript-comment">// registration in-flight. queue rdata and return
</span>        <span class="enscript-keyword">if</span> (rr-&gt;QueuedRData &amp;&amp; rr-&gt;UpdateCallback)
            <span class="enscript-comment">// if unsent rdata is already queued, free it before we replace it
</span>            rr-&gt;UpdateCallback(m, rr, rr-&gt;QueuedRData, rr-&gt;QueuedRDLen);
        rr-&gt;QueuedRData = rr-&gt;NewRData;
        rr-&gt;QueuedRDLen = rr-&gt;newrdlength;
        rr-&gt;NewRData = mDNSNULL;
        <span class="enscript-keyword">return</span> mStatus_NoError;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_Registered</span>:
        rr-&gt;OrigRData = rr-&gt;resrec.rdata;
        rr-&gt;OrigRDLen = rr-&gt;resrec.rdlength;
        rr-&gt;InFlightRData = rr-&gt;NewRData;
        rr-&gt;InFlightRDLen = rr-&gt;newrdlength;
        rr-&gt;NewRData = mDNSNULL;
        rr-&gt;state = regState_UpdatePending;
        rr-&gt;ThisAPInterval = INIT_RECORD_REG_INTERVAL;
        rr-&gt;LastAPTime = m-&gt;timenow - INIT_RECORD_REG_INTERVAL;
        SetNextuDNSEvent(m, rr);
        <span class="enscript-keyword">return</span> mStatus_NoError;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">regState_NATError</span>:
        LogMsg(<span class="enscript-string">&quot;ERROR: uDNS_UpdateRecord called for record %##s with bad state regState_NATError&quot;</span>, rr-&gt;resrec.name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_UnknownErr;      <span class="enscript-comment">// states for service records only
</span>
    <span class="enscript-reference">default</span>: LogMsg(<span class="enscript-string">&quot;uDNS_UpdateRecord: Unknown state %d for %##s&quot;</span>, rr-&gt;state, rr-&gt;resrec.name-&gt;c);
    }

<span class="enscript-reference">unreg_error</span>:
    LogMsg(<span class="enscript-string">&quot;uDNS_UpdateRecord: Requested update of record %##s type %d, in erroneous state %d&quot;</span>,
           rr-&gt;resrec.name-&gt;c, rr-&gt;resrec.rrtype, rr-&gt;state);
    <span class="enscript-keyword">return</span> mStatus_Invalid;
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Periodic</span> <span class="enscript-variable-name">Execution</span> <span class="enscript-variable-name">Routines</span>
#<span class="enscript-reference">endif</span>

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">handle_unanswered_query</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q = m-&gt;CurrentQuestion;

    <span class="enscript-keyword">if</span> (q-&gt;unansweredQueries &gt;= MAX_DNSSEC_UNANSWERED_QUERIES &amp;&amp; DNSSECOptionalQuestion(q))
    {
        <span class="enscript-comment">// If we are not receiving any responses for DNSSEC question, it could be due to
</span>        <span class="enscript-comment">// a broken middlebox or a DNS server that does not understand the EDNS0/DOK option that
</span>        <span class="enscript-comment">// silently drops the packets. Also as per RFC 5625 there are certain buggy DNS Proxies
</span>        <span class="enscript-comment">// that are known to drop these pkts. To handle this, we turn off sending the EDNS0/DOK
</span>        <span class="enscript-comment">// option if we have not received any responses indicating that the server or
</span>        <span class="enscript-comment">// the middlebox is DNSSEC aware. If we receive at least one response to a DNSSEC
</span>        <span class="enscript-comment">// question, we don't turn off validation. Also, we wait for MAX_DNSSEC_RETRANSMISSIONS
</span>        <span class="enscript-comment">// before turning off validation to accomodate packet loss.
</span>        <span class="enscript-comment">// 
</span>        <span class="enscript-comment">// Note: req_DO affects only DNSSEC_VALIDATION_SECURE_OPTIONAL questions;
</span>        <span class="enscript-comment">// DNSSEC_VALIDATION_SECURE questions ignores req_DO.
</span>
        <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer-&gt;DNSSECAware &amp;&amp; q-&gt;qDNSServer-&gt;req_DO)
        {
            q-&gt;qDNSServer-&gt;retransDO++;
            <span class="enscript-keyword">if</span> (q-&gt;qDNSServer-&gt;retransDO == MAX_DNSSEC_RETRANSMISSIONS)
            {
                LogInfo(<span class="enscript-string">&quot;handle_unanswered_query: setting req_DO false for %#a&quot;</span>, &amp;q-&gt;qDNSServer-&gt;addr);
                q-&gt;qDNSServer-&gt;req_DO = mDNSfalse;
            }
        }

        <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer-&gt;req_DO)
        {
            q-&gt;ValidationState     = DNSSECValNotRequired;
            q-&gt;ValidationRequired  = DNSSEC_VALIDATION_NONE;

            <span class="enscript-keyword">if</span> (q-&gt;ProxyQuestion)
                q-&gt;ProxyDNSSECOK = mDNSfalse;
            LogInfo(<span class="enscript-string">&quot;handle_unanswered_query: unanswered query for %##s (%s), so turned off validation for %#a&quot;</span>,
                q-&gt;qname.c, DNSTypeName(q-&gt;qtype), &amp;q-&gt;qDNSServer-&gt;addr);
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_HandleLLQState</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q)
{
    LogMsg(<span class="enscript-string">&quot;-&gt;uDNS_HandleLLQState: %##s %d&quot;</span>, &amp;q-&gt;qname, q-&gt;state);
    <span class="enscript-keyword">switch</span>(q-&gt;state)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_Init</span>:
        <span class="enscript-comment">// If DNS Push isn't supported, LLQ_Init falls through to LLQ_InitialRequest.
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
        <span class="enscript-comment">// First attempt to use DNS Push Notification.
</span>        DiscoverDNSPushNotificationServer(m, q);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_ServerDiscovery</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_Connecting</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_Established</span>:
        <span class="enscript-comment">// Sanity check the server state to see if it matches.   If we find that we aren't connected, when
</span>        <span class="enscript-comment">// we think we should be, change our state.
</span>        <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer == NULL)
        {
            q-&gt;state = LLQ_Init;
            q-&gt;ThisQInterval = 0;
            q-&gt;LastQTime = m-&gt;timenow;
            SetNextQueryTime(m, q);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">switch</span>(q-&gt;dnsPushServer-&gt;connectState)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerDisconnected</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerConnectFailed</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerNoDNSPush</span>:
                LogMsg(<span class="enscript-string">&quot;uDNS_HandleLLQState: %##s, server state %d doesn't match question state %d&quot;</span>,
                       &amp;q-&gt;dnsPushServer-&gt;serverName, q-&gt;state, q-&gt;dnsPushServer-&gt;connectState);
                q-&gt;state = LLQ_Poll;
                q-&gt;ThisQInterval = (mDNSPlatformOneSecond * 5);
                q-&gt;LastQTime     = m-&gt;timenow;
                SetNextQueryTime(m, q);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerSessionEstablished</span>:
                LogMsg(<span class="enscript-string">&quot;uDNS_HandleLLQState: %##s, server connection established but question state is %d&quot;</span>,
                       &amp;q-&gt;dnsPushServer-&gt;serverName, q-&gt;state);
                q-&gt;state = LLQ_DNSPush_Established;
                q-&gt;ThisQInterval = 0;
                q-&gt;LastQTime     = m-&gt;timenow;
                SetNextQueryTime(m, q);
                <span class="enscript-keyword">break</span>;
                
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerConnectionInProgress</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSPushServerConnected</span>:
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">else</span>
            <span class="enscript-comment">// Silence warnings; these are never reached without DNS Push
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_ServerDiscovery</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_Connecting</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_DNSPush_Established</span>:
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_InitialRequest</span>:   startLLQHandshake(m, q); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_SecondaryRequest</span>: sendChallengeResponse(m, q, mDNSNULL); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_Established</span>:      sendLLQRefresh(m, q); <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">LLQ_Poll</span>:             <span class="enscript-keyword">break</span>;       <span class="enscript-comment">// Do nothing (handled below)
</span>    }
    LogMsg(<span class="enscript-string">&quot;&lt;-uDNS_HandleLLQState: %##s %d %d&quot;</span>, &amp;q-&gt;qname, q-&gt;state);
}

<span class="enscript-comment">// The question to be checked is not passed in as an explicit parameter;
</span><span class="enscript-comment">// instead it is implicit that the question to be checked is m-&gt;CurrentQuestion.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_CheckCurrentQuestion</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q = m-&gt;CurrentQuestion;
    <span class="enscript-keyword">if</span> (m-&gt;timenow - NextQSendTime(q) &lt; 0) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (q-&gt;LongLived)
    {
        uDNS_HandleLLQState(m,q);
    }

    handle_unanswered_query(m);
    <span class="enscript-comment">// We repeat the check above (rather than just making this the &quot;else&quot; case) because startLLQHandshake can change q-&gt;state to LLQ_Poll
</span>    <span class="enscript-keyword">if</span> (!(q-&gt;LongLived &amp;&amp; q-&gt;state != LLQ_Poll))
    {
        <span class="enscript-keyword">if</span> (q-&gt;unansweredQueries &gt;= MAX_UCAST_UNANSWERED_QUERIES)
        {
            DNSServer *orig = q-&gt;qDNSServer;
            <span class="enscript-keyword">if</span> (orig)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion: Sent %d unanswered queries for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d (&quot;</span> PRI_DM_NAME <span class="enscript-string">&quot;)&quot;</span>,
                          q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q-&gt;unansweredQueries, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), &amp;orig-&gt;addr, mDNSVal16(orig-&gt;port), DM_NAME_PARAM(orig-&gt;domain.c));
            }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
            SymptomReporterDNSServerUnreachable(orig);
#<span class="enscript-reference">endif</span>
            PenalizeDNSServer(m, q, zeroID);
            q-&gt;noServerResponse = 1;
        }
        <span class="enscript-comment">// There are two cases here.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// 1. We have only one DNS server for this question. It is not responding even after we sent MAX_UCAST_UNANSWERED_QUERIES.
</span>        <span class="enscript-comment">//    In that case, we need to keep retrying till we get a response. But we need to backoff as we retry. We set
</span>        <span class="enscript-comment">//    noServerResponse in the block above and below we do not touch the question interval. When we come here, we
</span>        <span class="enscript-comment">//    already waited for the response. We need to send another query right at this moment. We do that below by
</span>        <span class="enscript-comment">//    reinitializing dns servers and reissuing the query.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// 2. We have more than one DNS server. If at least one server did not respond, we would have set noServerResponse
</span>        <span class="enscript-comment">//    either now (the last server in the list) or before (non-last server in the list). In either case, if we have
</span>        <span class="enscript-comment">//    reached the end of DNS server list, we need to try again from the beginning. Ideally we should try just the
</span>        <span class="enscript-comment">//    servers that did not respond, but for simplicity we try all the servers. Once we reached the end of list, we
</span>        <span class="enscript-comment">//    set triedAllServersOnce so that we don't try all the servers aggressively. See PenalizeDNSServer.
</span>        <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer &amp;&amp; q-&gt;noServerResponse)
        {
            DNSServer *new;
            DNSQuestion *qptr;
            q-&gt;triedAllServersOnce = mDNStrue;
            <span class="enscript-comment">// Re-initialize all DNS servers for this question. If we have a DNSServer, DNSServerChangeForQuestion will
</span>            <span class="enscript-comment">// handle all the work including setting the new DNS server.
</span>            SetValidDNSServers(m, q);
            new = GetServerForQuestion(m, q);
            <span class="enscript-keyword">if</span> (new)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_checkCurrentQuestion: Retrying question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) DNS Server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d ThisQInterval %d&quot;</span>,
                          q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype), new ? &amp;new-&gt;addr : mDNSNULL, mDNSVal16(new ? new-&gt;port : zeroIPPort), q-&gt;ThisQInterval);
                DNSServerChangeForQuestion(m, q, new);
            }
            <span class="enscript-keyword">for</span> (qptr = q-&gt;next ; qptr; qptr = qptr-&gt;next)
                <span class="enscript-keyword">if</span> (qptr-&gt;DuplicateOf == q) { qptr-&gt;validDNSServers = q-&gt;validDNSServers; qptr-&gt;qDNSServer = q-&gt;qDNSServer; }
        }
        <span class="enscript-keyword">if</span> (q-&gt;qDNSServer)
        {
            mDNSu8 *end;
            mStatus err = mStatus_NoError;

            InitializeDNSMessage(&amp;m-&gt;omsg.h, q-&gt;TargetQID, (DNSSECQuestion(q) ? DNSSecQFlags : uQueryFlags));

            end = putQuestion(&amp;m-&gt;omsg, m-&gt;omsg.data, m-&gt;omsg.data + AbsoluteMaxDNSMessageData, &amp;q-&gt;qname, q-&gt;qtype, q-&gt;qclass);
            <span class="enscript-keyword">if</span> (DNSSECQuestion(q) &amp;&amp; !q-&gt;qDNSServer-&gt;isCell)
            {
                <span class="enscript-keyword">if</span> (q-&gt;ProxyQuestion)
                    end = DNSProxySetAttributes(q, &amp;m-&gt;omsg.h, &amp;m-&gt;omsg, end, m-&gt;omsg.data + AbsoluteMaxDNSMessageData);
                <span class="enscript-keyword">else</span>
                    end = putDNSSECOption(&amp;m-&gt;omsg, end, m-&gt;omsg.data + AbsoluteMaxDNSMessageData);
            }

            <span class="enscript-keyword">if</span> (end &gt; m-&gt;omsg.data)
            {
                debugf(<span class="enscript-string">&quot;uDNS_CheckCurrentQuestion sending %p %##s (%s) %#a:%d UnansweredQueries %d&quot;</span>,
                       q, q-&gt;qname.c, DNSTypeName(q-&gt;qtype),
                       q-&gt;qDNSServer ? &amp;q-&gt;qDNSServer-&gt;addr : mDNSNULL, mDNSVal16(q-&gt;qDNSServer ? q-&gt;qDNSServer-&gt;port : zeroIPPort), q-&gt;unansweredQueries);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
                <span class="enscript-comment">// When a DNS proxy network extension initiates the close of a UDP flow (this usually happens when a DNS
</span>                <span class="enscript-comment">// proxy gets disabled or crashes), mDNSResponder's corresponding UDP socket will be marked with the
</span>                <span class="enscript-comment">// SS_CANTRCVMORE state flag. Reading from such a socket is no longer possible, so close the current
</span>                <span class="enscript-comment">// socket pair so that we can create a new pair.
</span>                <span class="enscript-keyword">if</span> (q-&gt;LocalSocket &amp;&amp; mDNSPlatformUDPSocketEncounteredEOF(q-&gt;LocalSocket))
                {
                    mDNSPlatformUDPClose(q-&gt;LocalSocket);
                    q-&gt;LocalSocket = mDNSNULL;
                }
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">if</span> (!q-&gt;LocalSocket)
                {
                    q-&gt;LocalSocket = mDNSPlatformUDPSocket(zeroIPPort);
                    <span class="enscript-keyword">if</span> (q-&gt;LocalSocket)
                    {
                        mDNSPlatformSetSocktOpt(q-&gt;LocalSocket, mDNSTransport_UDP, mDNSAddrType_IPv4, q);
                        mDNSPlatformSetSocktOpt(q-&gt;LocalSocket, mDNSTransport_UDP, mDNSAddrType_IPv6, q);
                    }
                }
                <span class="enscript-keyword">if</span> (!q-&gt;LocalSocket) err = mStatus_NoMemoryErr; <span class="enscript-comment">// If failed to make socket (should be very rare), we'll try again next time
</span>                <span class="enscript-keyword">else</span>
                {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
                    <span class="enscript-comment">// If we are in suspicious mode, restart question as TCP
</span>                    mDNSs32  suspiciousTimeout = m-&gt;NextSuspiciousTimeout ? m-&gt;NextSuspiciousTimeout - m-&gt;timenow : 0;
                    <span class="enscript-keyword">if</span> (suspiciousTimeout &gt; 0 &amp;&amp; suspiciousTimeout &lt;= SUSPICIOUS_REPLY_DEFENSE_SECS * mDNSPlatformOneSecond)
                    {
                        uDNS_RestartQuestionAsTCP(m, q, &amp;q-&gt;qDNSServer-&gt;addr, q-&gt;qDNSServer-&gt;port);
                        err = mStatus_NoError;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                        q-&gt;metrics.dnsOverTCPState = DNSOverTCP_SuspiciousDefense;
#<span class="enscript-reference">endif</span>
                    }
                    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
                    {
                        err = mDNSSendDNSMessage(m, &amp;m-&gt;omsg, end, q-&gt;qDNSServer-&gt;interface, mDNSNULL, q-&gt;LocalSocket, &amp;q-&gt;qDNSServer-&gt;addr, q-&gt;qDNSServer-&gt;port, mDNSNULL, q-&gt;UseBackgroundTraffic);
                    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
                    <span class="enscript-keyword">if</span> (!err)
                    {
                        MetricsUpdateDNSQuerySize((mDNSu32)(end - (mDNSu8 *)&amp;m-&gt;omsg));
                        <span class="enscript-keyword">if</span> (q-&gt;metrics.answered)
                        {
                            q-&gt;metrics.querySendCount = 0;
                            q-&gt;metrics.answered       = mDNSfalse;
                        }
                        <span class="enscript-keyword">if</span> (q-&gt;metrics.querySendCount++ == 0)
                        {
                            q-&gt;metrics.firstQueryTime = m-&gt;timenow;
                        }
                    }
#<span class="enscript-reference">endif</span>
				}
            }

            <span class="enscript-keyword">if</span> (err == mStatus_HostUnreachErr)
            {
                DNSServer *newServer;

                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion: host unreachable error for DNS server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot; for question [%p] &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                          q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), &amp;q-&gt;qDNSServer-&gt;addr, q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));

                <span class="enscript-keyword">if</span> (!StrictUnicastOrdering)
                {
                    q-&gt;qDNSServer-&gt;penaltyTime = NonZeroTime(m-&gt;timenow + DNSSERVER_PENALTY_TIME);
                }

                newServer = GetServerForQuestion(m, q);
                <span class="enscript-keyword">if</span> (!newServer)
                {
                    q-&gt;triedAllServersOnce = mDNStrue;
                    SetValidDNSServers(m, q);
                    newServer = GetServerForQuestion(m, q);
                }
                <span class="enscript-keyword">if</span> (newServer)
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_checkCurrentQuestion: Retrying question %p &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) DNS Server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%u ThisQInterval %d&quot;</span>,
                              q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype),
                              newServer ? &amp;newServer-&gt;addr : mDNSNULL, mDNSVal16(newServer ? newServer-&gt;port : zeroIPPort), q-&gt;ThisQInterval);
                    DNSServerChangeForQuestion(m, q, newServer);
                }
                <span class="enscript-keyword">if</span> (q-&gt;triedAllServersOnce)
                {
                    q-&gt;LastQTime = m-&gt;timenow;
                }
                <span class="enscript-keyword">else</span>
                {
                    q-&gt;ThisQInterval = InitialQuestionInterval;
                    q-&gt;LastQTime     = m-&gt;timenow - q-&gt;ThisQInterval;
                }
                q-&gt;unansweredQueries = 0;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (err != mStatus_TransientErr)   <span class="enscript-comment">// if it is not a transient error backoff and DO NOT flood queries unnecessarily
</span>                {
                    <span class="enscript-comment">// If all DNS Servers are not responding, then we back-off using the multiplier UDNSBackOffMultiplier(*2).
</span>                    <span class="enscript-comment">// Only increase interval if send succeeded
</span>
                    q-&gt;ThisQInterval = q-&gt;ThisQInterval * UDNSBackOffMultiplier;
                    <span class="enscript-keyword">if</span> ((q-&gt;ThisQInterval &gt; 0) &amp;&amp; (q-&gt;ThisQInterval &lt; MinQuestionInterval))  <span class="enscript-comment">// We do not want to retx within 1 sec
</span>                        q-&gt;ThisQInterval = MinQuestionInterval;

                    q-&gt;unansweredQueries++;
                    <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &gt; MAX_UCAST_POLL_INTERVAL)
                        q-&gt;ThisQInterval = MAX_UCAST_POLL_INTERVAL;
                    <span class="enscript-keyword">if</span> (q-&gt;qDNSServer-&gt;isCell)
                    {
                        <span class="enscript-comment">// We don't want to retransmit too soon. Schedule our first retransmisson at
</span>                        <span class="enscript-comment">// MIN_UCAST_RETRANS_TIMEOUT seconds.
</span>                        <span class="enscript-keyword">if</span> (q-&gt;ThisQInterval &lt; MIN_UCAST_RETRANS_TIMEOUT)
                            q-&gt;ThisQInterval = MIN_UCAST_RETRANS_TIMEOUT;
                    }
                    debugf(<span class="enscript-string">&quot;uDNS_CheckCurrentQuestion: Increased ThisQInterval to %d for %##s (%s), cell %d&quot;</span>, q-&gt;ThisQInterval, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;qDNSServer-&gt;isCell);
                }
                q-&gt;LastQTime = m-&gt;timenow;
            }
            SetNextQueryTime(m, q);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// If we have no server for this query, or the only server is a disabled one, then we deliver
</span>            <span class="enscript-comment">// a transient failure indication to the client. This is important for things like iPhone
</span>            <span class="enscript-comment">// where we want to return timely feedback to the user when no network is available.
</span>            <span class="enscript-comment">// After calling MakeNegativeCacheRecord() we store the resulting record in the
</span>            <span class="enscript-comment">// cache so that it will be visible to other clients asking the same question.
</span>            <span class="enscript-comment">// (When we have a group of identical questions, only the active representative of the group gets
</span>            <span class="enscript-comment">// passed to uDNS_CheckCurrentQuestion -- we only want one set of query packets hitting the wire --
</span>            <span class="enscript-comment">// but we want *all* of the questions to get answer callbacks.)
</span>            CacheRecord *cr;
            <span class="enscript-type">const</span> mDNSu32 slot = HashSlotFromNameHash(q-&gt;qnamehash);
            CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);

            <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer)
            {
                <span class="enscript-keyword">if</span> (!mDNSOpaque128IsZero(&amp;q-&gt;validDNSServers))
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_ERROR,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion: ERROR!!: valid DNSServer bits not zero 0x%x, 0x%x 0x%x 0x%x for question &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q-&gt;validDNSServers.l[3], q-&gt;validDNSServers.l[2], q-&gt;validDNSServers.l[1], q-&gt;validDNSServers.l[0], DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));
                <span class="enscript-comment">// If we reached the end of list while picking DNS servers, then we don't want to deactivate the
</span>                <span class="enscript-comment">// question. Try after 60 seconds. We find this by looking for valid DNSServers for this question,
</span>                <span class="enscript-comment">// if we find any, then we must have tried them before we came here. This avoids maintaining
</span>                <span class="enscript-comment">// another state variable to see if we had valid DNS servers for this question.
</span>                SetValidDNSServers(m, q);
                <span class="enscript-keyword">if</span> (mDNSOpaque128IsZero(&amp;q-&gt;validDNSServers))
                {
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion: no DNS server for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;)&quot;</span>,
                              q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype));
                    q-&gt;ThisQInterval = 0;
                }
                <span class="enscript-keyword">else</span>
                {
                    DNSQuestion *qptr;
                    <span class="enscript-comment">// Pretend that we sent this question. As this is an ActiveQuestion, the NextScheduledQuery should
</span>                    <span class="enscript-comment">// be set properly. Also, we need to properly backoff in cases where we don't set the question to
</span>                    <span class="enscript-comment">// MaxQuestionInterval when we answer the question e.g., LongLived, we need to keep backing off
</span>                    q-&gt;ThisQInterval = q-&gt;ThisQInterval * QuestionIntervalStep;
                    q-&gt;LastQTime = m-&gt;timenow;
                    SetNextQueryTime(m, q);
                    <span class="enscript-comment">// Pick a new DNS server now. Otherwise, when the cache is 80% of its expiry, we will try
</span>                    <span class="enscript-comment">// to send a query and come back to the same place here and log the above message.
</span>                    q-&gt;qDNSServer = GetServerForQuestion(m, q);
                    <span class="enscript-keyword">for</span> (qptr = q-&gt;next ; qptr; qptr = qptr-&gt;next)
                        <span class="enscript-keyword">if</span> (qptr-&gt;DuplicateOf == q) { qptr-&gt;validDNSServers = q-&gt;validDNSServers; qptr-&gt;qDNSServer = q-&gt;qDNSServer; }
                    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                              <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_checkCurrentQuestion: Tried all DNS servers, retry question %p SuppressUnusable %d &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PUB_S <span class="enscript-string">&quot;) with DNS Server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d after 60 seconds, ThisQInterval %d&quot;</span>,
                              q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), q, q-&gt;SuppressUnusable, DM_NAME_PARAM(q-&gt;qname.c), DNSTypeName(q-&gt;qtype),
                              q-&gt;qDNSServer ? &amp;q-&gt;qDNSServer-&gt;addr : mDNSNULL, mDNSVal16(q-&gt;qDNSServer ? q-&gt;qDNSServer-&gt;port : zeroIPPort), q-&gt;ThisQInterval);
                }
            }
            <span class="enscript-keyword">else</span>
            {
                q-&gt;ThisQInterval = 0;
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion DNS server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d for &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; is disabled&quot;</span>,
                          q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), &amp;q-&gt;qDNSServer-&gt;addr, mDNSVal16(q-&gt;qDNSServer-&gt;port), DM_NAME_PARAM(q-&gt;qname.c));
            }

            <span class="enscript-keyword">if</span> (cg)
            {
                <span class="enscript-keyword">for</span> (cr = cg-&gt;members; cr; cr=cr-&gt;next)
                {
                    <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, q))
                    {
                        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                                  <span class="enscript-string">&quot;[R%u-&gt;Q%u] uDNS_CheckCurrentQuestion: Purged resourcerecord &quot;</span> PRI_S,
                                  q-&gt;request_id, mDNSVal16(q-&gt;TargetQID), CRDisplayString(m, cr));
                        mDNS_PurgeCacheResourceRecord(m, cr);
                    }
                }
            }
            <span class="enscript-comment">// For some of the WAB queries that we generate form within the mDNSResponder, most of the home routers
</span>            <span class="enscript-comment">// don't understand and return ServFail/NXDomain. In those cases, we don't want to try too often. We try
</span>            <span class="enscript-comment">// every fifteen minutes in that case
</span>            MakeNegativeCacheRecord(m, &amp;m-&gt;rec.r, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;qtype, q-&gt;qclass, (DomainEnumQuery(&amp;q-&gt;qname) ? 60 * 15 : 60), mDNSInterface_Any, q-&gt;qDNSServer);
            q-&gt;unansweredQueries = 0;
            <span class="enscript-keyword">if</span> (!mDNSOpaque16IsZero(q-&gt;responseFlags))
                m-&gt;rec.r.responseFlags = q-&gt;responseFlags;
            <span class="enscript-comment">// We're already using the m-&gt;CurrentQuestion pointer, so CacheRecordAdd can't use it to walk the question list.
</span>            <span class="enscript-comment">// To solve this problem we set cr-&gt;DelayDelivery to a nonzero value (which happens to be 'now') so that we
</span>            <span class="enscript-comment">// momentarily defer generating answer callbacks until mDNS_Execute time.
</span>            CreateNewCacheEntry(m, slot, cg, NonZeroTime(m-&gt;timenow), mDNStrue, mDNSNULL);
            ScheduleNextCacheCheckTime(m, slot, NonZeroTime(m-&gt;timenow));
            m-&gt;rec.r.responseFlags = zeroID;
            m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>            <span class="enscript-comment">// MUST NOT touch m-&gt;CurrentQuestion (or q) after this -- client callback could have deleted it
</span>        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">CheckNATMappings</span>(mDNS *m)
{
    mDNSBool rfc1918 = mDNSv4AddrIsRFC1918(&amp;m-&gt;AdvertisedV4.ip.v4);
    mDNSBool HaveRoutable = !rfc1918 &amp;&amp; !mDNSIPv4AddressIsZero(m-&gt;AdvertisedV4.ip.v4);
    m-&gt;NextScheduledNATOp = m-&gt;timenow + FutureTime;

    <span class="enscript-keyword">if</span> (HaveRoutable) m-&gt;ExtAddress = m-&gt;AdvertisedV4.ip.v4;

    <span class="enscript-keyword">if</span> (m-&gt;NATTraversals &amp;&amp; rfc1918)            <span class="enscript-comment">// Do we need to open a socket to receive multicast announcements from router?
</span>    {
        <span class="enscript-keyword">if</span> (m-&gt;NATMcastRecvskt == mDNSNULL)     <span class="enscript-comment">// If we are behind a NAT and the socket hasn't been opened yet, open it
</span>        {
            <span class="enscript-comment">// we need to log a message if we can't get our socket, but only the first time (after success)
</span>            <span class="enscript-type">static</span> mDNSBool needLog = mDNStrue;
            m-&gt;NATMcastRecvskt = mDNSPlatformUDPSocket(NATPMPAnnouncementPort);
            <span class="enscript-keyword">if</span> (!m-&gt;NATMcastRecvskt)
            {
                <span class="enscript-keyword">if</span> (needLog)
                {
                    LogMsg(<span class="enscript-string">&quot;CheckNATMappings: Failed to allocate port 5350 UDP multicast socket for PCP &amp; NAT-PMP announcements&quot;</span>);
                    needLog = mDNSfalse;
                }
            }
            <span class="enscript-keyword">else</span>
                needLog = mDNStrue;
        }
    }
    <span class="enscript-keyword">else</span>                                        <span class="enscript-comment">// else, we don't want to listen for announcements, so close them if they're open
</span>    {
        <span class="enscript-keyword">if</span> (m-&gt;NATMcastRecvskt) { mDNSPlatformUDPClose(m-&gt;NATMcastRecvskt); m-&gt;NATMcastRecvskt = mDNSNULL; }
        <span class="enscript-keyword">if</span> (m-&gt;SSDPSocket)      { debugf(<span class="enscript-string">&quot;CheckNATMappings destroying SSDPSocket %p&quot;</span>, &amp;m-&gt;SSDPSocket); mDNSPlatformUDPClose(m-&gt;SSDPSocket); m-&gt;SSDPSocket = mDNSNULL; }
    }

    uDNS_RequestAddress(m);

    <span class="enscript-keyword">if</span> (m-&gt;CurrentNATTraversal) LogMsg(<span class="enscript-string">&quot;WARNING m-&gt;CurrentNATTraversal already in use&quot;</span>);
    m-&gt;CurrentNATTraversal = m-&gt;NATTraversals;

    <span class="enscript-keyword">while</span> (m-&gt;CurrentNATTraversal)
    {
        NATTraversalInfo *cur = m-&gt;CurrentNATTraversal;
        mDNSv4Addr EffectiveAddress = HaveRoutable ? m-&gt;AdvertisedV4.ip.v4 : cur-&gt;NewAddress;
        m-&gt;CurrentNATTraversal = m-&gt;CurrentNATTraversal-&gt;next;

        <span class="enscript-keyword">if</span> (HaveRoutable)       <span class="enscript-comment">// If not RFC 1918 address, our own address and port are effectively our external address and port
</span>        {
            cur-&gt;ExpiryTime = 0;
            cur-&gt;NewResult  = mStatus_NoError;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-comment">// Check if it's time to send port mapping packet(s)
</span>        {
            <span class="enscript-keyword">if</span> (m-&gt;timenow - cur-&gt;retryPortMap &gt;= 0) <span class="enscript-comment">// Time to send a mapping request for this packet
</span>            {
                <span class="enscript-keyword">if</span> (cur-&gt;ExpiryTime &amp;&amp; cur-&gt;ExpiryTime - m-&gt;timenow &lt; 0)    <span class="enscript-comment">// Mapping has expired
</span>                {
                    cur-&gt;ExpiryTime    = 0;
                    cur-&gt;retryInterval = NATMAP_INIT_RETRY;
                }

                uDNS_SendNATMsg(m, cur, mDNStrue, mDNSfalse); <span class="enscript-comment">// Will also do UPnP discovery for us, if necessary
</span>
                <span class="enscript-keyword">if</span> (cur-&gt;ExpiryTime)                        <span class="enscript-comment">// If have active mapping then set next renewal time halfway to expiry
</span>                    NATSetNextRenewalTime(m, cur);
                <span class="enscript-keyword">else</span>                                        <span class="enscript-comment">// else no mapping; use exponential backoff sequence
</span>                {
                    <span class="enscript-keyword">if</span>      (cur-&gt;retryInterval &lt; NATMAP_INIT_RETRY            ) cur-&gt;retryInterval = NATMAP_INIT_RETRY;
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cur-&gt;retryInterval &lt; NATMAP_MAX_RETRY_INTERVAL / 2) cur-&gt;retryInterval *= 2;
                    <span class="enscript-keyword">else</span> cur-&gt;retryInterval = NATMAP_MAX_RETRY_INTERVAL;
                    cur-&gt;retryPortMap = m-&gt;timenow + cur-&gt;retryInterval;
                }
            }

            <span class="enscript-keyword">if</span> (m-&gt;NextScheduledNATOp - cur-&gt;retryPortMap &gt; 0)
            {
                m-&gt;NextScheduledNATOp = cur-&gt;retryPortMap;
            }
        }

        <span class="enscript-comment">// Notify the client if necessary. We invoke the callback if:
</span>        <span class="enscript-comment">// (1) We have an effective address,
</span>        <span class="enscript-comment">//     or we've tried and failed a couple of times to discover it
</span>        <span class="enscript-comment">// AND
</span>        <span class="enscript-comment">// (2) the client requested the address only,
</span>        <span class="enscript-comment">//     or the client won't need a mapping because we have a routable address,
</span>        <span class="enscript-comment">//     or the client has an expiry time and therefore a successful mapping,
</span>        <span class="enscript-comment">//     or we've tried and failed a couple of times (see &quot;Time line&quot; below)
</span>        <span class="enscript-comment">// AND
</span>        <span class="enscript-comment">// (3) we have new data to give the client that's changed since the last callback
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Time line is: Send, Wait 500ms, Send, Wait 1sec, Send, Wait 2sec, Send
</span>        <span class="enscript-comment">// At this point we've sent three requests without an answer, we've just sent our fourth request,
</span>        <span class="enscript-comment">// retryInterval is now 4 seconds, which is greater than NATMAP_INIT_RETRY * 8 (2 seconds),
</span>        <span class="enscript-comment">// so we return an error result to the caller.
</span>        <span class="enscript-keyword">if</span> (!mDNSIPv4AddressIsZero(EffectiveAddress) || cur-&gt;retryInterval &gt; NATMAP_INIT_RETRY * 8)
        {
            <span class="enscript-type">const</span> mStatus EffectiveResult = cur-&gt;NewResult ? cur-&gt;NewResult : mDNSv4AddrIsRFC1918(&amp;EffectiveAddress) ? mStatus_DoubleNAT : mStatus_NoError;
            <span class="enscript-type">const</span> mDNSIPPort ExternalPort = HaveRoutable ? cur-&gt;IntPort :
                                            !mDNSIPv4AddressIsZero(EffectiveAddress) &amp;&amp; cur-&gt;ExpiryTime ? cur-&gt;RequestedPort : zeroIPPort;

            <span class="enscript-keyword">if</span> (!cur-&gt;Protocol || HaveRoutable || cur-&gt;ExpiryTime || cur-&gt;retryInterval &gt; NATMAP_INIT_RETRY * 8)
            {
                <span class="enscript-keyword">if</span> (!mDNSSameIPv4Address(cur-&gt;ExternalAddress, EffectiveAddress) ||
                    !mDNSSameIPPort     (cur-&gt;ExternalPort,       ExternalPort)    ||
                    cur-&gt;Result != EffectiveResult)
                {
                    <span class="enscript-comment">//LogMsg(&quot;NAT callback %d %d %d&quot;, cur-&gt;Protocol, cur-&gt;ExpiryTime, cur-&gt;retryInterval);
</span>                    <span class="enscript-keyword">if</span> (cur-&gt;Protocol &amp;&amp; mDNSIPPortIsZero(ExternalPort) &amp;&amp; !mDNSIPv4AddressIsZero(m-&gt;Router.ip.v4))
                    {
                        <span class="enscript-keyword">if</span> (!EffectiveResult)
                            LogInfo(<span class="enscript-string">&quot;CheckNATMapping: Failed to obtain NAT port mapping %p from router %#a external address %.4a internal port %5d interval %d error %d&quot;</span>,
                                    cur, &amp;m-&gt;Router, &amp;EffectiveAddress, mDNSVal16(cur-&gt;IntPort), cur-&gt;retryInterval, EffectiveResult);
                        <span class="enscript-keyword">else</span>
                            LogMsg(<span class="enscript-string">&quot;CheckNATMapping: Failed to obtain NAT port mapping %p from router %#a external address %.4a internal port %5d interval %d error %d&quot;</span>,
                                   cur, &amp;m-&gt;Router, &amp;EffectiveAddress, mDNSVal16(cur-&gt;IntPort), cur-&gt;retryInterval, EffectiveResult);
                    }

                    cur-&gt;ExternalAddress = EffectiveAddress;
                    cur-&gt;ExternalPort    = ExternalPort;
                    cur-&gt;Lifetime        = cur-&gt;ExpiryTime &amp;&amp; !mDNSIPPortIsZero(ExternalPort) ?
                                           (cur-&gt;ExpiryTime - m-&gt;timenow + mDNSPlatformOneSecond/2) / mDNSPlatformOneSecond : 0;
                    cur-&gt;Result          = EffectiveResult;
                    mDNS_DropLockBeforeCallback();      <span class="enscript-comment">// Allow client to legally make mDNS API calls from the callback
</span>                    <span class="enscript-keyword">if</span> (cur-&gt;clientCallback)
                        cur-&gt;clientCallback(m, cur);
                    mDNS_ReclaimLockAfterCallback();    <span class="enscript-comment">// Decrement mDNS_reentrancy to block mDNS API calls again
</span>                    <span class="enscript-comment">// MUST NOT touch cur after invoking the callback
</span>                }
            }
        }
    }
}

mDNSlocal mDNSs32 <span class="enscript-function-name">CheckRecordUpdates</span>(mDNS *m)
{
    AuthRecord *rr;
    mDNSs32 nextevent = m-&gt;timenow + FutureTime;

    CheckGroupRecordUpdates(m);

    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr = rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (!AuthRecord_uDNS(rr)) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_NoTarget) {debugf(<span class="enscript-string">&quot;CheckRecordUpdates: Record %##s in NoTarget&quot;</span>, rr-&gt;resrec.name-&gt;c); <span class="enscript-keyword">continue</span>;}
        <span class="enscript-comment">// While we are waiting for the port mapping, we have nothing to do. The port mapping callback
</span>        <span class="enscript-comment">// will take care of this
</span>        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_NATMap) {debugf(<span class="enscript-string">&quot;CheckRecordUpdates: Record %##s in NATMap&quot;</span>, rr-&gt;resrec.name-&gt;c); <span class="enscript-keyword">continue</span>;}
        <span class="enscript-keyword">if</span> (rr-&gt;state == regState_Pending || rr-&gt;state == regState_DeregPending || rr-&gt;state == regState_UpdatePending ||
            rr-&gt;state == regState_Refresh || rr-&gt;state == regState_Registered)
        {
            <span class="enscript-keyword">if</span> (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval - m-&gt;timenow &lt;= 0)
            {
                <span class="enscript-keyword">if</span> (rr-&gt;tcp) { DisposeTCPConn(rr-&gt;tcp); rr-&gt;tcp = mDNSNULL; }
                <span class="enscript-keyword">if</span> (!rr-&gt;nta || mDNSIPv4AddressIsZero(rr-&gt;nta-&gt;Addr.ip.v4))
                {
                    <span class="enscript-comment">// Zero out the updateid so that if we have a pending response from the server, it won't
</span>                    <span class="enscript-comment">// be accepted as a valid response. If we accept the response, we might free the new &quot;nta&quot;
</span>                    <span class="enscript-keyword">if</span> (rr-&gt;nta) { rr-&gt;updateid = zeroID; CancelGetZoneData(m, rr-&gt;nta); }
                    rr-&gt;nta = StartGetZoneData(m, rr-&gt;resrec.name, ZoneServiceUpdate, RecordRegistrationGotZoneData, rr);

                    <span class="enscript-comment">// We have just started the GetZoneData. We need to wait for it to finish. SetRecordRetry here
</span>                    <span class="enscript-comment">// schedules the update timer to fire in the future.
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// There are three cases.
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// 1) When the updates are sent the first time, the first retry is intended to be at three seconds
</span>                    <span class="enscript-comment">//    in the future. But by calling SetRecordRetry here we set it to nine seconds. But it does not
</span>                    <span class="enscript-comment">//    matter because when the answer comes back, RecordRegistrationGotZoneData resets the interval
</span>                    <span class="enscript-comment">//    back to INIT_RECORD_REG_INTERVAL. This also gives enough time for the query.
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// 2) In the case of update errors (updateError), this causes further backoff as
</span>                    <span class="enscript-comment">//    RecordRegistrationGotZoneData does not reset the timer. This is intentional as in the case of
</span>                    <span class="enscript-comment">//    errors, we don't want to update aggressively.
</span>                    <span class="enscript-comment">//
</span>                    <span class="enscript-comment">// 3) We might be refreshing the update. This is very similar to case (1). RecordRegistrationGotZoneData
</span>                    <span class="enscript-comment">//    resets it back to INIT_RECORD_REG_INTERVAL.
</span>                    <span class="enscript-comment">//
</span>                    SetRecordRetry(m, rr, 0);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rr-&gt;state == regState_DeregPending) SendRecordDeregistration(m, rr);
                <span class="enscript-keyword">else</span> SendRecordRegistration(m, rr);
            }
        }
        <span class="enscript-keyword">if</span> (nextevent - (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval) &gt; 0)
            nextevent = (rr-&gt;LastAPTime + rr-&gt;ThisAPInterval);
    }
    <span class="enscript-keyword">return</span> nextevent;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_Tasks</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSs32 nexte;
    DNSServer *d;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    <span class="enscript-keyword">if</span> (m-&gt;NextSuspiciousTimeout &amp;&amp; m-&gt;NextSuspiciousTimeout &lt;= m-&gt;timenow) m-&gt;NextSuspiciousTimeout = 0;
#<span class="enscript-reference">endif</span>
    m-&gt;NextuDNSEvent = m-&gt;timenow + FutureTime;

    nexte = CheckRecordUpdates(m);
    <span class="enscript-keyword">if</span> (m-&gt;NextuDNSEvent - nexte &gt; 0)
        m-&gt;NextuDNSEvent = nexte;

    <span class="enscript-keyword">for</span> (d = m-&gt;DNSServers; d; d=d-&gt;next)
        <span class="enscript-keyword">if</span> (d-&gt;penaltyTime)
        {
            <span class="enscript-keyword">if</span> (m-&gt;timenow - d-&gt;penaltyTime &gt;= 0)
            {
                LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
                          <span class="enscript-string">&quot;DNS server &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d out of penalty box&quot;</span>, &amp;d-&gt;addr, mDNSVal16(d-&gt;port));
                d-&gt;penaltyTime = 0;
            }
            <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">if</span> (m-&gt;NextuDNSEvent - d-&gt;penaltyTime &gt; 0)
                m-&gt;NextuDNSEvent = d-&gt;penaltyTime;
        }

    <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion)
    {
        LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_DEFAULT,
                  <span class="enscript-string">&quot;uDNS_Tasks ERROR m-&gt;CurrentQuestion already set: &quot;</span> PRI_DM_NAME <span class="enscript-string">&quot; (&quot;</span> PRI_S <span class="enscript-string">&quot;)&quot;</span>,
                  DM_NAME_PARAM(m-&gt;CurrentQuestion-&gt;qname.c), DNSTypeName(m-&gt;CurrentQuestion-&gt;qtype));
    }
    m-&gt;CurrentQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;CurrentQuestion &amp;&amp; m-&gt;CurrentQuestion != m-&gt;NewQuestions)
    {
        DNSQuestion *<span class="enscript-type">const</span> q = m-&gt;CurrentQuestion;
        <span class="enscript-keyword">if</span> (ActiveQuestion(q) &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID))
        {
            uDNS_CheckCurrentQuestion(m);
            <span class="enscript-keyword">if</span> (q == m-&gt;CurrentQuestion)
                <span class="enscript-keyword">if</span> (m-&gt;NextuDNSEvent - NextQSendTime(q) &gt; 0)
                    m-&gt;NextuDNSEvent = NextQSendTime(q);
        }
        <span class="enscript-comment">// If m-&gt;CurrentQuestion wasn't modified out from under us, advance it now
</span>        <span class="enscript-comment">// We can't do this at the start of the loop because uDNS_CheckCurrentQuestion()
</span>        <span class="enscript-comment">// depends on having m-&gt;CurrentQuestion point to the right question
</span>        <span class="enscript-keyword">if</span> (m-&gt;CurrentQuestion == q)
            m-&gt;CurrentQuestion = q-&gt;next;
    }
    m-&gt;CurrentQuestion = mDNSNULL;
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Startup</span>, <span class="enscript-variable-name">Shutdown</span>, <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">Sleep</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SleepRecordRegistrations</span>(mDNS *m)
{
    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;ResourceRecords; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (AuthRecord_uDNS(rr))
        {
            <span class="enscript-comment">// Zero out the updateid so that if we have a pending response from the server, it won't
</span>            <span class="enscript-comment">// be accepted as a valid response.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;nta) { rr-&gt;updateid = zeroID; CancelGetZoneData(m, rr-&gt;nta); rr-&gt;nta = mDNSNULL; }

            <span class="enscript-keyword">if</span> (rr-&gt;NATinfo.clientContext)
            {
                mDNS_StopNATOperation_internal(m, &amp;rr-&gt;NATinfo);
                rr-&gt;NATinfo.clientContext = mDNSNULL;
            }
            <span class="enscript-comment">// We are waiting to update the resource record. The original data of the record is
</span>            <span class="enscript-comment">// in OrigRData and the updated value is in InFlightRData. Free the old and the new
</span>            <span class="enscript-comment">// one will be registered when we come back.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;state == regState_UpdatePending)
            {
                <span class="enscript-comment">// act as if the update succeeded, since we're about to delete the name anyway
</span>                rr-&gt;state = regState_Registered;
                <span class="enscript-comment">// deallocate old RData
</span>                <span class="enscript-keyword">if</span> (rr-&gt;UpdateCallback) rr-&gt;UpdateCallback(m, rr, rr-&gt;OrigRData, rr-&gt;OrigRDLen);
                SetNewRData(&amp;rr-&gt;resrec, rr-&gt;InFlightRData, rr-&gt;InFlightRDLen);
                rr-&gt;OrigRData = mDNSNULL;
                rr-&gt;InFlightRData = mDNSNULL;
            }

            <span class="enscript-comment">// If we have not begun the registration process i.e., never sent a registration packet,
</span>            <span class="enscript-comment">// then uDNS_DeregisterRecord will not send a deregistration
</span>            uDNS_DeregisterRecord(m, rr);

            <span class="enscript-comment">// When we wake, we call ActivateUnicastRegistration which starts at StartGetZoneData
</span>        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddSearchDomain</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain, mDNSInterfaceID InterfaceID)
{
    SearchListElem **p;
    SearchListElem *tmp = mDNSNULL;

    <span class="enscript-comment">// Check to see if we already have this domain in our list
</span>    <span class="enscript-keyword">for</span> (p = &amp;SearchList; *p; p = &amp;(*p)-&gt;next)
        <span class="enscript-keyword">if</span> (((*p)-&gt;InterfaceID == InterfaceID) &amp;&amp; SameDomainName(&amp;(*p)-&gt;domain, domain))
        {
            <span class="enscript-comment">// If domain is already in list, and marked for deletion, unmark the delete
</span>            <span class="enscript-comment">// Be careful not to touch the other flags that may be present
</span>            LogInfo(<span class="enscript-string">&quot;mDNS_AddSearchDomain already in list %##s&quot;</span>, domain-&gt;c);
            <span class="enscript-keyword">if</span> ((*p)-&gt;flag &amp; SLE_DELETE) (*p)-&gt;flag &amp;= ~SLE_DELETE;
            tmp = *p;
            *p = tmp-&gt;next;
            tmp-&gt;next = mDNSNULL;
            <span class="enscript-keyword">break</span>;
        }


    <span class="enscript-comment">// move to end of list so that we maintain the same order
</span>    <span class="enscript-keyword">while</span> (*p) p = &amp;(*p)-&gt;next;

    <span class="enscript-keyword">if</span> (tmp) *p = tmp;
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// if domain not in list, add to list, mark as add (1)
</span>        *p = (SearchListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(**p));
        <span class="enscript-keyword">if</span> (!*p) { LogMsg(<span class="enscript-string">&quot;ERROR: mDNS_AddSearchDomain - malloc&quot;</span>); <span class="enscript-keyword">return</span>; }
        AssignDomainName(&amp;(*p)-&gt;domain, domain);
        (*p)-&gt;next = mDNSNULL;
        (*p)-&gt;InterfaceID = InterfaceID;
        LogInfo(<span class="enscript-string">&quot;mDNS_AddSearchDomain created new %##s, InterfaceID %p&quot;</span>, domain-&gt;c, InterfaceID);
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeARElemCallback</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result)
{
    (<span class="enscript-type">void</span>)m;    <span class="enscript-comment">// unused
</span>    <span class="enscript-keyword">if</span> (result == mStatus_MemFree) mDNSPlatformMemFree(rr-&gt;RecordContext);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FoundDomain</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    SearchListElem *slElem = question-&gt;QuestionContext;
    mStatus err;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;

    <span class="enscript-keyword">if</span> (answer-&gt;rrtype != kDNSType_PTR) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (answer-&gt;RecordType == kDNSRecordTypePacketNegative) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (answer-&gt;InterfaceID == mDNSInterface_LocalOnly) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span>      (question == &amp;slElem-&gt;BrowseQ) name = mDNS_DomainTypeNames[mDNS_DomainTypeBrowse];
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question == &amp;slElem-&gt;DefBrowseQ) name = mDNS_DomainTypeNames[mDNS_DomainTypeBrowseDefault];
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question == &amp;slElem-&gt;AutomaticBrowseQ) name = mDNS_DomainTypeNames[mDNS_DomainTypeBrowseAutomatic];
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question == &amp;slElem-&gt;RegisterQ) name = mDNS_DomainTypeNames[mDNS_DomainTypeRegistration];
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (question == &amp;slElem-&gt;DefRegisterQ) name = mDNS_DomainTypeNames[mDNS_DomainTypeRegistrationDefault];
    <span class="enscript-keyword">else</span> { LogMsg(<span class="enscript-string">&quot;FoundDomain - unknown question&quot;</span>); <span class="enscript-keyword">return</span>; }

    LogInfo(<span class="enscript-string">&quot;FoundDomain: %p %s %s Q %##s A %s&quot;</span>, answer-&gt;InterfaceID, AddRecord ? <span class="enscript-string">&quot;Add&quot;</span> : <span class="enscript-string">&quot;Rmv&quot;</span>, name, question-&gt;qname.c, RRDisplayString(m, answer));

    <span class="enscript-keyword">if</span> (AddRecord)
    {
        ARListElem *arElem = (ARListElem *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*arElem));
        <span class="enscript-keyword">if</span> (!arElem) { LogMsg(<span class="enscript-string">&quot;ERROR: FoundDomain out of memory&quot;</span>); <span class="enscript-keyword">return</span>; }
        mDNS_SetupResourceRecord(&amp;arElem-&gt;ar, mDNSNULL, mDNSInterface_LocalOnly, kDNSType_PTR, 7200, kDNSRecordTypeShared, AuthRecordLocalOnly, FreeARElemCallback, arElem);
        MakeDomainNameFromDNSNameString(&amp;arElem-&gt;ar.namestorage, name);
        AppendDNSNameString            (&amp;arElem-&gt;ar.namestorage, <span class="enscript-string">&quot;local&quot;</span>);
        AssignDomainName(&amp;arElem-&gt;ar.resrec.rdata-&gt;u.name, &amp;answer-&gt;rdata-&gt;u.name);
        LogInfo(<span class="enscript-string">&quot;FoundDomain: Registering %s&quot;</span>, ARDisplayString(m, &amp;arElem-&gt;ar));
        err = mDNS_Register(m, &amp;arElem-&gt;ar);
        <span class="enscript-keyword">if</span> (err) { LogMsg(<span class="enscript-string">&quot;ERROR: FoundDomain - mDNS_Register returned %d&quot;</span>, err); mDNSPlatformMemFree(arElem); <span class="enscript-keyword">return</span>; }
        arElem-&gt;next = slElem-&gt;AuthRecs;
        slElem-&gt;AuthRecs = arElem;
    }
    <span class="enscript-keyword">else</span>
    {
        ARListElem **ptr = &amp;slElem-&gt;AuthRecs;
        <span class="enscript-keyword">while</span> (*ptr)
        {
            <span class="enscript-keyword">if</span> (SameDomainName(&amp;(*ptr)-&gt;ar.resrec.rdata-&gt;u.name, &amp;answer-&gt;rdata-&gt;u.name))
            {
                ARListElem *dereg = *ptr;
                *ptr = (*ptr)-&gt;next;
                LogInfo(<span class="enscript-string">&quot;FoundDomain: Deregistering %s&quot;</span>, ARDisplayString(m, &amp;dereg-&gt;ar));
                err = mDNS_Deregister(m, &amp;dereg-&gt;ar);
                <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;ERROR: FoundDomain - mDNS_Deregister returned %d&quot;</span>, err);
                <span class="enscript-comment">// Memory will be freed in the FreeARElemCallback
</span>            }
            <span class="enscript-keyword">else</span>
                ptr = &amp;(*ptr)-&gt;next;
        }
    }
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span> &amp;&amp; <span class="enscript-variable-name">MACOSX_MDNS_MALLOC_DEBUGGING</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">udns_validatelists</span>(<span class="enscript-type">void</span> *<span class="enscript-type">const</span> v)
{
    mDNS *<span class="enscript-type">const</span> m = v;

    NATTraversalInfo *n;
    <span class="enscript-keyword">for</span> (n = m-&gt;NATTraversals; n; n=n-&gt;next)
        <span class="enscript-keyword">if</span> (n-&gt;next == (NATTraversalInfo *)~0 || n-&gt;clientCallback == (NATTraversalClientCallback) ~0)
            LogMemCorruption(<span class="enscript-string">&quot;m-&gt;NATTraversals: %p is garbage&quot;</span>, n);

    DNSServer *d;
    <span class="enscript-keyword">for</span> (d = m-&gt;DNSServers; d; d=d-&gt;next)
        <span class="enscript-keyword">if</span> (d-&gt;next == (DNSServer *)~0)
            LogMemCorruption(<span class="enscript-string">&quot;m-&gt;DNSServers: %p is garbage&quot;</span>, d);

    DomainAuthInfo *info;
    <span class="enscript-keyword">for</span> (info = m-&gt;AuthInfoList; info; info = info-&gt;next)
        <span class="enscript-keyword">if</span> (info-&gt;next == (DomainAuthInfo *)~0)
            LogMemCorruption(<span class="enscript-string">&quot;m-&gt;AuthInfoList: %p is garbage&quot;</span>, info);

    HostnameInfo *hi;
    <span class="enscript-keyword">for</span> (hi = m-&gt;Hostnames; hi; hi = hi-&gt;next)
        <span class="enscript-keyword">if</span> (hi-&gt;next == (HostnameInfo *)~0 || hi-&gt;StatusCallback == (mDNSRecordCallback*)~0)
            LogMemCorruption(<span class="enscript-string">&quot;m-&gt;Hostnames: %p is garbage&quot;</span>, n);

    SearchListElem *ptr;
    <span class="enscript-keyword">for</span> (ptr = SearchList; ptr; ptr = ptr-&gt;next)
        <span class="enscript-keyword">if</span> (ptr-&gt;next == (SearchListElem *)~0 || ptr-&gt;AuthRecs == (<span class="enscript-type">void</span>*)~0)
            LogMemCorruption(<span class="enscript-string">&quot;SearchList: %p is garbage (%X)&quot;</span>, ptr, ptr-&gt;AuthRecs);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// This should probably move to the UDS daemon -- the concept of legacy clients and automatic registration / automatic browsing
</span><span class="enscript-comment">// is really a UDS API issue, not something intrinsic to uDNS
</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_DeleteWABQueries</span>(mDNS *<span class="enscript-type">const</span> m, SearchListElem *ptr, <span class="enscript-type">int</span> delete)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name1 = mDNSNULL;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name2 = mDNSNULL;
    ARListElem **arList = &amp;ptr-&gt;AuthRecs;
    domainname namestorage1, namestorage2;
    mStatus err;

    <span class="enscript-comment">// &quot;delete&quot; parameter indicates the type of query.
</span>    <span class="enscript-keyword">switch</span> (delete)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">UDNS_WAB_BROWSE_QUERY</span>:
        mDNS_StopGetDomains(m, &amp;ptr-&gt;BrowseQ);
        mDNS_StopGetDomains(m, &amp;ptr-&gt;DefBrowseQ);
        name1 = mDNS_DomainTypeNames[mDNS_DomainTypeBrowse];
        name2 = mDNS_DomainTypeNames[mDNS_DomainTypeBrowseDefault];
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">UDNS_WAB_LBROWSE_QUERY</span>:
        mDNS_StopGetDomains(m, &amp;ptr-&gt;AutomaticBrowseQ);
        name1 = mDNS_DomainTypeNames[mDNS_DomainTypeBrowseAutomatic];
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">UDNS_WAB_REG_QUERY</span>:
        mDNS_StopGetDomains(m, &amp;ptr-&gt;RegisterQ);
        mDNS_StopGetDomains(m, &amp;ptr-&gt;DefRegisterQ);
        name1 = mDNS_DomainTypeNames[mDNS_DomainTypeRegistration];
        name2 = mDNS_DomainTypeNames[mDNS_DomainTypeRegistrationDefault];
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;uDNS_DeleteWABQueries: ERROR!! returning from default&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">// When we get the results to the domain enumeration queries, we add a LocalOnly
</span>    <span class="enscript-comment">// entry. For example, if we issue a domain enumeration query for b._dns-sd._udp.xxxx.com,
</span>    <span class="enscript-comment">// and when we get a response, we add a LocalOnly entry b._dns-sd._udp.local whose RDATA
</span>    <span class="enscript-comment">// points to what we got in the response. Locate the appropriate LocalOnly entries and delete
</span>    <span class="enscript-comment">// them.
</span>    <span class="enscript-keyword">if</span> (name1)
    {
        MakeDomainNameFromDNSNameString(&amp;namestorage1, name1);
        AppendDNSNameString(&amp;namestorage1, <span class="enscript-string">&quot;local&quot;</span>);
    }
    <span class="enscript-keyword">if</span> (name2)
    {
        MakeDomainNameFromDNSNameString(&amp;namestorage2, name2);
        AppendDNSNameString(&amp;namestorage2, <span class="enscript-string">&quot;local&quot;</span>);
    }
    <span class="enscript-keyword">while</span> (*arList)
    {
        ARListElem *dereg = *arList;
        <span class="enscript-keyword">if</span> ((name1 &amp;&amp; SameDomainName(&amp;dereg-&gt;ar.namestorage, &amp;namestorage1)) ||
            (name2 &amp;&amp; SameDomainName(&amp;dereg-&gt;ar.namestorage, &amp;namestorage2)))
        {
            LogInfo(<span class="enscript-string">&quot;uDNS_DeleteWABQueries: Deregistering PTR %##s -&gt; %##s&quot;</span>, dereg-&gt;ar.resrec.name-&gt;c, dereg-&gt;ar.resrec.rdata-&gt;u.name.c);
            *arList = dereg-&gt;next;
            err = mDNS_Deregister(m, &amp;dereg-&gt;ar);
            <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;uDNS_DeleteWABQueries:: ERROR!! mDNS_Deregister returned %d&quot;</span>, err);
            <span class="enscript-comment">// Memory will be freed in the FreeARElemCallback
</span>        }
        <span class="enscript-keyword">else</span>
        {
            LogInfo(<span class="enscript-string">&quot;uDNS_DeleteWABQueries: Skipping PTR %##s -&gt; %##s&quot;</span>, dereg-&gt;ar.resrec.name-&gt;c, dereg-&gt;ar.resrec.rdata-&gt;u.name.c);
            arList = &amp;(*arList)-&gt;next;
        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_SetupWABQueries</span>(mDNS *<span class="enscript-type">const</span> m)
{
    SearchListElem **p = &amp;SearchList, *ptr;
    mStatus err;
    <span class="enscript-type">int</span> action = 0;

    <span class="enscript-comment">// step 1: mark each element for removal
</span>    <span class="enscript-keyword">for</span> (ptr = SearchList; ptr; ptr = ptr-&gt;next)
        ptr-&gt;flag |= SLE_DELETE;

    <span class="enscript-comment">// Make sure we have the search domains from the platform layer so that if we start the WAB
</span>    <span class="enscript-comment">// queries below, we have the latest information.
</span>    mDNS_Lock(m);
    <span class="enscript-keyword">if</span> (!mDNSPlatformSetDNSConfig(mDNSfalse, mDNStrue, mDNSNULL, mDNSNULL, mDNSNULL, mDNSfalse))
    {
        <span class="enscript-comment">// If the configuration did not change, clear the flag so that we don't free the searchlist.
</span>        <span class="enscript-comment">// We still have to start the domain enumeration queries as we may not have started them
</span>        <span class="enscript-comment">// before.
</span>        <span class="enscript-keyword">for</span> (ptr = SearchList; ptr; ptr = ptr-&gt;next)
            ptr-&gt;flag &amp;= ~SLE_DELETE;
        LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: No config change&quot;</span>);
    }
    mDNS_Unlock(m);

    <span class="enscript-keyword">if</span> (m-&gt;WABBrowseQueriesCount)
        action |= UDNS_WAB_BROWSE_QUERY;
    <span class="enscript-keyword">if</span> (m-&gt;WABLBrowseQueriesCount)
        action |= UDNS_WAB_LBROWSE_QUERY;
    <span class="enscript-keyword">if</span> (m-&gt;WABRegQueriesCount)
        action |= UDNS_WAB_REG_QUERY;


    <span class="enscript-comment">// delete elems marked for removal, do queries for elems marked add
</span>    <span class="enscript-keyword">while</span> (*p)
    {
        ptr = *p;
        LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries:action 0x%x: Flags 0x%x,  AuthRecs %p, InterfaceID %p %##s&quot;</span>, action, ptr-&gt;flag, ptr-&gt;AuthRecs, ptr-&gt;InterfaceID, ptr-&gt;domain.c);
        <span class="enscript-comment">// If SLE_DELETE is set, stop all the queries, deregister all the records and free the memory.
</span>        <span class="enscript-comment">// Otherwise, check to see what the &quot;action&quot; requires. If a particular action bit is not set and
</span>        <span class="enscript-comment">// we have started the corresponding queries as indicated by the &quot;flags&quot;, stop those queries and
</span>        <span class="enscript-comment">// deregister the records corresponding to them.
</span>        <span class="enscript-keyword">if</span> ((ptr-&gt;flag &amp; SLE_DELETE) ||
            (!(action &amp; UDNS_WAB_BROWSE_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_BROWSE_QUERY_STARTED)) ||
            (!(action &amp; UDNS_WAB_LBROWSE_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_LBROWSE_QUERY_STARTED)) ||
            (!(action &amp; UDNS_WAB_REG_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_REG_QUERY_STARTED)))
        {
            <span class="enscript-keyword">if</span> (ptr-&gt;flag &amp; SLE_DELETE)
            {
                ARListElem *arList = ptr-&gt;AuthRecs;
                ptr-&gt;AuthRecs = mDNSNULL;
                *p = ptr-&gt;next;

                <span class="enscript-comment">// If the user has &quot;local&quot; in their DNS searchlist, we ignore that for the purposes of domain enumeration queries
</span>                <span class="enscript-comment">// We suppressed the domain enumeration for scoped search domains below. When we enable that
</span>                <span class="enscript-comment">// enable this.
</span>                <span class="enscript-keyword">if</span> ((ptr-&gt;flag &amp; SLE_WAB_BROWSE_QUERY_STARTED) &amp;&amp;
                    !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: DELETE  Browse for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                    mDNS_StopGetDomains(m, &amp;ptr-&gt;BrowseQ);
                    mDNS_StopGetDomains(m, &amp;ptr-&gt;DefBrowseQ);
                }
                <span class="enscript-keyword">if</span> ((ptr-&gt;flag &amp; SLE_WAB_LBROWSE_QUERY_STARTED) &amp;&amp;
                    !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: DELETE  Legacy Browse for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                    mDNS_StopGetDomains(m, &amp;ptr-&gt;AutomaticBrowseQ);
                }
                <span class="enscript-keyword">if</span> ((ptr-&gt;flag &amp; SLE_WAB_REG_QUERY_STARTED) &amp;&amp;
                    !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: DELETE  Registration for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                    mDNS_StopGetDomains(m, &amp;ptr-&gt;RegisterQ);
                    mDNS_StopGetDomains(m, &amp;ptr-&gt;DefRegisterQ);
                }

                mDNSPlatformMemFree(ptr);

                <span class="enscript-comment">// deregister records generated from answers to the query
</span>                <span class="enscript-keyword">while</span> (arList)
                {
                    ARListElem *dereg = arList;
                    arList = arList-&gt;next;
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: DELETE Deregistering PTR %##s -&gt; %##s&quot;</span>, dereg-&gt;ar.resrec.name-&gt;c, dereg-&gt;ar.resrec.rdata-&gt;u.name.c);
                    err = mDNS_Deregister(m, &amp;dereg-&gt;ar);
                    <span class="enscript-keyword">if</span> (err) LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries:: ERROR!! mDNS_Deregister returned %d&quot;</span>, err);
                    <span class="enscript-comment">// Memory will be freed in the FreeARElemCallback
</span>                }
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// If the user has &quot;local&quot; in their DNS searchlist, we ignore that for the purposes of domain enumeration queries
</span>            <span class="enscript-comment">// We suppressed the domain enumeration for scoped search domains below. When we enable that
</span>            <span class="enscript-comment">// enable this.
</span>            <span class="enscript-keyword">if</span> (!(action &amp; UDNS_WAB_BROWSE_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_BROWSE_QUERY_STARTED) &amp;&amp;
                !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Deleting Browse for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                ptr-&gt;flag &amp;= ~SLE_WAB_BROWSE_QUERY_STARTED;
                uDNS_DeleteWABQueries(m, ptr, UDNS_WAB_BROWSE_QUERY);
            }

            <span class="enscript-keyword">if</span> (!(action &amp; UDNS_WAB_LBROWSE_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_LBROWSE_QUERY_STARTED) &amp;&amp;
                !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Deleting Legacy Browse for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                ptr-&gt;flag &amp;= ~SLE_WAB_LBROWSE_QUERY_STARTED;
                uDNS_DeleteWABQueries(m, ptr, UDNS_WAB_LBROWSE_QUERY);
            }

            <span class="enscript-keyword">if</span> (!(action &amp; UDNS_WAB_REG_QUERY) &amp;&amp; (ptr-&gt;flag &amp; SLE_WAB_REG_QUERY_STARTED) &amp;&amp;
                !SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Deleting Registration for domain  %##s&quot;</span>, ptr-&gt;domain.c);
                ptr-&gt;flag &amp;= ~SLE_WAB_REG_QUERY_STARTED;
                uDNS_DeleteWABQueries(m, ptr, UDNS_WAB_REG_QUERY);
            }

            <span class="enscript-comment">// Fall through to handle the ADDs
</span>        }

        <span class="enscript-keyword">if</span> ((action &amp; UDNS_WAB_BROWSE_QUERY) &amp;&amp; !(ptr-&gt;flag &amp; SLE_WAB_BROWSE_QUERY_STARTED))
        {
            <span class="enscript-comment">// If the user has &quot;local&quot; in their DNS searchlist, we ignore that for the purposes of domain enumeration queries.
</span>            <span class="enscript-comment">// Also, suppress the domain enumeration for scoped search domains for now until there is a need.
</span>            <span class="enscript-keyword">if</span> (!SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                mStatus err1, err2;
                err1 = mDNS_GetDomains(m, &amp;ptr-&gt;BrowseQ,          mDNS_DomainTypeBrowse,              &amp;ptr-&gt;domain, ptr-&gt;InterfaceID, FoundDomain, ptr);
                <span class="enscript-keyword">if</span> (err1)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries: GetDomains for domain %##s returned error(s):\n&quot;</span>
                           <span class="enscript-string">&quot;%d (mDNS_DomainTypeBrowse)\n&quot;</span>, ptr-&gt;domain.c, err1);
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Starting Browse for domain %##s&quot;</span>, ptr-&gt;domain.c);
                }
                err2 = mDNS_GetDomains(m, &amp;ptr-&gt;DefBrowseQ,       mDNS_DomainTypeBrowseDefault,       &amp;ptr-&gt;domain, ptr-&gt;InterfaceID, FoundDomain, ptr);
                <span class="enscript-keyword">if</span> (err2)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries: GetDomains for domain %##s returned error(s):\n&quot;</span>
                           <span class="enscript-string">&quot;%d (mDNS_DomainTypeBrowseDefault)\n&quot;</span>, ptr-&gt;domain.c, err2);
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Starting Default Browse for domain %##s&quot;</span>, ptr-&gt;domain.c);
                }
                <span class="enscript-comment">// For simplicity, we mark a single bit for denoting that both the browse queries have started.
</span>                <span class="enscript-comment">// It is not clear as to why one would fail to start and the other would succeed in starting up.
</span>                <span class="enscript-comment">// If that happens, we will try to stop both the queries and one of them won't be in the list and
</span>                <span class="enscript-comment">// it is not a hard error.
</span>                <span class="enscript-keyword">if</span> (!err1 || !err2)
                {
                    ptr-&gt;flag |= SLE_WAB_BROWSE_QUERY_STARTED;
                }
            }
        }
        <span class="enscript-keyword">if</span> ((action &amp; UDNS_WAB_LBROWSE_QUERY) &amp;&amp; !(ptr-&gt;flag &amp; SLE_WAB_LBROWSE_QUERY_STARTED))
        {
            <span class="enscript-comment">// If the user has &quot;local&quot; in their DNS searchlist, we ignore that for the purposes of domain enumeration queries.
</span>            <span class="enscript-comment">// Also, suppress the domain enumeration for scoped search domains for now until there is a need.
</span>            <span class="enscript-keyword">if</span> (!SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                mStatus err1;
                err1 = mDNS_GetDomains(m, &amp;ptr-&gt;AutomaticBrowseQ, mDNS_DomainTypeBrowseAutomatic,     &amp;ptr-&gt;domain, ptr-&gt;InterfaceID, FoundDomain, ptr);
                <span class="enscript-keyword">if</span> (err1)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries: GetDomains for domain %##s returned error(s):\n&quot;</span>
                           <span class="enscript-string">&quot;%d (mDNS_DomainTypeBrowseAutomatic)\n&quot;</span>,
                           ptr-&gt;domain.c, err1);
                }
                <span class="enscript-keyword">else</span>
                {
                    ptr-&gt;flag |= SLE_WAB_LBROWSE_QUERY_STARTED;
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Starting Legacy Browse for domain %##s&quot;</span>, ptr-&gt;domain.c);
                }
            }
        }
        <span class="enscript-keyword">if</span> ((action &amp; UDNS_WAB_REG_QUERY) &amp;&amp; !(ptr-&gt;flag &amp; SLE_WAB_REG_QUERY_STARTED))
        {
            <span class="enscript-comment">// If the user has &quot;local&quot; in their DNS searchlist, we ignore that for the purposes of domain enumeration queries.
</span>            <span class="enscript-comment">// Also, suppress the domain enumeration for scoped search domains for now until there is a need.
</span>            <span class="enscript-keyword">if</span> (!SameDomainName(&amp;ptr-&gt;domain, &amp;localdomain) &amp;&amp; (ptr-&gt;InterfaceID == mDNSInterface_Any))
            {
                mStatus err1, err2;
                err1 = mDNS_GetDomains(m, &amp;ptr-&gt;RegisterQ,        mDNS_DomainTypeRegistration,        &amp;ptr-&gt;domain, ptr-&gt;InterfaceID, FoundDomain, ptr);
                <span class="enscript-keyword">if</span> (err1)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries: GetDomains for domain %##s returned error(s):\n&quot;</span>
                           <span class="enscript-string">&quot;%d (mDNS_DomainTypeRegistration)\n&quot;</span>, ptr-&gt;domain.c, err1);
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Starting Registration for domain %##s&quot;</span>, ptr-&gt;domain.c);
                }
                err2 = mDNS_GetDomains(m, &amp;ptr-&gt;DefRegisterQ,     mDNS_DomainTypeRegistrationDefault, &amp;ptr-&gt;domain, ptr-&gt;InterfaceID, FoundDomain, ptr);
                <span class="enscript-keyword">if</span> (err2)
                {
                    LogMsg(<span class="enscript-string">&quot;uDNS_SetupWABQueries: GetDomains for domain %##s returned error(s):\n&quot;</span>
                           <span class="enscript-string">&quot;%d (mDNS_DomainTypeRegistrationDefault)&quot;</span>, ptr-&gt;domain.c, err2);
                }
                <span class="enscript-keyword">else</span>
                {
                    LogInfo(<span class="enscript-string">&quot;uDNS_SetupWABQueries: Starting Default Registration for domain %##s&quot;</span>, ptr-&gt;domain.c);
                }
                <span class="enscript-keyword">if</span> (!err1 || !err2)
                {
                    ptr-&gt;flag |= SLE_WAB_REG_QUERY_STARTED;
                }
            }
        }

        p = &amp;ptr-&gt;next;
    }
}

<span class="enscript-comment">// mDNS_StartWABQueries is called once per API invocation where normally
</span><span class="enscript-comment">// one of the bits is set.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_StartWABQueries</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">int</span> queryType)
{
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_BROWSE_QUERY)
    {
        m-&gt;WABBrowseQueriesCount++;
        LogInfo(<span class="enscript-string">&quot;uDNS_StartWABQueries: Browse query count %d&quot;</span>, m-&gt;WABBrowseQueriesCount);
    }
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_LBROWSE_QUERY)
    {
        m-&gt;WABLBrowseQueriesCount++;
        LogInfo(<span class="enscript-string">&quot;uDNS_StartWABQueries: Legacy Browse query count %d&quot;</span>, m-&gt;WABLBrowseQueriesCount);
    }
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_REG_QUERY)
    {
        m-&gt;WABRegQueriesCount++;
        LogInfo(<span class="enscript-string">&quot;uDNS_StartWABQueries: Reg query count %d&quot;</span>, m-&gt;WABRegQueriesCount);
    }
    uDNS_SetupWABQueries(m);
}

<span class="enscript-comment">// mDNS_StopWABQueries is called once per API invocation where normally
</span><span class="enscript-comment">// one of the bits is set.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_StopWABQueries</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">int</span> queryType)
{
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_BROWSE_QUERY)
    {
        m-&gt;WABBrowseQueriesCount--;
        LogInfo(<span class="enscript-string">&quot;uDNS_StopWABQueries: Browse query count %d&quot;</span>, m-&gt;WABBrowseQueriesCount);
    }
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_LBROWSE_QUERY)
    {
        m-&gt;WABLBrowseQueriesCount--;
        LogInfo(<span class="enscript-string">&quot;uDNS_StopWABQueries: Legacy Browse query count %d&quot;</span>, m-&gt;WABLBrowseQueriesCount);
    }
    <span class="enscript-keyword">if</span> (queryType &amp; UDNS_WAB_REG_QUERY)
    {
        m-&gt;WABRegQueriesCount--;
        LogInfo(<span class="enscript-string">&quot;uDNS_StopWABQueries: Reg query count %d&quot;</span>, m-&gt;WABRegQueriesCount);
    }
    uDNS_SetupWABQueries(m);
}

mDNSexport domainname  *<span class="enscript-function-name">uDNS_GetNextSearchDomain</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">int</span> *searchIndex, mDNSBool ignoreDotLocal)
{
    SearchListElem *p = SearchList;
    <span class="enscript-type">int</span> count = *searchIndex;

    <span class="enscript-keyword">if</span> (count &lt; 0) { LogMsg(<span class="enscript-string">&quot;uDNS_GetNextSearchDomain: count %d less than zero&quot;</span>, count); <span class="enscript-keyword">return</span> mDNSNULL; }

    <span class="enscript-comment">// Skip the  domains that we already looked at before. Guard against &quot;p&quot;
</span>    <span class="enscript-comment">// being NULL. When search domains change we may not set the SearchListIndex
</span>    <span class="enscript-comment">// of the question to zero immediately e.g., domain enumeration query calls
</span>    <span class="enscript-comment">// uDNS_SetupWABQueries which reads in the new search domain but does not
</span>    <span class="enscript-comment">// restart the questions immediately. Questions are restarted as part of
</span>    <span class="enscript-comment">// network change and hence temporarily SearchListIndex may be out of range.
</span>
    <span class="enscript-keyword">for</span> (; count &amp;&amp; p; count--)
        p = p-&gt;next;

    <span class="enscript-keyword">while</span> (p)
    {
        <span class="enscript-type">int</span> labels = CountLabels(&amp;p-&gt;domain);
        <span class="enscript-keyword">if</span> (labels &gt; 0)
        {
            <span class="enscript-type">const</span> domainname *d = SkipLeadingLabels(&amp;p-&gt;domain, labels - 1);
            <span class="enscript-keyword">if</span> (SameDomainLabel(d-&gt;c, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_GetNextSearchDomain: skipping search domain %##s, InterfaceID %p&quot;</span>, p-&gt;domain.c, p-&gt;InterfaceID);
                (*searchIndex)++;
                p = p-&gt;next;
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (ignoreDotLocal &amp;&amp; SameDomainLabel(d-&gt;c, (<span class="enscript-type">const</span> mDNSu8 *)<span class="enscript-string">&quot;\x5&quot;</span> <span class="enscript-string">&quot;local&quot;</span>))
            {
                LogInfo(<span class="enscript-string">&quot;uDNS_GetNextSearchDomain: skipping local domain %##s, InterfaceID %p&quot;</span>, p-&gt;domain.c, p-&gt;InterfaceID);
                (*searchIndex)++;
                p = p-&gt;next;
                <span class="enscript-keyword">continue</span>;
            }
        }
        <span class="enscript-comment">// Point to the next one in the list which we will look at next time.
</span>        (*searchIndex)++;
        <span class="enscript-keyword">if</span> (p-&gt;InterfaceID == InterfaceID)
        {
            LogInfo(<span class="enscript-string">&quot;uDNS_GetNextSearchDomain returning domain %##s, InterfaceID %p&quot;</span>, p-&gt;domain.c, p-&gt;InterfaceID);
            <span class="enscript-keyword">return</span> &amp;p-&gt;domain;
        }
        LogInfo(<span class="enscript-string">&quot;uDNS_GetNextSearchDomain skipping domain %##s, InterfaceID %p&quot;</span>, p-&gt;domain.c, p-&gt;InterfaceID);
        p = p-&gt;next;
    }
    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_RestartQuestionAsTCP</span>(mDNS *m, DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport)
{
    <span class="enscript-comment">// Don't reuse TCP connections. We might have failed over to a different DNS server
</span>    <span class="enscript-comment">// while the first TCP connection is in progress. We need a new TCP connection to the
</span>    <span class="enscript-comment">// new DNS server. So, always try to establish a new connection.
</span>    <span class="enscript-keyword">if</span> (q-&gt;tcp) { DisposeTCPConn(q-&gt;tcp); q-&gt;tcp = mDNSNULL; }
    q-&gt;tcp = MakeTCPConn(m, mDNSNULL, mDNSNULL, kTCPSocketFlags_Zero, srcaddr, srcport, mDNSNULL, q, mDNSNULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;uDNS_RestartQuestionAsTCP: suspicious timeout %d ticks&quot;</span>,
        m-&gt;NextSuspiciousTimeout ? m-&gt;NextSuspiciousTimeout - m-&gt;timenow : 0);
#<span class="enscript-reference">endif</span>
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FlushAddressCacheRecords</span>(mDNS *<span class="enscript-type">const</span> m)
{
    mDNSu32 slot;
    CacheGroup *cg;
    CacheRecord *cr;
    FORALL_CACHERECORDS(slot, cg, cr)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.InterfaceID) <span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">// If a resource record can answer A or AAAA, they need to be flushed so that we will
</span>        <span class="enscript-comment">// deliver an ADD or RMV
</span>        <span class="enscript-keyword">if</span> (RRTypeAnswersQuestionType(&amp;cr-&gt;resrec, kDNSType_A) ||
            RRTypeAnswersQuestionType(&amp;cr-&gt;resrec, kDNSType_AAAA))
        {
            LogInfo(<span class="enscript-string">&quot;FlushAddressCacheRecords: Purging Resourcerecord %s&quot;</span>, CRDisplayString(m, cr));
            mDNS_PurgeCacheResourceRecord(m, cr);
        }
    }
}

<span class="enscript-comment">// Retry questions which has seach domains appended
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RetrySearchDomainQuestions</span>(mDNS *<span class="enscript-type">const</span> m)
{
    DNSQuestion *q;
    mDNSBool found = mDNSfalse;

    <span class="enscript-comment">// Check to see if there are any questions which needs search domains to be applied.
</span>    <span class="enscript-comment">// If there is none, search domains can't possibly affect them.
</span>    <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
    {
        <span class="enscript-keyword">if</span> (q-&gt;AppendSearchDomains)
        {
            found = mDNStrue;
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">if</span> (!found)
    {
        LogInfo(<span class="enscript-string">&quot;RetrySearchDomainQuestions: Questions with AppendSearchDomain not found&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    LogInfo(<span class="enscript-string">&quot;RetrySearchDomainQuestions: Question with AppendSearchDomain found %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
    <span class="enscript-comment">// Purge all the A/AAAA cache records and restart the queries. mDNSCoreRestartAddressQueries
</span>    <span class="enscript-comment">// does this. When we restart the question,  we first want to try the new search domains rather
</span>    <span class="enscript-comment">// than use the entries that is already in the cache. When we appended search domains, we might
</span>    <span class="enscript-comment">// have created cache entries which is no longer valid as there are new search domains now
</span>    mDNSCoreRestartAddressQueries(m, mDNStrue, FlushAddressCacheRecords, mDNSNULL, mDNSNULL);
}

<span class="enscript-comment">// Construction of Default Browse domain list (i.e. when clients pass NULL) is as follows:
</span><span class="enscript-comment">// 1) query for b._dns-sd._udp.local on LocalOnly interface
</span><span class="enscript-comment">//    (.local manually generated via explicit callback)
</span><span class="enscript-comment">// 2) for each search domain (from prefs pane), query for b._dns-sd._udp.&lt;searchdomain&gt;.
</span><span class="enscript-comment">// 3) for each result from (2), register LocalOnly PTR record b._dns-sd._udp.local. -&gt; &lt;result&gt;
</span><span class="enscript-comment">// 4) result above should generate a callback from question in (1).  result added to global list
</span><span class="enscript-comment">// 5) global list delivered to client via GetSearchDomainList()
</span><span class="enscript-comment">// 6) client calls to enumerate domains now go over LocalOnly interface
</span><span class="enscript-comment">//    (!!!KRS may add outgoing interface in addition)
</span>
<span class="enscript-type">struct</span> CompileTimeAssertionChecks_uDNS
{
    <span class="enscript-comment">// Check our structures are reasonable sizes. Including overly-large buffers, or embedding
</span>    <span class="enscript-comment">// other overly-large structures instead of having a pointer to them, can inadvertently
</span>    <span class="enscript-comment">// cause structure sizes (and therefore memory usage) to balloon unreasonably.
</span>    <span class="enscript-type">char</span> sizecheck_tcpInfo_t     [(<span class="enscript-keyword">sizeof</span>(tcpInfo_t)      &lt;=  9056) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_SearchListElem[(<span class="enscript-keyword">sizeof</span>(SearchListElem) &lt;=  6136) ? 1 : -1];
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">Push</span> <span class="enscript-variable-name">Notification</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushProcessResponse</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg,
                                      DNSPushNotificationServer *server, ResourceRecord *mrr)
{
    <span class="enscript-comment">// &quot;(CacheRecord*)1&quot; is a special (non-zero) end-of-list marker
</span>    <span class="enscript-comment">// We use this non-zero marker so that records in our CacheFlushRecords list will always have NextInCFList
</span>    <span class="enscript-comment">// set non-zero, and that tells GetCacheEntity() that they're not, at this moment, eligible for recycling.
</span>    CacheRecord *CacheFlushRecords = (CacheRecord*)1;
    CacheRecord **cfp = &amp;CacheFlushRecords;
    <span class="enscript-type">enum</span> { removeName, removeClass, removeRRset, removeRR, addRR } action;

    <span class="enscript-comment">// Ignore records we don't want to cache.
</span>
    <span class="enscript-comment">// Don't want to cache OPT or TSIG pseudo-RRs
</span>    <span class="enscript-keyword">if</span> (mrr-&gt;rrtype == kDNSType_TSIG)
    {
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (mrr-&gt;rrtype == kDNSType_OPT)
    {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> ((mrr-&gt;rrtype == kDNSType_CNAME) &amp;&amp; SameDomainName(mrr-&gt;name, &amp;mrr-&gt;rdata-&gt;u.name))
    {
        LogInfo(<span class="enscript-string">&quot;DNSPushProcessResponse: CNAME loop domain name %##s&quot;</span>, mrr-&gt;name-&gt;c);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// TTL == -1: delete individual record
</span>    <span class="enscript-comment">// TTL == -2: wildcard delete
</span>    <span class="enscript-comment">//   CLASS != ANY, TYPE != ANY: delete all records of specified type and class
</span>    <span class="enscript-comment">//   CLASS != ANY, TYPE == ANY: delete all RRs of specified class
</span>    <span class="enscript-comment">//   CLASS == ANY: delete all RRs on the name, regardless of type or class (TYPE is ignored).
</span>    <span class="enscript-comment">// If TTL is zero, this is a delete, not an add.
</span>    <span class="enscript-keyword">if</span> ((mDNSs32)mrr-&gt;rroriginalttl == -1)
    {
        LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponse: Got remove on %##s with type %s&quot;</span>,
               mrr-&gt;name, DNSTypeName(mrr-&gt;rrtype));
        action = removeRR;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mDNSs32)mrr-&gt;rroriginalttl == -2)
    {
        <span class="enscript-keyword">if</span> (mrr-&gt;rrclass == kDNSQClass_ANY)
        {
            LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponse: Got Remove Name on %##s&quot;</span>, mrr-&gt;name);
            action = removeName;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mrr-&gt;rrtype == kDNSQType_ANY)
        {
            LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponse: Got Remove Name on %##s&quot;</span>, mrr-&gt;name);
            action = removeClass;
        }
        <span class="enscript-keyword">else</span>
        {
            LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponse: Got Remove RRset on %##s, type %s, rdlength %d&quot;</span>,
                   mrr-&gt;name, DNSTypeName(mrr-&gt;rrtype), mrr-&gt;rdlength);
            action = removeRRset;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        action = addRR;
    }

    <span class="enscript-keyword">if</span> (action != addRR)
    {
        <span class="enscript-keyword">if</span> (m-&gt;rrcache_size)
        {
            CacheRecord *rr;
            <span class="enscript-comment">// Remember the unicast question that we found, which we use to make caching
</span>            <span class="enscript-comment">// decisions later on in this function
</span>            CacheGroup *cg = CacheGroupForName(m, mrr-&gt;namehash, mrr-&gt;name);
            <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
            {
                <span class="enscript-keyword">if</span> ( action == removeName  ||
                    (action == removeClass &amp;&amp; rr-&gt;resrec.rrclass == mrr-&gt;rrclass) ||
                    (rr-&gt;resrec.rrclass == mrr-&gt;rrclass &amp;&amp;
                     ((action == removeRRset &amp;&amp; rr-&gt;resrec.rrtype == mrr-&gt;rrtype) ||
                      (action == removeRR    &amp;&amp; rr-&gt;resrec.rrtype == mrr-&gt;rrtype  &amp;&amp;
                       SameRDataBody(mrr, &amp;rr-&gt;resrec.rdata-&gt;u, SameDomainName)))))
                {
                    LogInfo(<span class="enscript-string">&quot;DNSPushProcessResponse purging %##s (%s) %s&quot;</span>,
                            rr-&gt;resrec.name, DNSTypeName(mrr-&gt;rrtype), CRDisplayString(m, rr));
                    <span class="enscript-comment">// We've found a cache entry to delete.   Now what?
</span>                    mDNS_PurgeCacheResourceRecord(m, rr);
                }
            }
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// It's an add.
</span>        LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponse: Got add RR on %##s, type %s, length %d&quot;</span>,
               mrr-&gt;name, DNSTypeName(mrr-&gt;rrtype), mrr-&gt;rdlength);

        <span class="enscript-comment">// When we receive DNS Push responses, we assume a long cache lifetime --
</span>        <span class="enscript-comment">// This path is only reached for DNS Push responses; as long as the connection to the server is
</span>        <span class="enscript-comment">// live, the RR should stay ypdated.
</span>        mrr-&gt;rroriginalttl = kLLQ_DefLease <span class="enscript-comment">/* XXX */</span>;

        <span class="enscript-comment">// Use the DNS Server we remember from the question that created this DNS Push server structure.
</span>        mrr-&gt;rDNSServer = server-&gt;qDNSServer;
        
        <span class="enscript-comment">// 2. See if we want to add this packet resource record to our cache
</span>        <span class="enscript-comment">// We only try to cache answers if we have a cache to put them in
</span>        <span class="enscript-keyword">if</span> (m-&gt;rrcache_size)
        {
            <span class="enscript-type">const</span> mDNSu32 slot = HashSlotFromNameHash(mrr-&gt;namehash);
            CacheGroup *cg = CacheGroupForName(m, mrr-&gt;namehash, mrr-&gt;name);
            CacheRecord *rr = mDNSNULL;
            CacheRecord *NSECCachePtr = (CacheRecord *)1;

            <span class="enscript-comment">// 2a. Check if this packet resource record is already in our cache.
</span>            rr = mDNSCoreReceiveCacheCheck(m, msg, uDNS_LLQ_Events, slot, cg, mDNSNULL, &amp;cfp, &amp;NSECCachePtr, mDNSNULL);

            <span class="enscript-comment">// If packet resource record not in our cache, add it now
</span>            <span class="enscript-comment">// (unless it is just a deletion of a record we never had, in which case we don't care)
</span>            <span class="enscript-keyword">if</span> (!rr &amp;&amp; mrr-&gt;rroriginalttl &gt; 0)
            {
                rr = CreateNewCacheEntry(m, slot, cg, 0,
                                         mDNStrue, &amp;server-&gt;connection-&gt;transport-&gt;remote_addr);
                <span class="enscript-keyword">if</span> (rr)
                {
                    <span class="enscript-comment">// Not clear that this is ever used, but for verisimilitude, set this to look like
</span>                    <span class="enscript-comment">// an authoritative response to a regular query.
</span>                    rr-&gt;responseFlags.b[0] = kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery | kDNSFlag0_AA;
                    rr-&gt;responseFlags.b[1] = kDNSFlag1_RC_NoErr | kDNSFlag0_AA;
                }
            }
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushProcessResponses</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *firstAnswer,
                                           <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, DNSPushNotificationServer *server)
{
    DNSQuestion *q;
    <span class="enscript-type">const</span> mDNSu8 *ptr = firstAnswer;
    mDNSIPPort port;
    port.NotAnInteger = 0;
    ResourceRecord *mrr = &amp;m-&gt;rec.r.resrec;

    <span class="enscript-comment">// Validate the contents of the message
</span>    <span class="enscript-comment">// XXX Right now this code will happily parse all the valid data and then hit invalid data
</span>    <span class="enscript-comment">// and give up.  I don't think there's a risk here, but we should discuss it.
</span>    <span class="enscript-comment">// XXX what about source validation?   Like, if we have a VPN, are we safe?   I think yes, but let's think about it.
</span>    <span class="enscript-keyword">while</span> ((ptr = GetLargeResourceRecord(m, msg, ptr, end, mDNSNULL, kDNSRecordTypePacketAns, &amp;m-&gt;rec)))
    {
        <span class="enscript-type">int</span> gotOne = 0;
        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
        {
            <span class="enscript-keyword">if</span> (q-&gt;LongLived &amp;&amp;
                (q-&gt;qtype == mrr-&gt;rrtype || q-&gt;qtype == kDNSServiceType_ANY)
                &amp;&amp; q-&gt;qnamehash == mrr-&gt;namehash &amp;&amp; SameDomainName(&amp;q-&gt;qname, mrr-&gt;name))
            {
                LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponses found %##s (%s) %d %s %s&quot;</span>,
                       q-&gt;qname.c, DNSTypeName(q-&gt;qtype), q-&gt;state,
                       q-&gt;dnsPushServer ? (q-&gt;dnsPushServer-&gt;connection
                                           ? q-&gt;dnsPushServer-&gt;connection-&gt;remote_name
                                           : <span class="enscript-string">&quot;&lt;no push server&gt;&quot;</span>) : <span class="enscript-string">&quot;&lt;no push server&gt;&quot;</span>,
                       server-&gt;connection-&gt;remote_name);
                <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer == server)
                {
                    gotOne++;
                    DNSPushProcessResponse(m, msg, server, mrr);
                    <span class="enscript-keyword">break</span>; <span class="enscript-comment">// question list may have changed
</span>                }
            }
        }
        <span class="enscript-keyword">if</span> (!gotOne) {
            LogMsg(<span class="enscript-string">&quot;DNSPushProcessResponses: no match for %##s %d %d&quot;</span>, mrr-&gt;name, mrr-&gt;rrtype, mrr-&gt;rrclass);
        }
        mrr-&gt;RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }
}
                                           
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">DNSPushStartConnecting</span>(DNSPushNotificationServer *server)
{
    <span class="enscript-keyword">if</span> (dso_connect(server-&gt;connectInfo))
    {
        server-&gt;connectState = DNSPushServerConnectionInProgress;
    }
    <span class="enscript-keyword">else</span>
    {
        server-&gt;connectState = DNSPushServerConnectFailed;
    }
}

mDNSexport  <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushReconcileConnection</span>(mDNS *m, DNSQuestion *q)
{
    DNSPushNotificationZone   *zone;
    DNSPushNotificationZone   *nextZone;

    <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer == mDNSNULL)
    {
        <span class="enscript-keyword">return</span>;
    }
    
    <span class="enscript-comment">// Update the counts
</span>    <span class="enscript-keyword">for</span> (zone = m-&gt;DNSPushZones; zone != mDNSNULL; zone = zone-&gt;next)
    {
        <span class="enscript-keyword">if</span> (zone-&gt;server == q-&gt;dnsPushServer)
        {
            zone-&gt;numberOfQuestions--;
        }
    }
    q-&gt;dnsPushServer-&gt;numberOfQuestions--;

    nextZone = mDNSNULL;
    <span class="enscript-keyword">for</span> (zone = m-&gt;DNSPushZones; zone != mDNSNULL; zone = nextZone)
    {
        nextZone = zone-&gt;next;
        <span class="enscript-keyword">if</span> (zone-&gt;numberOfQuestions == 0)
        {
            <span class="enscript-keyword">if</span> (zone == m-&gt;DNSPushZones)
                m-&gt;DNSPushZones = nextZone;
            LogInfo(<span class="enscript-string">&quot;DNSPushReconcileConnection: zone %##s is being freed&quot;</span>, &amp;zone-&gt;zoneName);
            mDNSPlatformMemFree(zone);
         }
     }

    q-&gt;dnsPushServer = mDNSNULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> kDNSPushActivity_Subscription[] = <span class="enscript-string">&quot;dns-push-subscription&quot;</span>;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushSendKeepalive</span>(DNSPushNotificationServer *server, mDNSu32 inactivity_timeout, mDNSu32 keepalive_interval)
{
    dso_message_t state;
    dso_transport_t *transport = server-&gt;connection-&gt;transport;
    <span class="enscript-keyword">if</span> (transport == NULL || transport-&gt;outbuf == NULL) {
        <span class="enscript-comment">// Should be impossible, don't crash.
</span>        LogInfo(<span class="enscript-string">&quot;DNSPushNotificationSendSubscribe: no transport!&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    dso_make_message(&amp;state, transport-&gt;outbuf, transport-&gt;outbuf_size, server-&gt;connection, false, 0);
    dso_start_tlv(&amp;state, kDSOType_Keepalive);
    dso_add_tlv_u32(&amp;state, inactivity_timeout);
    dso_add_tlv_u32(&amp;state, keepalive_interval);
    dso_finish_tlv(&amp;state);
    dso_message_write(server-&gt;connection, &amp;state, mDNSfalse);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushNotificationSendSubscriptionChange</span>(mDNSBool subscribe, dso_state_t *dso, DNSQuestion *q)
{
    dso_message_t state;
    dso_transport_t *transport = dso-&gt;transport;
    mDNSu16 len;
    <span class="enscript-keyword">if</span> (transport == NULL || transport-&gt;outbuf == NULL) {
        <span class="enscript-comment">// Should be impossible, don't crash.
</span>        LogInfo(<span class="enscript-string">&quot;DNSPushNotificationSendSubscribe: no transport!&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    dso_make_message(&amp;state, transport-&gt;outbuf, transport-&gt;outbuf_size, dso, subscribe ? false : true, q);
    dso_start_tlv(&amp;state, subscribe ? kDSOType_DNSPushSubscribe : kDSOType_DNSPushUnsubscribe);
    len = DomainNameLengthLimit(&amp;q-&gt;qname, q-&gt;qname.c + (<span class="enscript-keyword">sizeof</span> q-&gt;qname));
    dso_add_tlv_bytes(&amp;state, q-&gt;qname.c, len);
    dso_add_tlv_u16(&amp;state, q-&gt;qtype);
    dso_add_tlv_u16(&amp;state, q-&gt;qclass);
    dso_finish_tlv(&amp;state);
    dso_message_write(dso, &amp;state, mDNSfalse);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushStop</span>(mDNS *m, DNSPushNotificationServer *server)
{
    mDNSBool found = mDNStrue;
    DNSQuestion *q;
    <span class="enscript-keyword">while</span> (found)
    {
        found = mDNSfalse;
        server-&gt;connectState = DNSPushServerNoDNSPush;
        
        <span class="enscript-keyword">for</span> (q = m-&gt;Questions; q; q = q-&gt;next)
        {
            <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer == server)
            {
                DNSPushReconcileConnection(m, q);
                q-&gt;dnsPushServer = NULL;
                q-&gt;state = LLQ_Poll;
                q-&gt;ThisQInterval = 0;
                q-&gt;LastQTime     = m-&gt;timenow;
                SetNextQueryTime(m, q);
                <span class="enscript-keyword">break</span>;
            }
        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushServerDrop</span>(DNSPushNotificationServer *server)
{
    <span class="enscript-keyword">if</span> (server-&gt;connection)
    {
        dso_drop(server-&gt;connection);
        server-&gt;connection = NULL;
    }
    <span class="enscript-keyword">if</span> (server-&gt;connectInfo)
    {
        dso_connect_state_drop(server-&gt;connectInfo);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushServerFree</span>(mDNS *m, DNSPushNotificationServer *server)
{
    DNSPushNotificationServer **sp;
    DNSPushServerDrop(server);

    sp = &amp;m-&gt;DNSPushServers;
    <span class="enscript-keyword">while</span> (*sp)
    {
        <span class="enscript-keyword">if</span> (*sp == server)
        {
            *sp = server-&gt;next;
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">else</span>
        {
        	sp = &amp;server-&gt;next;
        }
    }
    mDNSPlatformMemFree(server);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSPushDSOCallback</span>(<span class="enscript-type">void</span> *context, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *event_context,
                               dso_state_t *dso, dso_event_type_t eventType)
{
    <span class="enscript-type">const</span> DNSMessage *message;
    DNSPushNotificationServer *server = context;
    dso_activity_t *activity;
    <span class="enscript-type">const</span> dso_query_receive_context_t *receive_context;
    <span class="enscript-type">const</span> dso_disconnect_context_t *disconnect_context;
    <span class="enscript-type">const</span> dso_keepalive_context_t *keepalive_context;
    DNSQuestion *q;
    uint16_t rcode;
    mDNSs32 reconnect_when = 0;
    mDNS *m = server-&gt;m;

    mDNS_CheckLock(m);
    
	<span class="enscript-keyword">switch</span>(eventType)
    {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_DNSMessage</span>:
        <span class="enscript-comment">// We shouldn't get here because we won't use this connection for DNS messages.
</span>        message = event_context;
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: DNS Message (opcode=%d) received from %##s&quot;</span>,
               (message-&gt;h.flags.b[0] &amp; kDNSFlag0_OP_Mask) &gt;&gt; 3, &amp;server-&gt;serverName);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_DNSResponse</span>:
        <span class="enscript-comment">// We shouldn't get here because we already handled any DNS messages
</span>        message = event_context;
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: DNS Response (opcode=%d) received from %##s&quot;</span>,
               (message-&gt;h.flags.b[0] &amp; kDNSFlag0_OP_Mask) &gt;&gt; 3, &amp;server-&gt;serverName);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_DSOMessage</span>:
        message = event_context;
        <span class="enscript-keyword">if</span> (dso-&gt;primary.opcode == kDSOType_DNSPushUpdate) {
            DNSPushProcessResponses(server-&gt;m, message, dso-&gt;primary.payload,
                                    dso-&gt;primary.payload + dso-&gt;primary.length, server);
        } <span class="enscript-keyword">else</span> {
            dso_send_not_implemented(dso, &amp;message-&gt;h);
            LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Unknown DSO Message (Primary TLV=%d) received from %##s&quot;</span>,
                   dso-&gt;primary.opcode, &amp;server-&gt;serverName);
        }
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_DSOResponse</span>:
        receive_context = event_context;
        q = receive_context-&gt;query_context;
        rcode = receive_context-&gt;rcode;
        <span class="enscript-keyword">if</span> (q) {
            <span class="enscript-comment">// If we got an error on a subscribe, we need to evaluate what went wrong
</span>            <span class="enscript-keyword">if</span> (rcode == kDNSFlag1_RC_NoErr) {
                LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Subscription for %##s/%d/%d succeeded.&quot;</span>, q-&gt;qname.c, q-&gt;qtype, q-&gt;qclass);
                q-&gt;state = LLQ_DNSPush_Established;
                server-&gt;connectState = DNSPushServerSessionEstablished;
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// Don't use this server.
</span>                q-&gt;dnsPushServer-&gt;connectState = DNSPushServerNoDNSPush;
                q-&gt;state = LLQ_Poll;
                q-&gt;ThisQInterval = 0;
                q-&gt;LastQTime     = m-&gt;timenow;
                SetNextQueryTime(m, q);
                LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Subscription for %##s/%d/%d failed.&quot;</span>, q-&gt;qname.c, q-&gt;qtype, q-&gt;qclass);
            }
        } <span class="enscript-keyword">else</span> {
            LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: DSO Response (Primary TLV=%d) (RCODE=%d) (no query) received from %##s&quot;</span>,
                   dso-&gt;primary.opcode, receive_context-&gt;rcode, &amp;server-&gt;serverName);
            server-&gt;connectState = DNSPushServerSessionEstablished;
        }
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_Finalize</span>:
		LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Finalize&quot;</span>);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_Connected</span>:
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Connected to %##s&quot;</span>, &amp;server-&gt;serverName);
        server-&gt;connectState = DNSPushServerConnected;
        <span class="enscript-keyword">for</span> (activity = dso-&gt;activities; activity; activity = activity-&gt;next) {
            DNSPushNotificationSendSubscriptionChange(mDNStrue, dso, activity-&gt;context);
        }
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_ConnectFailed</span>:
        DNSPushStop(m, server);
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Connection to %##s failed&quot;</span>, &amp;server-&gt;serverName);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_Disconnected</span>:
        disconnect_context = event_context;

        <span class="enscript-comment">// If a network glitch broke the connection, try to reconnect immediately.  But if this happens
</span>        <span class="enscript-comment">// twice, don't just blindly reconnect.
</span>        <span class="enscript-keyword">if</span> (disconnect_context-&gt;reconnect_delay == 0) {
            <span class="enscript-keyword">if</span> ((server-&gt;lastDisconnect + 90 * mDNSPlatformOneSecond) - m-&gt;timenow &gt; 0) {
                reconnect_when = 3600000; <span class="enscript-comment">// If we get two disconnects in quick succession, wait an hour before trying again.
</span>            } <span class="enscript-keyword">else</span> {
                DNSPushStartConnecting(server);
                LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Connection to %##s disconnected, trying immediate reconnect&quot;</span>,
                       &amp;server-&gt;serverName);
            }
        } <span class="enscript-keyword">else</span> {
            reconnect_when = disconnect_context-&gt;reconnect_delay;
        }
        <span class="enscript-keyword">if</span> (reconnect_when != 0) {
            LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Holding server %##s out as not reconnectable for %lf seconds&quot;</span>,
                   &amp;server-&gt;serverName, 1000.0 * (reconnect_when - m-&gt;timenow) / (<span class="enscript-type">double</span>)mDNSPlatformOneSecond);
            dso_schedule_reconnect(m, server-&gt;connectInfo, reconnect_when);
        }
        server-&gt;lastDisconnect = m-&gt;timenow;
        server-&gt;connection = mDNSNULL;
		<span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// We don't reconnect unless there is demand.   The reason we have this event is so that we can
</span>        <span class="enscript-comment">// leave the DNSPushNotificationServer data structure around to _prevent_ attempts to reconnect
</span>        <span class="enscript-comment">// before the reconnect delay interval has expired.   When we get this call, we just free up the
</span>        <span class="enscript-comment">// server.
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_ShouldReconnect</span>:
        <span class="enscript-comment">// This should be unnecessary, but it would be bad to accidentally have a question pointing at
</span>        <span class="enscript-comment">// a server that had been freed, so make sure we don't.
</span>        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: ShouldReconnect timer for %##s fired, disposing of it.&quot;</span>, &amp;server-&gt;serverName);
        DNSPushStop(m, server);
        DNSPushServerFree(m, server);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_Keepalive</span>:
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Keepalive timer for %##s fired.&quot;</span>, &amp;server-&gt;serverName);
        keepalive_context = event_context;
        DNSPushSendKeepalive(server, keepalive_context-&gt;inactivity_timeout, keepalive_context-&gt;keepalive_interval);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_KeepaliveRcvd</span>:
        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Keepalive message received from %##s.&quot;</span>, &amp;server-&gt;serverName);
        <span class="enscript-keyword">break</span>;
        
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_Inactive</span>:
        <span class="enscript-comment">// The set of activities went to zero, and we set the idle timeout.   And it expired without any
</span>        <span class="enscript-comment">// new activities starting.   So we can disconnect.
</span>        LogMsg(<span class="enscript-string">&quot;DNSPushDSOCallback: Inactivity timer for %##s fired, disposing of it.&quot;</span>, &amp;server-&gt;serverName);
        DNSPushStop(m, server);
        DNSPushServerFree(m, server);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDSOEventType_RetryDelay</span>:
        disconnect_context = event_context;
        DNSPushStop(m, server);
        dso_schedule_reconnect(m, server-&gt;connectInfo, disconnect_context-&gt;reconnect_delay);
        <span class="enscript-keyword">break</span>;
    }
}

DNSPushNotificationServer *<span class="enscript-function-name">GetConnectionToDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    DNSPushNotificationZone   *zone;
    DNSPushNotificationServer *server;
    DNSPushNotificationZone   *newZone;
    DNSPushNotificationServer *newServer;
    <span class="enscript-type">char</span> name[MAX_ESCAPED_DOMAIN_NAME];

    <span class="enscript-comment">// If we already have a question for this zone and if the server is the same, reuse it
</span>    <span class="enscript-keyword">for</span> (zone = m-&gt;DNSPushZones; zone != mDNSNULL; zone = zone-&gt;next)
    {
        LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: zone compare zone %##s question %##s&quot;</span>, &amp;zone-&gt;zoneName, &amp;q-&gt;nta-&gt;ChildName);
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;q-&gt;nta-&gt;ChildName, &amp;zone-&gt;zoneName))
        {
            DNSPushNotificationServer *zoneServer = mDNSNULL;
            zoneServer = zone-&gt;server;
            <span class="enscript-keyword">if</span> (zoneServer != mDNSNULL) {
                LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: server compare server %##s question %##s&quot;</span>,
                       &amp;zoneServer-&gt;serverName, &amp;q-&gt;nta-&gt;Host);
                <span class="enscript-keyword">if</span> (SameDomainName(&amp;q-&gt;nta-&gt;Host, &amp;zoneServer-&gt;serverName))
                {
                    LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: server and zone already present.&quot;</span>);
                    zone-&gt;numberOfQuestions++;
                    zoneServer-&gt;numberOfQuestions++;
                    <span class="enscript-keyword">return</span> zoneServer;
                }
            }
        }
    }

    <span class="enscript-comment">// If we have a connection to this server but it is for a differnt zone, create a new zone entry and reuse the connection
</span>    <span class="enscript-keyword">for</span> (server = m-&gt;DNSPushServers; server != mDNSNULL; server = server-&gt;next)
    {
        LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: server compare server %##s question %##s&quot;</span>,
               &amp;server-&gt;serverName, &amp;q-&gt;nta-&gt;Host);
        <span class="enscript-keyword">if</span> (SameDomainName(&amp;q-&gt;nta-&gt;Host, &amp;server-&gt;serverName))
        {
            newZone = (DNSPushNotificationZone *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*newZone));
            <span class="enscript-keyword">if</span> (newZone == NULL)
            {
                <span class="enscript-keyword">return</span> NULL;
            }
            newZone-&gt;numberOfQuestions = 1;
            newZone-&gt;zoneName = q-&gt;nta-&gt;ChildName;
            newZone-&gt;server = server;

            <span class="enscript-comment">// Add the new zone to the begining of the list
</span>            newZone-&gt;next = m-&gt;DNSPushZones;
            m-&gt;DNSPushZones = newZone;

            server-&gt;numberOfQuestions++;
            LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: server already present.&quot;</span>);
            <span class="enscript-keyword">return</span> server;
        }
    }

    <span class="enscript-comment">// If we do not have any existing connections, create a new connection
</span>    newServer = (DNSPushNotificationServer *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*newServer));
    <span class="enscript-keyword">if</span> (newServer == NULL)
    {
        <span class="enscript-keyword">return</span> NULL;
    }
    newZone = (DNSPushNotificationZone *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*newZone));
    <span class="enscript-keyword">if</span> (newZone == NULL)
    {
        mDNSPlatformMemFree(newServer);
        <span class="enscript-keyword">return</span> NULL;
    }

    newServer-&gt;m = m;
    newServer-&gt;numberOfQuestions = 1;
    AssignDomainName(&amp;newServer-&gt;serverName, &amp;q-&gt;nta-&gt;Host);
    newServer-&gt;port = q-&gt;nta-&gt;Port;
    newServer-&gt;qDNSServer = q-&gt;qDNSServer;
    ConvertDomainNameToCString(&amp;newServer-&gt;serverName, name);
    newServer-&gt;connection = dso_create(mDNSfalse, 10, name, DNSPushDSOCallback, newServer, NULL);
    <span class="enscript-keyword">if</span> (newServer-&gt;connection == NULL)
    {
        mDNSPlatformMemFree(newServer);
        mDNSPlatformMemFree(newZone);
        <span class="enscript-keyword">return</span> NULL;
    }
    newServer-&gt;connectInfo = dso_connect_state_create(name, mDNSNULL, newServer-&gt;port, 10,
                                                      AbsoluteMaxDNSMessageData, AbsoluteMaxDNSMessageData,
                                                      DNSPushDSOCallback, newServer-&gt;connection, newServer, <span class="enscript-string">&quot;GetDSOConnectionToPushServer&quot;</span>);
    <span class="enscript-keyword">if</span> (newServer-&gt;connectInfo)
    {
        dso_connect_state_use_tls(newServer-&gt;connectInfo);
        DNSPushStartConnecting(newServer);
    }
    <span class="enscript-keyword">else</span>
    {
        newServer-&gt;connectState = DNSPushServerConnectFailed;
    }    
    newZone-&gt;numberOfQuestions = 1;
    newZone-&gt;zoneName = q-&gt;nta-&gt;ChildName;
    newZone-&gt;server = newServer;

    <span class="enscript-comment">// Add the new zone to the begining of the list
</span>    newZone-&gt;next   = m-&gt;DNSPushZones;
    m-&gt;DNSPushZones = newZone;

    newServer-&gt;next   = m-&gt;DNSPushServers;
    m-&gt;DNSPushServers = newServer;
    LogMsg(<span class="enscript-string">&quot;GetConnectionToDNSPushNotificationServer: allocated new server.&quot;</span>);

    <span class="enscript-keyword">return</span> newServer;
}

DNSPushNotificationServer *<span class="enscript-function-name">SubscribeToDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    DNSPushNotificationServer *server = GetConnectionToDNSPushNotificationServer(m, q);
    <span class="enscript-type">char</span> name[MAX_ESCAPED_DOMAIN_NAME + 9];  <span class="enscript-comment">// type(hex)+class(hex)+name
</span>    dso_activity_t *activity;
    <span class="enscript-keyword">if</span> (server == mDNSNULL) <span class="enscript-keyword">return</span> server;

    <span class="enscript-comment">// Now we have a connection to a push notification server.   It may be pending, or it may be active,
</span>    <span class="enscript-comment">// but either way we can add a DNS Push subscription to the server object.
</span>    mDNS_snprintf(name, <span class="enscript-keyword">sizeof</span> name, <span class="enscript-string">&quot;%04x%04x&quot;</span>, q-&gt;qtype, q-&gt;qclass);
    ConvertDomainNameToCString(&amp;q-&gt;qname, &amp;name[8]);
    activity = dso_add_activity(server-&gt;connection, name, kDNSPushActivity_Subscription, q, mDNSNULL);
    <span class="enscript-keyword">if</span> (activity == mDNSNULL)
    {
        LogInfo(<span class="enscript-string">&quot;SubscribeToDNSPushNotificationServer: failed to add question %##s&quot;</span>, &amp;q-&gt;qname);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    <span class="enscript-comment">// If we're already connected, send the subscribe request immediately.
</span>    <span class="enscript-keyword">if</span> (server-&gt;connectState == DNSPushServerConnected || server-&gt;connectState == DNSPushServerSessionEstablished)
    {
        DNSPushNotificationSendSubscriptionChange(mDNStrue, server-&gt;connection, q);
    }
    <span class="enscript-keyword">return</span> server;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DiscoverDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    LogInfo(<span class="enscript-string">&quot;DiscoverDNSPushNotificationServer: StartGetZoneData for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
    q-&gt;ThisQInterval = LLQ_POLL_INTERVAL + mDNSRandom(LLQ_POLL_INTERVAL/10);    <span class="enscript-comment">// Retry in approx 15 minutes
</span>    q-&gt;LastQTime     = m-&gt;timenow;
    SetNextQueryTime(m, q);
    <span class="enscript-keyword">if</span> (q-&gt;nta) CancelGetZoneData(m, q-&gt;nta);
    q-&gt;nta = StartGetZoneData(m, &amp;q-&gt;qname, ZoneServiceDNSPush, DNSPushNotificationGotZoneData, q);
    q-&gt;state = LLQ_DNSPush_ServerDiscovery;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">UnSubscribeToDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    dso_activity_t *activity;
    
    <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer != mDNSNULL)
    {
        <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer-&gt;connection != mDNSNULL)
        {
            <span class="enscript-keyword">if</span> (q-&gt;dnsPushServer-&gt;connectState == DNSPushServerSessionEstablished ||
                q-&gt;dnsPushServer-&gt;connectState == DNSPushServerConnected)
            {
                <span class="enscript-comment">// Ignore any response we get to a pending subscribe.
</span>                dso_ignore_response(q-&gt;dnsPushServer-&gt;connection, q);
                DNSPushNotificationSendSubscriptionChange(mDNSfalse, q-&gt;dnsPushServer-&gt;connection, q);
            }
            <span class="enscript-comment">// activities linger even if we are not connected.
</span>            activity = dso_find_activity(q-&gt;dnsPushServer-&gt;connection, mDNSNULL, kDNSPushActivity_Subscription, q);
            <span class="enscript-keyword">if</span> (activity != mDNSNULL) {
                dso_drop_activity(q-&gt;dnsPushServer-&gt;connection, activity);
            }
        }
        DNSPushReconcileConnection(m, q);
    }
    <span class="enscript-comment">// We let the DSO Idle mechanism clean up the connection to the server.
</span>}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">COMMON</span>, <span class="enscript-variable-name">DNS_PUSH</span>)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">UNICAST_DISABLED</span>

mDNSexport <span class="enscript-type">const</span> domainname *<span class="enscript-function-name">GetServiceTarget</span>(mDNS *m, AuthRecord *<span class="enscript-type">const</span> rr)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) rr;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName_internal</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) name;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForQuestion</span>(mDNS *m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) q;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">startLLQHandshake</span>(mDNS *m, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) q;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DisposeTCPConn</span>(<span class="enscript-type">struct</span> tcpInfo_t *tcp)
{
    (<span class="enscript-type">void</span>) tcp;
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartNATOperation_internal</span>(mDNS *m, NATTraversalInfo *traversal)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) traversal;

    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StopNATOperation_internal</span>(mDNS *m, NATTraversalInfo *traversal)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) traversal;

    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">sendLLQRefresh</span>(mDNS *m, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) q;
}

mDNSexport ZoneData *<span class="enscript-function-name">StartGetZoneData</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> ZoneService target, ZoneDataCallback callback, <span class="enscript-type">void</span> *ZoneDataContext)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) name;
    (<span class="enscript-type">void</span>) target;
    (<span class="enscript-type">void</span>) callback;
    (<span class="enscript-type">void</span>) ZoneDataContext;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RecordRegistrationGotZoneData</span>(mDNS *<span class="enscript-type">const</span> m, mStatus err, <span class="enscript-type">const</span> ZoneData *zoneData)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) err;
    (<span class="enscript-type">void</span>) zoneData;
}

mDNSexport uDNS_LLQType <span class="enscript-function-name">uDNS_recvLLQResponse</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                             <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport, DNSQuestion **matchQuestion)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) msg;
    (<span class="enscript-type">void</span>) end;
    (<span class="enscript-type">void</span>) srcaddr;
    (<span class="enscript-type">void</span>) srcport;
    (<span class="enscript-type">void</span>) matchQuestion;

    <span class="enscript-keyword">return</span> uDNS_LLQ_Not;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">PenalizeDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSOpaque16 responseFlags)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) q;
    (<span class="enscript-type">void</span>) responseFlags;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddSearchDomain</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain, mDNSInterfaceID InterfaceID)
{
    (<span class="enscript-type">void</span>) domain;
    (<span class="enscript-type">void</span>) InterfaceID;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RetrySearchDomainQuestions</span>(mDNS *<span class="enscript-type">const</span> m)
{
    (<span class="enscript-type">void</span>) m;
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_SetSecretForDomain</span>(mDNS *m, DomainAuthInfo *info, <span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> domainname *keyname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64keydata, <span class="enscript-type">const</span> domainname *hostname, mDNSIPPort *port)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) info;
    (<span class="enscript-type">void</span>) domain;
    (<span class="enscript-type">void</span>) keyname;
    (<span class="enscript-type">void</span>) b64keydata;
    (<span class="enscript-type">void</span>) hostname;
    (<span class="enscript-type">void</span>) port;

    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

mDNSexport domainname  *<span class="enscript-function-name">uDNS_GetNextSearchDomain</span>(mDNSInterfaceID InterfaceID, mDNSs8 *searchIndex, mDNSBool ignoreDotLocal)
{
    (<span class="enscript-type">void</span>) InterfaceID;
    (<span class="enscript-type">void</span>) searchIndex;
    (<span class="enscript-type">void</span>) ignoreDotLocal;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) name;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StartNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) traversal;

    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

mDNSexport mStatus <span class="enscript-function-name">mDNS_StopNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) traversal;

    <span class="enscript-keyword">return</span> mStatus_UnsupportedErr;
}

mDNSexport DNSServer *<span class="enscript-function-name">mDNS_AddDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">const</span> mDNSInterfaceID interface, <span class="enscript-type">const</span> mDNSs32 serviceID, <span class="enscript-type">const</span> mDNSAddr *addr,
                                        <span class="enscript-type">const</span> mDNSIPPort port, ScopeType scopeType, mDNSu32 timeout, mDNSBool isCell, mDNSBool isExpensive, mDNSBool isConstrained, mDNSBool isCLAT46,
                                        mDNSu32 resGroupID, mDNSBool reqA, mDNSBool reqAAAA, mDNSBool reqDO)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) d;
    (<span class="enscript-type">void</span>) interface;
    (<span class="enscript-type">void</span>) serviceID;
    (<span class="enscript-type">void</span>) addr;
    (<span class="enscript-type">void</span>) port;
    (<span class="enscript-type">void</span>) scopeType;
    (<span class="enscript-type">void</span>) timeout;
    (<span class="enscript-type">void</span>) isCell;
    (<span class="enscript-type">void</span>) isExpensive;
    (<span class="enscript-type">void</span>) isCLAT46;
    (<span class="enscript-type">void</span>) isConstrained;
    (<span class="enscript-type">void</span>) resGroupID;
    (<span class="enscript-type">void</span>) reqA;
    (<span class="enscript-type">void</span>) reqAAAA;
    (<span class="enscript-type">void</span>) reqDO;

    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_SetupWABQueries</span>(mDNS *<span class="enscript-type">const</span> m)
{
    (<span class="enscript-type">void</span>) m;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_StartWABQueries</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">int</span> queryType)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) queryType;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">uDNS_StopWABQueries</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">int</span> queryType)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) queryType;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn, mDNSRecordCallback *StatusCallback, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *StatusContext)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) fqdn;
    (<span class="enscript-type">void</span>) StatusCallback;
    (<span class="enscript-type">void</span>) StatusContext;
}
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetPrimaryInterfaceInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSAddr *v4addr, <span class="enscript-type">const</span> mDNSAddr *v6addr, <span class="enscript-type">const</span> mDNSAddr *router)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) v4addr;
    (<span class="enscript-type">void</span>) v6addr;
    (<span class="enscript-type">void</span>) router;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RemoveDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) fqdn;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">RecreateNATMappings</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 waitTicks)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) waitTicks;
}

mDNSexport mDNSBool <span class="enscript-function-name">IsGetZoneDataQuestion</span>(DNSQuestion *q)
{
    (<span class="enscript-type">void</span>)q;

    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SubscribeToDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>)m;
    (<span class="enscript-type">void</span>)q;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">UnSubscribeToDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>)m;
    (<span class="enscript-type">void</span>)q;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DiscoverDNSPushNotificationServer</span>(mDNS *m, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>)m;
    (<span class="enscript-type">void</span>)q;
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">UNICAST_DISABLED</span>


<span class="enscript-comment">// Local Variables:
</span><span class="enscript-comment">// mode: C
</span><span class="enscript-comment">// tab-width: 4
</span><span class="enscript-comment">// c-file-style: &quot;bsd&quot;
</span><span class="enscript-comment">// c-basic-offset: 4
</span><span class="enscript-comment">// fill-column: 108
</span><span class="enscript-comment">// indent-tabs-mode: nil
</span><span class="enscript-comment">// End:
</span></pre>
<hr />
</body></html>