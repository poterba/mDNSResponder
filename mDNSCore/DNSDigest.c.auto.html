<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DNSDigest.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">DNSDigest.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="DNSDigest.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>

<span class="enscript-comment">// Disable certain benign warnings with Microsoft compilers
</span>#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>))
<span class="enscript-comment">// Disable &quot;conditional expression is constant&quot; warning for debug macros.
</span><span class="enscript-comment">// Otherwise, this generates warnings for the perfectly natural construct &quot;while(1)&quot;
</span><span class="enscript-comment">// If someone knows a variant way of writing &quot;while(1)&quot; that doesn't generate warning messages, please let us know
</span>    #pragma warning(disable:4127)
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Byte</span> <span class="enscript-variable-name">Swapping</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSlocal mDNSu16 <span class="enscript-function-name">NToH16</span>(mDNSu8 * bytes)
{
    <span class="enscript-keyword">return</span> (mDNSu16)((mDNSu16)bytes[0] &lt;&lt; 8 | (mDNSu16)bytes[1]);
}

mDNSlocal mDNSu32 <span class="enscript-function-name">NToH32</span>(mDNSu8 * bytes)
{
    <span class="enscript-keyword">return</span> (mDNSu32)((mDNSu32) bytes[0] &lt;&lt; 24 | (mDNSu32) bytes[1] &lt;&lt; 16 | (mDNSu32) bytes[2] &lt;&lt; 8 | (mDNSu32)bytes[3]);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">MD5</span> <span class="enscript-variable-name">Hash</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* The source for the has is derived CommonCrypto files CommonDigest.h, md32_common.h, md5_locl.h, md5_locl.h, and openssl/md5.h.
 * The following changes have been made to the original sources:
 *    replaced CC_LONG w/ mDNSu32
 *    replaced CC_MD5* with MD5*
 *    replaced CC_LONG w/ mDNSu32, removed conditional #defines from md5.h
 *    removed extern decls for MD5_Init/Update/Final from CommonDigest.h
 *    removed APPLE_COMMON_DIGEST specific #defines from md5_locl.h
 *
 * Note: machine archetecure specific conditionals from the original sources are turned off, but are left in the code
 * to aid in platform-specific optimizations and debugging.
 * Sources originally distributed under the following license headers:
 * CommonDigest.h - APSL
 *
 * md32_Common.h
 * ====================================================================
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    &quot;This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (<a href="http://www.OpenSSL.org/">http://www.OpenSSL.org/</a>)&quot;
 *
 * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    <a href="mailto:licensing@OpenSSL.org">licensing@OpenSSL.org</a>.
 *
 * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
 *    nor may &quot;OpenSSL&quot; appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    &quot;This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (<a href="http://www.OpenSSL.org/">http://www.OpenSSL.org/</a>)&quot;
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * md5_dgst.c, md5_locl.h
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (<a href="mailto:eay@cryptsoft.com">eay@cryptsoft.com</a>).  This product includes software written by Tim
 * Hudson (<a href="mailto:tjh@cryptsoft.com">tjh@cryptsoft.com</a>).
 *
 * Copyright (C) 1995-1998 Eric Young (<a href="mailto:eay@cryptsoft.com">eay@cryptsoft.com</a>)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (<a href="mailto:eay@cryptsoft.com">eay@cryptsoft.com</a>).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (<a href="mailto:tjh@cryptsoft.com">tjh@cryptsoft.com</a>).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    &quot;This product includes cryptographic software written by
 *     Eric Young (<a href="mailto:eay@cryptsoft.com">eay@cryptsoft.com</a>)&quot;
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    &quot;This product includes software written by Tim Hudson (<a href="mailto:tjh@cryptsoft.com">tjh@cryptsoft.com</a>)&quot;
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 *
 */</span>

<span class="enscript-comment">//from CommonDigest.h
</span>


<span class="enscript-comment">// from openssl/md5.h
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_CBLOCK</span>  64
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_LBLOCK</span>  (MD5_CBLOCK/4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_DIGEST_LENGTH</span> 16

<span class="enscript-type">void</span> <span class="enscript-function-name">MD5_Transform</span>(MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *b);

<span class="enscript-comment">// From md5_locl.h
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MD5_LONG_LOG2</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_LONG_LOG2</span> 2 <span class="enscript-comment">/* default to 32 bits */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MD5_ASM</span>
# <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_M_IX86</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__INTEL__</span>)
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">md5_block_host_order</span> md5_block_asm_host_order
# <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__sparc</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_SYS_ULTRASPARC</span>)
<span class="enscript-type">void</span> <span class="enscript-function-name">md5_block_asm_data_order_aligned</span> (MD5_CTX *c, <span class="enscript-type">const</span> mDNSu32 *p,<span class="enscript-type">int</span> num);
#  <span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span> md5_block_asm_data_order_aligned
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">md5_block_host_order</span> (MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *p,<span class="enscript-type">int</span> num);
<span class="enscript-type">void</span> <span class="enscript-function-name">md5_block_data_order</span> (MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *p,<span class="enscript-type">int</span> num);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_M_IX86</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__INTEL__</span>)
<span class="enscript-comment">/*
 * *_block_host_order is expected to handle aligned data while
 * *_block_data_order - unaligned. As algorithm and host (x86)
 * are in this case of the same &quot;endianness&quot; these two are
 * otherwise indistinguishable. But normally you don't want to
 * call the same function because unaligned access in places
 * where alignment is expected is usually a &quot;Bad Thing&quot;. Indeed,
 * on RISCs you get punished with BUS ERROR signal or *severe*
 * performance degradation. Intel CPUs are in turn perfectly
 * capable of loading unaligned data without such drastic side
 * effect. Yes, they say it's slower than aligned load, but no
 * exception is generated and therefore performance degradation
 * is *incomparable* with RISCs. What we should weight here is
 * costs of unaligned access against costs of aligning data.
 * According to my measurements allowing unaligned access results
 * in ~9% performance improvement on Pentium II operating at
 * 266MHz. I won't be surprised if the difference will be higher
 * on faster systems:-)
 *
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">md5_block_data_order</span> md5_block_host_order
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_LONG</span>       mDNSu32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_LONG_LOG2</span>  MD5_LONG_LOG2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_CTX</span>        MD5_CTX
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_CBLOCK</span>     MD5_CBLOCK
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_LBLOCK</span>     MD5_LBLOCK

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_UPDATE</span>     MD5_Update
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_TRANSFORM</span>  MD5_Transform
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_FINAL</span>      MD5_Final

#<span class="enscript-reference">define</span> <span class="enscript-function-name">HASH_MAKE_STRING</span>(c,s)   do {    \
        unsigned long ll;       \
        ll=(c)-&gt;A; HOST_l2c(ll,(s));    \
        ll=(c)-&gt;B; HOST_l2c(ll,(s));    \
        ll=(c)-&gt;C; HOST_l2c(ll,(s));    \
        ll=(c)-&gt;D; HOST_l2c(ll,(s));    \
} while (0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_BLOCK_HOST_ORDER</span>   md5_block_host_order
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">L_ENDIAN</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">md5_block_data_order</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>   md5_block_data_order
<span class="enscript-comment">/*
 * Little-endians (Intel and Alpha) feel better without this.
 * It looks like memcpy does better job than generic
 * md5_block_data_order on copying-n-aligning input data.
 * But frankly speaking I didn't expect such result on Alpha.
 * On the other hand I've got this with egcs-1.0.2 and if
 * program is compiled with another (better?) compiler it
 * might turn out other way around.
 *
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// from md32_common.h
</span>
<span class="enscript-comment">/*
 * This is a generic 32 bit &quot;collector&quot; for message digest algorithms.
 * Whenever needed it collects input character stream into chunks of
 * 32 bit values and invokes a block function that performs actual hash
 * calculations.
 *
 * Porting guide.
 *
 * Obligatory macros:
 *
 * DATA_ORDER_IS_BIG_ENDIAN or DATA_ORDER_IS_LITTLE_ENDIAN
 *	this macro defines byte order of input stream.
 * HASH_CBLOCK
 *	size of a unit chunk HASH_BLOCK operates on.
 * HASH_LONG
 *	has to be at lest 32 bit wide, if it's wider, then
 *	HASH_LONG_LOG2 *has to* be defined along
 * HASH_CTX
 *	context structure that at least contains following
 *	members:
 *		typedef struct {
 *			...
 *			HASH_LONG	Nl,Nh;
 *			HASH_LONG	data[HASH_LBLOCK];
 *			int		num;
 *			...
 *			} HASH_CTX;
 * HASH_UPDATE
 *	name of &quot;Update&quot; function, implemented here.
 * HASH_TRANSFORM
 *	name of &quot;Transform&quot; function, implemented here.
 * HASH_FINAL
 *	name of &quot;Final&quot; function, implemented here.
 * HASH_BLOCK_HOST_ORDER
 *	name of &quot;block&quot; function treating *aligned* input message
 *	in host byte order, implemented externally.
 * HASH_BLOCK_DATA_ORDER
 *	name of &quot;block&quot; function treating *unaligned* input message
 *	in original (data) byte order, implemented externally (it
 *	actually is optional if data and host are of the same
 *	&quot;endianess&quot;).
 * HASH_MAKE_STRING
 *	macro convering context variables to an ASCII hash string.
 *
 * Optional macros:
 *
 * B_ENDIAN or L_ENDIAN
 *	defines host byte-order.
 * HASH_LONG_LOG2
 *	defaults to 2 if not states otherwise.
 * HASH_LBLOCK
 *	assumed to be HASH_CBLOCK/4 if not stated otherwise.
 * HASH_BLOCK_DATA_ORDER_ALIGNED
 *	alternative &quot;block&quot; function capable of treating
 *	aligned input message in original (data) order,
 *	implemented externally.
 *
 * MD5 example:
 *
 *	#define DATA_ORDER_IS_LITTLE_ENDIAN
 *
 *	#define HASH_LONG		mDNSu32
 *	#define HASH_LONG_LOG2	mDNSu32_LOG2
 *	#define HASH_CTX		MD5_CTX
 *	#define HASH_CBLOCK		MD5_CBLOCK
 *	#define HASH_LBLOCK		MD5_LBLOCK
 *	#define HASH_UPDATE		MD5_Update
 *	#define HASH_TRANSFORM		MD5_Transform
 *	#define HASH_FINAL		MD5_Final
 *	#define HASH_BLOCK_HOST_ORDER	md5_block_host_order
 *	#define HASH_BLOCK_DATA_ORDER	md5_block_data_order
 *
 *					&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_BIG_ENDIAN</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>)
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;DATA_ORDER must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_CBLOCK</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_CBLOCK must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_LONG</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_LONG must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_CTX</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_CTX must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_UPDATE</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_UPDATE must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_TRANSFORM</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_TRANSFORM must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_FINAL</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_FINAL must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_BLOCK_HOST_ORDER</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_BLOCK_HOST_ORDER must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * Moved below as it's required only if HASH_BLOCK_DATA_ORDER_ALIGNED
 * isn't defined.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_BLOCK_DATA_ORDER must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_LBLOCK</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_LBLOCK</span> (HASH_CBLOCK/4)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_LONG_LOG2</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_LONG_LOG2</span>  2
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Engage compiler specific rotate intrinsic function if available.
 */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ROTATE</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PEDANTIC</span>
# <span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* defined(_MSC_VER) */</span>
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)   _lrotl(a,n)
# <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__MWERKS__</span>)
#  <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__POWERPC__</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)  (unsigned MD32_REG_T)__rlwinm((int)a,n,0,31)
#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__MC68K__</span>)
<span class="enscript-comment">/* Motorola specific tweak. &lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt; */</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)  (n&lt;24 ? __rol(a,n) : __ror(a,32-n))
#  <span class="enscript-reference">else</span>
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)  __rol(a,n)
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__GNUC__</span>) &amp;&amp; <span class="enscript-variable-name">__GNUC__</span>&gt;=2 &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_NO_ASM</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_NO_INLINE_ASM</span>)
<span class="enscript-comment">/*
 * Some GNU C inline assembler templates. Note that these are
 * rotates by *constant* number of bits! But that's exactly
 * what we need here...
 *
 *                  &lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
<span class="enscript-comment">/*
 * LLVM is more strict about compatibility of types between input &amp; output constraints,
 * but we want these to be rotations of 32 bits, not 64, so we explicitly drop the
 * most significant bytes by casting to an unsigned int.
 */</span>
#  <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)  ({ register unsigned int ret;   \
                           asm (           \
                               <span class="enscript-string">&quot;roll %1,%0&quot;</span>        \
                               : <span class="enscript-string">&quot;=r&quot;</span> (ret)     \
                               : <span class="enscript-string">&quot;I&quot;</span> (n), <span class="enscript-string">&quot;0&quot;</span> ((unsigned int)a)  \
                               : <span class="enscript-string">&quot;cc&quot;</span>);        \
                           ret;             \
                         })
#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__powerpc</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__ppc</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)  ({ register unsigned int ret;   \
                           asm (           \
                               <span class="enscript-string">&quot;rlwinm %0,%1,%2,0,31&quot;</span>  \
                               : <span class="enscript-string">&quot;=r&quot;</span> (ret)     \
                               : <span class="enscript-string">&quot;r&quot;</span> (a), <span class="enscript-string">&quot;I&quot;</span> (n));  \
                           ret;             \
                         })
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Engage compiler specific &quot;fetch in reverse byte order&quot;
 * intrinsic function if available.
 */</span>
# <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__GNUC__</span>) &amp;&amp; <span class="enscript-variable-name">__GNUC__</span>&gt;=2 &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_NO_ASM</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_NO_INLINE_ASM</span>)
<span class="enscript-comment">/* some GNU C inline assembler templates by &lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt; */</span>
#  <span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">I386_ONLY</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">BE_FETCH32</span>(a)    ({ register unsigned int l=(a); \
                               asm (           \
                                   <span class="enscript-string">&quot;bswapl %0&quot;</span>     \
                                   : <span class="enscript-string">&quot;=r&quot;</span> (l) : <span class="enscript-string">&quot;0&quot;</span> (l));    \
                               l;                \
                             })
#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__powerpc</span>)
#   <span class="enscript-reference">define</span> <span class="enscript-function-name">LE_FETCH32</span>(a)    ({ register unsigned int l; \
                               asm (           \
                                   <span class="enscript-string">&quot;lwbrx %0,0,%1&quot;</span>     \
                                   : <span class="enscript-string">&quot;=r&quot;</span> (l)       \
                                   : <span class="enscript-string">&quot;r&quot;</span> (a));      \
                               l;               \
                             })

#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__sparc</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">OPENSSL_SYS_ULTRASPARC</span>)
#  <span class="enscript-reference">define</span> <span class="enscript-function-name">LE_FETCH32</span>(a) ({ register unsigned int l;     \
                           asm (               \
                               <span class="enscript-string">&quot;lda [%1]#ASI_PRIMARY_LITTLE,%0&quot;</span> \
                               : <span class="enscript-string">&quot;=r&quot;</span> (l)           \
                               : <span class="enscript-string">&quot;r&quot;</span> (a));          \
                           l;                   \
                         })
#  <span class="enscript-reference">endif</span>
# <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PEDANTIC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HASH_LONG_LOG2</span>==2   <span class="enscript-comment">/* Engage only if sizeof(HASH_LONG)== 4 */</span>
<span class="enscript-comment">/* A nice byte order reversal from Wei Dai &lt;<a href="mailto:weidai@eskimo.com">weidai@eskimo.com</a>&gt; */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ROTATE</span>
<span class="enscript-comment">/* 5 instructions with rotate instruction, else 9 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">REVERSE_FETCH32</span>(a,l)    (                   \
        l=*(const HASH_LONG *)(a),              \
        ((ROTATE(l,8)&amp;0x00FF00FF)|(ROTATE((l&amp;0x00FF00FF),24)))  \
        )
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* 6 instructions with rotate instruction, else 8 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">REVERSE_FETCH32</span>(a,l)    (               \
        l=*(const HASH_LONG *)(a),          \
        l=(((l&gt;&gt;8)&amp;0x00FF00FF)|((l&amp;0x00FF00FF)&lt;&lt;8)),    \
        ROTATE(l,16)                    \
        )
<span class="enscript-comment">/*
 * Originally the middle line started with l=(((l&amp;0xFF00FF00)&gt;&gt;8)|...
 * It's rewritten as above for two reasons:
 *	- RISCs aren't good at long constants and have to explicitely
 *	  compose 'em with several (well, usually 2) instructions in a
 *	  register before performing the actual operation and (as you
 *	  already realized:-) having same constant should inspire the
 *	  compiler to permanently allocate the only register for it;
 *	- most modern CPUs have two ALUs, but usually only one has
 *	  circuitry for shifts:-( this minor tweak inspires compiler
 *	  to schedule shift instructions in a better way...
 *
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ROTATE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ROTATE</span>(a,n)     (((a)&lt;&lt;(n))|(((a)&amp;0xffffffff)&gt;&gt;(32-(n))))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Make some obvious choices. E.g., HASH_BLOCK_DATA_ORDER_ALIGNED
 * and HASH_BLOCK_HOST_ORDER ought to be the same if input data
 * and host are of the same &quot;endianess&quot;. It's possible to mask
 * this with blank #define HASH_BLOCK_DATA_ORDER though...
 *
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">B_ENDIAN</span>)
#  <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_BIG_ENDIAN</span>)
#    <span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span>) &amp;&amp; <span class="enscript-variable-name">HASH_LONG_LOG2</span>==2
#      <span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span> HASH_BLOCK_HOST_ORDER
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>)
#    <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HOST_FETCH32</span>
#      <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LE_FETCH32</span>
#        <span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_FETCH32</span>(p,l)   LE_FETCH32(p)
#      <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">REVERSE_FETCH32</span>)
#        <span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_FETCH32</span>(p,l)   REVERSE_FETCH32(p,l)
#      <span class="enscript-reference">endif</span>
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">L_ENDIAN</span>)
#  <span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>)
#    <span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span>) &amp;&amp; <span class="enscript-variable-name">HASH_LONG_LOG2</span>==2
#      <span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span> HASH_BLOCK_HOST_ORDER
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_BIG_ENDIAN</span>)
#    <span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HOST_FETCH32</span>
#      <span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BE_FETCH32</span>
#        <span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_FETCH32</span>(p,l)   BE_FETCH32(p)
#      <span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">REVERSE_FETCH32</span>)
#        <span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_FETCH32</span>(p,l)   REVERSE_FETCH32(p,l)
#      <span class="enscript-reference">endif</span>
#    <span class="enscript-reference">endif</span>
#  <span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span>)
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_BLOCK_DATA_ORDER must be defined!&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// None of the invocations of the following macros actually use the result,
</span><span class="enscript-comment">// so cast them to void to avoid any compiler warnings/errors about not using
</span><span class="enscript-comment">// the result (e.g. when using clang).
</span><span class="enscript-comment">// If the resultant values need to be used at some point, these must be changed.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_c2l</span>(c,l) ((void)_HOST_c2l(c,l))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_l2c</span>(l,c) ((void)_HOST_l2c(l,c))

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_BIG_ENDIAN</span>)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_HOST_c2l</span>(c,l)  (l =(((unsigned long)(*((c)++)))&lt;&lt;24),      \
                         l|=(((unsigned long)(*((c)++)))&lt;&lt;16),      \
                         l|=(((unsigned long)(*((c)++)))&lt;&lt; 8),      \
                         l|=(((unsigned long)(*((c)++)))    ),      \
                         l)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_p_c2l</span>(c,l,n)   {                       \
        switch (n) {                                \
        case 0: l =((unsigned long)(*((c)++)))&lt;&lt;24; \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \
            fallthrough();                          \
        case 3: l|=((unsigned long)(*((c)++)));     \
        } }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_p_c2l_p</span>(c,l,sc,len) {                  \
        switch (sc) {                               \
        case 0: l =((unsigned long)(*((c)++)))&lt;&lt;24; \
            if (--len == 0) break;                  \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \
            if (--len == 0) break;                  \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \
        } }
<span class="enscript-comment">/* NOTE the pointer is not incremented at the end of this */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_c2l_p</span>(c,l,n)   {                       \
        l=0; (c)+=n;                                \
        switch (n) {                                \
        case 3: l =((unsigned long)(*(--(c))))&lt;&lt; 8; \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*(--(c))))&lt;&lt;16; \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*(--(c))))&lt;&lt;24; \
        } }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_HOST_l2c</span>(l,c)  (*((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)    )&amp;0xff),  \
                         l)

#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_HOST_c2l</span>(c,l)  (l =(((unsigned long)(*((c)++)))    ),      \
                         l|=(((unsigned long)(*((c)++)))&lt;&lt; 8),      \
                         l|=(((unsigned long)(*((c)++)))&lt;&lt;16),      \
                         l|=(((unsigned long)(*((c)++)))&lt;&lt;24),      \
                         l)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_p_c2l</span>(c,l,n)   {                       \
        switch (n) {                                \
        case 0: l =((unsigned long)(*((c)++)));     \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \
            fallthrough();                          \
        case 3: l|=((unsigned long)(*((c)++)))&lt;&lt;24; \
        } }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_p_c2l_p</span>(c,l,sc,len) {                  \
        switch (sc) {                               \
        case 0: l =((unsigned long)(*((c)++)));     \
            if (--len == 0) break;                  \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*((c)++)))&lt;&lt; 8; \
            if (--len == 0) break;                  \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*((c)++)))&lt;&lt;16; \
        } }
<span class="enscript-comment">/* NOTE the pointer is not incremented at the end of this */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HOST_c2l_p</span>(c,l,n)   {                       \
        l=0; (c)+=n;                                \
        switch (n) {                                \
        case 3: l =((unsigned long)(*(--(c))))&lt;&lt;16; \
            fallthrough();                          \
        case 2: l|=((unsigned long)(*(--(c))))&lt;&lt; 8; \
            fallthrough();                          \
        case 1: l|=((unsigned long)(*(--(c))));     \
        } }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_HOST_l2c</span>(l,c)  (*((c)++)=(unsigned char)(((l)    )&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff),  \
                         *((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff),  \
                         l)

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Time for some action:-)
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">HASH_UPDATE</span> (HASH_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data_, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> len)
{
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *data=(<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)data_;
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> data_end=(<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)data_;
    <span class="enscript-type">register</span> HASH_LONG * p;
    <span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> l;
    <span class="enscript-type">int</span> sw,sc,ew,ec;

    <span class="enscript-keyword">if</span> (len==0) <span class="enscript-keyword">return</span> 1;

    l=(c-&gt;Nl+(len&lt;&lt;3))&amp;0xffffffffL;
    <span class="enscript-comment">/* 95-05-24 eay Fixed a bug with the overflow handling, thanks to
     * Wei Dai &lt;<a href="mailto:weidai@eskimo.com">weidai@eskimo.com</a>&gt; for pointing it out. */</span>
    <span class="enscript-keyword">if</span> (l &lt; c-&gt;Nl) <span class="enscript-comment">/* overflow */</span>
        c-&gt;Nh++;
    c-&gt;Nh+=(len&gt;&gt;29);
    c-&gt;Nl=l;

    <span class="enscript-keyword">if</span> (c-&gt;num != 0)
    {
        p=c-&gt;data;
        sw=c-&gt;num&gt;&gt;2;
        sc=c-&gt;num&amp;0x03;

        <span class="enscript-keyword">if</span> ((c-&gt;num+len) &gt;= HASH_CBLOCK)
        {
            l=p[sw]; HOST_p_c2l(data,l,sc); p[sw++]=l;
            <span class="enscript-keyword">for</span> (; (sw &lt; HASH_LBLOCK) &amp;&amp; ((data_end - data) &gt;= 4); sw++)
            {
                HOST_c2l(data,l); p[sw]=l;
            }
            HASH_BLOCK_HOST_ORDER (c,p,1);
            len-=(HASH_CBLOCK-c-&gt;num);
            c-&gt;num=0;
            <span class="enscript-comment">/* drop through and do the rest */</span>
        }
        <span class="enscript-keyword">else</span>
        {
            c-&gt;num+=len;
            <span class="enscript-keyword">if</span> ((sc+len) &lt; 4) <span class="enscript-comment">/* ugly, add char's to a word */</span>
            {
                l=p[sw]; HOST_p_c2l_p(data,l,sc,len); p[sw]=l;
            }
            <span class="enscript-keyword">else</span>
            {
                ew=(c-&gt;num&gt;&gt;2);
                ec=(c-&gt;num&amp;0x03);
                <span class="enscript-keyword">if</span> (sc)
                    l=p[sw];
                HOST_p_c2l(data,l,sc);
                p[sw++]=l;
                <span class="enscript-keyword">for</span> (; (sw &lt; ew) &amp;&amp; ((data_end - data) &gt;= 4); sw++)
                {
                    HOST_c2l(data,l); p[sw]=l;
                }
                <span class="enscript-keyword">if</span> (ec)
                {
                    HOST_c2l_p(data,l,ec); p[sw]=l;
                }
            }
            <span class="enscript-keyword">return</span> 1;
        }
    }

    sw=(<span class="enscript-type">int</span>)(len/HASH_CBLOCK);
    <span class="enscript-keyword">if</span> (sw &gt; 0)
    {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span>)
        <span class="enscript-comment">/*
         * Note that HASH_BLOCK_DATA_ORDER_ALIGNED gets defined
         * only if sizeof(HASH_LONG)==4.
         */</span>
        <span class="enscript-keyword">if</span> ((((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)data)%4) == 0)
        {
            <span class="enscript-comment">/* data is properly aligned so that we can cast it: */</span>
            HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,sw);
            sw*=HASH_CBLOCK;
            data+=sw;
            len-=sw;
        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>)
            <span class="enscript-keyword">while</span> (sw--)
            {
                mDNSPlatformMemCopy(p=c-&gt;data,data,HASH_CBLOCK);
                HASH_BLOCK_DATA_ORDER_ALIGNED(c,p,1);
                data+=HASH_CBLOCK;
                len-=HASH_CBLOCK;
            }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>)
        {
            HASH_BLOCK_DATA_ORDER(c,data,sw);
            sw*=HASH_CBLOCK;
            data+=sw;
            len-=sw;
        }
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">if</span> (len!=0)
    {
        p = c-&gt;data;
        c-&gt;num = (<span class="enscript-type">int</span>)len;
        ew=(<span class="enscript-type">int</span>)(len&gt;&gt;2);   <span class="enscript-comment">/* words to copy */</span>
        ec=(<span class="enscript-type">int</span>)(len&amp;0x03);
        <span class="enscript-keyword">for</span> (; ew &amp;&amp; ((data_end - data) &gt;= 4); ew--,p++)
        {
            HOST_c2l(data,l); *p=l;
        }
        HOST_c2l_p(data,l,ec);
        *p=l;
    }
    <span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">void</span> <span class="enscript-function-name">HASH_TRANSFORM</span> (HASH_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *data)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER_ALIGNED</span>)
    <span class="enscript-keyword">if</span> ((((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)data)%4) == 0)
        <span class="enscript-comment">/* data is properly aligned so that we can cast it: */</span>
        HASH_BLOCK_DATA_ORDER_ALIGNED (c,(HASH_LONG *)data,1);
    <span class="enscript-keyword">else</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>)
    {
        mDNSPlatformMemCopy(c-&gt;data,data,HASH_CBLOCK);
        HASH_BLOCK_DATA_ORDER_ALIGNED (c,c-&gt;data,1);
    }
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">HASH_BLOCK_DATA_ORDER</span>)
    HASH_BLOCK_DATA_ORDER (c,data,1);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-type">int</span> <span class="enscript-function-name">HASH_FINAL</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *md, HASH_CTX *c)
{
    <span class="enscript-type">register</span> HASH_LONG *p;
    <span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> l;
    <span class="enscript-type">register</span> <span class="enscript-type">int</span> i,j;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> end[4]={0x80,0x00,0x00,0x00};
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *cp=end;

    <span class="enscript-comment">/* c-&gt;num should definitly have room for at least one more byte. */</span>
    p=c-&gt;data;
    i=c-&gt;num&gt;&gt;2;
    j=c-&gt;num&amp;0x03;

#<span class="enscript-reference">if</span> 0
    <span class="enscript-comment">/* purify often complains about the following line as an
     * Uninitialized Memory Read.  While this can be true, the
     * following p_c2l macro will reset l when that case is true.
     * This is because j&amp;0x03 contains the number of 'valid' bytes
     * already in p[i].  If and only if j&amp;0x03 == 0, the UMR will
     * occur but this is also the only time p_c2l will do
     * l= *(cp++) instead of l|= *(cp++)
     * Many thanks to Alex Tang &lt;<a href="mailto:altitude@cic.net">altitude@cic.net</a>&gt; for pickup this
     * 'potential bug' */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PURIFY</span>
    <span class="enscript-keyword">if</span> (j==0) p[i]=0; <span class="enscript-comment">/* Yeah, but that's not the way to fix it:-) */</span>
#<span class="enscript-reference">endif</span>
    l=p[i];
#<span class="enscript-reference">else</span>
    l = (j==0) ? 0 : p[i];
#<span class="enscript-reference">endif</span>
    HOST_p_c2l(cp,l,j); p[i++]=l; <span class="enscript-comment">/* i is the next 'undefined word' */</span>

    <span class="enscript-keyword">if</span> (i&gt;(HASH_LBLOCK-2)) <span class="enscript-comment">/* save room for Nl and Nh */</span>
    {
        <span class="enscript-keyword">if</span> (i&lt;HASH_LBLOCK) p[i]=0;
        HASH_BLOCK_HOST_ORDER (c,p,1);
        i=0;
    }
    <span class="enscript-keyword">for</span> (; i&lt;(HASH_LBLOCK-2); i++)
        p[i]=0;

#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_BIG_ENDIAN</span>)
    p[HASH_LBLOCK-2]=c-&gt;Nh;
    p[HASH_LBLOCK-1]=c-&gt;Nl;
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DATA_ORDER_IS_LITTLE_ENDIAN</span>)
    p[HASH_LBLOCK-2]=c-&gt;Nl;
    p[HASH_LBLOCK-1]=c-&gt;Nh;
#<span class="enscript-reference">endif</span>
    HASH_BLOCK_HOST_ORDER (c,p,1);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HASH_MAKE_STRING</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;HASH_MAKE_STRING must be defined!&quot;</span>
#<span class="enscript-reference">else</span>
    HASH_MAKE_STRING(c,md);
#<span class="enscript-reference">endif</span>

    c-&gt;num=0;
    <span class="enscript-comment">/* clear stuff, HASH_BLOCK may be leaving some stuff on the stack
     * but I'm not worried :-)
       OPENSSL_cleanse((void *)c,sizeof(HASH_CTX));
     */</span>
    <span class="enscript-keyword">return</span> 1;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MD32_REG_T</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD32_REG_T</span> long
<span class="enscript-comment">/*
 * This comment was originaly written for MD5, which is why it
 * discusses A-D. But it basically applies to all 32-bit digests,
 * which is why it was moved to common header file.
 *
 * In case you wonder why A-D are declared as long and not
 * as mDNSu32. Doing so results in slight performance
 * boost on LP64 architectures. The catch is we don't
 * really care if 32 MSBs of a 64-bit register get polluted
 * with eventual overflows as we *save* only 32 LSBs in
 * *either* case. Now declaring 'em long excuses the compiler
 * from keeping 32 MSBs zeroed resulting in 13% performance
 * improvement under SPARC Solaris7/64 and 5% under AlphaLinux.
 * Well, to be honest it should say that this *prevents*
 * performance degradation.
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 * Apparently there're LP64 compilers that generate better
 * code if A-D are declared int. Most notably GCC-x86_64
 * generates better code.
 *				&lt;<a href="mailto:appro@fy.chalmers.se">appro@fy.chalmers.se</a>&gt;
 */</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// from md5_locl.h (continued)
</span>
<span class="enscript-comment">/*
 #define	F(x,y,z)	(((x) &amp; (y))  |  ((~(x)) &amp; (z)))
 #define	G(x,y,z)	(((x) &amp; (z))  |  ((y) &amp; (~(z))))
 */</span>

<span class="enscript-comment">/* As pointed out by Wei Dai &lt;<a href="mailto:weidai@eskimo.com">weidai@eskimo.com</a>&gt;, the above can be
 * simplified to the code below.  Wei attributes these optimizations
 * to Peter Gutmann's SHS code, and he attributes it to Rich Schroeppel.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">F</span>(b,c,d)    ((((c) ^ (d)) &amp; (b)) ^ (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">G</span>(b,c,d)    ((((b) ^ (c)) &amp; (d)) ^ (c))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">H</span>(b,c,d)    ((b) ^ (c) ^ (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">I</span>(b,c,d)    (((~(d)) | (b)) ^ (c))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">R0</span>(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+F((b),(c),(d))); \
        a=ROTATE(a,s); \
        a+=b; }; \

#<span class="enscript-reference">define</span> <span class="enscript-function-name">R1</span>(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+G((b),(c),(d))); \
        a=ROTATE(a,s); \
        a+=b; };

#<span class="enscript-reference">define</span> <span class="enscript-function-name">R2</span>(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+H((b),(c),(d))); \
        a=ROTATE(a,s); \
        a+=b; };

#<span class="enscript-reference">define</span> <span class="enscript-function-name">R3</span>(a,b,c,d,k,s,t) { \
        a+=((k)+(t)+I((b),(c),(d))); \
        a=ROTATE(a,s); \
        a+=b; };

<span class="enscript-comment">// from md5_dgst.c
</span>

<span class="enscript-comment">/* Implemented from RFC1321 The MD5 Message-Digest Algorithm
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INIT_DATA_A</span> (unsigned long)0x67452301L
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INIT_DATA_B</span> (unsigned long)0xefcdab89L
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INIT_DATA_C</span> (unsigned long)0x98badcfeL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INIT_DATA_D</span> (unsigned long)0x10325476L

<span class="enscript-type">int</span> <span class="enscript-function-name">MD5_Init</span>(MD5_CTX *c)
{
    c-&gt;A=INIT_DATA_A;
    c-&gt;B=INIT_DATA_B;
    c-&gt;C=INIT_DATA_C;
    c-&gt;D=INIT_DATA_D;
    c-&gt;Nl=0;
    c-&gt;Nh=0;
    c-&gt;num=0;
    <span class="enscript-keyword">return</span> 1;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">md5_block_host_order</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">md5_block_host_order</span> (MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> num)
{
    <span class="enscript-type">const</span> mDNSu32 *X=(<span class="enscript-type">const</span> mDNSu32 *)data;
    <span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> MD32_REG_T A,B,C,D;

    A=c-&gt;A;
    B=c-&gt;B;
    C=c-&gt;C;
    D=c-&gt;D;

    <span class="enscript-keyword">for</span> (; num--; X+=HASH_LBLOCK)
    {
        <span class="enscript-comment">/* Round 0 */</span>
        R0(A,B,C,D,X[ 0], 7,0xd76aa478L);
        R0(D,A,B,C,X[ 1],12,0xe8c7b756L);
        R0(C,D,A,B,X[ 2],17,0x242070dbL);
        R0(B,C,D,A,X[ 3],22,0xc1bdceeeL);
        R0(A,B,C,D,X[ 4], 7,0xf57c0fafL);
        R0(D,A,B,C,X[ 5],12,0x4787c62aL);
        R0(C,D,A,B,X[ 6],17,0xa8304613L);
        R0(B,C,D,A,X[ 7],22,0xfd469501L);
        R0(A,B,C,D,X[ 8], 7,0x698098d8L);
        R0(D,A,B,C,X[ 9],12,0x8b44f7afL);
        R0(C,D,A,B,X[10],17,0xffff5bb1L);
        R0(B,C,D,A,X[11],22,0x895cd7beL);
        R0(A,B,C,D,X[12], 7,0x6b901122L);
        R0(D,A,B,C,X[13],12,0xfd987193L);
        R0(C,D,A,B,X[14],17,0xa679438eL);
        R0(B,C,D,A,X[15],22,0x49b40821L);
        <span class="enscript-comment">/* Round 1 */</span>
        R1(A,B,C,D,X[ 1], 5,0xf61e2562L);
        R1(D,A,B,C,X[ 6], 9,0xc040b340L);
        R1(C,D,A,B,X[11],14,0x265e5a51L);
        R1(B,C,D,A,X[ 0],20,0xe9b6c7aaL);
        R1(A,B,C,D,X[ 5], 5,0xd62f105dL);
        R1(D,A,B,C,X[10], 9,0x02441453L);
        R1(C,D,A,B,X[15],14,0xd8a1e681L);
        R1(B,C,D,A,X[ 4],20,0xe7d3fbc8L);
        R1(A,B,C,D,X[ 9], 5,0x21e1cde6L);
        R1(D,A,B,C,X[14], 9,0xc33707d6L);
        R1(C,D,A,B,X[ 3],14,0xf4d50d87L);
        R1(B,C,D,A,X[ 8],20,0x455a14edL);
        R1(A,B,C,D,X[13], 5,0xa9e3e905L);
        R1(D,A,B,C,X[ 2], 9,0xfcefa3f8L);
        R1(C,D,A,B,X[ 7],14,0x676f02d9L);
        R1(B,C,D,A,X[12],20,0x8d2a4c8aL);
        <span class="enscript-comment">/* Round 2 */</span>
        R2(A,B,C,D,X[ 5], 4,0xfffa3942L);
        R2(D,A,B,C,X[ 8],11,0x8771f681L);
        R2(C,D,A,B,X[11],16,0x6d9d6122L);
        R2(B,C,D,A,X[14],23,0xfde5380cL);
        R2(A,B,C,D,X[ 1], 4,0xa4beea44L);
        R2(D,A,B,C,X[ 4],11,0x4bdecfa9L);
        R2(C,D,A,B,X[ 7],16,0xf6bb4b60L);
        R2(B,C,D,A,X[10],23,0xbebfbc70L);
        R2(A,B,C,D,X[13], 4,0x289b7ec6L);
        R2(D,A,B,C,X[ 0],11,0xeaa127faL);
        R2(C,D,A,B,X[ 3],16,0xd4ef3085L);
        R2(B,C,D,A,X[ 6],23,0x04881d05L);
        R2(A,B,C,D,X[ 9], 4,0xd9d4d039L);
        R2(D,A,B,C,X[12],11,0xe6db99e5L);
        R2(C,D,A,B,X[15],16,0x1fa27cf8L);
        R2(B,C,D,A,X[ 2],23,0xc4ac5665L);
        <span class="enscript-comment">/* Round 3 */</span>
        R3(A,B,C,D,X[ 0], 6,0xf4292244L);
        R3(D,A,B,C,X[ 7],10,0x432aff97L);
        R3(C,D,A,B,X[14],15,0xab9423a7L);
        R3(B,C,D,A,X[ 5],21,0xfc93a039L);
        R3(A,B,C,D,X[12], 6,0x655b59c3L);
        R3(D,A,B,C,X[ 3],10,0x8f0ccc92L);
        R3(C,D,A,B,X[10],15,0xffeff47dL);
        R3(B,C,D,A,X[ 1],21,0x85845dd1L);
        R3(A,B,C,D,X[ 8], 6,0x6fa87e4fL);
        R3(D,A,B,C,X[15],10,0xfe2ce6e0L);
        R3(C,D,A,B,X[ 6],15,0xa3014314L);
        R3(B,C,D,A,X[13],21,0x4e0811a1L);
        R3(A,B,C,D,X[ 4], 6,0xf7537e82L);
        R3(D,A,B,C,X[11],10,0xbd3af235L);
        R3(C,D,A,B,X[ 2],15,0x2ad7d2bbL);
        R3(B,C,D,A,X[ 9],21,0xeb86d391L);

        A = c-&gt;A += A;
        B = c-&gt;B += B;
        C = c-&gt;C += C;
        D = c-&gt;D += D;
    }
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">md5_block_data_order</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">X</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">X</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">md5_block_data_order</span> (MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data_, <span class="enscript-type">int</span> num)
{
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *data=data_;
    <span class="enscript-type">register</span> <span class="enscript-type">unsigned</span> MD32_REG_T A,B,C,D,l;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MD32_XARRAY</span>
    <span class="enscript-comment">/* See comment in crypto/sha/sha_locl.h for details. */</span>
    <span class="enscript-type">unsigned</span> MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,
                        XX8, XX9,XX10,XX11,XX12,XX13,XX14,XX15;
# <span class="enscript-reference">define</span> <span class="enscript-function-name">X</span>(i)   XX ## i
#<span class="enscript-reference">else</span>
    mDNSu32 XX[MD5_LBLOCK];
# <span class="enscript-reference">define</span> <span class="enscript-function-name">X</span>(i)   XX[i]
#<span class="enscript-reference">endif</span>

    A=c-&gt;A;
    B=c-&gt;B;
    C=c-&gt;C;
    D=c-&gt;D;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang_analyzer__</span>)
    <span class="enscript-comment">// Get rid of false positive analyzer warning.
</span>    <span class="enscript-keyword">for</span> (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *_ptr = data; _ptr &lt; &amp;data[num * HASH_CBLOCK]; ++_ptr) {}
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">for</span> (; num--;)
    {
        HOST_c2l(data,l); X( 0)=l;      HOST_c2l(data,l); X( 1)=l;
        <span class="enscript-comment">/* Round 0 */</span>
        R0(A,B,C,D,X( 0), 7,0xd76aa478L);   HOST_c2l(data,l); X( 2)=l;
        R0(D,A,B,C,X( 1),12,0xe8c7b756L);   HOST_c2l(data,l); X( 3)=l;
        R0(C,D,A,B,X( 2),17,0x242070dbL);   HOST_c2l(data,l); X( 4)=l;
        R0(B,C,D,A,X( 3),22,0xc1bdceeeL);   HOST_c2l(data,l); X( 5)=l;
        R0(A,B,C,D,X( 4), 7,0xf57c0fafL);   HOST_c2l(data,l); X( 6)=l;
        R0(D,A,B,C,X( 5),12,0x4787c62aL);   HOST_c2l(data,l); X( 7)=l;
        R0(C,D,A,B,X( 6),17,0xa8304613L);   HOST_c2l(data,l); X( 8)=l;
        R0(B,C,D,A,X( 7),22,0xfd469501L);   HOST_c2l(data,l); X( 9)=l;
        R0(A,B,C,D,X( 8), 7,0x698098d8L);   HOST_c2l(data,l); X(10)=l;
        R0(D,A,B,C,X( 9),12,0x8b44f7afL);   HOST_c2l(data,l); X(11)=l;
        R0(C,D,A,B,X(10),17,0xffff5bb1L);   HOST_c2l(data,l); X(12)=l;
        R0(B,C,D,A,X(11),22,0x895cd7beL);   HOST_c2l(data,l); X(13)=l;
        R0(A,B,C,D,X(12), 7,0x6b901122L);   HOST_c2l(data,l); X(14)=l;
        R0(D,A,B,C,X(13),12,0xfd987193L);   HOST_c2l(data,l); X(15)=l;
        R0(C,D,A,B,X(14),17,0xa679438eL);
        R0(B,C,D,A,X(15),22,0x49b40821L);
        <span class="enscript-comment">/* Round 1 */</span>
        R1(A,B,C,D,X( 1), 5,0xf61e2562L);
        R1(D,A,B,C,X( 6), 9,0xc040b340L);
        R1(C,D,A,B,X(11),14,0x265e5a51L);
        R1(B,C,D,A,X( 0),20,0xe9b6c7aaL);
        R1(A,B,C,D,X( 5), 5,0xd62f105dL);
        R1(D,A,B,C,X(10), 9,0x02441453L);
        R1(C,D,A,B,X(15),14,0xd8a1e681L);
        R1(B,C,D,A,X( 4),20,0xe7d3fbc8L);
        R1(A,B,C,D,X( 9), 5,0x21e1cde6L);
        R1(D,A,B,C,X(14), 9,0xc33707d6L);
        R1(C,D,A,B,X( 3),14,0xf4d50d87L);
        R1(B,C,D,A,X( 8),20,0x455a14edL);
        R1(A,B,C,D,X(13), 5,0xa9e3e905L);
        R1(D,A,B,C,X( 2), 9,0xfcefa3f8L);
        R1(C,D,A,B,X( 7),14,0x676f02d9L);
        R1(B,C,D,A,X(12),20,0x8d2a4c8aL);
        <span class="enscript-comment">/* Round 2 */</span>
        R2(A,B,C,D,X( 5), 4,0xfffa3942L);
        R2(D,A,B,C,X( 8),11,0x8771f681L);
        R2(C,D,A,B,X(11),16,0x6d9d6122L);
        R2(B,C,D,A,X(14),23,0xfde5380cL);
        R2(A,B,C,D,X( 1), 4,0xa4beea44L);
        R2(D,A,B,C,X( 4),11,0x4bdecfa9L);
        R2(C,D,A,B,X( 7),16,0xf6bb4b60L);
        R2(B,C,D,A,X(10),23,0xbebfbc70L);
        R2(A,B,C,D,X(13), 4,0x289b7ec6L);
        R2(D,A,B,C,X( 0),11,0xeaa127faL);
        R2(C,D,A,B,X( 3),16,0xd4ef3085L);
        R2(B,C,D,A,X( 6),23,0x04881d05L);
        R2(A,B,C,D,X( 9), 4,0xd9d4d039L);
        R2(D,A,B,C,X(12),11,0xe6db99e5L);
        R2(C,D,A,B,X(15),16,0x1fa27cf8L);
        R2(B,C,D,A,X( 2),23,0xc4ac5665L);
        <span class="enscript-comment">/* Round 3 */</span>
        R3(A,B,C,D,X( 0), 6,0xf4292244L);
        R3(D,A,B,C,X( 7),10,0x432aff97L);
        R3(C,D,A,B,X(14),15,0xab9423a7L);
        R3(B,C,D,A,X( 5),21,0xfc93a039L);
        R3(A,B,C,D,X(12), 6,0x655b59c3L);
        R3(D,A,B,C,X( 3),10,0x8f0ccc92L);
        R3(C,D,A,B,X(10),15,0xffeff47dL);
        R3(B,C,D,A,X( 1),21,0x85845dd1L);
        R3(A,B,C,D,X( 8), 6,0x6fa87e4fL);
        R3(D,A,B,C,X(15),10,0xfe2ce6e0L);
        R3(C,D,A,B,X( 6),15,0xa3014314L);
        R3(B,C,D,A,X(13),21,0x4e0811a1L);
        R3(A,B,C,D,X( 4), 6,0xf7537e82L);
        R3(D,A,B,C,X(11),10,0xbd3af235L);
        R3(C,D,A,B,X( 2),15,0x2ad7d2bbL);
        R3(B,C,D,A,X( 9),21,0xeb86d391L);

        A = c-&gt;A += A;
        B = c-&gt;B += B;
        C = c-&gt;C += C;
        D = c-&gt;D += D;
    }
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">base64</span> -&gt; <span class="enscript-variable-name">binary</span> <span class="enscript-variable-name">conversion</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> Base64[] = <span class="enscript-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> Pad64 = <span class="enscript-string">'='</span>;


#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSisspace</span>(x) (x == <span class="enscript-string">'\t'</span> || x == <span class="enscript-string">'\n'</span> || x == <span class="enscript-string">'\v'</span> || x == <span class="enscript-string">'\f'</span> || x == <span class="enscript-string">'\r'</span> || x == <span class="enscript-string">' '</span>)

mDNSlocal <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">mDNSstrchr</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, <span class="enscript-type">int</span> c)
{
    <span class="enscript-keyword">while</span> (1)
    {
        <span class="enscript-keyword">if</span> (c == *s) <span class="enscript-keyword">return</span> s;
        <span class="enscript-keyword">if</span> (!*s) <span class="enscript-keyword">return</span> mDNSNULL;
        s++;
    }
}

<span class="enscript-comment">// skips all whitespace anywhere.
</span><span class="enscript-comment">// converts characters, four at a time, starting at (or after)
</span><span class="enscript-comment">// src from base - 64 numbers into three 8 bit bytes in the target area.
</span><span class="enscript-comment">// it returns the number of data bytes stored at the target, or -1 on error.
</span><span class="enscript-comment">// adapted from BIND sources
</span>
mDNSlocal mDNSs32 <span class="enscript-function-name">DNSDigest_Base64ToBin</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *src, mDNSu8 *target, mDNSu32 targsize)
{
    <span class="enscript-type">int</span> tarindex, state, ch;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *pos;

    state = 0;
    tarindex = 0;

    <span class="enscript-keyword">while</span> ((ch = *src++) != <span class="enscript-string">'\0'</span>) {
        <span class="enscript-keyword">if</span> (mDNSisspace(ch))    <span class="enscript-comment">/* Skip whitespace anywhere. */</span>
            <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (ch == Pad64)
            <span class="enscript-keyword">break</span>;

        pos = mDNSstrchr(Base64, ch);
        <span class="enscript-keyword">if</span> (pos == 0)       <span class="enscript-comment">/* A non-base64 character. */</span>
            <span class="enscript-keyword">return</span> (-1);

        <span class="enscript-keyword">switch</span> (state) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
            <span class="enscript-keyword">if</span> (target) {
                <span class="enscript-keyword">if</span> ((mDNSu32)tarindex &gt;= targsize)
                    <span class="enscript-keyword">return</span> (-1);
                target[tarindex] = (mDNSu8)((pos - Base64) &lt;&lt; 2);
            }
            state = 1;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
            <span class="enscript-keyword">if</span> (target) {
                <span class="enscript-keyword">if</span> ((mDNSu32)tarindex + 1 &gt;= targsize)
                    <span class="enscript-keyword">return</span> (-1);
                target[tarindex]   |=  (pos - Base64) &gt;&gt; 4;
                target[tarindex+1]  = (mDNSu8)(((pos - Base64) &amp; 0x0f) &lt;&lt; 4);
            }
            tarindex++;
            state = 2;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
            <span class="enscript-keyword">if</span> (target) {
                <span class="enscript-keyword">if</span> ((mDNSu32)tarindex + 1 &gt;= targsize)
                    <span class="enscript-keyword">return</span> (-1);
                target[tarindex]   |=  (pos - Base64) &gt;&gt; 2;
                target[tarindex+1]  = (mDNSu8)(((pos - Base64) &amp; 0x03) &lt;&lt; 6);
            }
            tarindex++;
            state = 3;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
            <span class="enscript-keyword">if</span> (target) {
                <span class="enscript-keyword">if</span> ((mDNSu32)tarindex &gt;= targsize)
                    <span class="enscript-keyword">return</span> (-1);
                target[tarindex] |= (pos - Base64);
            }
            tarindex++;
            state = 0;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span> -1;
        }
    }

    <span class="enscript-comment">/*
     * We are done decoding Base-64 chars.  Let's see if we ended
     * on a byte boundary, and/or with erroneous trailing characters.
     */</span>

    <span class="enscript-keyword">if</span> (ch == Pad64) {      <span class="enscript-comment">/* We got a pad char. */</span>
        ch = *src++;        <span class="enscript-comment">/* Skip it, get next. */</span>
        <span class="enscript-keyword">switch</span> (state) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:     <span class="enscript-comment">/* Invalid = in first position */</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:     <span class="enscript-comment">/* Invalid = in second position */</span>
            <span class="enscript-keyword">return</span> (-1);

        <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:     <span class="enscript-comment">/* Valid, means one byte of info */</span>
            <span class="enscript-comment">/* Skip any number of spaces. */</span>
            <span class="enscript-keyword">for</span> ((<span class="enscript-type">void</span>)mDNSNULL; ch != <span class="enscript-string">'\0'</span>; ch = *src++)
                <span class="enscript-keyword">if</span> (!mDNSisspace(ch))
                    <span class="enscript-keyword">break</span>;
            <span class="enscript-comment">/* Make sure there is another trailing = sign. */</span>
            <span class="enscript-keyword">if</span> (ch != Pad64)
                <span class="enscript-keyword">return</span> (-1);
            ch = *src++;        <span class="enscript-comment">/* Skip the = */</span>
        <span class="enscript-comment">/* Fall through to &quot;single trailing =&quot; case. */</span>
        <span class="enscript-comment">/* FALLTHROUGH */</span>

        <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:     <span class="enscript-comment">/* Valid, means two bytes of info */</span>
            <span class="enscript-comment">/*
             * We know this char is an =.  Is there anything but
             * whitespace after it?
             */</span>
            <span class="enscript-keyword">for</span> ((<span class="enscript-type">void</span>)mDNSNULL; ch != <span class="enscript-string">'\0'</span>; ch = *src++)
                <span class="enscript-keyword">if</span> (!mDNSisspace(ch))
                    <span class="enscript-keyword">return</span> (-1);

            <span class="enscript-comment">/*
             * Now make sure for cases 2 and 3 that the &quot;extra&quot;
             * bits that slopped past the last full byte were
             * zeros.  If we don't check them, they become a
             * subliminal channel.
             */</span>
            <span class="enscript-keyword">if</span> (target &amp;&amp; target[tarindex] != 0)
                <span class="enscript-keyword">return</span> (-1);
        }
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/*
         * We ended by seeing the end of the string.  Make sure we
         * have no partial bytes lying around.
         */</span>
        <span class="enscript-keyword">if</span> (state != 0)
            <span class="enscript-keyword">return</span> (-1);
    }

    <span class="enscript-keyword">return</span> (tarindex);
}


<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">API</span> <span class="enscript-variable-name">exported</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">mDNS</span> <span class="enscript-variable-name">Core</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Constants
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_IPAD</span>   0x36
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_OPAD</span>   0x5c
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_LEN</span>     16

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_MD5_AlgName</span> <span class="enscript-string">&quot;\010&quot;</span> <span class="enscript-string">&quot;hmac-md5&quot;</span> <span class="enscript-string">&quot;\007&quot;</span> <span class="enscript-string">&quot;sig-alg&quot;</span> <span class="enscript-string">&quot;\003&quot;</span> <span class="enscript-string">&quot;reg&quot;</span> <span class="enscript-string">&quot;\003&quot;</span> <span class="enscript-string">&quot;int&quot;</span>

<span class="enscript-comment">// Adapted from Appendix, RFC 2104
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSDigest_ConstructHMACKey</span>(DomainAuthInfo *info, <span class="enscript-type">const</span> mDNSu8 *key, mDNSu32 len)
{
    MD5_CTX k;
    mDNSu8 buf[MD5_LEN];
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// If key is longer than HMAC_LEN reset it to MD5(key)
</span>    <span class="enscript-keyword">if</span> (len &gt; HMAC_LEN)
    {
        MD5_Init(&amp;k);
        MD5_Update(&amp;k, key, len);
        MD5_Final(buf, &amp;k);
        key = buf;
        len = MD5_LEN;
    }

    <span class="enscript-comment">// store key in pads
</span>    mDNSPlatformMemZero(info-&gt;keydata_ipad, HMAC_LEN);
    mDNSPlatformMemZero(info-&gt;keydata_opad, HMAC_LEN);
    mDNSPlatformMemCopy(info-&gt;keydata_ipad, key, len);
    mDNSPlatformMemCopy(info-&gt;keydata_opad, key, len);

    <span class="enscript-comment">// XOR key with ipad and opad values
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; HMAC_LEN; i++)
    {
        info-&gt;keydata_ipad[i] ^= HMAC_IPAD;
        info-&gt;keydata_opad[i] ^= HMAC_OPAD;
    }

}

mDNSexport mDNSs32 <span class="enscript-function-name">DNSDigest_ConstructHMACKeyfromBase64</span>(DomainAuthInfo *info, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64key)
{
    mDNSu8 keybuf[1024];
    mDNSs32 keylen = DNSDigest_Base64ToBin(b64key, keybuf, <span class="enscript-keyword">sizeof</span>(keybuf));
    <span class="enscript-keyword">if</span> (keylen &lt; 0) <span class="enscript-keyword">return</span>(keylen);
    DNSDigest_ConstructHMACKey(info, keybuf, (mDNSu32)keylen);
    <span class="enscript-keyword">return</span>(keylen);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DNSDigest_SignMessage</span>(DNSMessage *msg, mDNSu8 **end, DomainAuthInfo *info, mDNSu16 tcode)
{
    AuthRecord tsig;
    mDNSu8  *rdata, *<span class="enscript-type">const</span> countPtr = (mDNSu8 *)&amp;msg-&gt;h.numAdditionals; <span class="enscript-comment">// Get existing numAdditionals value
</span>    mDNSu32 utc32;
    mDNSu8 utc48[6];
    mDNSu8 digest[MD5_LEN];
    mDNSu8 *ptr = *end;
    mDNSu32 len;
    mDNSOpaque16 buf;
    MD5_CTX c;
    mDNSu16 numAdditionals = (mDNSu16)((mDNSu16)countPtr[0] &lt;&lt; 8 | countPtr[1]);

    <span class="enscript-comment">// Init MD5 context, digest inner key pad and message
</span>    MD5_Init(&amp;c);
    MD5_Update(&amp;c, info-&gt;keydata_ipad, HMAC_LEN);
    MD5_Update(&amp;c, (mDNSu8 *)msg, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(*end - (mDNSu8 *)msg));

    <span class="enscript-comment">// Construct TSIG RR, digesting variables as apporpriate
</span>    mDNS_SetupResourceRecord(&amp;tsig, mDNSNULL, 0, kDNSType_TSIG, 0, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);

    <span class="enscript-comment">// key name
</span>    AssignDomainName(&amp;tsig.namestorage, &amp;info-&gt;keyname);
    MD5_Update(&amp;c, info-&gt;keyname.c, DomainNameLength(&amp;info-&gt;keyname));

    <span class="enscript-comment">// class
</span>    tsig.resrec.rrclass = kDNSQClass_ANY;
    buf = mDNSOpaque16fromIntVal(kDNSQClass_ANY);
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));

    <span class="enscript-comment">// ttl
</span>    tsig.resrec.rroriginalttl = 0;
    MD5_Update(&amp;c, (mDNSu8 *)&amp;tsig.resrec.rroriginalttl, <span class="enscript-keyword">sizeof</span>(tsig.resrec.rroriginalttl));

    <span class="enscript-comment">// alg name
</span>    AssignConstStringDomainName(&amp;tsig.resrec.rdata-&gt;u.name, HMAC_MD5_AlgName);
    len = DomainNameLengthLimit((domainname *)HMAC_MD5_AlgName, (mDNSu8 *)HMAC_MD5_AlgName + <span class="enscript-keyword">sizeof</span> HMAC_MD5_AlgName);
    rdata = tsig.resrec.rdata-&gt;u.data + len;
    MD5_Update(&amp;c, (mDNSu8 *)HMAC_MD5_AlgName, len);

    <span class="enscript-comment">// time
</span>    <span class="enscript-comment">// get UTC (universal time), convert to 48-bit unsigned in network byte order
</span>    utc32 = (mDNSu32)mDNSPlatformUTC();
    <span class="enscript-keyword">if</span> (utc32 == (<span class="enscript-type">unsigned</span>)-1) { LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_SignMessage - mDNSPlatformUTC returned bad time -1&quot;</span>); *end = mDNSNULL; }
    utc48[0] = 0;
    utc48[1] = 0;
    utc48[2] = (mDNSu8)((utc32 &gt;&gt; 24) &amp; 0xff);
    utc48[3] = (mDNSu8)((utc32 &gt;&gt; 16) &amp; 0xff);
    utc48[4] = (mDNSu8)((utc32 &gt;&gt;  8) &amp; 0xff);
    utc48[5] = (mDNSu8)( utc32        &amp; 0xff);

    mDNSPlatformMemCopy(rdata, utc48, 6);
    rdata += 6;
    MD5_Update(&amp;c, utc48, 6);

    <span class="enscript-comment">// 300 sec is fudge recommended in RFC 2485
</span>    rdata[0] = (mDNSu8)((300 &gt;&gt; 8)  &amp; 0xff);
    rdata[1] = (mDNSu8)( 300        &amp; 0xff);
    MD5_Update(&amp;c, rdata, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));
    rdata += <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);

    <span class="enscript-comment">// digest error (tcode) and other data len (zero) - we'll add them to the rdata later
</span>    buf.b[0] = (mDNSu8)((tcode &gt;&gt; 8) &amp; 0xff);
    buf.b[1] = (mDNSu8)( tcode       &amp; 0xff);
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));  <span class="enscript-comment">// error
</span>    buf.NotAnInteger = 0;
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));  <span class="enscript-comment">// other data len
</span>
    <span class="enscript-comment">// finish the message &amp; tsig var hash
</span>    MD5_Final(digest, &amp;c);

    <span class="enscript-comment">// perform outer MD5 (outer key pad, inner digest)
</span>    MD5_Init(&amp;c);
    MD5_Update(&amp;c, info-&gt;keydata_opad, HMAC_LEN);
    MD5_Update(&amp;c, digest, MD5_LEN);
    MD5_Final(digest, &amp;c);

    <span class="enscript-comment">// set remaining rdata fields
</span>    rdata[0] = (mDNSu8)((MD5_LEN &gt;&gt; 8)  &amp; 0xff);
    rdata[1] = (mDNSu8)( MD5_LEN        &amp; 0xff);
    rdata += <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);
    mDNSPlatformMemCopy(rdata, digest, MD5_LEN);                          <span class="enscript-comment">// MAC
</span>    rdata += MD5_LEN;
    rdata[0] = msg-&gt;h.id.b[0];                                            <span class="enscript-comment">// original ID
</span>    rdata[1] = msg-&gt;h.id.b[1];
    rdata[2] = (mDNSu8)((tcode &gt;&gt; 8) &amp; 0xff);
    rdata[3] = (mDNSu8)( tcode       &amp; 0xff);
    rdata[4] = 0;                                                         <span class="enscript-comment">// other data len
</span>    rdata[5] = 0;
    rdata += 6;

    tsig.resrec.rdlength = (mDNSu16)(rdata - tsig.resrec.rdata-&gt;u.data);
    *end = PutResourceRecordTTLJumbo(msg, ptr, &amp;numAdditionals, &amp;tsig.resrec, 0);
    <span class="enscript-keyword">if</span> (!*end) { LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_SignMessage - could not put TSIG&quot;</span>); *end = mDNSNULL; <span class="enscript-keyword">return</span>; }

    <span class="enscript-comment">// Write back updated numAdditionals value
</span>    countPtr[0] = (mDNSu8)(numAdditionals &gt;&gt; 8);
    countPtr[1] = (mDNSu8)(numAdditionals &amp;  0xFF);
}

mDNSexport mDNSBool <span class="enscript-function-name">DNSDigest_VerifyMessage</span>(DNSMessage *msg, mDNSu8 *end, LargeCacheRecord * lcr, DomainAuthInfo *info, mDNSu16 * rcode, mDNSu16 * tcode)
{
    mDNSu8          *   ptr = (mDNSu8*) &amp;lcr-&gt;r.resrec.rdata-&gt;u.data;
    mDNSs32 now;
    mDNSs32 then;
    mDNSu8 thisDigest[MD5_LEN];
    mDNSu8 thatDigest[MD5_LEN];
    mDNSOpaque16 buf;
    mDNSu8 utc48[6];
    mDNSs32 delta;
    mDNSu16 fudge;
    domainname      *   algo;
    MD5_CTX c;
    mDNSBool ok = mDNSfalse;

    <span class="enscript-comment">// We only support HMAC-MD5 for now
</span>
    algo = (domainname*) ptr;

    <span class="enscript-keyword">if</span> (!SameDomainName(algo, (domainname *)HMAC_MD5_AlgName))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_VerifyMessage - TSIG algorithm not supported: %##s&quot;</span>, algo-&gt;c);
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadKey;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    ptr += DomainNameLength(algo);

    <span class="enscript-comment">// Check the times
</span>
    now = mDNSPlatformUTC();
    <span class="enscript-keyword">if</span> (now == -1)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_VerifyMessage - mDNSPlatformUTC returned bad time -1&quot;</span>);
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadTime;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// Get the 48 bit time field, skipping over the first word
</span>
    utc48[0] = *ptr++;
    utc48[1] = *ptr++;
    utc48[2] = *ptr++;
    utc48[3] = *ptr++;
    utc48[4] = *ptr++;
    utc48[5] = *ptr++;

    then  = (mDNSs32)NToH32(utc48 + <span class="enscript-keyword">sizeof</span>(mDNSu16));

    fudge = NToH16(ptr);

    ptr += <span class="enscript-keyword">sizeof</span>(mDNSu16);

    delta = (now &gt; then) ? now - then : then - now;

    <span class="enscript-keyword">if</span> (delta &gt; fudge)
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_VerifyMessage - time skew &gt; %d&quot;</span>, fudge);
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadTime;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// MAC size
</span>
    ptr += <span class="enscript-keyword">sizeof</span>(mDNSu16);

    <span class="enscript-comment">// MAC
</span>
    mDNSPlatformMemCopy(thatDigest, ptr, MD5_LEN);

    <span class="enscript-comment">// Init MD5 context, digest inner key pad and message
</span>
    MD5_Init(&amp;c);
    MD5_Update(&amp;c, info-&gt;keydata_ipad, HMAC_LEN);
    MD5_Update(&amp;c, (mDNSu8*) msg, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(end - (mDNSu8*) msg));

    <span class="enscript-comment">// Key name
</span>
    MD5_Update(&amp;c, lcr-&gt;r.resrec.name-&gt;c, DomainNameLength(lcr-&gt;r.resrec.name));

    <span class="enscript-comment">// Class name
</span>
    buf = mDNSOpaque16fromIntVal(lcr-&gt;r.resrec.rrclass);
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));

    <span class="enscript-comment">// TTL
</span>
    MD5_Update(&amp;c, (mDNSu8*) &amp;lcr-&gt;r.resrec.rroriginalttl, <span class="enscript-keyword">sizeof</span>(lcr-&gt;r.resrec.rroriginalttl));

    <span class="enscript-comment">// Algorithm
</span>
    MD5_Update(&amp;c, algo-&gt;c, DomainNameLength(algo));

    <span class="enscript-comment">// Time
</span>
    MD5_Update(&amp;c, utc48, 6);

    <span class="enscript-comment">// Fudge
</span>
    buf = mDNSOpaque16fromIntVal(fudge);
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));

    <span class="enscript-comment">// Digest error and other data len (both zero) - we'll add them to the rdata later
</span>
    buf.NotAnInteger = 0;
    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));  <span class="enscript-comment">// error
</span>    MD5_Update(&amp;c, buf.b, <span class="enscript-keyword">sizeof</span>(mDNSOpaque16));  <span class="enscript-comment">// other data len
</span>
    <span class="enscript-comment">// Finish the message &amp; tsig var hash
</span>
    MD5_Final(thisDigest, &amp;c);

    <span class="enscript-comment">// perform outer MD5 (outer key pad, inner digest)
</span>
    MD5_Init(&amp;c);
    MD5_Update(&amp;c, info-&gt;keydata_opad, HMAC_LEN);
    MD5_Update(&amp;c, thisDigest, MD5_LEN);
    MD5_Final(thisDigest, &amp;c);

    <span class="enscript-keyword">if</span> (!mDNSPlatformMemSame(thisDigest, thatDigest, MD5_LEN))
    {
        LogMsg(<span class="enscript-string">&quot;ERROR: DNSDigest_VerifyMessage - bad signature&quot;</span>);
        *rcode = kDNSFlag1_RC_NotAuth;
        *tcode = TSIG_ErrBadSig;
        ok = mDNSfalse;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// set remaining rdata fields
</span>    ok = mDNStrue;

<span class="enscript-reference">exit</span>:

    <span class="enscript-keyword">return</span> ok;
}


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>