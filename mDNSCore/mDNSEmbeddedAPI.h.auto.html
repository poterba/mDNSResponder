<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mDNSEmbeddedAPI.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mDNSEmbeddedAPI.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="mDNSEmbeddedAPI.h">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

   NOTE:
   If you're building an application that uses DNS Service Discovery
   this is probably NOT the header file you're looking for.
   In most cases you will want to use /usr/include/dns_sd.h instead.

   This header file defines the lowest level raw interface to mDNSCore,
   which is appropriate *only* on tiny embedded systems where everything
   runs in a single address space and memory is extremely constrained.
   All the APIs here are malloc-free, which means that the caller is
   responsible for passing in a pointer to the relevant storage that
   will be used in the execution of that call, and (when called with
   correct parameters) all the calls are guaranteed to succeed. There
   is never a case where a call can suffer intermittent failures because
   the implementation calls malloc() and sometimes malloc() returns NULL
   because memory is so limited that no more is available.
   This is primarily for devices that need to have precisely known fixed
   memory requirements, with absolutely no uncertainty or run-time variation,
   but that certainty comes at a cost of more difficult programming.

   For applications running on general-purpose desktop operating systems
   (Mac OS, Linux, Solaris, Windows, etc.) the API you should use is
   /usr/include/dns_sd.h, which defines the API by which multiple
   independent client processes communicate their DNS Service Discovery
   requests to a single &quot;mdnsd&quot; daemon running in the background.

   Even on platforms that don't run multiple independent processes in
   multiple independent address spaces, you can still use the preferred
   dns_sd.h APIs by linking in &quot;dnssd_clientshim.c&quot;, which implements
   the standard &quot;dns_sd.h&quot; API calls, allocates any required storage
   using malloc(), and then calls through to the low-level malloc-free
   mDNSCore routines defined here. This has the benefit that even though
   you're running on a small embedded system with a single address space,
   you can still use the exact same client C code as you'd use on a
   general-purpose desktop system.

 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__mDNSEmbeddedAPI_h</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__mDNSEmbeddedAPI_h</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">EFI32</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">EFI64</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">EFIX64</span>)
<span class="enscript-comment">// EFI doesn't have stdarg.h unless it's building with GCC.
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;Tiano.h&quot;</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__GNUC__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">va_list</span>         VA_LIST
#<span class="enscript-reference">define</span> <span class="enscript-function-name">va_start</span>(a, b)  VA_START(a, b)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">va_end</span>(a)       VA_END(a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">va_arg</span>(a, b)    VA_ARG(a, b)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>     // stdarg.h is required for for va_list support for the mDNS_vsnprintf declaration
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSFeatures.h&quot;</span>

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// Feature removal compile options &amp; limited resource targets
</span>
<span class="enscript-comment">// The following compile options are responsible for removing certain features from mDNSCore to reduce the
</span><span class="enscript-comment">// memory footprint for use in embedded systems with limited resources.
</span>
<span class="enscript-comment">// UNICAST_DISABLED - disables unicast DNS functionality, including Wide Area Bonjour
</span><span class="enscript-comment">// DNSSEC_DISABLED - disables DNSSEC functionality
</span><span class="enscript-comment">// SPC_DISABLED - disables Bonjour Sleep Proxy client
</span><span class="enscript-comment">// IDLESLEEPCONTROL_DISABLED - disables sleep control for Bonjour Sleep Proxy clients
</span>
<span class="enscript-comment">// In order to disable the above features pass the option to your compiler, e.g. -D UNICAST_DISABLED
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">WEB_CONTENT_FILTER</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;WebFilterDNS/WebFilterDNS.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Additionally, the LIMITED_RESOURCES_TARGET compile option will reduce the maximum DNS message sizes.
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LIMITED_RESOURCES_TARGET</span>
<span class="enscript-comment">// Don't support jumbo frames
</span><span class="enscript-comment">// 40 (IPv6 header) + 8 (UDP header) + 12 (DNS message header) + 1440 (DNS message body) = 1500 total
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AbsoluteMaxDNSMessageData</span>   1440
<span class="enscript-comment">// StandardAuthRDSize is 264 (256+8), which is large enough to hold a maximum-sized SRV record (6 + 256 bytes)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MaximumRDSize</span>               264
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// Function scope indicators
</span>
<span class="enscript-comment">// If you see &quot;mDNSlocal&quot; before a function name in a C file, it means the function is not callable outside this file
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">mDNSlocal</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSlocal</span> static
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">// If you see &quot;mDNSexport&quot; before a symbol in a C file, it means the symbol is exported for use by clients
</span><span class="enscript-comment">// For every &quot;mDNSexport&quot; in a C file, there needs to be a corresponding &quot;extern&quot; declaration in some header file
</span><span class="enscript-comment">// (When a C file #includes a header file, the &quot;extern&quot; declarations tell the compiler:
</span><span class="enscript-comment">// &quot;This symbol exists -- but not necessarily in this C file.&quot;)
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">mDNSexport</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSexport</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Explanation: These local/export markers are a little habit of mine for signaling the programmers' intentions.
</span><span class="enscript-comment">// When &quot;mDNSlocal&quot; is just a synonym for &quot;static&quot;, and &quot;mDNSexport&quot; is a complete no-op, you could be
</span><span class="enscript-comment">// forgiven for asking what purpose they serve. The idea is that if you see &quot;mDNSexport&quot; in front of a
</span><span class="enscript-comment">// function definition it means the programmer intended it to be exported and callable from other files
</span><span class="enscript-comment">// in the project. If you see &quot;mDNSlocal&quot; in front of a function definition it means the programmer
</span><span class="enscript-comment">// intended it to be private to that file. If you see neither in front of a function definition it
</span><span class="enscript-comment">// means the programmer forgot (so you should work out which it is supposed to be, and fix it).
</span><span class="enscript-comment">// Using &quot;mDNSlocal&quot; instead of &quot;static&quot; makes it easier to do a textual searches for one or the other.
</span><span class="enscript-comment">// For example you can do a search for &quot;static&quot; to find if any functions declare any local variables as &quot;static&quot;
</span><span class="enscript-comment">// (generally a bad idea unless it's also &quot;const&quot;, because static storage usually risks being non-thread-safe)
</span><span class="enscript-comment">// without the results being cluttered with hundreds of matches for functions declared static.
</span><span class="enscript-comment">// - Stuart Cheshire
</span>
<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// Structure packing macro
</span>
<span class="enscript-comment">// If we're not using GNUC, it's not fatal.
</span><span class="enscript-comment">// Most compilers naturally pack the on-the-wire structures correctly anyway, so a plain &quot;struct&quot; is usually fine.
</span><span class="enscript-comment">// In the event that structures are not packed correctly, mDNS_Init() will detect this and report an error, so the
</span><span class="enscript-comment">// developer will know what's wrong, and can investigate what needs to be done on that compiler to provide proper packing.
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">packedstruct</span>
 #<span class="enscript-keyword">if</span> ((__GNUC__ &gt; 2) || ((__GNUC__ == 2) &amp;&amp; (__GNUC_MINOR__ &gt;= 9)))
  #define packedstruct <span class="enscript-type">struct</span> __attribute__((__packed__))
  #define packedunion  <span class="enscript-type">union</span>  __attribute__((__packed__))
 #<span class="enscript-keyword">else</span>
  #define packedstruct <span class="enscript-type">struct</span>
  #define packedunion  <span class="enscript-type">union</span>
 #endif
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">fallthrough</span>
 #<span class="enscript-keyword">if</span> __clang__
  #<span class="enscript-keyword">if</span> __has_c_attribute(fallthrough)
   #define fallthrough() [[fallthrough]]
  #<span class="enscript-keyword">else</span>
   #define fallthrough()
  #endif
 #elif __GNUC__
  #define fallthrough() __attribute__((fallthrough))
 #<span class="enscript-keyword">else</span>
  #define fallthrough()
 #endif <span class="enscript-comment">// __GNUC__
</span>#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">fallthrough</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">Resource</span> <span class="enscript-variable-name">Record</span> <span class="enscript-variable-name">class</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">type</span> <span class="enscript-variable-name">constants</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>                            <span class="enscript-comment">// From RFC 1035
</span>{
    kDNSClass_IN               = 1,     <span class="enscript-comment">// Internet
</span>    kDNSClass_CS               = 2,     <span class="enscript-comment">// CSNET
</span>    kDNSClass_CH               = 3,     <span class="enscript-comment">// CHAOS
</span>    kDNSClass_HS               = 4,     <span class="enscript-comment">// Hesiod
</span>    kDNSClass_NONE             = 254,   <span class="enscript-comment">// Used in DNS UPDATE [RFC 2136]
</span>
    kDNSClass_Mask             = 0x7FFF, <span class="enscript-comment">// Multicast DNS uses the bottom 15 bits to identify the record class...
</span>    kDNSClass_UniqueRRSet      = 0x8000, <span class="enscript-comment">// ... and the top bit indicates that all other cached records are now invalid
</span>
    kDNSQClass_ANY             = 255,   <span class="enscript-comment">// Not a DNS class, but a DNS query class, meaning &quot;all classes&quot;
</span>    kDNSQClass_UnicastResponse = 0x8000 <span class="enscript-comment">// Top bit set in a question means &quot;unicast response acceptable&quot;
</span>} DNS_ClassValues;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>                <span class="enscript-comment">// From RFC 1035
</span>{
    kDNSType_A = 1,         <span class="enscript-comment">//  1 Address
</span>    kDNSType_NS,            <span class="enscript-comment">//  2 Name Server
</span>    kDNSType_MD,            <span class="enscript-comment">//  3 Mail Destination
</span>    kDNSType_MF,            <span class="enscript-comment">//  4 Mail Forwarder
</span>    kDNSType_CNAME,         <span class="enscript-comment">//  5 Canonical Name
</span>    kDNSType_SOA,           <span class="enscript-comment">//  6 Start of Authority
</span>    kDNSType_MB,            <span class="enscript-comment">//  7 Mailbox
</span>    kDNSType_MG,            <span class="enscript-comment">//  8 Mail Group
</span>    kDNSType_MR,            <span class="enscript-comment">//  9 Mail Rename
</span>    kDNSType_NULL,          <span class="enscript-comment">// 10 NULL RR
</span>    kDNSType_WKS,           <span class="enscript-comment">// 11 Well-known-service
</span>    kDNSType_PTR,           <span class="enscript-comment">// 12 Domain name pointer
</span>    kDNSType_HINFO,         <span class="enscript-comment">// 13 Host information
</span>    kDNSType_MINFO,         <span class="enscript-comment">// 14 Mailbox information
</span>    kDNSType_MX,            <span class="enscript-comment">// 15 Mail Exchanger
</span>    kDNSType_TXT,           <span class="enscript-comment">// 16 Arbitrary text string
</span>    kDNSType_RP,            <span class="enscript-comment">// 17 Responsible person
</span>    kDNSType_AFSDB,         <span class="enscript-comment">// 18 AFS cell database
</span>    kDNSType_X25,           <span class="enscript-comment">// 19 X_25 calling address
</span>    kDNSType_ISDN,          <span class="enscript-comment">// 20 ISDN calling address
</span>    kDNSType_RT,            <span class="enscript-comment">// 21 Router
</span>    kDNSType_NSAP,          <span class="enscript-comment">// 22 NSAP address
</span>    kDNSType_NSAP_PTR,      <span class="enscript-comment">// 23 Reverse NSAP lookup (deprecated)
</span>    kDNSType_SIG,           <span class="enscript-comment">// 24 Security signature
</span>    kDNSType_KEY,           <span class="enscript-comment">// 25 Security key
</span>    kDNSType_PX,            <span class="enscript-comment">// 26 X.400 mail mapping
</span>    kDNSType_GPOS,          <span class="enscript-comment">// 27 Geographical position (withdrawn)
</span>    kDNSType_AAAA,          <span class="enscript-comment">// 28 IPv6 Address
</span>    kDNSType_LOC,           <span class="enscript-comment">// 29 Location Information
</span>    kDNSType_NXT,           <span class="enscript-comment">// 30 Next domain (security)
</span>    kDNSType_EID,           <span class="enscript-comment">// 31 Endpoint identifier
</span>    kDNSType_NIMLOC,        <span class="enscript-comment">// 32 Nimrod Locator
</span>    kDNSType_SRV,           <span class="enscript-comment">// 33 Service record
</span>    kDNSType_ATMA,          <span class="enscript-comment">// 34 ATM Address
</span>    kDNSType_NAPTR,         <span class="enscript-comment">// 35 Naming Authority PoinTeR
</span>    kDNSType_KX,            <span class="enscript-comment">// 36 Key Exchange
</span>    kDNSType_CERT,          <span class="enscript-comment">// 37 Certification record
</span>    kDNSType_A6,            <span class="enscript-comment">// 38 IPv6 Address (deprecated)
</span>    kDNSType_DNAME,         <span class="enscript-comment">// 39 Non-terminal DNAME (for IPv6)
</span>    kDNSType_SINK,          <span class="enscript-comment">// 40 Kitchen sink (experimental)
</span>    kDNSType_OPT,           <span class="enscript-comment">// 41 EDNS0 option (meta-RR)
</span>    kDNSType_APL,           <span class="enscript-comment">// 42 Address Prefix List
</span>    kDNSType_DS,            <span class="enscript-comment">// 43 Delegation Signer
</span>    kDNSType_SSHFP,         <span class="enscript-comment">// 44 SSH Key Fingerprint
</span>    kDNSType_IPSECKEY,      <span class="enscript-comment">// 45 IPSECKEY
</span>    kDNSType_RRSIG,         <span class="enscript-comment">// 46 RRSIG
</span>    kDNSType_NSEC,          <span class="enscript-comment">// 47 Denial of Existence
</span>    kDNSType_DNSKEY,        <span class="enscript-comment">// 48 DNSKEY
</span>    kDNSType_DHCID,         <span class="enscript-comment">// 49 DHCP Client Identifier
</span>    kDNSType_NSEC3,         <span class="enscript-comment">// 50 Hashed Authenticated Denial of Existence
</span>    kDNSType_NSEC3PARAM,    <span class="enscript-comment">// 51 Hashed Authenticated Denial of Existence
</span>
    kDNSType_HIP = 55,      <span class="enscript-comment">// 55 Host Identity Protocol
</span>
    kDNSType_SPF = 99,      <span class="enscript-comment">// 99 Sender Policy Framework for E-Mail
</span>    kDNSType_UINFO,         <span class="enscript-comment">// 100 IANA-Reserved
</span>    kDNSType_UID,           <span class="enscript-comment">// 101 IANA-Reserved
</span>    kDNSType_GID,           <span class="enscript-comment">// 102 IANA-Reserved
</span>    kDNSType_UNSPEC,        <span class="enscript-comment">// 103 IANA-Reserved
</span>
    kDNSType_TKEY = 249,    <span class="enscript-comment">// 249 Transaction key
</span>    kDNSType_TSIG,          <span class="enscript-comment">// 250 Transaction signature
</span>    kDNSType_IXFR,          <span class="enscript-comment">// 251 Incremental zone transfer
</span>    kDNSType_AXFR,          <span class="enscript-comment">// 252 Transfer zone of authority
</span>    kDNSType_MAILB,         <span class="enscript-comment">// 253 Transfer mailbox records
</span>    kDNSType_MAILA,         <span class="enscript-comment">// 254 Transfer mail agent records
</span>    kDNSQType_ANY           <span class="enscript-comment">// Not a DNS type, but a DNS query type, meaning &quot;all types&quot;
</span>} DNS_TypeValues;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Simple</span> <span class="enscript-variable-name">types</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// mDNS defines its own names for these common types to simplify portability across
</span><span class="enscript-comment">// multiple platforms that may each have their own (different) names for these types.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> mDNSBool;
<span class="enscript-type">typedef</span>   <span class="enscript-type">signed</span> <span class="enscript-type">char</span> mDNSs8;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> mDNSu8;
<span class="enscript-type">typedef</span>   <span class="enscript-type">signed</span> <span class="enscript-type">short</span> mDNSs16;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> mDNSu16;

<span class="enscript-comment">// Source: <a href="http://www.unix.org/version2/whatsnew/lp64_wp.html">http://www.unix.org/version2/whatsnew/lp64_wp.html</a>
</span><span class="enscript-comment">// <a href="http://software.intel.com/sites/products/documentation/hpc/mkl/lin/MKL_UG_structure/Support_for_ILP64_Programming.htm">http://software.intel.com/sites/products/documentation/hpc/mkl/lin/MKL_UG_structure/Support_for_ILP64_Programming.htm</a>
</span><span class="enscript-comment">// It can be safely assumed that int is 32bits on the platform
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_ILP64</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__ILP64__</span>)
<span class="enscript-type">typedef</span>   <span class="enscript-type">signed</span> int32 mDNSs32;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> int32 mDNSu32;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span>   <span class="enscript-type">signed</span> <span class="enscript-type">int</span> mDNSs32;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mDNSu32;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSDebug.h&quot;</span>

<span class="enscript-comment">// To enforce useful type checking, we make mDNSInterfaceID be a pointer to a dummy struct
</span><span class="enscript-comment">// This way, mDNSInterfaceIDs can be assigned, and compared with each other, but not with other types
</span><span class="enscript-comment">// Declaring the type to be the typical generic &quot;void *&quot; would lack this type checking
</span><span class="enscript-type">typedef</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> mDNSInterfaceID_dummystruct { <span class="enscript-type">void</span> *dummy; } *mDNSInterfaceID;

<span class="enscript-comment">// Use when printing interface IDs; the interface ID is actually a pointer, but we're only using
</span><span class="enscript-comment">// the pointer as a unique identifier, and in special cases it's actually a small number.   So there's
</span><span class="enscript-comment">// little point in printing all 64 bits--the upper 32 bits in particular will not add information.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">IIDPrintable</span>(x) ((uint32_t)(uintptr_t)(x))

<span class="enscript-comment">// These types are for opaque two- and four-byte identifiers.
</span><span class="enscript-comment">// The &quot;NotAnInteger&quot; fields of the unions allow the value to be conveniently passed around in a
</span><span class="enscript-comment">// register for the sake of efficiency, and compared for equality or inequality, but don't forget --
</span><span class="enscript-comment">// just because it is in a register doesn't mean it is an integer. Operations like greater than,
</span><span class="enscript-comment">// less than, add, multiply, increment, decrement, etc., are undefined for opaque identifiers,
</span><span class="enscript-comment">// and if you make the mistake of trying to do those using the NotAnInteger field, then you'll
</span><span class="enscript-comment">// find you get code that doesn't work consistently on big-endian and little-endian machines.
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
 #pragma pack(push,2)
#<span class="enscript-reference">endif</span>
<span class="enscript-type">typedef</span>       <span class="enscript-type">union</span> { mDNSu8 b[ 2]; mDNSu16 NotAnInteger; } mDNSOpaque16;
<span class="enscript-type">typedef</span>       <span class="enscript-type">union</span> { mDNSu8 b[ 4]; mDNSu32 NotAnInteger; } mDNSOpaque32;
<span class="enscript-type">typedef</span> packedunion { mDNSu8 b[ 6]; mDNSu16 w[3]; mDNSu32 l[1]; } mDNSOpaque48;
<span class="enscript-type">typedef</span>       <span class="enscript-type">union</span> { mDNSu8 b[ 8]; mDNSu16 w[4]; mDNSu32 l[2]; } mDNSOpaque64;
<span class="enscript-type">typedef</span>       <span class="enscript-type">union</span> { mDNSu8 b[16]; mDNSu16 w[8]; mDNSu32 l[4]; } mDNSOpaque128;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>)
 #pragma pack(pop)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> mDNSOpaque16 mDNSIPPort;        <span class="enscript-comment">// An IP port is a two-byte opaque identifier (not an integer)
</span><span class="enscript-type">typedef</span> mDNSOpaque32 mDNSv4Addr;        <span class="enscript-comment">// An IP address is a four-byte opaque identifier (not an integer)
</span><span class="enscript-type">typedef</span> mDNSOpaque128 mDNSv6Addr;       <span class="enscript-comment">// An IPv6 address is a 16-byte opaque identifier (not an integer)
</span><span class="enscript-type">typedef</span> mDNSOpaque48 mDNSEthAddr;       <span class="enscript-comment">// An Ethernet address is a six-byte opaque identifier (not an integer)
</span>
<span class="enscript-comment">// Bit operations for opaque 64 bit quantity. Uses the 32 bit quantity(l[2]) to set and clear bits
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSNBBY</span> 8
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_set_opaque64</span>(op64, index) (op64.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] |= (1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_clr_opaque64</span>(op64, index) (op64.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] &amp;= ~(1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_get_opaque64</span>(op64, index) (op64.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] &amp; (1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))
    
<span class="enscript-comment">// Bit operations for opaque 128 bit quantity. Uses the 32 bit quantity(l[4]) to set and clear bits
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_set_opaque128</span>(op128, index) (op128.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] |= (1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_clr_opaque128</span>(op128, index) (op128.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] &amp;= ~(1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">bit_get_opaque128</span>(op128, index) (op128.l[((index))/(sizeof(mDNSu32) * mDNSNBBY)] &amp; (1 &lt;&lt; ((index) % (sizeof(mDNSu32) * mDNSNBBY))))

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mDNSAddrType_None    = 0,
    mDNSAddrType_IPv4    = 4,
    mDNSAddrType_IPv6    = 6,
    mDNSAddrType_Unknown = ~0   <span class="enscript-comment">// Special marker value used in known answer list recording
</span>} mDNSAddr_Type;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mDNSTransport_None = 0,
    mDNSTransport_UDP  = 1,
    mDNSTransport_TCP  = 2
} mDNSTransport_Type;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSs32 type;
    <span class="enscript-type">union</span> { mDNSv6Addr v6; mDNSv4Addr v4; } ip;
} mDNSAddr;

<span class="enscript-type">enum</span> { mDNSfalse = 0, mDNStrue = 1 };

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSNULL</span> 0L

<span class="enscript-type">enum</span>
{
    mStatus_Waiting           = 1,
    mStatus_NoError           = 0,

    <span class="enscript-comment">// mDNS return values are in the range FFFE FF00 (-65792) to FFFE FFFF (-65537)
</span>    <span class="enscript-comment">// The top end of the range (FFFE FFFF) is used for error codes;
</span>    <span class="enscript-comment">// the bottom end of the range (FFFE FF00) is used for non-error values;
</span>
    <span class="enscript-comment">// Error codes:
</span>    mStatus_UnknownErr                = -65537,     <span class="enscript-comment">// First value: 0xFFFE FFFF
</span>    mStatus_NoSuchNameErr             = -65538,
    mStatus_NoMemoryErr               = -65539,
    mStatus_BadParamErr               = -65540,
    mStatus_BadReferenceErr           = -65541,
    mStatus_BadStateErr               = -65542,
    mStatus_BadFlagsErr               = -65543,
    mStatus_UnsupportedErr            = -65544,
    mStatus_NotInitializedErr         = -65545,
    mStatus_NoCache                   = -65546,
    mStatus_AlreadyRegistered         = -65547,
    mStatus_NameConflict              = -65548,
    mStatus_Invalid                   = -65549,
    mStatus_Firewall                  = -65550,
    mStatus_Incompatible              = -65551,
    mStatus_BadInterfaceErr           = -65552,
    mStatus_Refused                   = -65553,
    mStatus_NoSuchRecord              = -65554,
    mStatus_NoAuth                    = -65555,
    mStatus_NoSuchKey                 = -65556,
    mStatus_NATTraversal              = -65557,
    mStatus_DoubleNAT                 = -65558,
    mStatus_BadTime                   = -65559,
    mStatus_BadSig                    = -65560,     <span class="enscript-comment">// while we define this per RFC 2845, BIND 9 returns Refused for bad/missing signatures
</span>    mStatus_BadKey                    = -65561,
    mStatus_TransientErr              = -65562,     <span class="enscript-comment">// transient failures, e.g. sending packets shortly after a network transition or wake from sleep
</span>    mStatus_ServiceNotRunning         = -65563,     <span class="enscript-comment">// Background daemon not running
</span>    mStatus_NATPortMappingUnsupported = -65564,     <span class="enscript-comment">// NAT doesn't support PCP, NAT-PMP or UPnP
</span>    mStatus_NATPortMappingDisabled    = -65565,     <span class="enscript-comment">// NAT supports PCP, NAT-PMP or UPnP, but it's disabled by the administrator
</span>    mStatus_NoRouter                  = -65566,
    mStatus_PollingMode               = -65567,
    mStatus_Timeout                   = -65568,
    mStatus_DefunctConnection         = -65569,
    <span class="enscript-comment">// -65570 to -65785 currently unused; available for allocation
</span>
    <span class="enscript-comment">// udp connection status
</span>    mStatus_HostUnreachErr    = -65786,

    <span class="enscript-comment">// tcp connection status
</span>    mStatus_ConnPending       = -65787,
    mStatus_ConnFailed        = -65788,
    mStatus_ConnEstablished   = -65789,

    <span class="enscript-comment">// Non-error values:
</span>    mStatus_GrowCache         = -65790,
    mStatus_ConfigChanged     = -65791,
    mStatus_MemFree           = -65792      <span class="enscript-comment">// Last value: 0xFFFE FF00
</span>                                <span class="enscript-comment">// mStatus_MemFree is the last legal mDNS error code, at the end of the range allocated for mDNS
</span>};

<span class="enscript-type">typedef</span> mDNSs32 mStatus;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MaxIp</span> 5 // Needs to be consistent with MaxInputIf in dns_services.h

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { q_stop = 0, q_start } q_state;
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { reg_stop = 0, reg_start } reg_state;

<span class="enscript-comment">// RFC 1034/1035 specify that a domain label consists of a length byte plus up to 63 characters
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_DOMAIN_LABEL</span> 63
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> { mDNSu8 c[ 64]; } domainlabel;      <span class="enscript-comment">// One label: length byte and up to 63 characters
</span>
<span class="enscript-comment">// RFC 1034/1035/2181 specify that a domain name (length bytes and data bytes) may be up to 255 bytes long,
</span><span class="enscript-comment">// plus the terminating zero at the end makes 256 bytes total in the on-the-wire format.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_DOMAIN_NAME</span> 256
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> { mDNSu8 c[256]; } domainname;       <span class="enscript-comment">// Up to 256 bytes of length-prefixed domainlabels
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> { mDNSu8 c[256]; } UTF8str255;       <span class="enscript-comment">// Null-terminated C string
</span>
<span class="enscript-comment">// The longest legal textual form of a DNS name is 1009 bytes, including the C-string terminating NULL at the end.
</span><span class="enscript-comment">// Explanation:
</span><span class="enscript-comment">// When a native domainname object is converted to printable textual form using ConvertDomainNameToCString(),
</span><span class="enscript-comment">// non-printing characters are represented in the conventional DNS way, as '\ddd', where ddd is a three-digit decimal number.
</span><span class="enscript-comment">// The longest legal domain name is 256 bytes, in the form of four labels as shown below:
</span><span class="enscript-comment">// Length byte, 63 data bytes, length byte, 63 data bytes, length byte, 63 data bytes, length byte, 62 data bytes, zero byte.
</span><span class="enscript-comment">// Each label is encoded textually as characters followed by a trailing dot.
</span><span class="enscript-comment">// If every character has to be represented as a four-byte escape sequence, then this makes the maximum textual form four labels
</span><span class="enscript-comment">// plus the C-string terminating NULL as shown below:
</span><span class="enscript-comment">// 63*4+1 + 63*4+1 + 63*4+1 + 62*4+1 + 1 = 1009.
</span><span class="enscript-comment">// Note that MAX_ESCAPED_DOMAIN_LABEL is not normally used: If you're only decoding a single label, escaping is usually not required.
</span><span class="enscript-comment">// It is for domain names, where dots are used as label separators, that proper escaping is vital.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_ESCAPED_DOMAIN_LABEL</span> 254
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_ESCAPED_DOMAIN_NAME</span> 1009

<span class="enscript-comment">// MAX_REVERSE_MAPPING_NAME
</span><span class="enscript-comment">// For IPv4: &quot;123.123.123.123.in-addr.arpa.&quot;  30 bytes including terminating NUL
</span><span class="enscript-comment">// For IPv6: &quot;x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.ip6.arpa.&quot;  74 bytes including terminating NUL
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_REVERSE_MAPPING_NAME_V4</span> 30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_REVERSE_MAPPING_NAME_V6</span> 74
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_REVERSE_MAPPING_NAME</span>    74

<span class="enscript-comment">// Most records have a TTL of 75 minutes, so that their 80% cache-renewal query occurs once per hour.
</span><span class="enscript-comment">// For records containing a hostname (in the name on the left, or in the rdata on the right),
</span><span class="enscript-comment">// like A, AAAA, reverse-mapping PTR, and SRV, we use a two-minute TTL by default, because we don't want
</span><span class="enscript-comment">// them to hang around for too long in the cache if the host in question crashes or otherwise goes away.
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kStandardTTL</span> (3600UL * 100 / 80)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHostNameTTL</span> 120UL

<span class="enscript-comment">// Multicast DNS uses announcements (gratuitous responses) to update peer caches.
</span><span class="enscript-comment">// This means it is feasible to use relatively larger TTL values than we might otherwise
</span><span class="enscript-comment">// use, because we have a cache coherency protocol to keep the peer caches up to date.
</span><span class="enscript-comment">// With Unicast DNS, once an authoritative server gives a record with a certain TTL value to a client
</span><span class="enscript-comment">// or caching server, that client or caching server is entitled to hold onto the record until its TTL
</span><span class="enscript-comment">// expires, and has no obligation to contact the authoritative server again until that time arrives.
</span><span class="enscript-comment">// This means that whereas Multicast DNS can use announcements to pre-emptively update stale data
</span><span class="enscript-comment">// before it would otherwise have expired, standard Unicast DNS (not using LLQs) has no equivalent
</span><span class="enscript-comment">// mechanism, and TTL expiry is the *only* mechanism by which stale data gets deleted. Because of this,
</span><span class="enscript-comment">// we currently limit the TTL to ten seconds in such cases where no dynamic cache updating is possible.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kStaticCacheTTL</span> 10

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DefaultTTLforRRType</span>(X) (((X) == kDNSType_A || (X) == kDNSType_AAAA || (X) == kDNSType_SRV) ? kHostNameTTL : kStandardTTL)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_KeepaliveRecord</span>(rr) ((rr)-&gt;rrtype == kDNSType_NULL &amp;&amp; SameDomainLabel(SecondLabel((rr)-&gt;name)-&gt;c, (mDNSu8 *)<span class="enscript-string">&quot;\x0A_keepalive&quot;</span>))

<span class="enscript-comment">// Number of times keepalives are sent if no ACK is received before waking up the system
</span><span class="enscript-comment">// this is analogous to net.inet.tcp.keepcnt
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kKeepaliveRetryCount</span>    10
<span class="enscript-comment">// The frequency at which keepalives are retried if no ACK is received
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kKeepaliveRetryInterval</span> 30

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> AuthRecord_struct AuthRecord;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ServiceRecordSet_struct ServiceRecordSet;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> CacheRecord_struct CacheRecord;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> CacheGroup_struct CacheGroup;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> AuthGroup_struct AuthGroup;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> DNSQuestion_struct DNSQuestion;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ZoneData_struct ZoneData;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mDNS_struct mDNS;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mDNS_PlatformSupport_struct mDNS_PlatformSupport;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> NATTraversalInfo_struct NATTraversalInfo;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ResourceRecord_struct ResourceRecord;

<span class="enscript-comment">// Structure to abstract away the differences between TCP/SSL sockets, and one for UDP sockets
</span><span class="enscript-comment">// The actual definition of these structures appear in the appropriate platform support code
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> TCPListener_struct TCPListener;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> TCPSocket_struct TCPSocket;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> UDPSocket_struct UDPSocket;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">Message</span> <span class="enscript-variable-name">structures</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_numZones</span>   numQuestions
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_numPrereqs</span> numAnswers
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_numUpdates</span> numAuthorities

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSOpaque16 id;
    mDNSOpaque16 flags;
    mDNSu16 numQuestions;
    mDNSu16 numAnswers;
    mDNSu16 numAuthorities;
    mDNSu16 numAdditionals;
} DNSMessageHeader;

<span class="enscript-comment">// We can send and receive packets up to 9000 bytes (Ethernet Jumbo Frame size, if that ever becomes widely used)
</span><span class="enscript-comment">// However, in the normal case we try to limit packets to 1500 bytes so that we don't get IP fragmentation on standard Ethernet
</span><span class="enscript-comment">// 40 (IPv6 header) + 8 (UDP header) + 12 (DNS message header) + 1440 (DNS message body) = 1500 total
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">AbsoluteMaxDNSMessageData</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AbsoluteMaxDNSMessageData</span> 8940
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NormalMaxDNSMessageData</span> 1440
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    DNSMessageHeader h;                     <span class="enscript-comment">// Note: Size 12 bytes
</span>    mDNSu8 data[AbsoluteMaxDNSMessageData]; <span class="enscript-comment">// 40 (IPv6) + 8 (UDP) + 12 (DNS header) + 8940 (data) = 9000
</span>} DNSMessage;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> tcpInfo_t
{
    mDNS             *m;
    TCPSocket        *sock;
    DNSMessage request;
    <span class="enscript-type">int</span> requestLen;
    DNSQuestion      *question;   <span class="enscript-comment">// For queries
</span>    AuthRecord       *rr;         <span class="enscript-comment">// For record updates
</span>    mDNSAddr Addr;
    mDNSIPPort Port;
    mDNSIPPort SrcPort;
    DNSMessage       *reply;
    mDNSu16 replylen;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> nread;
    <span class="enscript-type">int</span> numReplies;
} tcpInfo_t;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Other</span> <span class="enscript-variable-name">Packet</span> <span class="enscript-variable-name">Format</span> <span class="enscript-variable-name">Structures</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSEthAddr dst;
    mDNSEthAddr src;
    mDNSOpaque16 ethertype;
} EthernetHeader;           <span class="enscript-comment">// 14 bytes
</span>
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSOpaque16 hrd;
    mDNSOpaque16 pro;
    mDNSu8 hln;
    mDNSu8 pln;
    mDNSOpaque16 op;
    mDNSEthAddr sha;
    mDNSv4Addr spa;
    mDNSEthAddr tha;
    mDNSv4Addr tpa;
} ARP_EthIP;                <span class="enscript-comment">// 28 bytes
</span>
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 vlen;
    mDNSu8 tos;
    mDNSOpaque16 totlen;
    mDNSOpaque16 id;
    mDNSOpaque16 flagsfrags;
    mDNSu8 ttl;
    mDNSu8 protocol;        <span class="enscript-comment">// Payload type: 0x06 = TCP, 0x11 = UDP
</span>    mDNSu16 checksum;
    mDNSv4Addr src;
    mDNSv4Addr dst;
} IPv4Header;               <span class="enscript-comment">// 20 bytes
</span>
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu32 vcf;            <span class="enscript-comment">// Version, Traffic Class, Flow Label
</span>    mDNSu16 len;            <span class="enscript-comment">// Payload Length
</span>    mDNSu8 pro;             <span class="enscript-comment">// Type of next header: 0x06 = TCP, 0x11 = UDP, 0x3A = ICMPv6
</span>    mDNSu8 ttl;             <span class="enscript-comment">// Hop Limit
</span>    mDNSv6Addr src;
    mDNSv6Addr dst;
} IPv6Header;               <span class="enscript-comment">// 40 bytes
</span>
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSv6Addr src;
    mDNSv6Addr dst;
    mDNSOpaque32 len;
    mDNSOpaque32 pro;
} IPv6PseudoHeader;         <span class="enscript-comment">// 40 bytes
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">union</span>
{
    mDNSu8 bytes[20];
    ARP_EthIP arp;
    IPv4Header v4;
    IPv6Header v6;
} NetworkLayerPacket;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSIPPort src;
    mDNSIPPort dst;
    mDNSu32 seq;
    mDNSu32 ack;
    mDNSu8 offset;
    mDNSu8 flags;
    mDNSu16 window;
    mDNSu16 checksum;
    mDNSu16 urgent;
} TCPHeader;                <span class="enscript-comment">// 20 bytes; IP protocol type 0x06
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSInterfaceID IntfId;
    mDNSu32 seq;
    mDNSu32 ack;
    mDNSu16 window;
} mDNSTCPInfo;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSIPPort src;
    mDNSIPPort dst;
    mDNSu16 len;            <span class="enscript-comment">// Length including UDP header (i.e. minimum value is 8 bytes)
</span>    mDNSu16 checksum;
} UDPHeader;                <span class="enscript-comment">// 8 bytes; IP protocol type 0x11
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu8 type;            <span class="enscript-comment">// 0x87 == Neighbor Solicitation, 0x88 == Neighbor Advertisement
</span>    mDNSu8 code;
    mDNSu16 checksum;
    mDNSu32 flags_res;      <span class="enscript-comment">// R/S/O flags and reserved bits
</span>    mDNSv6Addr target;
    <span class="enscript-comment">// Typically 8 bytes of options are also present
</span>} IPv6NDP;                  <span class="enscript-comment">// 24 bytes or more; IP protocol type 0x3A
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSAddr    ipaddr;
    <span class="enscript-type">char</span>        ethaddr[18];
} IPAddressMACMapping;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_Sol</span> 0x87
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_Adv</span> 0x88

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_Router</span>    0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_Solicited</span> 0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_Override</span>  0x20

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_SrcLL</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDP_TgtLL</span> 2

<span class="enscript-type">typedef</span> <span class="enscript-type">union</span>
{
    mDNSu8 bytes[20];
    TCPHeader tcp;
    UDPHeader udp;
    IPv6NDP ndp;
} TransportLayerPacket;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSOpaque64 InitiatorCookie;
    mDNSOpaque64 ResponderCookie;
    mDNSu8 NextPayload;
    mDNSu8 Version;
    mDNSu8 ExchangeType;
    mDNSu8 Flags;
    mDNSOpaque32 MessageID;
    mDNSu32 Length;
} IKEHeader;                <span class="enscript-comment">// 28 bytes
</span>
<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Resource</span> <span class="enscript-variable-name">Record</span> <span class="enscript-variable-name">structures</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Authoritative Resource Records:
</span><span class="enscript-comment">// There are four basic types: Shared, Advisory, Unique, Known Unique
</span>
<span class="enscript-comment">// * Shared Resource Records do not have to be unique
</span><span class="enscript-comment">// -- Shared Resource Records are used for DNS-SD service PTRs
</span><span class="enscript-comment">// -- It is okay for several hosts to have RRs with the same name but different RDATA
</span><span class="enscript-comment">// -- We use a random delay on responses to reduce collisions when all the hosts respond to the same query
</span><span class="enscript-comment">// -- These RRs typically have moderately high TTLs (e.g. one hour)
</span><span class="enscript-comment">// -- These records are announced on startup and topology changes for the benefit of passive listeners
</span><span class="enscript-comment">// -- These records send a goodbye packet when deregistering
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// * Advisory Resource Records are like Shared Resource Records, except they don't send a goodbye packet
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// * Unique Resource Records should be unique among hosts within any given mDNS scope
</span><span class="enscript-comment">// -- The majority of Resource Records are of this type
</span><span class="enscript-comment">// -- If two entities on the network have RRs with the same name but different RDATA, this is a conflict
</span><span class="enscript-comment">// -- Responses may be sent immediately, because only one host should be responding to any particular query
</span><span class="enscript-comment">// -- These RRs typically have low TTLs (e.g. a few minutes)
</span><span class="enscript-comment">// -- On startup and after topology changes, a host issues queries to verify uniqueness
</span>
<span class="enscript-comment">// * Known Unique Resource Records are treated like Unique Resource Records, except that mDNS does
</span><span class="enscript-comment">// not have to verify their uniqueness because this is already known by other means (e.g. the RR name
</span><span class="enscript-comment">// is derived from the host's IP or Ethernet address, which is already known to be a unique identifier).
</span>
<span class="enscript-comment">// Summary of properties of different record types:
</span><span class="enscript-comment">// Probe?    Does this record type send probes before announcing?
</span><span class="enscript-comment">// Conflict? Does this record type react if we observe an apparent conflict?
</span><span class="enscript-comment">// Goodbye?  Does this record type send a goodbye packet on departure?
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//               Probe? Conflict? Goodbye? Notes
</span><span class="enscript-comment">// Unregistered                            Should not appear in any list (sanity check value)
</span><span class="enscript-comment">// Shared         No      No       Yes     e.g. Service PTR record
</span><span class="enscript-comment">// Deregistering  No      No       Yes     Shared record about to announce its departure and leave the list
</span><span class="enscript-comment">// Advisory       No      No       No
</span><span class="enscript-comment">// Unique         Yes     Yes      No      Record intended to be unique -- will probe to verify
</span><span class="enscript-comment">// Verified       Yes     Yes      No      Record has completed probing, and is verified unique
</span><span class="enscript-comment">// KnownUnique    No      Yes      No      Record is assumed by other means to be unique
</span>
<span class="enscript-comment">// Valid lifecycle of a record:
</span><span class="enscript-comment">// Unregistered -&gt;                   Shared      -&gt; Deregistering -(goodbye)-&gt; Unregistered
</span><span class="enscript-comment">// Unregistered -&gt;                   Advisory                               -&gt; Unregistered
</span><span class="enscript-comment">// Unregistered -&gt; Unique -(probe)-&gt; Verified                               -&gt; Unregistered
</span><span class="enscript-comment">// Unregistered -&gt;                   KnownUnique                            -&gt; Unregistered
</span>
<span class="enscript-comment">// Each Authoritative kDNSRecordType has only one bit set. This makes it easy to quickly see if a record
</span><span class="enscript-comment">// is one of a particular set of types simply by performing the appropriate bitwise masking operation.
</span>
<span class="enscript-comment">// Cache Resource Records (received from the network):
</span><span class="enscript-comment">// There are four basic types: Answer, Unique Answer, Additional, Unique Additional
</span><span class="enscript-comment">// Bit 7 (the top bit) of kDNSRecordType is always set for Cache Resource Records; always clear for Authoritative Resource Records
</span><span class="enscript-comment">// Bit 6 (value 0x40) is set for answer records; clear for authority/additional records
</span><span class="enscript-comment">// Bit 5 (value 0x20) is set for records received with the kDNSClass_UniqueRRSet
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    kDNSRecordTypeUnregistered     = 0x00,  <span class="enscript-comment">// Not currently in any list
</span>    kDNSRecordTypeDeregistering    = 0x01,  <span class="enscript-comment">// Shared record about to announce its departure and leave the list
</span>
    kDNSRecordTypeUnique           = 0x02,  <span class="enscript-comment">// Will become a kDNSRecordTypeVerified when probing is complete
</span>
    kDNSRecordTypeAdvisory         = 0x04,  <span class="enscript-comment">// Like Shared, but no goodbye packet
</span>    kDNSRecordTypeShared           = 0x08,  <span class="enscript-comment">// Shared means record name does not have to be unique -- use random delay on responses
</span>
    kDNSRecordTypeVerified         = 0x10,  <span class="enscript-comment">// Unique means mDNS should check that name is unique (and then send immediate responses)
</span>    kDNSRecordTypeKnownUnique      = 0x20,  <span class="enscript-comment">// Known Unique means mDNS can assume name is unique without checking
</span>                                            <span class="enscript-comment">// For Dynamic Update records, Known Unique means the record must already exist on the server.
</span>    kDNSRecordTypeUniqueMask       = (kDNSRecordTypeUnique | kDNSRecordTypeVerified | kDNSRecordTypeKnownUnique),
    kDNSRecordTypeActiveSharedMask = (kDNSRecordTypeAdvisory         | kDNSRecordTypeShared),
    kDNSRecordTypeActiveUniqueMask = (kDNSRecordTypeVerified         | kDNSRecordTypeKnownUnique),
    kDNSRecordTypeActiveMask       = (kDNSRecordTypeActiveSharedMask | kDNSRecordTypeActiveUniqueMask),

    kDNSRecordTypePacketAdd        = 0x80,  <span class="enscript-comment">// Received in the Additional  Section of a DNS Response
</span>    kDNSRecordTypePacketAddUnique  = 0x90,  <span class="enscript-comment">// Received in the Additional  Section of a DNS Response with kDNSClass_UniqueRRSet set
</span>    kDNSRecordTypePacketAuth       = 0xA0,  <span class="enscript-comment">// Received in the Authorities Section of a DNS Response
</span>    kDNSRecordTypePacketAuthUnique = 0xB0,  <span class="enscript-comment">// Received in the Authorities Section of a DNS Response with kDNSClass_UniqueRRSet set
</span>    kDNSRecordTypePacketAns        = 0xC0,  <span class="enscript-comment">// Received in the Answer      Section of a DNS Response
</span>    kDNSRecordTypePacketAnsUnique  = 0xD0,  <span class="enscript-comment">// Received in the Answer      Section of a DNS Response with kDNSClass_UniqueRRSet set
</span>
    kDNSRecordTypePacketNegative   = 0xF0,  <span class="enscript-comment">// Pseudo-RR generated to cache non-existence results like NXDomain
</span>
    kDNSRecordTypePacketUniqueMask = 0x10   <span class="enscript-comment">// True for PacketAddUnique, PacketAnsUnique, PacketAuthUnique, kDNSRecordTypePacketNegative
</span>} kDNSRecordTypes;

<span class="enscript-type">typedef</span> packedstruct { mDNSu16 priority; mDNSu16 weight; mDNSIPPort port; domainname target;   } rdataSRV;
<span class="enscript-type">typedef</span> packedstruct { mDNSu16 preference;                                domainname exchange; } rdataMX;
<span class="enscript-type">typedef</span> packedstruct { domainname mbox; domainname txt;                                        } rdataRP;
<span class="enscript-type">typedef</span> packedstruct { mDNSu16 preference; domainname map822; domainname mapx400;              } rdataPX;

<span class="enscript-type">typedef</span> packedstruct
{
    domainname mname;
    domainname rname;
    mDNSs32 serial;     <span class="enscript-comment">// Modular counter; increases when zone changes
</span>    mDNSu32 refresh;    <span class="enscript-comment">// Time in seconds that a slave waits after successful replication of the database before it attempts replication again
</span>    mDNSu32 retry;      <span class="enscript-comment">// Time in seconds that a slave waits after an unsuccessful replication attempt before it attempts replication again
</span>    mDNSu32 expire;     <span class="enscript-comment">// Time in seconds that a slave holds on to old data while replication attempts remain unsuccessful
</span>    mDNSu32 min;        <span class="enscript-comment">// Nominally the minimum record TTL for this zone, in seconds; also used for negative caching.
</span>} rdataSOA;

<span class="enscript-comment">// <a href="http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml">http://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml</a>
</span><span class="enscript-comment">// Algorithm used for RRSIG, DS and DNS KEY
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_RSA_SHA1</span>             0x05
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_DSA_NSEC3_SHA1</span>       0x06
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_RSA_NSEC3_SHA1</span>       0x07
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_RSA_SHA256</span>           0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_RSA_SHA512</span>           0x0A

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRYPTO_ALG_MAX</span>              0x0B

<span class="enscript-comment">// alg - same as in RRSIG, DNS KEY or DS.
</span><span class="enscript-comment">// RFC 4034 defines SHA1
</span><span class="enscript-comment">// RFC 4509 defines SHA256
</span><span class="enscript-comment">// Note: NSEC3 also uses 1 for SHA1 and hence we will reuse for now till a new
</span><span class="enscript-comment">// value is assigned.
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SHA1_DIGEST_TYPE</span>        1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SHA256_DIGEST_TYPE</span>      2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIGEST_TYPE_MAX</span>         3

<span class="enscript-comment">// We need support for base64 and base32 encoding for displaying KEY, NSEC3
</span><span class="enscript-comment">// To make this platform agnostic, we define two types which the platform
</span><span class="enscript-comment">// needs to support
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ENC_BASE32</span>              1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ENC_BASE64</span>              2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ENC_ALG_MAX</span>             3

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DS_FIXED_SIZE</span>           4
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu16 keyTag;
    mDNSu8 alg;
    mDNSu8 digestType;
    mDNSu8  *digest;
} rdataDS;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> TrustAnchor
{
    <span class="enscript-type">struct</span> TrustAnchor *next;
    <span class="enscript-type">int</span> digestLen;
    mDNSu32 validFrom;
    mDNSu32 validUntil;
    domainname zone;
    rdataDS rds;
} TrustAnchor;

<span class="enscript-comment">//size of rdataRRSIG excluding signerName and signature (which are variable fields)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RRSIG_FIXED_SIZE</span>      18
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 typeCovered;
    mDNSu8 alg;
    mDNSu8 labels;
    mDNSu32 origTTL;
    mDNSu32 sigExpireTime;
    mDNSu32 sigInceptTime;
    mDNSu16 keyTag;
    mDNSu8  signerName[1]; <span class="enscript-comment">// signerName is a dynamically-sized array
</span>    <span class="enscript-comment">// mDNSu8 *signature
</span>} rdataRRSig;

<span class="enscript-comment">// RFC 4034: For DNS Key RR
</span><span class="enscript-comment">// flags - the valid value for DNSSEC is 256 (Zone signing key - ZSK) and 257 (Secure Entry Point) which also
</span><span class="enscript-comment">// includes the ZSK bit
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSKEY_ZONE_SIGN_KEY</span>        0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSKEY_SECURE_ENTRY_POINT</span>   0x101

<span class="enscript-comment">// proto - the only valid value for protocol is 3 (See RFC 4034)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSKEY_VALID_PROTO_VALUE</span>    0x003

<span class="enscript-comment">// alg - The only mandatory algorithm that we support is RSA/SHA-1
</span><span class="enscript-comment">// DNSSEC_RSA_SHA1_ALG
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSKEY_FIXED_SIZE</span>          4
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu16 flags;
    mDNSu8 proto;
    mDNSu8 alg;
    mDNSu8  *data;
} rdataDNSKey;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC3_FIXED_SIZE</span>          5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC3_FLAGS_OPTOUT</span>        1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC3_MAX_ITERATIONS</span>      2500
<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 alg;
    mDNSu8 flags;
    mDNSu16 iterations;
    mDNSu8 saltLength;
    mDNSu8 *salt;
    <span class="enscript-comment">// hashLength, nxt, bitmap
</span>} rdataNSEC3;

<span class="enscript-comment">// We define it here instead of dnssec.h so that these values can be used
</span><span class="enscript-comment">// in files without bringing in all of dnssec.h unnecessarily.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    DNSSEC_Secure = 1,      <span class="enscript-comment">// Securely validated and has a chain up to the trust anchor
</span>    DNSSEC_Insecure,        <span class="enscript-comment">// Cannot build a chain up to the trust anchor
</span>    DNSSEC_Indeterminate,   <span class="enscript-comment">// Not used currently
</span>    DNSSEC_Bogus,           <span class="enscript-comment">// failed to validate signatures
</span>    DNSSEC_NoResponse       <span class="enscript-comment">// No DNSSEC records to start with
</span>} DNSSECStatus;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSSECRecordType</span>(rrtype) (((rrtype) == kDNSType_RRSIG) || ((rrtype) == kDNSType_NSEC) || ((rrtype) == kDNSType_DNSKEY) || ((rrtype) == kDNSType_DS) || \
                                  ((rrtype) == kDNSType_NSEC3))

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    platform_OSX = 1,   <span class="enscript-comment">// OSX Platform 
</span>    platform_iOS,       <span class="enscript-comment">// iOS Platform 
</span>    platform_Atv,       <span class="enscript-comment">// Atv Platform 
</span>    platform_NonApple   <span class="enscript-comment">// Non-Apple (Windows, POSIX) Platform
</span>} Platform_t;

<span class="enscript-comment">// EDNS Option Code registrations are recorded in the &quot;DNS EDNS0 Options&quot; section of
</span><span class="enscript-comment">// &lt;<a href="http://www.iana.org/assignments/dns-parameters">http://www.iana.org/assignments/dns-parameters</a>&gt;
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDNSOpt_LLQ</span>   1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDNSOpt_Lease</span> 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDNSOpt_NSID</span>  3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDNSOpt_Owner</span> 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDNSOpt_Trace</span> 65001  // 65001-65534 Reserved for Local/Experimental Use 

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 vers;
    mDNSu16 llqOp;
    mDNSu16 err;        <span class="enscript-comment">// Or UDP reply port, in setup request
</span>    <span class="enscript-comment">// Note: In the in-memory form, there's typically a two-byte space here, so that the following 64-bit id is word-aligned
</span>    mDNSOpaque64 id;
    mDNSu32 llqlease;
} LLQOptData;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu8 vers;            <span class="enscript-comment">// Version number of this Owner OPT record
</span>    mDNSs8 seq;             <span class="enscript-comment">// Sleep/wake epoch
</span>    mDNSEthAddr HMAC;       <span class="enscript-comment">// Host's primary identifier (e.g. MAC of on-board Ethernet)
</span>    mDNSEthAddr IMAC;       <span class="enscript-comment">// Interface's MAC address (if different to primary MAC)
</span>    mDNSOpaque48 password;  <span class="enscript-comment">// Optional password
</span>} OwnerOptData;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu8    platf;      <span class="enscript-comment">// Running platform (see enum Platform_t)
</span>    mDNSu32   mDNSv;      <span class="enscript-comment">// mDNSResponder Version (DNS_SD_H defined in dns_sd.h)
</span>} TracerOptData;

<span class="enscript-comment">// Note: rdataOPT format may be repeated an arbitrary number of times in a single resource record
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 opt;
    mDNSu16 optlen;
    <span class="enscript-type">union</span> { LLQOptData llq; mDNSu32 updatelease; OwnerOptData owner; TracerOptData tracer; } u;
} rdataOPT;

<span class="enscript-comment">// Space needed to put OPT records into a packet:
</span><span class="enscript-comment">// Header         11  bytes (name 1, type 2, class 2, TTL 4, length 2)
</span><span class="enscript-comment">// LLQ   rdata    18  bytes (opt 2, len 2, vers 2, op 2, err 2, id 8, lease 4)
</span><span class="enscript-comment">// Lease rdata     8  bytes (opt 2, len 2, lease 4)
</span><span class="enscript-comment">// Owner rdata 12-24  bytes (opt 2, len 2, owner 8-20)
</span><span class="enscript-comment">// Trace rdata     9  bytes (opt 2, len 2, platf 1, mDNSv 4)
</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_Header_Space</span>                 11
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_LLQData_Space</span>               (4 + 2 + 2 + 2 + 8 + 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_LeaseData_Space</span>             (4 + 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_OwnerData_ID_Space</span>          (4 + 2 + 6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_OwnerData_ID_Wake_Space</span>     (4 + 2 + 6 + 6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_OwnerData_ID_Wake_PW4_Space</span> (4 + 2 + 6 + 6 + 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_OwnerData_ID_Wake_PW6_Space</span> (4 + 2 + 6 + 6 + 6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSOpt_TraceData_Space</span>             (4 + 1 + 4)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ValidOwnerLength</span>(X) (   (X) == DNSOpt_OwnerData_ID_Space          - 4 || \
                                (X) == DNSOpt_OwnerData_ID_Wake_Space     - 4 || \
                                (X) == DNSOpt_OwnerData_ID_Wake_PW4_Space - 4 || \
                                (X) == DNSOpt_OwnerData_ID_Wake_PW6_Space - 4    )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSOpt_Owner_Space</span>(A,B) (mDNSSameEthAddress((A),(B)) ? DNSOpt_OwnerData_ID_Space : DNSOpt_OwnerData_ID_Wake_Space)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSOpt_Data_Space</span>(O) (                                  \
        (O)-&gt;opt == kDNSOpt_LLQ   ? DNSOpt_LLQData_Space   :        \
        (O)-&gt;opt == kDNSOpt_Lease ? DNSOpt_LeaseData_Space :        \
        (O)-&gt;opt == kDNSOpt_Trace ? DNSOpt_TraceData_Space :        \
        (O)-&gt;opt == kDNSOpt_Owner ? DNSOpt_Owner_Space(&amp;(O)-&gt;u.owner.HMAC, &amp;(O)-&gt;u.owner.IMAC) : 0x10000)

<span class="enscript-comment">// NSEC record is defined in RFC 4034.
</span><span class="enscript-comment">// 16 bit RRTYPE space is split into 256 windows and each window has 256 bits (32 bytes).
</span><span class="enscript-comment">// If we create a structure for NSEC, it's size would be:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   256 bytes domainname 'nextname'
</span><span class="enscript-comment">// + 256 * 34 = 8704 bytes of bitmap data
</span><span class="enscript-comment">// = 8960 bytes total
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This would be a waste, as types about 256 are not very common. But it would be odd, if we receive
</span><span class="enscript-comment">// a type above 256 (.US zone had TYPE65534 when this code was written) and not able to handle it.
</span><span class="enscript-comment">// Hence, we handle any size by not fixing a strucure in place. The following is just a placeholder
</span><span class="enscript-comment">// and never used anywhere.
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC_MCAST_WINDOW_SIZE</span> 32
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    domainname *next; <span class="enscript-comment">//placeholders are uncommented because C89 in Windows requires that a struct has at least a member.
</span>    <span class="enscript-type">char</span> bitmap[32];
} rdataNSEC;

<span class="enscript-comment">// StandardAuthRDSize is 264 (256+8), which is large enough to hold a maximum-sized SRV record (6 + 256 bytes)
</span><span class="enscript-comment">// MaximumRDSize is 8K the absolute maximum we support (at least for now)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">StandardAuthRDSize</span> 264
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MaximumRDSize</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MaximumRDSize</span> 8192
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// InlineCacheRDSize is 68
</span><span class="enscript-comment">// Records received from the network with rdata this size or less have their rdata stored right in the CacheRecord object
</span><span class="enscript-comment">// Records received from the network with rdata larger than this have additional storage allocated for the rdata
</span><span class="enscript-comment">// A quick unscientific sample from a busy network at Apple with lots of machines revealed this:
</span><span class="enscript-comment">// 1461 records in cache
</span><span class="enscript-comment">// 292 were one-byte TXT records
</span><span class="enscript-comment">// 136 were four-byte A records
</span><span class="enscript-comment">// 184 were sixteen-byte AAAA records
</span><span class="enscript-comment">// 780 were various PTR, TXT and SRV records from 12-64 bytes
</span><span class="enscript-comment">// Only 69 records had rdata bigger than 64 bytes
</span><span class="enscript-comment">// Note that since CacheRecord object and a CacheGroup object are allocated out of the same pool, it's sensible to
</span><span class="enscript-comment">// have them both be the same size. Making one smaller without making the other smaller won't actually save any memory.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">InlineCacheRDSize</span> 68

<span class="enscript-comment">// The RDataBody union defines the common rdata types that fit into our 264-byte limit
</span><span class="enscript-type">typedef</span> <span class="enscript-type">union</span>
{
    mDNSu8 data[StandardAuthRDSize];
    mDNSv4Addr ipv4;        <span class="enscript-comment">// For 'A' record
</span>    domainname name;        <span class="enscript-comment">// For PTR, NS, CNAME, DNAME
</span>    UTF8str255 txt;
    rdataMX mx;
    mDNSv6Addr ipv6;        <span class="enscript-comment">// For 'AAAA' record
</span>    rdataSRV srv;
    rdataOPT opt[2];        <span class="enscript-comment">// For EDNS0 OPT record; RDataBody may contain multiple variable-length rdataOPT objects packed together
</span>} RDataBody;

<span class="enscript-comment">// The RDataBody2 union is the same as above, except it includes fields for the larger types like soa, rp, px
</span><span class="enscript-type">typedef</span> <span class="enscript-type">union</span>
{
    mDNSu8 data[StandardAuthRDSize];
    mDNSv4Addr ipv4;        <span class="enscript-comment">// For 'A' record
</span>    domainname name;        <span class="enscript-comment">// For PTR, NS, CNAME, DNAME
</span>    rdataSOA soa;           <span class="enscript-comment">// This is large; not included in the normal RDataBody definition
</span>    UTF8str255 txt;
    rdataMX mx;
    rdataRP rp;             <span class="enscript-comment">// This is large; not included in the normal RDataBody definition
</span>    rdataPX px;             <span class="enscript-comment">// This is large; not included in the normal RDataBody definition
</span>    mDNSv6Addr ipv6;        <span class="enscript-comment">// For 'AAAA' record
</span>    rdataSRV srv;
    rdataOPT opt[2];        <span class="enscript-comment">// For EDNS0 OPT record; RDataBody may contain multiple variable-length rdataOPT objects packed together
</span>    rdataDS ds;
    rdataDNSKey key;
    rdataRRSig rrsig;
} RDataBody2;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 MaxRDLength;    <span class="enscript-comment">// Amount of storage allocated for rdata (usually sizeof(RDataBody))
</span>    mDNSu16 padding;        <span class="enscript-comment">// So that RDataBody is aligned on 32-bit boundary
</span>    RDataBody u;
} RData;

<span class="enscript-comment">// sizeofRDataHeader should be 4 bytes
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sizeofRDataHeader</span> (sizeof(RData) - sizeof(RDataBody))

<span class="enscript-comment">// RData_small is a smaller version of the RData object, used for inline data storage embedded in a CacheRecord_struct
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 MaxRDLength;    <span class="enscript-comment">// Storage allocated for data (may be greater than InlineCacheRDSize if additional storage follows this object)
</span>    mDNSu16 padding;        <span class="enscript-comment">// So that data is aligned on 32-bit boundary
</span>    mDNSu8 data[InlineCacheRDSize];
} RData_small;

<span class="enscript-comment">// Note: Within an mDNSRecordCallback mDNS all API calls are legal except mDNS_Init(), mDNS_Exit(), mDNS_Execute()
</span><span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSRecordCallback</span> (mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);

<span class="enscript-comment">// Note:
</span><span class="enscript-comment">// Restrictions: An mDNSRecordUpdateCallback may not make any mDNS API calls.
</span><span class="enscript-comment">// The intent of this callback is to allow the client to free memory, if necessary.
</span><span class="enscript-comment">// The internal data structures of the mDNS code may not be in a state where mDNS API calls may be made safely.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSRecordUpdateCallback</span> (mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, RData *OldRData, mDNSu16 OldRDLen);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">NAT</span> <span class="enscript-variable-name">Traversal</span> <span class="enscript-variable-name">structures</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">constants</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NATMAP_MAX_RETRY_INTERVAL</span>    ((mDNSPlatformOneSecond * 60) * 15)    // Max retry interval is 15 minutes
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NATMAP_MIN_RETRY_INTERVAL</span>     (mDNSPlatformOneSecond * 2)           // Min retry interval is 2 seconds
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NATMAP_INIT_RETRY</span>             (mDNSPlatformOneSecond / 4)           // start at 250ms w/ exponential decay
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NATMAP_DEFAULT_LEASE</span>          (60 * 60 * 2)                         // 2 hour lease life in seconds
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NATMAP_VERS</span> 0

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    NATOp_AddrRequest    = 0,
    NATOp_MapUDP         = 1,
    NATOp_MapTCP         = 2,

    NATOp_AddrResponse   = 0x80 | 0,
    NATOp_MapUDPResponse = 0x80 | 1,
    NATOp_MapTCPResponse = 0x80 | 2,
} NATOp_t;

<span class="enscript-type">enum</span>
{
    NATErr_None    = 0,
    NATErr_Vers    = 1,
    NATErr_Refused = 2,
    NATErr_NetFail = 3,
    NATErr_Res     = 4,
    NATErr_Opcode  = 5
};

<span class="enscript-type">typedef</span> mDNSu16 NATErr_t;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 vers;
    mDNSu8 opcode;
} NATAddrRequest;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 vers;
    mDNSu8 opcode;
    mDNSu16 err;
    mDNSu32 upseconds;          <span class="enscript-comment">// Time since last NAT engine reboot, in seconds
</span>    mDNSv4Addr ExtAddr;
} NATAddrReply;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 vers;
    mDNSu8 opcode;
    mDNSOpaque16 unused;
    mDNSIPPort intport;
    mDNSIPPort extport;
    mDNSu32 NATReq_lease;
} NATPortMapRequest;

<span class="enscript-type">typedef</span> packedstruct
{
    mDNSu8 vers;
    mDNSu8 opcode;
    mDNSu16 err;
    mDNSu32 upseconds;          <span class="enscript-comment">// Time since last NAT engine reboot, in seconds
</span>    mDNSIPPort intport;
    mDNSIPPort extport;
    mDNSu32 NATRep_lease;
} NATPortMapReply;

<span class="enscript-comment">// PCP Support for IPv4 mappings
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PCP_VERS</span> 0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PCP_WAITSECS_AFTER_EPOCH_INVALID</span> 5

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    PCPOp_Announce = 0,
    PCPOp_Map      = 1
} PCPOp_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    PCPProto_All = 0,
    PCPProto_TCP = 6,
    PCPProto_UDP = 17
} PCPProto_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    PCPResult_Success         = 0,
    PCPResult_UnsuppVersion   = 1,
    PCPResult_NotAuthorized   = 2,
    PCPResult_MalformedReq    = 3,
    PCPResult_UnsuppOpcode    = 4,
    PCPResult_UnsuppOption    = 5,
    PCPResult_MalformedOption = 6,
    PCPResult_NetworkFailure  = 7,
    PCPResult_NoResources     = 8,
    PCPResult_UnsuppProtocol  = 9,
    PCPResult_UserExQuota     = 10,
    PCPResult_CantProvideExt  = 11,
    PCPResult_AddrMismatch    = 12,
    PCPResult_ExcesRemotePeer = 13
} PCPResult_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu8       version;
    mDNSu8       opCode;
    mDNSOpaque16 reserved;
    mDNSu32      lifetime;
    mDNSv6Addr   clientAddr;
    mDNSu32      nonce[3];
    mDNSu8       protocol;
    mDNSu8       reservedMapOp[3];
    mDNSIPPort   intPort;
    mDNSIPPort   extPort;
    mDNSv6Addr   extAddress;
} PCPMapRequest;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu8     version;
    mDNSu8     opCode;
    mDNSu8     reserved;
    mDNSu8     result;
    mDNSu32    lifetime;
    mDNSu32    epoch;
    mDNSu32    clientAddrParts[3];
    mDNSu32    nonce[3];
    mDNSu8     protocol;
    mDNSu8     reservedMapOp[3];
    mDNSIPPort intPort;
    mDNSIPPort extPort;
    mDNSv6Addr extAddress;
} PCPMapReply;

<span class="enscript-comment">// LNT Support
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    LNTDiscoveryOp      = 1,
    LNTExternalAddrOp   = 2,
    LNTPortMapOp        = 3,
    LNTPortMapDeleteOp  = 4
} LNTOp_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LNT_MAXBUFSIZE</span> 8192
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> tcpLNTInfo_struct tcpLNTInfo;
<span class="enscript-type">struct</span> tcpLNTInfo_struct
{
    tcpLNTInfo       *next;
    mDNS             *m;
    NATTraversalInfo *parentNATInfo;    <span class="enscript-comment">// pointer back to the parent NATTraversalInfo
</span>    TCPSocket        *sock;
    LNTOp_t op;                         <span class="enscript-comment">// operation performed using this connection
</span>    mDNSAddr Address;                   <span class="enscript-comment">// router address
</span>    mDNSIPPort Port;                    <span class="enscript-comment">// router port
</span>    mDNSu8           *Request;          <span class="enscript-comment">// xml request to router
</span>    <span class="enscript-type">int</span> requestLen;
    mDNSu8           *Reply;            <span class="enscript-comment">// xml reply from router
</span>    <span class="enscript-type">int</span> replyLen;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> nread;                <span class="enscript-comment">// number of bytes read so far
</span>    <span class="enscript-type">int</span> retries;                        <span class="enscript-comment">// number of times we've tried to do this port mapping
</span>};

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*NATTraversalClientCallback)(mDNS *m, NATTraversalInfo *n);

<span class="enscript-comment">// if m-&gt;timenow &lt;  ExpiryTime then we have an active mapping, and we'll renew halfway to expiry
</span><span class="enscript-comment">// if m-&gt;timenow &gt;= ExpiryTime then our mapping has expired, and we're trying to create one
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    NATTProtocolNone    = 0,
    NATTProtocolNATPMP  = 1,
    NATTProtocolUPNPIGD = 2,
    NATTProtocolPCP     = 3,
} NATTProtocol;

<span class="enscript-type">struct</span> NATTraversalInfo_struct
{
    <span class="enscript-comment">// Internal state fields. These are used internally by mDNSCore; the client layer needn't be concerned with them.
</span>    NATTraversalInfo           *next;

    mDNSs32 ExpiryTime;                             <span class="enscript-comment">// Time this mapping expires, or zero if no mapping
</span>    mDNSs32 retryInterval;                          <span class="enscript-comment">// Current interval, between last packet we sent and the next one
</span>    mDNSs32 retryPortMap;                           <span class="enscript-comment">// If Protocol is nonzero, time to send our next mapping packet
</span>    mStatus NewResult;                              <span class="enscript-comment">// New error code; will be copied to Result just prior to invoking callback
</span>    NATTProtocol lastSuccessfulProtocol;            <span class="enscript-comment">// To send correct deletion request &amp; update non-PCP external address operations
</span>    mDNSBool sentNATPMP;                            <span class="enscript-comment">// Whether we just sent a NAT-PMP packet, so we won't send another if
</span>                                                    <span class="enscript-comment">//    we receive another NAT-PMP &quot;Unsupported Version&quot; packet
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
    tcpLNTInfo tcpInfo;                             <span class="enscript-comment">// Legacy NAT traversal (UPnP) TCP connection
</span>#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Result fields: When the callback is invoked these fields contain the answers the client is looking for
</span>    <span class="enscript-comment">// When the callback is invoked ExternalPort is *usually* set to be the same the same as RequestedPort, except:
</span>    <span class="enscript-comment">// (a) When we're behind a NAT gateway with port mapping disabled, ExternalPort is reported as zero to
</span>    <span class="enscript-comment">//     indicate that we don't currently have a working mapping (but RequestedPort retains the external port
</span>    <span class="enscript-comment">//     we'd like to get, the next time we meet an accomodating NAT gateway willing to give us one).
</span>    <span class="enscript-comment">// (b) When we have a routable non-RFC1918 address, we don't *need* a port mapping, so ExternalPort
</span>    <span class="enscript-comment">//     is reported as the same as our InternalPort, since that is effectively our externally-visible port too.
</span>    <span class="enscript-comment">//     Again, RequestedPort retains the external port we'd like to get the next time we find ourself behind a NAT gateway.
</span>    <span class="enscript-comment">// To improve stability of port mappings, RequestedPort is updated any time we get a successful
</span>    <span class="enscript-comment">// mapping response from the PCP, NAT-PMP or UPnP gateway. For example, if we ask for port 80, and
</span>    <span class="enscript-comment">// get assigned port 81, then thereafter we'll contine asking for port 81.
</span>    mDNSInterfaceID InterfaceID;
    mDNSv4Addr ExternalAddress;                     <span class="enscript-comment">// Initially set to onesIPv4Addr, until first callback
</span>    mDNSv4Addr NewAddress;                          <span class="enscript-comment">// May be updated with actual value assigned by gateway
</span>    mDNSIPPort ExternalPort;
    mDNSu32 Lifetime;
    mStatus Result;

    <span class="enscript-comment">// Client API fields: The client must set up these fields *before* making any NAT traversal API calls
</span>    mDNSu8 Protocol;                                <span class="enscript-comment">// NATOp_MapUDP or NATOp_MapTCP, or zero if just requesting the external IP address
</span>    mDNSIPPort IntPort;                             <span class="enscript-comment">// Client's internal port number (doesn't change)
</span>    mDNSIPPort RequestedPort;                       <span class="enscript-comment">// Requested external port; may be updated with actual value assigned by gateway
</span>    mDNSu32 NATLease;                               <span class="enscript-comment">// Requested lifetime in seconds (doesn't change)
</span>    NATTraversalClientCallback clientCallback;
    <span class="enscript-type">void</span>                       *clientContext;
};

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNSServer</span> &amp; <span class="enscript-variable-name">McastResolver</span> <span class="enscript-variable-name">structures</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">constants</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">enum</span>
{
    McastResolver_FlagDelete = 1,
    McastResolver_FlagNew    = 2
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> McastResolver
{
    <span class="enscript-type">struct</span> McastResolver *next;
    mDNSInterfaceID interface;
    mDNSu32 flags;              <span class="enscript-comment">// Set when we're planning to delete this from the list
</span>    domainname domain;
    mDNSu32 timeout;            <span class="enscript-comment">// timeout value for questions
</span>} McastResolver;

<span class="enscript-type">enum</span> {
    Mortality_Mortal      = 0,          <span class="enscript-comment">// This cache record can expire and get purged
</span>    Mortality_Immortal    = 1,          <span class="enscript-comment">// Allow this record to remain in the cache indefinitely
</span>    Mortality_Ghost       = 2           <span class="enscript-comment">// An immortal record that has expired and can linger in the cache
</span>};
<span class="enscript-type">typedef</span> mDNSu8 MortalityState;

<span class="enscript-comment">// ScopeType values for DNSServer matching
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    kScopeNone         = 0,        <span class="enscript-comment">// DNS server used by unscoped questions
</span>    kScopeInterfaceID  = 1,        <span class="enscript-comment">// Scoped DNS server used only by scoped questions
</span>    kScopeServiceID    = 2         <span class="enscript-comment">// Service specific DNS server used only by questions
</span>                                   <span class="enscript-comment">// have a matching serviceID
</span>} ScopeType;

<span class="enscript-type">typedef</span> mDNSu32 DNSServerFlags;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSServerFlag_Delete</span>        (1U &lt;&lt; 0)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SYMPTOMS</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSServerFlag_Unreachable</span>   (1U &lt;&lt; 1)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Note: DNSSECAware is set if we are able to get a valid response to
</span><span class="enscript-comment">// a DNSSEC question. In some cases it is possible that the proxy
</span><span class="enscript-comment">// strips the EDNS0 option and we just get a plain response with no
</span><span class="enscript-comment">// signatures. But we still mark DNSSECAware in that case. As DNSSECAware
</span><span class="enscript-comment">// is only used to determine whether DNSSEC_VALIDATION_SECURE_OPTIONAL
</span><span class="enscript-comment">// should be turned off or not, it is sufficient that we are getting
</span><span class="enscript-comment">// responses back.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> DNSServer
{
    <span class="enscript-type">struct</span> DNSServer *next;
    mDNSInterfaceID interface;  <span class="enscript-comment">// DNS requests should be sent on this interface
</span>    mDNSs32 serviceID;          <span class="enscript-comment">// ServiceID from DNS configuration.
</span>    mDNSAddr addr;              <span class="enscript-comment">// DNS server's IP address.
</span>    DNSServerFlags flags;       <span class="enscript-comment">// Set when we're planning to delete this from the list.
</span>    mDNSs32 penaltyTime;        <span class="enscript-comment">// amount of time this server is penalized
</span>    ScopeType scopeType;        <span class="enscript-comment">// See the ScopeType enum above
</span>    mDNSu32 timeout;            <span class="enscript-comment">// timeout value for questions
</span>    mDNSu32 resGroupID;         <span class="enscript-comment">// ID of the resolver group that contains this DNSServer
</span>    mDNSIPPort port;            <span class="enscript-comment">// DNS server's port number.
</span>    mDNSBool usableA;           <span class="enscript-comment">// True if A query results are usable over the interface, i.e., interface has IPv4.
</span>    mDNSBool usableAAAA;        <span class="enscript-comment">// True if AAAA query results are usable over the interface, i.e., interface has IPv6.
</span>    mDNSBool isCell;            <span class="enscript-comment">// True if the interface to this server is cellular.
</span>    mDNSBool isExpensive;       <span class="enscript-comment">// True if the interface to this server is expensive.
</span>    mDNSBool isConstrained;     <span class="enscript-comment">// True if the interface to this server is constrained.
</span>    mDNSBool isCLAT46;          <span class="enscript-comment">// True if the interface to this server supports CLAT46.
</span>    mDNSBool req_DO;            <span class="enscript-comment">// If set, okay to send DNSSEC queries (EDNS DO bit is supported)
</span>    mDNSBool DNSSECAware;       <span class="enscript-comment">// Set if we are able to receive a response to a request sent with DO option.
</span>    mDNSu8 retransDO;           <span class="enscript-comment">// Total Retransmissions for queries sent with DO option
</span>    domainname domain;          <span class="enscript-comment">// name-&gt;server matching for &quot;split dns&quot;
</span>} DNSServer;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kNegativeRecordType_Unspecified</span> 0 // Initializer of ResourceRecord didn't specify why the record is negative.
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kNegativeRecordType_NoData</span>      1 // The record's name exists, but there are no records of this type.

<span class="enscript-type">struct</span> ResourceRecord_struct
{
    mDNSu8 RecordType;                  <span class="enscript-comment">// See kDNSRecordTypes enum.
</span>    mDNSu8 negativeRecordType;          <span class="enscript-comment">// If RecordType is kDNSRecordTypePacketNegative, specifies type of negative record.
</span>    MortalityState mortality;           <span class="enscript-comment">// Mortality of this resource record (See MortalityState enum)
</span>    mDNSu16 rrtype;                     <span class="enscript-comment">// See DNS_TypeValues enum.
</span>    mDNSu16 rrclass;                    <span class="enscript-comment">// See DNS_ClassValues enum.
</span>    mDNSu32 rroriginalttl;              <span class="enscript-comment">// In seconds
</span>    mDNSu16 rdlength;                   <span class="enscript-comment">// Size of the raw rdata, in bytes, in the on-the-wire format
</span>                                        <span class="enscript-comment">// (In-memory storage may be larger, for structures containing 'holes', like SOA)
</span>    mDNSu16 rdestimate;                 <span class="enscript-comment">// Upper bound on on-the-wire size of rdata after name compression
</span>    mDNSu32 namehash;                   <span class="enscript-comment">// Name-based (i.e. case-insensitive) hash of name
</span>    mDNSu32 rdatahash;                  <span class="enscript-comment">// For rdata containing domain name (e.g. PTR, SRV, CNAME etc.), case-insensitive name hash
</span>                                        <span class="enscript-comment">// else, for all other rdata, 32-bit hash of the raw rdata
</span>                                        <span class="enscript-comment">// Note: This requirement is important. Various routines like AddAdditionalsToResponseList(),
</span>                                        <span class="enscript-comment">// ReconfirmAntecedents(), etc., use rdatahash as a pre-flight check to see
</span>                                        <span class="enscript-comment">// whether it's worth doing a full SameDomainName() call. If the rdatahash
</span>                                        <span class="enscript-comment">// is not a correct case-insensitive name hash, they'll get false negatives.
</span>    <span class="enscript-comment">// Grouping pointers together at the end of the structure improves the memory layout efficiency
</span>    mDNSInterfaceID InterfaceID;        <span class="enscript-comment">// Set if this RR is specific to one interface
</span>                                        <span class="enscript-comment">// For records received off the wire, InterfaceID is *always* set to the receiving interface
</span>                                        <span class="enscript-comment">// For our authoritative records, InterfaceID is usually zero, except for those few records
</span>                                        <span class="enscript-comment">// that are interface-specific (e.g. address records, especially linklocal addresses)
</span>    <span class="enscript-type">const</span> domainname *name;
    RData           *rdata;             <span class="enscript-comment">// Pointer to storage for this rdata
</span>    DNSServer       *rDNSServer;        <span class="enscript-comment">// Unicast DNS server authoritative for this entry; null for multicast
</span>};


<span class="enscript-comment">// Unless otherwise noted, states may apply to either independent record registrations or service registrations
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    regState_Zero              = 0,
    regState_Pending           = 1,     <span class="enscript-comment">// update sent, reply not received
</span>    regState_Registered        = 2,     <span class="enscript-comment">// update sent, reply received
</span>    regState_DeregPending      = 3,     <span class="enscript-comment">// dereg sent, reply not received
</span>    regState_Unregistered      = 4,     <span class="enscript-comment">// not in any list
</span>    regState_Refresh           = 5,     <span class="enscript-comment">// outstanding refresh (or target change) message
</span>    regState_NATMap            = 6,     <span class="enscript-comment">// establishing NAT port mapping
</span>    regState_UpdatePending     = 7,     <span class="enscript-comment">// update in flight as result of mDNS_Update call
</span>    regState_NoTarget          = 8,     <span class="enscript-comment">// SRV Record registration pending registration of hostname
</span>    regState_NATError          = 9     <span class="enscript-comment">// unable to complete NAT traversal
</span>} regState_t;

<span class="enscript-type">enum</span>
{
    Target_Manual = 0,
    Target_AutoHost = 1,
    Target_AutoHostAndNATMAP = 2
};

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mergeState_Zero = 0,
    mergeState_DontMerge = 1  <span class="enscript-comment">// Set on fatal error conditions to disable merging
</span>} mergeState_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AUTH_GROUP_NAME_SIZE</span>    128
<span class="enscript-type">struct</span> AuthGroup_struct             <span class="enscript-comment">// Header object for a list of AuthRecords with the same name
</span>{
    AuthGroup      *next;               <span class="enscript-comment">// Next AuthGroup object in this hash table bucket
</span>    mDNSu32 namehash;                   <span class="enscript-comment">// Name-based (i.e. case insensitive) hash of name
</span>    AuthRecord     *members;            <span class="enscript-comment">// List of CacheRecords with this same name
</span>    AuthRecord    **rrauth_tail;        <span class="enscript-comment">// Tail end of that list
</span>    domainname     *name;               <span class="enscript-comment">// Common name for all AuthRecords in this list
</span>    AuthRecord     *NewLocalOnlyRecords;
    mDNSu8 namestorage[AUTH_GROUP_NAME_SIZE];
};

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">AUTH_HASH_SLOTS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AUTH_HASH_SLOTS</span> 499
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FORALL_AUTHRECORDS</span>(SLOT,AG,AR)                              \
    for ((SLOT) = 0; (SLOT) &lt; AUTH_HASH_SLOTS; (SLOT)++)                                                                     \
        for ((AG)=m-&gt;rrauth.rrauth_hash[(SLOT)]; (AG); (AG)=(AG)-&gt;next)                                                                         \
            for ((AR) = (AG)-&gt;members; (AR); (AR)=(AR)-&gt;next)

<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> AuthEntity_union AuthEntity;
<span class="enscript-type">union</span> AuthEntity_union { AuthEntity *next; AuthGroup ag; };
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    mDNSu32 rrauth_size;                <span class="enscript-comment">// Total number of available auth entries
</span>    mDNSu32 rrauth_totalused;           <span class="enscript-comment">// Number of auth entries currently occupied
</span>    mDNSu32 rrauth_report;
    mDNSu8 rrauth_lock;                 <span class="enscript-comment">// For debugging: Set at times when these lists may not be modified
</span>    AuthEntity *rrauth_free;
    AuthGroup *rrauth_hash[AUTH_HASH_SLOTS];
}AuthHash;

<span class="enscript-comment">// AuthRecordAny includes mDNSInterface_Any and interface specific auth records.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    AuthRecordAny,              <span class="enscript-comment">// registered for *Any, NOT including P2P interfaces
</span>    AuthRecordAnyIncludeP2P,    <span class="enscript-comment">// registered for *Any, including P2P interfaces
</span>    AuthRecordAnyIncludeAWDL,   <span class="enscript-comment">// registered for *Any, including AWDL interface
</span>    AuthRecordAnyIncludeAWDLandP2P, <span class="enscript-comment">// registered for *Any, including AWDL and P2P interfaces
</span>    AuthRecordLocalOnly,
    AuthRecordP2P,              <span class="enscript-comment">// discovered over D2D/P2P framework
</span>} AuthRecType;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">AuthRecordIncludesAWDL</span>(AR) \
    (((AR)-&gt;ARType == AuthRecordAnyIncludeAWDL) || ((AR)-&gt;ARType == AuthRecordAnyIncludeAWDLandP2P))

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    AuthFlagsWakeOnly = 0x1     <span class="enscript-comment">// WakeOnly service
</span>} AuthRecordFlags;

<span class="enscript-type">struct</span> AuthRecord_struct
{
    <span class="enscript-comment">// For examples of how to set up this structure for use in mDNS_Register(),
</span>    <span class="enscript-comment">// see mDNS_AdvertiseInterface() or mDNS_RegisterService().
</span>    <span class="enscript-comment">// Basically, resrec and persistent metadata need to be set up before calling mDNS_Register().
</span>    <span class="enscript-comment">// mDNS_SetupResourceRecord() is avaliable as a helper routine to set up most fields to sensible default values for you
</span>
    AuthRecord     *next;               <span class="enscript-comment">// Next in list; first element of structure for efficiency reasons
</span>    <span class="enscript-comment">// Field Group 1: Common ResourceRecord fields
</span>    ResourceRecord resrec;              <span class="enscript-comment">// 36 bytes when compiling for 32-bit; 48 when compiling for 64-bit (now 44/64)
</span>
    <span class="enscript-comment">// Field Group 2: Persistent metadata for Authoritative Records
</span>    AuthRecord     *Additional1;        <span class="enscript-comment">// Recommended additional record to include in response (e.g. SRV for PTR record)
</span>    AuthRecord     *Additional2;        <span class="enscript-comment">// Another additional (e.g. TXT for PTR record)
</span>    AuthRecord     *DependentOn;        <span class="enscript-comment">// This record depends on another for its uniqueness checking
</span>    AuthRecord     *RRSet;              <span class="enscript-comment">// This unique record is part of an RRSet
</span>    mDNSRecordCallback *RecordCallback; <span class="enscript-comment">// Callback function to call for state changes, and to free memory asynchronously on deregistration
</span>    <span class="enscript-type">void</span>           *RecordContext;      <span class="enscript-comment">// Context parameter for the callback function
</span>    mDNSu8 AutoTarget;                  <span class="enscript-comment">// Set if the target of this record (PTR, CNAME, SRV, etc.) is our host name
</span>    mDNSu8 AllowRemoteQuery;            <span class="enscript-comment">// Set if we allow hosts not on the local link to query this record
</span>    mDNSu8 ForceMCast;                  <span class="enscript-comment">// Set by client to advertise solely via multicast, even for apparently unicast names
</span>    mDNSu8 AuthFlags;

    OwnerOptData WakeUp;                <span class="enscript-comment">// WakeUp.HMAC.l[0] nonzero indicates that this is a Sleep Proxy record
</span>    mDNSAddr AddressProxy;              <span class="enscript-comment">// For reverse-mapping Sleep Proxy PTR records, address in question
</span>    mDNSs32 TimeRcvd;                   <span class="enscript-comment">// In platform time units
</span>    mDNSs32 TimeExpire;                 <span class="enscript-comment">// In platform time units
</span>    AuthRecType ARType;                 <span class="enscript-comment">// LocalOnly, P2P or Normal ?
</span>    mDNSs32 KATimeExpire;               <span class="enscript-comment">// In platform time units: time to send keepalive packet for the proxy record
</span>
    <span class="enscript-comment">// Field Group 3: Transient state for Authoritative Records
</span>    mDNSs32 ProbingConflictCount;       <span class="enscript-comment">// Number of conflicting records observed during probing.
</span>    mDNSs32 LastConflictPktNum;         <span class="enscript-comment">// Number of the last received packet that caused a probing conflict.
</span>    mDNSu8 Acknowledged;                <span class="enscript-comment">// Set if we've given the success callback to the client
</span>    mDNSu8 ProbeRestartCount;           <span class="enscript-comment">// Number of times we have restarted probing
</span>    mDNSu8 ProbeCount;                  <span class="enscript-comment">// Number of probes remaining before this record is valid (kDNSRecordTypeUnique)
</span>    mDNSu8 AnnounceCount;               <span class="enscript-comment">// Number of announcements remaining (kDNSRecordTypeShared)
</span>    mDNSu8 RequireGoodbye;              <span class="enscript-comment">// Set if this RR has been announced on the wire and will require a goodbye packet
</span>    mDNSu8 AnsweredLocalQ;              <span class="enscript-comment">// Set if this AuthRecord has been delivered to any local question (LocalOnly or mDNSInterface_Any)
</span>    mDNSu8 IncludeInProbe;              <span class="enscript-comment">// Set if this RR is being put into a probe right now
</span>    mDNSu8 ImmedUnicast;                <span class="enscript-comment">// Set if we may send our response directly via unicast to the requester
</span>    mDNSInterfaceID SendNSECNow;        <span class="enscript-comment">// Set if we need to generate associated NSEC data for this rrname
</span>    mDNSInterfaceID ImmedAnswer;        <span class="enscript-comment">// Someone on this interface issued a query we need to answer (all-ones for all interfaces)
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_LOG_ANSWER_SUPPRESSION_TIMES</span>
    mDNSs32 ImmedAnswerMarkTime;
#<span class="enscript-reference">endif</span>
    mDNSInterfaceID ImmedAdditional;    <span class="enscript-comment">// Hint that we might want to also send this record, just to be helpful
</span>    mDNSInterfaceID SendRNow;           <span class="enscript-comment">// The interface this query is being sent on right now
</span>    mDNSv4Addr v4Requester;             <span class="enscript-comment">// Recent v4 query for this record, or all-ones if more than one recent query
</span>    mDNSv6Addr v6Requester;             <span class="enscript-comment">// Recent v6 query for this record, or all-ones if more than one recent query
</span>    AuthRecord     *NextResponse;       <span class="enscript-comment">// Link to the next element in the chain of responses to generate
</span>    <span class="enscript-type">const</span> mDNSu8   *NR_AnswerTo;        <span class="enscript-comment">// Set if this record was selected by virtue of being a direct answer to a question
</span>    AuthRecord     *NR_AdditionalTo;    <span class="enscript-comment">// Set if this record was selected by virtue of being additional to another
</span>    mDNSs32 ThisAPInterval;             <span class="enscript-comment">// In platform time units: Current interval for announce/probe
</span>    mDNSs32 LastAPTime;                 <span class="enscript-comment">// In platform time units: Last time we sent announcement/probe
</span>    mDNSs32 LastMCTime;                 <span class="enscript-comment">// Last time we multicast this record (used to guard against packet-storm attacks)
</span>    mDNSInterfaceID LastMCInterface;    <span class="enscript-comment">// Interface this record was multicast on at the time LastMCTime was recorded
</span>    RData          *NewRData;           <span class="enscript-comment">// Set if we are updating this record with new rdata
</span>    mDNSu16 newrdlength;                <span class="enscript-comment">// ... and the length of the new RData
</span>    mDNSRecordUpdateCallback *UpdateCallback;
    mDNSu32 UpdateCredits;              <span class="enscript-comment">// Token-bucket rate limiting of excessive updates
</span>    mDNSs32 NextUpdateCredit;           <span class="enscript-comment">// Time next token is added to bucket
</span>    mDNSs32 UpdateBlocked;              <span class="enscript-comment">// Set if update delaying is in effect
</span>
    <span class="enscript-comment">// Field Group 4: Transient uDNS state for Authoritative Records
</span>    regState_t state;           <span class="enscript-comment">// Maybe combine this with resrec.RecordType state? Right now it's ambiguous and confusing.
</span>                                <span class="enscript-comment">// e.g. rr-&gt;resrec.RecordType can be kDNSRecordTypeUnregistered,
</span>                                <span class="enscript-comment">// and rr-&gt;state can be regState_Unregistered
</span>                                <span class="enscript-comment">// What if we find one of those statements is true and the other false? What does that mean?
</span>    mDNSBool uselease;          <span class="enscript-comment">// dynamic update contains (should contain) lease option
</span>    mDNSs32 expire;             <span class="enscript-comment">// In platform time units: expiration of lease (-1 for static)
</span>    mDNSBool Private;           <span class="enscript-comment">// If zone is private, DNS updates may have to be encrypted to prevent eavesdropping
</span>    mDNSOpaque16 updateid;      <span class="enscript-comment">// Identifier to match update request and response -- also used when transferring records to Sleep Proxy
</span>    mDNSOpaque64 updateIntID;   <span class="enscript-comment">// Interface IDs (one bit per interface index)to which updates have been sent
</span>    <span class="enscript-type">const</span> domainname *zone;     <span class="enscript-comment">// the zone that is updated
</span>    ZoneData  *nta;
    <span class="enscript-type">struct</span> tcpInfo_t *tcp;
    NATTraversalInfo NATinfo;
    mDNSBool SRVChanged;       <span class="enscript-comment">// temporarily deregistered service because its SRV target or port changed
</span>    mergeState_t mState;       <span class="enscript-comment">// Unicast Record Registrations merge state
</span>    mDNSu8 refreshCount;        <span class="enscript-comment">// Number of refreshes to the server
</span>    mStatus updateError;        <span class="enscript-comment">// Record update resulted in Error ?
</span>
    <span class="enscript-comment">// uDNS_UpdateRecord support fields
</span>    <span class="enscript-comment">// Do we really need all these in *addition* to NewRData and newrdlength above?
</span>    <span class="enscript-type">void</span> *UpdateContext;    <span class="enscript-comment">// Context parameter for the update callback function
</span>    mDNSu16 OrigRDLen;      <span class="enscript-comment">// previously registered, being deleted
</span>    mDNSu16 InFlightRDLen;  <span class="enscript-comment">// currently being registered
</span>    mDNSu16 QueuedRDLen;    <span class="enscript-comment">// pending operation (re-transmitting if necessary) THEN register the queued update
</span>    RData *OrigRData;
    RData *InFlightRData;
    RData *QueuedRData;

    <span class="enscript-comment">// Field Group 5: Large data objects go at the end
</span>    domainname namestorage;
    RData rdatastorage;                 <span class="enscript-comment">// Normally the storage is right here, except for oversized records
</span>    <span class="enscript-comment">// rdatastorage MUST be the last thing in the structure -- when using oversized AuthRecords, extra bytes
</span>    <span class="enscript-comment">// are appended after the end of the AuthRecord, logically augmenting the size of the rdatastorage
</span>    <span class="enscript-comment">// DO NOT ADD ANY MORE FIELDS HERE
</span>};

<span class="enscript-comment">// IsLocalDomain alone is not sufficient to determine that a record is mDNS or uDNS. By default domain names within
</span><span class="enscript-comment">// the &quot;local&quot; pseudo-TLD (and within the IPv4 and IPv6 link-local reverse mapping domains) are automatically treated
</span><span class="enscript-comment">// as mDNS records, but it is also possible to force any record (even those not within one of the inherently local
</span><span class="enscript-comment">// domains) to be handled as an mDNS record by setting the ForceMCast flag, or by setting a non-zero InterfaceID.
</span><span class="enscript-comment">// For example, the reverse-mapping PTR record created in AdvertiseInterface sets the ForceMCast flag, since it points to
</span><span class="enscript-comment">// a dot-local hostname, and therefore it would make no sense to register this record with a wide-area Unicast DNS server.
</span><span class="enscript-comment">// The same applies to Sleep Proxy records, which we will answer for when queried via mDNS, but we never want to try
</span><span class="enscript-comment">// to register them with a wide-area Unicast DNS server -- and we probably don't have the required credentials anyway.
</span><span class="enscript-comment">// Currently we have no concept of a wide-area uDNS record scoped to a particular interface, so if the InterfaceID is
</span><span class="enscript-comment">// nonzero we treat this the same as ForceMCast.
</span><span class="enscript-comment">// Note: Question_uDNS(Q) is used in *only* one place -- on entry to mDNS_StartQuery_internal, to decide whether to set TargetQID.
</span><span class="enscript-comment">// Everywhere else in the code, the determination of whether a question is unicast is made by checking to see if TargetQID is nonzero.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">AuthRecord_uDNS</span>(R) ((R)-&gt;resrec.InterfaceID == mDNSInterface_Any &amp;&amp; !(R)-&gt;ForceMCast &amp;&amp; !IsLocalDomain((R)-&gt;resrec.name))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">Question_uDNS</span>(Q)   ((Q)-&gt;IsUnicastDotLocal || (Q)-&gt;ProxyQuestion || \
                            ((Q)-&gt;InterfaceID != mDNSInterface_LocalOnly &amp;&amp; (Q)-&gt;InterfaceID != mDNSInterface_P2P &amp;&amp; (Q)-&gt;InterfaceID != mDNSInterface_BLE &amp;&amp; !(Q)-&gt;ForceMCast &amp;&amp; !IsLocalDomain(&amp;(Q)-&gt;qname)))

<span class="enscript-comment">// AuthRecordLocalOnly records are registered using mDNSInterface_LocalOnly and 
</span><span class="enscript-comment">// AuthRecordP2P records are created by D2DServiceFound events.  Both record types are kept on the same list.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRLocalOnly</span>(rr) ((rr)-&gt;ARType == AuthRecordLocalOnly || (rr)-&gt;ARType == AuthRecordP2P)

<span class="enscript-comment">// All other auth records, not including those defined as RRLocalOnly().
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRAny</span>(rr) ((rr)-&gt;ARType == AuthRecordAny || (rr)-&gt;ARType == AuthRecordAnyIncludeP2P || (rr)-&gt;ARType == AuthRecordAnyIncludeAWDL || (rr)-&gt;ARType == AuthRecordAnyIncludeAWDLandP2P)

<span class="enscript-comment">// Normally we always lookup the cache and /etc/hosts before sending the query on the wire. For single label
</span><span class="enscript-comment">// queries (A and AAAA) that are unqualified (indicated by AppendSearchDomains), we want to append search
</span><span class="enscript-comment">// domains before we try them as such
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">ApplySearchDomainsFirst</span>(q) ((q)-&gt;AppendSearchDomains &amp;&amp; (CountLabels(&amp;((q)-&gt;qname))) == 1)

<span class="enscript-comment">// Wrapper struct for Auth Records for higher-level code that cannot use the AuthRecord's -&gt;next pointer field
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ARListElem
{
    <span class="enscript-type">struct</span> ARListElem *next;
    AuthRecord ar;          <span class="enscript-comment">// Note: Must be last element of structure, to accomodate oversized AuthRecords
</span>} ARListElem;

<span class="enscript-type">struct</span> CacheRecord_struct
{
    CacheRecord    *next;               <span class="enscript-comment">// Next in list; first element of structure for efficiency reasons
</span>    ResourceRecord resrec;              <span class="enscript-comment">// 36 bytes when compiling for 32-bit; 48 when compiling for 64-bit (now 44/64)
</span>
    <span class="enscript-comment">// Transient state for Cache Records
</span>    CacheRecord    *NextInKAList;       <span class="enscript-comment">// Link to the next element in the chain of known answers to send
</span>    mDNSs32 TimeRcvd;                   <span class="enscript-comment">// In platform time units
</span>    mDNSs32 DelayDelivery;              <span class="enscript-comment">// Set if we want to defer delivery of this answer to local clients
</span>    mDNSs32 NextRequiredQuery;          <span class="enscript-comment">// In platform time units
</span>    <span class="enscript-comment">// Extra four bytes here (on 64bit)
</span>    DNSQuestion    *CRActiveQuestion;   <span class="enscript-comment">// Points to an active question referencing this answer. Can never point to a NewQuestion.
</span>    mDNSs32 LastUnansweredTime;         <span class="enscript-comment">// In platform time units; last time we incremented UnansweredQueries
</span>    mDNSu8  UnansweredQueries;          <span class="enscript-comment">// Number of times we've issued a query for this record without getting an answer
</span>    mDNSu8  CRDNSSECQuestion;           <span class="enscript-comment">// Set to 1 if this was created in response to a DNSSEC question
</span>    mDNSOpaque16 responseFlags;         <span class="enscript-comment">// Second 16 bit in the DNS response
</span>    CacheRecord    *NextInCFList;       <span class="enscript-comment">// Set if this is in the list of records we just received with the cache flush bit set
</span>    CacheRecord    *nsec;               <span class="enscript-comment">// NSEC records needed for non-existence proofs
</span>    CacheRecord    *soa;                <span class="enscript-comment">// SOA record to return for proxy questions
</span>
    mDNSAddr sourceAddress;             <span class="enscript-comment">// node from which we received this record
</span>    <span class="enscript-comment">// Size to here is 76 bytes when compiling 32-bit; 104 bytes when compiling 64-bit (now 160 bytes for 64-bit)
</span>    RData_small smallrdatastorage;      <span class="enscript-comment">// Storage for small records is right here (4 bytes header + 68 bytes data = 72 bytes)
</span>};

<span class="enscript-comment">// Should match the CacheGroup_struct members, except namestorage[].  Only used to calculate
</span><span class="enscript-comment">// the size of the namestorage array in CacheGroup_struct so that sizeof(CacheGroup) == sizeof(CacheRecord)
</span><span class="enscript-type">struct</span> CacheGroup_base
{
    CacheGroup     *next;
    mDNSu32         namehash;
    CacheRecord    *members;
    CacheRecord   **rrcache_tail;
    domainname     *name;
};

<span class="enscript-type">struct</span> CacheGroup_struct                <span class="enscript-comment">// Header object for a list of CacheRecords with the same name
</span>{
    CacheGroup     *next;               <span class="enscript-comment">// Next CacheGroup object in this hash table bucket
</span>    mDNSu32         namehash;           <span class="enscript-comment">// Name-based (i.e. case insensitive) hash of name
</span>    CacheRecord    *members;            <span class="enscript-comment">// List of CacheRecords with this same name
</span>    CacheRecord   **rrcache_tail;       <span class="enscript-comment">// Tail end of that list
</span>    domainname     *name;               <span class="enscript-comment">// Common name for all CacheRecords in this list
</span>    mDNSu8 namestorage[<span class="enscript-keyword">sizeof</span>(CacheRecord) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> CacheGroup_base)];  <span class="enscript-comment">// match sizeof(CacheRecord)
</span>};

<span class="enscript-comment">// Storage sufficient to hold either a CacheGroup header or a CacheRecord
</span><span class="enscript-comment">// -- for best efficiency (to avoid wasted unused storage) they should be the same size
</span><span class="enscript-type">typedef</span> <span class="enscript-type">union</span> CacheEntity_union CacheEntity;
<span class="enscript-type">union</span> CacheEntity_union { CacheEntity *next; CacheGroup cg; CacheRecord cr; };

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    CacheRecord r;
    mDNSu8 _extradata[MaximumRDSize-InlineCacheRDSize];     <span class="enscript-comment">// Glue on the necessary number of extra bytes
</span>    domainname namestorage;                                 <span class="enscript-comment">// Needs to go *after* the extra rdata bytes
</span>} LargeCacheRecord;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> HostnameInfo
{
    <span class="enscript-type">struct</span> HostnameInfo *next;
    NATTraversalInfo natinfo;
    domainname fqdn;
    AuthRecord arv4;                          <span class="enscript-comment">// registered IPv4 address record
</span>    AuthRecord arv6;                          <span class="enscript-comment">// registered IPv6 address record
</span>    mDNSRecordCallback *StatusCallback;       <span class="enscript-comment">// callback to deliver success or error code to client layer
</span>    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *StatusContext;                <span class="enscript-comment">// Client Context
</span>} HostnameInfo;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ExtraResourceRecord_struct ExtraResourceRecord;
<span class="enscript-type">struct</span> ExtraResourceRecord_struct
{
    ExtraResourceRecord *next;
    mDNSu32 ClientID;  <span class="enscript-comment">// Opaque ID field to be used by client to map an AddRecord call to a set of Extra records
</span>    AuthRecord r;
    <span class="enscript-comment">// Note: Add any additional fields *before* the AuthRecord in this structure, not at the end.
</span>    <span class="enscript-comment">// In some cases clients can allocate larger chunks of memory and set r-&gt;rdata-&gt;MaxRDLength to indicate
</span>    <span class="enscript-comment">// that this extra memory is available, which would result in any fields after the AuthRecord getting smashed
</span>};

<span class="enscript-comment">// Note: Within an mDNSServiceCallback mDNS all API calls are legal except mDNS_Init(), mDNS_Exit(), mDNS_Execute()
</span><span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSServiceCallback</span> (mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> sr, mStatus result);

<span class="enscript-comment">// A ServiceRecordSet has no special meaning to the core code of the Multicast DNS protocol engine;
</span><span class="enscript-comment">// it is just a convenience structure to group together the records that make up a standard service
</span><span class="enscript-comment">// registration so that they can be allocted and deallocted together as a single memory object.
</span><span class="enscript-comment">// It contains its own ServiceCallback+ServiceContext to report aggregate results up to the next layer of software above.
</span><span class="enscript-comment">// It also contains:
</span><span class="enscript-comment">//  * the basic PTR/SRV/TXT triplet used to represent any DNS-SD service
</span><span class="enscript-comment">//  * the &quot;_services&quot; PTR record for service enumeration
</span><span class="enscript-comment">//  * the optional list of SubType PTR records
</span><span class="enscript-comment">//  * the optional list of additional records attached to the service set (e.g. iChat pictures)
</span>
<span class="enscript-type">struct</span> ServiceRecordSet_struct
{
    <span class="enscript-comment">// These internal state fields are used internally by mDNSCore; the client layer needn't be concerned with them.
</span>    <span class="enscript-comment">// No fields need to be set up by the client prior to calling mDNS_RegisterService();
</span>    <span class="enscript-comment">// all required data is passed as parameters to that function.
</span>    mDNSServiceCallback *ServiceCallback;
    <span class="enscript-type">void</span>                *ServiceContext;
    mDNSBool Conflict;              <span class="enscript-comment">// Set if this record set was forcibly deregistered because of a conflict
</span>
    ExtraResourceRecord *Extras;    <span class="enscript-comment">// Optional list of extra AuthRecords attached to this service registration
</span>    mDNSu32 NumSubTypes;
    AuthRecord          *SubTypes;
    mDNSu32             flags;      <span class="enscript-comment">// saved for subsequent calls to mDNS_RegisterService() if records 
</span>                                    <span class="enscript-comment">// need to be re-registered.
</span>    AuthRecord RR_ADV;              <span class="enscript-comment">// e.g. _services._dns-sd._udp.local. PTR _printer._tcp.local.
</span>    AuthRecord RR_PTR;              <span class="enscript-comment">// e.g. _printer._tcp.local.        PTR Name._printer._tcp.local.
</span>    AuthRecord RR_SRV;              <span class="enscript-comment">// e.g. Name._printer._tcp.local.   SRV 0 0 port target
</span>    AuthRecord RR_TXT;              <span class="enscript-comment">// e.g. Name._printer._tcp.local.   TXT PrintQueueName
</span>    <span class="enscript-comment">// Don't add any fields after AuthRecord RR_TXT.
</span>    <span class="enscript-comment">// This is where the implicit extra space goes if we allocate a ServiceRecordSet containing an oversized RR_TXT record
</span>};

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Question</span> <span class="enscript-variable-name">structures</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// We record the last eight instances of each duplicate query
</span><span class="enscript-comment">// This gives us v4/v6 on each of Ethernet, AirPort and Firewire, and two free slots &quot;for future expansion&quot;
</span><span class="enscript-comment">// If the host has more active interfaces that this it is not fatal -- duplicate question suppression will degrade gracefully.
</span><span class="enscript-comment">// Since we will still remember the last eight, the busiest interfaces will still get the effective duplicate question suppression.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DupSuppressInfoSize</span> 8

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSs32 Time;
    mDNSInterfaceID InterfaceID;
    mDNSs32 Type;                           <span class="enscript-comment">// v4 or v6?
</span>} DupSuppressInfo;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    <span class="enscript-comment">// This is the initial state.
</span>    LLQ_Init = 1,

    <span class="enscript-comment">// All of these states indicate that we are doing DNS Push, and haven't given up yet.
</span>	LLQ_DNSPush_ServerDiscovery = 100,
	LLQ_DNSPush_Connecting      = 101,
	LLQ_DNSPush_Established     = 102,

    <span class="enscript-comment">// All of these states indicate that we are doing LLQ and haven't given up yet.
</span>    LLQ_InitialRequest   = 200,
    LLQ_SecondaryRequest = 201,
    LLQ_Established      = 202,

    <span class="enscript-comment">// If we get here, it means DNS Push isn't available, so we're polling.
</span>    LLQ_Poll                    = 300
} LLQ_State;

<span class="enscript-comment">// LLQ constants
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQ_Vers</span>      1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQ_DefLease</span>  7200 // 2 hours
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQ_MAX_TRIES</span> 3    // retry an operation 3 times max
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQ_INIT_RESEND</span> 2 // resend an un-ack'd packet after 2 seconds, then double for each additional
<span class="enscript-comment">// LLQ Operation Codes
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQOp_Setup</span>     1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQOp_Refresh</span>   2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLLQOp_Event</span>     3

<span class="enscript-comment">// LLQ Errror Codes
</span><span class="enscript-type">enum</span>
{
    LLQErr_NoError    = 0,
    LLQErr_ServFull   = 1,
    LLQErr_Static     = 2,
    LLQErr_FormErr    = 3,
    LLQErr_NoSuchLLQ  = 4,
    LLQErr_BadVers    = 5,
    LLQErr_UnknownErr = 6
};

<span class="enscript-type">enum</span> { NoAnswer_Normal = 0, NoAnswer_Suspended = 1, NoAnswer_Fail = 2 };

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    DNSPushServerDisconnected,
	DNSPushServerConnectFailed,
	DNSPushServerConnectionInProgress,
	DNSPushServerConnected,
	DNSPushServerSessionEstablished,
	DNSPushServerNoDNSPush
} DNSPushServer_ConnectState;

<span class="enscript-type">enum</span> {
    AllowExpired_None = 0,                  <span class="enscript-comment">// Don't allow expired answers or mark answers immortal (behave normally)
</span>    AllowExpired_MakeAnswersImmortal = 1,   <span class="enscript-comment">// Any answers to this question get marked as immortal
</span>    AllowExpired_AllowExpiredAnswers = 2    <span class="enscript-comment">// Allow already expired answers from the cache
</span>};
<span class="enscript-type">typedef</span> mDNSu8 AllowExpiredState;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_LEN</span>    64
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_IPAD</span>   0x36
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HMAC_OPAD</span>   0x5c
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_LEN</span>     16

<span class="enscript-comment">// Internal data structure to maintain authentication information
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> DomainAuthInfo
{
    <span class="enscript-type">struct</span> DomainAuthInfo *next;
    mDNSs32 deltime;                        <span class="enscript-comment">// If we're planning to delete this DomainAuthInfo, the time we want it deleted
</span>    domainname domain;
    domainname keyname;
    domainname hostname;
    mDNSIPPort port;
    <span class="enscript-type">char</span> b64keydata[32];
    mDNSu8 keydata_ipad[HMAC_LEN];              <span class="enscript-comment">// padded key for inner hash rounds
</span>    mDNSu8 keydata_opad[HMAC_LEN];              <span class="enscript-comment">// padded key for outer hash rounds
</span>} DomainAuthInfo;

<span class="enscript-comment">// Note: Within an mDNSQuestionCallback mDNS all API calls are legal except mDNS_Init(), mDNS_Exit(), mDNS_Execute()
</span><span class="enscript-comment">// Note: Any value other than QC_rmv i.e., any non-zero value will result in kDNSServiceFlagsAdd to the application
</span><span class="enscript-comment">// layer. These values are used within mDNSResponder and not sent across to the application. QC_addnocache is for
</span><span class="enscript-comment">// delivering a response without adding to the cache. QC_forceresponse is superset of QC_addnocache where in
</span><span class="enscript-comment">// addition to not entering in the cache, it also forces the negative response through.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { QC_rmv = 0, QC_add, QC_addnocache, QC_forceresponse, QC_dnssec , QC_nodnssec, QC_suppressed } QC_result;
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSQuestionCallback</span> (mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*mDNSQuestionResetHandler)(DNSQuestion *question);
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">AsyncDispatchFunc</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context);
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECAuthInfoFreeCallback</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformDispatchAsync</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context, AsyncDispatchFunc func);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NextQSendTime</span>(Q)  ((Q)-&gt;LastQTime + (Q)-&gt;ThisQInterval)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ActiveQuestion</span>(Q) ((Q)-&gt;ThisQInterval &gt; 0 &amp;&amp; !(Q)-&gt;DuplicateOf)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TimeToSendThisQuestion</span>(Q,time) (ActiveQuestion(Q) &amp;&amp; (time) - NextQSendTime(Q) &gt;= 0)

<span class="enscript-comment">// q-&gt;ValidationStatus is either DNSSECValNotRequired or DNSSECValRequired and then moves onto DNSSECValInProgress.
</span><span class="enscript-comment">// When Validation is done, we mark all &quot;DNSSECValInProgress&quot; questions &quot;DNSSECValDone&quot;. If we are answering
</span><span class="enscript-comment">// questions from /etc/hosts, then we go straight to DNSSECValDone from the initial state.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { DNSSECValNotRequired = 0, DNSSECValRequired, DNSSECValInProgress, DNSSECValDone } DNSSECValState;

<span class="enscript-comment">// ValidationRequired can be set to the following values:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// SECURE validation is set to determine whether something is secure or bogus 
</span><span class="enscript-comment">// INSECURE validation is set internally by dnssec code to indicate that it is currently proving something
</span><span class="enscript-comment">// is insecure
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSEC_VALIDATION_NONE</span>              0x00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSEC_VALIDATION_SECURE</span>            0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSEC_VALIDATION_SECURE_OPTIONAL</span>   0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNSSEC_VALIDATION_INSECURE</span>          0x03

<span class="enscript-comment">// For both ValidationRequired and ValidatingResponse question, we validate DNSSEC responses.
</span><span class="enscript-comment">// For ProxyQuestion with DNSSECOK, we just receive the DNSSEC records to pass them along without
</span><span class="enscript-comment">// validation and if the CD bit is not set, we also validate.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSSECQuestion</span>(q) ((q)-&gt;ValidationRequired || (q)-&gt;ValidatingResponse || ((q)-&gt;ProxyQuestion &amp;&amp; (q)-&gt;ProxyDNSSECOK))

<span class="enscript-comment">// ValidatingQuestion is used when we need to know whether we are validating the DNSSEC responses for a question
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">ValidatingQuestion</span>(q) ((q)-&gt;ValidationRequired || (q)-&gt;ValidatingResponse)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSSECOptionalQuestion</span>(q) ((q)-&gt;ValidationRequired == DNSSEC_VALIDATION_SECURE_OPTIONAL)

<span class="enscript-comment">// Given the resource record and the question, should we follow the CNAME ?
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">FollowCNAME</span>(q, rr, AddRecord)   (AddRecord &amp;&amp; (q)-&gt;qtype != kDNSType_CNAME &amp;&amp; \
                                         (rr)-&gt;RecordType != kDNSRecordTypePacketNegative &amp;&amp; \
                                         (rr)-&gt;rrtype == kDNSType_CNAME)

<span class="enscript-comment">// RFC 4122 defines it to be 16 bytes 
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UUID_SIZE</span>       16

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
<span class="enscript-type">enum</span>
{
    ExpiredAnswer_None = 0,                  <span class="enscript-comment">// No expired answers used
</span>    ExpiredAnswer_Allowed = 1,               <span class="enscript-comment">// An expired answer is allowed by this request
</span>    ExpiredAnswer_AnsweredWithCache = 2,     <span class="enscript-comment">// Question was answered with a cached answer
</span>    ExpiredAnswer_AnsweredWithExpired = 3,   <span class="enscript-comment">// Question was answered with an expired answer
</span>    ExpiredAnswer_ExpiredAnswerChanged = 4,  <span class="enscript-comment">// Expired answer changed on refresh
</span>    
    ExpiredAnswer_EnumCount
};
<span class="enscript-type">typedef</span> mDNSu8 ExpiredAnswerMetric;

<span class="enscript-type">enum</span>
{
    DNSOverTCP_None = 0,                     <span class="enscript-comment">// DNS Over TCP not used
</span>    DNSOverTCP_Truncated = 1,                <span class="enscript-comment">// DNS Over TCP used because UDP reply was truncated
</span>    DNSOverTCP_Suspicious = 2,               <span class="enscript-comment">// DNS Over TCP used because we received a suspicious reply
</span>    DNSOverTCP_SuspiciousDefense = 3,        <span class="enscript-comment">// DNS Over TCP used because we were within the timeframe of a previous suspicious response
</span>
    DNSOverTCP_EnumCount
};
<span class="enscript-type">typedef</span> mDNSu8 DNSOverTCPMetric;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    domainname *        originalQName;          <span class="enscript-comment">// Name of original A/AAAA record if this question is for a CNAME record.
</span>    mDNSu32             querySendCount;         <span class="enscript-comment">// Number of queries that have been sent to DNS servers so far.
</span>    mDNSs32             firstQueryTime;         <span class="enscript-comment">// The time when the first query was sent to a DNS server.
</span>    mDNSBool            answered;               <span class="enscript-comment">// Has this question been answered?
</span>    ExpiredAnswerMetric expiredAnswerState;     <span class="enscript-comment">// Expired answer state (see ExpiredAnswerMetric above)
</span>    DNSOverTCPMetric    dnsOverTCPState;        <span class="enscript-comment">// DNS Over TCP state (see DNSOverTCPMetric above)
</span>
}   uDNSMetrics;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
<span class="enscript-type">extern</span> mDNSu32 curr_num_regservices; <span class="enscript-comment">// tracks the current number of services registered
</span><span class="enscript-type">extern</span> mDNSu32 max_num_regservices;  <span class="enscript-comment">// tracks the max number of simultaneous services registered by the device
</span>#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNS64State.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mDNS_DNSPushNotificationServer DNSPushNotificationServer;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mDNS_DNSPushNotificationZone   DNSPushNotificationZone;

<span class="enscript-type">struct</span> DNSQuestion_struct
{
    <span class="enscript-comment">// Internal state fields. These are used internally by mDNSCore; the client layer needn't be concerned with them.
</span>    DNSQuestion          *next;
    mDNSu32 qnamehash;
    mDNSs32 DelayAnswering;                 <span class="enscript-comment">// Set if we want to defer answering this question until the cache settles
</span>    mDNSs32 LastQTime;                      <span class="enscript-comment">// Last scheduled transmission of this Q on *all* applicable interfaces
</span>    mDNSs32 ThisQInterval;                  <span class="enscript-comment">// LastQTime + ThisQInterval is the next scheduled transmission of this Q
</span>                                            <span class="enscript-comment">// ThisQInterval &gt; 0 for an active question;
</span>                                            <span class="enscript-comment">// ThisQInterval = 0 for a suspended question that's still in the list
</span>                                            <span class="enscript-comment">// ThisQInterval = -1 for a cancelled question (should not still be in list)
</span>    mDNSs32 ExpectUnicastResp;              <span class="enscript-comment">// Set when we send a query with the kDNSQClass_UnicastResponse bit set
</span>    mDNSs32 LastAnswerPktNum;               <span class="enscript-comment">// The sequence number of the last response packet containing an answer to this Q
</span>    mDNSu32 RecentAnswerPkts;               <span class="enscript-comment">// Number of answers since the last time we sent this query
</span>    mDNSu32 CurrentAnswers;                 <span class="enscript-comment">// Number of records currently in the cache that answer this question
</span>    mDNSu32 BrowseThreshold;                <span class="enscript-comment">// If we have received at least this number of answers,
</span>                                            <span class="enscript-comment">// set the next question interval to MaxQuestionInterval
</span>    mDNSu32 LargeAnswers;                   <span class="enscript-comment">// Number of answers with rdata &gt; 1024 bytes
</span>    mDNSu32 UniqueAnswers;                  <span class="enscript-comment">// Number of answers received with kDNSClass_UniqueRRSet bit set
</span>    mDNSInterfaceID FlappingInterface1;     <span class="enscript-comment">// Set when an interface goes away, to flag if remove events are delivered for this Q
</span>    mDNSInterfaceID FlappingInterface2;     <span class="enscript-comment">// Set when an interface goes away, to flag if remove events are delivered for this Q
</span>    DomainAuthInfo       *AuthInfo;         <span class="enscript-comment">// Non-NULL if query is currently being done using Private DNS
</span>    DNSQuestion          *DuplicateOf;
    DNSQuestion          *NextInDQList;
    DupSuppressInfo DupSuppress[DupSuppressInfoSize];
    mDNSInterfaceID SendQNow;               <span class="enscript-comment">// The interface this query is being sent on right now
</span>    mDNSBool SendOnAll;                     <span class="enscript-comment">// Set if we're sending this question on all active interfaces
</span>    mDNSBool CachedAnswerNeedsUpdate;       <span class="enscript-comment">// See SendQueries().  Set if we're sending this question 
</span>                                            <span class="enscript-comment">// because a cached answer needs to be refreshed.
</span>    mDNSu32 RequestUnicast;                 <span class="enscript-comment">// Non-zero if we want to send query with kDNSQClass_UnicastResponse bit set
</span>    mDNSs32 LastQTxTime;                    <span class="enscript-comment">// Last time this Q was sent on one (but not necessarily all) interfaces
</span>    mDNSu32 CNAMEReferrals;                 <span class="enscript-comment">// Count of how many CNAME redirections we've done
</span>    mDNSBool Suppressed;                    <span class="enscript-comment">// This query should be suppressed, i.e., not sent on the wire.
</span>    mDNSu8 LOAddressAnswers;                <span class="enscript-comment">// Number of answers from the local only auth records that are
</span>                                            <span class="enscript-comment">// answering A, AAAA, CNAME, or PTR (/etc/hosts)
</span>    mDNSu8 WakeOnResolveCount;              <span class="enscript-comment">// Number of wakes that should be sent on resolve
</span>    mDNSBool InitialCacheMiss;              <span class="enscript-comment">// True after the question cannot be answered from the cache
</span>    mDNSs32 StopTime;                       <span class="enscript-comment">// Time this question should be stopped by giving them a negative answer
</span>
    <span class="enscript-comment">// DNSSEC fields
</span>    DNSSECValState ValidationState;            <span class="enscript-comment">// Current state of the Validation process
</span>    DNSSECStatus ValidationStatus;             <span class="enscript-comment">// Validation status for &quot;ValidationRequired&quot; questions (dnssec)
</span>    mDNSu8 ValidatingResponse;                 <span class="enscript-comment">// Question trying to validate a response (dnssec) on behalf of
</span>                                               <span class="enscript-comment">// ValidationRequired question
</span>    <span class="enscript-type">void</span> *DNSSECAuthInfo;
    DNSSECAuthInfoFreeCallback *DAIFreeCallback;

    <span class="enscript-comment">// Wide Area fields. These are used internally by the uDNS core (Unicast)
</span>    UDPSocket            *LocalSocket;

    <span class="enscript-comment">// |-&gt; DNS Configuration related fields used in uDNS (Subset of Wide Area/Unicast fields)
</span>    DNSServer            *qDNSServer;       <span class="enscript-comment">// Caching server for this query (in the absence of an SRV saying otherwise)
</span>    mDNSOpaque128 validDNSServers;          <span class="enscript-comment">// Valid DNSServers for this question
</span>    mDNSu16 noServerResponse;               <span class="enscript-comment">// At least one server did not respond.
</span>    mDNSBool triedAllServersOnce;           <span class="enscript-comment">// True if all DNS servers have been tried once.
</span>    mDNSu8 unansweredQueries;               <span class="enscript-comment">// The number of unanswered queries to this server
</span>    AllowExpiredState allowExpired;         <span class="enscript-comment">// Allow expired answers state (see enum AllowExpired_None, etc. above)
</span>
    ZoneData             *nta;              <span class="enscript-comment">// Used for getting zone data for private or LLQ query
</span>    mDNSAddr servAddr;                      <span class="enscript-comment">// Address and port learned from _dns-llq, _dns-llq-tls or _dns-query-tls SRV query
</span>    mDNSIPPort servPort;
    <span class="enscript-type">struct</span> tcpInfo_t *tcp;
    mDNSIPPort tcpSrcPort;                  <span class="enscript-comment">// Local Port TCP packet received on;need this as tcp struct is disposed
</span>                                            <span class="enscript-comment">// by tcpCallback before calling into mDNSCoreReceive
</span>    mDNSu8 NoAnswer;                        <span class="enscript-comment">// Set if we want to suppress answers until tunnel setup has completed
</span>    mDNSBool Restart;                       <span class="enscript-comment">// This question should be restarted soon.
</span>
    <span class="enscript-comment">// LLQ-specific fields. These fields are only meaningful when LongLived flag is set
</span>    LLQ_State state;
    mDNSu32 ReqLease;                       <span class="enscript-comment">// seconds (relative)
</span>    mDNSs32 expire;                         <span class="enscript-comment">// ticks (absolute)
</span>    mDNSs16 ntries;                         <span class="enscript-comment">// for UDP: the number of packets sent for this LLQ state
</span>                                            <span class="enscript-comment">// for TCP: there is some ambiguity in the use of this variable, but in general, it is
</span>                                            <span class="enscript-comment">//          the number of TCP/TLS connection attempts for this LLQ state, or
</span>                                            <span class="enscript-comment">//          the number of packets sent for this TCP/TLS connection
</span>
    <span class="enscript-comment">// DNS Push Notification fields. These fields are only meaningful when LongLived flag is set
</span>    DNSPushNotificationServer *dnsPushServer;
    
    mDNSOpaque64 id;

    <span class="enscript-comment">// DNS Proxy fields
</span>    mDNSOpaque16 responseFlags;             <span class="enscript-comment">// Temporary place holder for the error we get back from the DNS server
</span>                                            <span class="enscript-comment">// till we populate in the cache
</span>    mDNSBool     BlockedByPolicy;           <span class="enscript-comment">// True if the question is blocked by policy rule evaluation.
</span>    mDNSs32      ServiceID;                 <span class="enscript-comment">// Service identifier to match against the DNS server
</span>
    <span class="enscript-comment">// Client API fields: The client must set up these fields *before* calling mDNS_StartQuery()
</span>    mDNSInterfaceID InterfaceID;            <span class="enscript-comment">// Non-zero if you want to issue queries only on a single specific IP interface
</span>    mDNSu32  flags;                         <span class="enscript-comment">// flags from original DNSService*() API request.
</span>    mDNSOpaque16 TargetQID;                 <span class="enscript-comment">// DNS or mDNS message ID.
</span>    domainname qname;
    domainname firstExpiredQname;           <span class="enscript-comment">// first expired qname in request chain
</span>    mDNSu16 qtype;
    mDNSu16 qclass;
    mDNSBool LongLived;                     <span class="enscript-comment">// Set by client for calls to mDNS_StartQuery to indicate LLQs to unicast layer.
</span>    mDNSBool ExpectUnique;                  <span class="enscript-comment">// Set by client if it's expecting unique RR(s) for this question, not shared RRs
</span>    mDNSBool ForceMCast;                    <span class="enscript-comment">// Set by client to force mDNS query, even for apparently uDNS names
</span>    mDNSBool ReturnIntermed;                <span class="enscript-comment">// Set by client to request callbacks for intermediate CNAME/NXDOMAIN results
</span>    mDNSBool SuppressUnusable;              <span class="enscript-comment">// Set by client to suppress unusable queries to be sent on the wire
</span>    mDNSBool TimeoutQuestion;               <span class="enscript-comment">// Timeout this question if there is no reply in configured time
</span>    mDNSBool IsUnicastDotLocal;             <span class="enscript-comment">// True if this is a dot-local query that should be answered via unicast DNS.
</span>    mDNSBool WakeOnResolve;                 <span class="enscript-comment">// Send wakeup on resolve
</span>    mDNSBool UseBackgroundTraffic;          <span class="enscript-comment">// Set by client to use background traffic class for request
</span>    mDNSBool AppendSearchDomains;           <span class="enscript-comment">// Search domains can be appended for this query
</span>    mDNSu8 ValidationRequired;              <span class="enscript-comment">// Requires DNSSEC validation.
</span>    mDNSu8 ProxyQuestion;                   <span class="enscript-comment">// Proxy Question
</span>    mDNSu8 ProxyDNSSECOK;                   <span class="enscript-comment">// Proxy Question with EDNS0 DNSSEC OK bit set
</span>    mDNSs32 pid;                            <span class="enscript-comment">// Process ID of the client that is requesting the question
</span>    mDNSu8  uuid[UUID_SIZE];                <span class="enscript-comment">// Unique ID of the client that is requesting the question (valid only if pid is zero)
</span>    mDNSu32 euid;                           <span class="enscript-comment">// Effective User Id of the client that is requesting the question
</span>    mDNSu32 request_id;                     <span class="enscript-comment">// The ID of request that generates the current question
</span>    mDNSQuestionCallback *QuestionCallback;
    mDNSQuestionResetHandler ResetHandler;
    <span class="enscript-type">void</span>                 *QuestionContext;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    mDNSOpaque16 LastTargetQID;             <span class="enscript-comment">// Last used QID, to help determine suspicion with valid in-flight replies.
</span>#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">METRICS</span>)
    uDNSMetrics metrics;                    <span class="enscript-comment">// Data used for collecting unicast DNS query metrics.
</span>#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">DNS64</span>)
    DNS64 dns64;                            <span class="enscript-comment">// DNS64 state for performing IPv6 address synthesis on networks with NAT64.
</span>#<span class="enscript-reference">endif</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { ZoneServiceUpdate, ZoneServiceQuery, ZoneServiceLLQ, ZoneServiceDNSPush } ZoneService;

<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ZoneDataCallback</span> (mDNS *<span class="enscript-type">const</span> m, mStatus err, <span class="enscript-type">const</span> ZoneData *result);

<span class="enscript-type">struct</span> ZoneData_struct
{
    domainname ChildName;               <span class="enscript-comment">// Name for which we're trying to find the responsible server
</span>    ZoneService ZoneService;            <span class="enscript-comment">// Which service we're seeking for this zone (update, query, or LLQ)
</span>    domainname       *CurrentSOA;       <span class="enscript-comment">// Points to somewhere within ChildName
</span>    domainname ZoneName;                <span class="enscript-comment">// Discovered result: Left-hand-side of SOA record
</span>    mDNSu16 ZoneClass;                  <span class="enscript-comment">// Discovered result: DNS Class from SOA record
</span>    domainname Host;                    <span class="enscript-comment">// Discovered result: Target host from SRV record
</span>    mDNSIPPort Port;                    <span class="enscript-comment">// Discovered result: Update port, query port, or LLQ port from SRV record
</span>    mDNSAddr Addr;                      <span class="enscript-comment">// Discovered result: Address of Target host from SRV record
</span>    mDNSBool ZonePrivate;               <span class="enscript-comment">// Discovered result: Does zone require encrypted queries?
</span>    ZoneDataCallback *ZoneDataCallback; <span class="enscript-comment">// Caller-specified function to be called upon completion
</span>    <span class="enscript-type">void</span>             *ZoneDataContext;
    DNSQuestion question;               <span class="enscript-comment">// Storage for any active question
</span>};

<span class="enscript-type">extern</span> ZoneData *<span class="enscript-function-name">StartGetZoneData</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> ZoneService target, ZoneDataCallback callback, <span class="enscript-type">void</span> *callbackInfo);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">CancelGetZoneData</span>(mDNS *<span class="enscript-type">const</span> m, ZoneData *nta);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">IsGetZoneDataQuestion</span>(DNSQuestion *q);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> DNameListElem
{
    <span class="enscript-type">struct</span> DNameListElem *next;
    mDNSu32 uid;
    domainname name;
} DNameListElem;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-comment">// Different states that we go through locating the peer
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TC_STATE_AAAA_PEER</span>          0x000000001     <span class="enscript-comment">/* Peer's BTMM IPv6 address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TC_STATE_AAAA_PEER_RELAY</span>    0x000000002     <span class="enscript-comment">/* Peer's IPv6 Relay address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TC_STATE_SRV_PEER</span>           0x000000003     <span class="enscript-comment">/* Peer's SRV Record corresponding to IPv4 address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TC_STATE_ADDR_PEER</span>          0x000000004     <span class="enscript-comment">/* Peer's IPv4 address */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ClientTunnel
{
    <span class="enscript-type">struct</span> ClientTunnel *next;
    domainname dstname;
    mDNSBool MarkedForDeletion;
    mDNSv6Addr loc_inner;
    mDNSv4Addr loc_outer;
    mDNSv6Addr loc_outer6;
    mDNSv6Addr rmt_inner;
    mDNSv4Addr rmt_outer;
    mDNSv6Addr rmt_outer6;
    mDNSIPPort rmt_outer_port;
    mDNSu16 tc_state;
    DNSQuestion q;
} ClientTunnel;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">NetworkInterfaceInfo_struct</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> NetworkInterfaceInfo_struct NetworkInterfaceInfo;

<span class="enscript-comment">// A NetworkInterfaceInfo_struct serves two purposes:
</span><span class="enscript-comment">// 1. It holds the address, PTR and HINFO records to advertise a given IP address on a given physical interface
</span><span class="enscript-comment">// 2. It tells mDNSCore which physical interfaces are available; each physical interface has its own unique InterfaceID.
</span><span class="enscript-comment">//    Since there may be multiple IP addresses on a single physical interface,
</span><span class="enscript-comment">//    there may be multiple NetworkInterfaceInfo_structs with the same InterfaceID.
</span><span class="enscript-comment">//    In this case, to avoid sending the same packet n times, when there's more than one
</span><span class="enscript-comment">//    struct with the same InterfaceID, mDNSCore picks one member of the set to be the
</span><span class="enscript-comment">//    active representative of the set; all others have the 'InterfaceActive' flag unset.
</span>
<span class="enscript-type">struct</span> NetworkInterfaceInfo_struct
{
    <span class="enscript-comment">// Internal state fields. These are used internally by mDNSCore; the client layer needn't be concerned with them.
</span>    NetworkInterfaceInfo *next;

    mDNSu8 InterfaceActive;             <span class="enscript-comment">// Set if interface is sending &amp; receiving packets (see comment above)
</span>    mDNSu8 IPv4Available;               <span class="enscript-comment">// If InterfaceActive, set if v4 available on this InterfaceID
</span>    mDNSu8 IPv6Available;               <span class="enscript-comment">// If InterfaceActive, set if v6 available on this InterfaceID
</span>
    DNSQuestion NetWakeBrowse;
    DNSQuestion NetWakeResolve[3];      <span class="enscript-comment">// For fault-tolerance, we try up to three Sleep Proxies
</span>    mDNSAddr SPSAddr[3];
    mDNSIPPort SPSPort[3];
    mDNSs32 NextSPSAttempt;             <span class="enscript-comment">// -1 if we're not currently attempting to register with any Sleep Proxy
</span>    mDNSs32 NextSPSAttemptTime;

    <span class="enscript-comment">// Standard AuthRecords that every Responder host should have (one per active IP address)
</span>    AuthRecord RR_A;                    <span class="enscript-comment">// 'A' or 'AAAA' (address) record for our &quot;.local&quot; name
</span>    AuthRecord RR_PTR;                  <span class="enscript-comment">// PTR (reverse lookup) record
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    AuthRecord RR_AddrRand;             <span class="enscript-comment">// For non-AWDL interfaces, this is the A or AAAA record of the randomized hostname.
</span>#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Client API fields: The client must set up these fields *before* calling mDNS_RegisterInterface()
</span>    mDNSInterfaceID InterfaceID;        <span class="enscript-comment">// Identifies physical interface; MUST NOT be 0, -1, or -2
</span>    mDNSAddr ip;                        <span class="enscript-comment">// The IPv4 or IPv6 address to advertise
</span>    mDNSAddr mask;
    mDNSEthAddr MAC;
    <span class="enscript-type">char</span> ifname[64];                    <span class="enscript-comment">// Windows uses a GUID string for the interface name, which doesn't fit in 16 bytes
</span>    mDNSu8 Advertise;                   <span class="enscript-comment">// False if you are only searching on this interface
</span>    mDNSu8 McastTxRx;                   <span class="enscript-comment">// Send/Receive multicast on this { InterfaceID, address family } ?
</span>    mDNSu8 NetWake;                     <span class="enscript-comment">// Set if Wake-On-Magic-Packet is enabled on this interface
</span>    mDNSu8 Loopback;                    <span class="enscript-comment">// Set if this is the loopback interface
</span>    mDNSu8 IgnoreIPv4LL;                <span class="enscript-comment">// Set if IPv4 Link-Local addresses have to be ignored.
</span>    mDNSu8 SendGoodbyes;                <span class="enscript-comment">// Send goodbyes on this interface while sleeping
</span>    mDNSBool DirectLink;                <span class="enscript-comment">// a direct link, indicating we can skip the probe for
</span>                                        <span class="enscript-comment">// address records
</span>    mDNSBool SupportsUnicastMDNSResponse;  <span class="enscript-comment">// Indicates that the interface supports unicast responses
</span>                                        <span class="enscript-comment">// to Bonjour queries.  Generally true for an interface.  
</span>};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLE_DELETE</span>                      0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLE_WAB_BROWSE_QUERY_STARTED</span>    0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLE_WAB_LBROWSE_QUERY_STARTED</span>   0x00000004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLE_WAB_REG_QUERY_STARTED</span>       0x00000008

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> SearchListElem
{
    <span class="enscript-type">struct</span> SearchListElem *next;
    domainname domain;
    <span class="enscript-type">int</span> flag;
    mDNSInterfaceID InterfaceID;
    DNSQuestion BrowseQ;
    DNSQuestion DefBrowseQ;
    DNSQuestion AutomaticBrowseQ;
    DNSQuestion RegisterQ;
    DNSQuestion DefRegisterQ;
    <span class="enscript-type">int</span> numCfAnswers;
    ARListElem *AuthRecs;
} SearchListElem;

<span class="enscript-comment">// For domain enumeration and automatic browsing
</span><span class="enscript-comment">// This is the user's DNS search list.
</span><span class="enscript-comment">// In each of these domains we search for our special pointer records (lb._dns-sd._udp.&lt;domain&gt;, etc.)
</span><span class="enscript-comment">// to discover recommended domains for domain enumeration (browse, default browse, registration,
</span><span class="enscript-comment">// default registration) and possibly one or more recommended automatic browsing domains.
</span><span class="enscript-type">extern</span> SearchListElem *SearchList;      <span class="enscript-comment">// This really ought to be part of mDNS_struct -- SC
</span>
<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Main</span> <span class="enscript-variable-name">mDNS</span> <span class="enscript-variable-name">object</span>, <span class="enscript-variable-name">used</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">hold</span> <span class="enscript-variable-name">all</span> <span class="enscript-variable-name">the</span> <span class="enscript-variable-name">mDNS</span> <span class="enscript-variable-name">state</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCallback</span> (mDNS *<span class="enscript-type">const</span> m, mStatus result);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CACHE_HASH_SLOTS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CACHE_HASH_SLOTS</span> 499
#<span class="enscript-reference">endif</span>

<span class="enscript-type">enum</span>
{
    SleepState_Awake = 0,
    SleepState_Transferring = 1,
    SleepState_Sleeping = 2
};

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    kStatsActionIncrement,
    kStatsActionDecrement,
    kStatsActionClear,
    kStatsActionSet
} DNSSECStatsAction;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    kStatsTypeMemoryUsage,
    kStatsTypeLatency,
    kStatsTypeExtraPackets,
    kStatsTypeStatus,
    kStatsTypeProbe,
    kStatsTypeMsgSize
} DNSSECStatsType;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu32 TotalMemUsed;
    mDNSu32 Latency0;           <span class="enscript-comment">// 0 to 4 ms
</span>    mDNSu32 Latency5;           <span class="enscript-comment">// 5 to  9 ms
</span>    mDNSu32 Latency10;          <span class="enscript-comment">// 10 to 19 ms
</span>    mDNSu32 Latency20;          <span class="enscript-comment">// 20 to 49 ms
</span>    mDNSu32 Latency50;          <span class="enscript-comment">// 50 to 99 ms
</span>    mDNSu32 Latency100;         <span class="enscript-comment">// &gt;= 100 ms
</span>    mDNSu32 ExtraPackets0;      <span class="enscript-comment">// 0 to 2 packets
</span>    mDNSu32 ExtraPackets3;      <span class="enscript-comment">// 3 to 6 packets
</span>    mDNSu32 ExtraPackets7;      <span class="enscript-comment">// 7 to 9 packets
</span>    mDNSu32 ExtraPackets10;     <span class="enscript-comment">// &gt;= 10 packets
</span>    mDNSu32 SecureStatus;
    mDNSu32 InsecureStatus;
    mDNSu32 IndeterminateStatus;
    mDNSu32 BogusStatus;
    mDNSu32 NoResponseStatus;
    mDNSu32 NumProbesSent;      <span class="enscript-comment">// Number of probes sent
</span>    mDNSu32 MsgSize0;           <span class="enscript-comment">// DNSSEC message size &lt;= 1024
</span>    mDNSu32 MsgSize1;           <span class="enscript-comment">// DNSSEC message size &lt;= 2048
</span>    mDNSu32 MsgSize2;           <span class="enscript-comment">// DNSSEC message size &gt; 2048
</span>} DNSSECStatistics;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu32 NameConflicts;                  <span class="enscript-comment">// Normal Name conflicts
</span>    mDNSu32 KnownUniqueNameConflicts;       <span class="enscript-comment">// Name Conflicts for KnownUnique Records
</span>    mDNSu32 DupQuerySuppressions;           <span class="enscript-comment">// Duplicate query suppressions
</span>    mDNSu32 KnownAnswerSuppressions;        <span class="enscript-comment">// Known Answer suppressions
</span>    mDNSu32 KnownAnswerMultiplePkts;        <span class="enscript-comment">// Known Answer in queries spannign multiple packets
</span>    mDNSu32 PoofCacheDeletions;             <span class="enscript-comment">// Number of times the cache was deleted due to POOF
</span>    mDNSu32 UnicastBitInQueries;            <span class="enscript-comment">// Queries with QU bit set
</span>    mDNSu32 NormalQueries;                  <span class="enscript-comment">// Queries with QU bit not set
</span>    mDNSu32 MatchingAnswersForQueries;      <span class="enscript-comment">// Queries for which we had a response
</span>    mDNSu32 UnicastResponses;               <span class="enscript-comment">// Unicast responses to queries
</span>    mDNSu32 MulticastResponses;             <span class="enscript-comment">// Multicast responses to queries
</span>    mDNSu32 UnicastDemotedToMulticast;      <span class="enscript-comment">// Number of times unicast demoted to multicast
</span>    mDNSu32 Sleeps;                         <span class="enscript-comment">// Total sleeps
</span>    mDNSu32 Wakes;                          <span class="enscript-comment">// Total wakes
</span>    mDNSu32 InterfaceUp;                    <span class="enscript-comment">// Total Interface UP events
</span>    mDNSu32 InterfaceUpFlap;                <span class="enscript-comment">// Total Interface UP events with flaps
</span>    mDNSu32 InterfaceDown;                  <span class="enscript-comment">// Total Interface Down events
</span>    mDNSu32 InterfaceDownFlap;              <span class="enscript-comment">// Total Interface Down events with flaps
</span>    mDNSu32 CacheRefreshQueries;            <span class="enscript-comment">// Number of queries that we sent for refreshing cache
</span>    mDNSu32 CacheRefreshed;                 <span class="enscript-comment">// Number of times the cache was refreshed due to a response
</span>    mDNSu32 WakeOnResolves;                 <span class="enscript-comment">// Number of times we did a wake on resolve
</span>} mDNSStatistics;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">LogMDNSStatisticsToFD</span>(<span class="enscript-type">int</span> fd, mDNS *<span class="enscript-type">const</span> m);

<span class="enscript-comment">// Time constant (~= 260 hours ~= 10 days and 21 hours) used to set
</span><span class="enscript-comment">// various time values to a point well into the future.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FutureTime</span>   0x38000000

<span class="enscript-type">struct</span> mDNS_struct
{
    <span class="enscript-comment">// Internal state fields. These hold the main internal state of mDNSCore;
</span>    <span class="enscript-comment">// the client layer needn't be concerned with them.
</span>    <span class="enscript-comment">// No fields need to be set up by the client prior to calling mDNS_Init();
</span>    <span class="enscript-comment">// all required data is passed as parameters to that function.
</span>
    mDNS_PlatformSupport *p;            <span class="enscript-comment">// Pointer to platform-specific data of indeterminite size
</span>    mDNSs32 NetworkChanged;
    mDNSBool CanReceiveUnicastOn5353;
    mDNSBool AdvertiseLocalAddresses;
    mDNSBool DivertMulticastAdvertisements; <span class="enscript-comment">// from interfaces that do not advertise local addresses to local-only
</span>    mStatus mDNSPlatformStatus;
    mDNSIPPort UnicastPort4;
    mDNSIPPort UnicastPort6;
    mDNSEthAddr PrimaryMAC;             <span class="enscript-comment">// Used as unique host ID
</span>    mDNSCallback *MainCallback;
    <span class="enscript-type">void</span>         *MainContext;

    <span class="enscript-comment">// For debugging: To catch and report locking failures
</span>    mDNSu32 mDNS_busy;                  <span class="enscript-comment">// Incremented between mDNS_Lock/mDNS_Unlock section
</span>    mDNSu32 mDNS_reentrancy;            <span class="enscript-comment">// Incremented when calling a client callback
</span>    mDNSu8 lock_rrcache;                <span class="enscript-comment">// For debugging: Set at times when these lists may not be modified
</span>    mDNSu8 lock_Questions;
    mDNSu8 lock_Records;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MaxMsg</span>
    #define MaxMsg 512
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">char</span> MsgBuffer[MaxMsg];             <span class="enscript-comment">// Temp storage used while building error log messages
</span>
    <span class="enscript-comment">// Task Scheduling variables
</span>    mDNSs32 timenow_adjust;             <span class="enscript-comment">// Correction applied if we ever discover time went backwards
</span>    mDNSs32 timenow;                    <span class="enscript-comment">// The time that this particular activation of the mDNS code started
</span>    mDNSs32 timenow_last;               <span class="enscript-comment">// The time the last time we ran
</span>    mDNSs32 NextScheduledEvent;         <span class="enscript-comment">// Derived from values below
</span>    mDNSs32 ShutdownTime;               <span class="enscript-comment">// Set when we're shutting down; allows us to skip some unnecessary steps
</span>    mDNSs32 SuppressSending;            <span class="enscript-comment">// Don't send local-link mDNS packets during this time
</span>    mDNSs32 NextCacheCheck;             <span class="enscript-comment">// Next time to refresh cache record before it expires
</span>    mDNSs32 NextScheduledQuery;         <span class="enscript-comment">// Next time to send query in its exponential backoff sequence
</span>    mDNSs32 NextScheduledProbe;         <span class="enscript-comment">// Next time to probe for new authoritative record
</span>    mDNSs32 NextScheduledResponse;      <span class="enscript-comment">// Next time to send authoritative record(s) in responses
</span>    mDNSs32 NextScheduledNATOp;         <span class="enscript-comment">// Next time to send NAT-traversal packets
</span>    mDNSs32 NextScheduledSPS;           <span class="enscript-comment">// Next time to purge expiring Sleep Proxy records
</span>    mDNSs32 NextScheduledKA;            <span class="enscript-comment">// Next time to send Keepalive packets (SPS)
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    mDNSs32 NextBonjourDisableTime;     <span class="enscript-comment">// Next time to leave multicast group if Bonjour on Demand is enabled
</span>    mDNSu8 BonjourEnabled;              <span class="enscript-comment">// Non zero if Bonjour is currently enabled by the Bonjour on Demand logic
</span>#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
    mDNSs32 NextSuspiciousTimeout;      <span class="enscript-comment">// Time until suspicious reply defense will timeout
</span>#<span class="enscript-reference">endif</span>
    mDNSs32 RandomQueryDelay;           <span class="enscript-comment">// For de-synchronization of query packets on the wire
</span>    mDNSu32 RandomReconfirmDelay;       <span class="enscript-comment">// For de-synchronization of reconfirmation queries on the wire
</span>    mDNSs32 PktNum;                     <span class="enscript-comment">// Unique sequence number assigned to each received packet
</span>    mDNSs32 MPktNum;                    <span class="enscript-comment">// Unique sequence number assigned to each received Multicast packet
</span>    mDNSu8 LocalRemoveEvents;           <span class="enscript-comment">// Set if we may need to deliver remove events for local-only questions and/or local-only records
</span>    mDNSu8 SleepState;                  <span class="enscript-comment">// Set if we're sleeping
</span>    mDNSu8 SleepSeqNum;                 <span class="enscript-comment">// &quot;Epoch number&quot; of our current period of wakefulness
</span>    mDNSu8 SystemWakeOnLANEnabled;      <span class="enscript-comment">// Set if we want to register with a Sleep Proxy before going to sleep
</span>    mDNSu8 SentSleepProxyRegistration;  <span class="enscript-comment">// Set if we registered (or tried to register) with a Sleep Proxy
</span>    mDNSu8 SystemSleepOnlyIfWakeOnLAN;  <span class="enscript-comment">// Set if we may only sleep if we managed to register with a Sleep Proxy
</span>    mDNSs32 AnnounceOwner;              <span class="enscript-comment">// After waking from sleep, include OWNER option in packets until this time
</span>    mDNSs32 DelaySleep;                 <span class="enscript-comment">// To inhibit re-sleeping too quickly right after wake
</span>    mDNSs32 SleepLimit;                 <span class="enscript-comment">// Time window to allow deregistrations, etc.,
</span>                                        <span class="enscript-comment">// during which underying platform layer should inhibit system sleep
</span>    mDNSs32 TimeSlept;                  <span class="enscript-comment">// Time we went to sleep.
</span>
    mDNSs32 UnicastPacketsSent;         <span class="enscript-comment">// Number of unicast packets sent.
</span>    mDNSs32 MulticastPacketsSent;       <span class="enscript-comment">// Number of multicast packets sent.
</span>    mDNSs32 RemoteSubnet;               <span class="enscript-comment">// Multicast packets received from outside our subnet.
</span>
    mDNSs32 NextScheduledSPRetry;       <span class="enscript-comment">// Time next sleep proxy registration action is required.
</span>                                        <span class="enscript-comment">// Only valid if SleepLimit is nonzero and DelaySleep is zero.
</span>
    mDNSs32 NextScheduledStopTime;      <span class="enscript-comment">// Next time to stop a question
</span>
    mDNSs32 NextBLEServiceTime;         <span class="enscript-comment">// Next time to call the BLE discovery management layer.  Non zero when active.
</span>
    <span class="enscript-comment">// These fields only required for mDNS Searcher...
</span>    DNSQuestion *Questions;             <span class="enscript-comment">// List of all registered questions, active and inactive
</span>    DNSQuestion *NewQuestions;          <span class="enscript-comment">// Fresh questions not yet answered from cache
</span>    DNSQuestion *CurrentQuestion;       <span class="enscript-comment">// Next question about to be examined in AnswerLocalQuestions()
</span>    DNSQuestion *LocalOnlyQuestions;    <span class="enscript-comment">// Questions with InterfaceID set to mDNSInterface_LocalOnly or mDNSInterface_P2P
</span>    DNSQuestion *NewLocalOnlyQuestions; <span class="enscript-comment">// Fresh local-only or P2P questions not yet answered
</span>    DNSQuestion *RestartQuestion;       <span class="enscript-comment">// Questions that are being restarted (stop followed by start)
</span>    DNSQuestion *ValidationQuestion;    <span class="enscript-comment">// Questions that are being validated (dnssec)
</span>    mDNSu32 rrcache_size;               <span class="enscript-comment">// Total number of available cache entries
</span>    mDNSu32 rrcache_totalused;          <span class="enscript-comment">// Number of cache entries currently occupied
</span>    mDNSu32 rrcache_totalused_unicast;  <span class="enscript-comment">// Number of cache entries currently occupied by unicast
</span>    mDNSu32 rrcache_active;             <span class="enscript-comment">// Number of cache entries currently occupied by records that answer active questions
</span>    mDNSu32 rrcache_report;
    CacheEntity *rrcache_free;
    CacheGroup *rrcache_hash[CACHE_HASH_SLOTS];
    mDNSs32 rrcache_nextcheck[CACHE_HASH_SLOTS];

    AuthHash rrauth;

    <span class="enscript-comment">// Fields below only required for mDNS Responder...
</span>    domainlabel nicelabel;              <span class="enscript-comment">// Rich text label encoded using canonically precomposed UTF-8
</span>    domainlabel hostlabel;              <span class="enscript-comment">// Conforms to RFC 1034 &quot;letter-digit-hyphen&quot; ARPANET host name rules
</span>    domainname MulticastHostname;       <span class="enscript-comment">// Fully Qualified &quot;dot-local&quot; Host Name, e.g. &quot;Foo.local.&quot;
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
    domainname RandomizedHostname;      <span class="enscript-comment">// Randomized hostname to use for services involving AWDL interfaces. This is to
</span>                                        <span class="enscript-comment">// avoid using a hostname derived from the device's name, which may contain the
</span>                                        <span class="enscript-comment">// owner's real name, (e.g., &quot;Steve's iPhone&quot; -&gt; &quot;Steves-iPhone.local&quot;), which is a
</span>                                        <span class="enscript-comment">// privacy concern.
</span>    mDNSu32 AutoTargetAWDLIncludedCount;<span class="enscript-comment">// Number of registered AWDL-included auto-target records.
</span>    mDNSu32 AutoTargetAWDLOnlyCount;    <span class="enscript-comment">// Number of registered AWDL-only auto-target records.
</span>#<span class="enscript-reference">endif</span>
    UTF8str255 HIHardware;
    UTF8str255 HISoftware;
    AuthRecord DeviceInfo;
    AuthRecord *ResourceRecords;
    AuthRecord *DuplicateRecords;       <span class="enscript-comment">// Records currently 'on hold' because they are duplicates of existing records
</span>    AuthRecord *NewLocalRecords;        <span class="enscript-comment">// Fresh AuthRecords (public) not yet delivered to our local-only questions
</span>    AuthRecord *CurrentRecord;          <span class="enscript-comment">// Next AuthRecord about to be examined
</span>    mDNSBool NewLocalOnlyRecords;       <span class="enscript-comment">// Fresh AuthRecords (local only) not yet delivered to our local questions
</span>    NetworkInterfaceInfo *HostInterfaces;
    mDNSs32 ProbeFailTime;
    mDNSu32 NumFailedProbes;
    mDNSs32 SuppressProbes;
    Platform_t mDNS_plat;               <span class="enscript-comment">// Why is this here in the only required for mDNS Responder section? -- SC
</span>
    <span class="enscript-comment">// Unicast-specific data
</span>    mDNSs32 NextuDNSEvent;                  <span class="enscript-comment">// uDNS next event
</span>    mDNSs32 NextSRVUpdate;                  <span class="enscript-comment">// Time to perform delayed update
</span>
    DNSServer        *DNSServers;           <span class="enscript-comment">// list of DNS servers
</span>    McastResolver    *McastResolvers;       <span class="enscript-comment">// list of Mcast Resolvers
</span>
    mDNSAddr Router;
    mDNSAddr AdvertisedV4;                  <span class="enscript-comment">// IPv4 address pointed to by hostname
</span>    mDNSAddr AdvertisedV6;                  <span class="enscript-comment">// IPv6 address pointed to by hostname
</span>
    DomainAuthInfo   *AuthInfoList;         <span class="enscript-comment">// list of domains requiring authentication for updates
</span>
    DNSQuestion ReverseMap;                 <span class="enscript-comment">// Reverse-map query to find static hostname for service target
</span>    DNSQuestion AutomaticBrowseDomainQ;
    domainname StaticHostname;              <span class="enscript-comment">// Current answer to reverse-map query
</span>    domainname FQDN;
    HostnameInfo     *Hostnames;            <span class="enscript-comment">// List of registered hostnames + hostname metadata
</span>
    mDNSu32 WABBrowseQueriesCount;          <span class="enscript-comment">// Number of WAB Browse domain enumeration queries (b, db) callers
</span>    mDNSu32 WABLBrowseQueriesCount;         <span class="enscript-comment">// Number of legacy WAB Browse domain enumeration queries (lb) callers
</span>    mDNSu32 WABRegQueriesCount;             <span class="enscript-comment">// Number of WAB Registration domain enumeration queries (r, dr) callers
</span>    mDNSu8 SearchDomainsHash[MD5_LEN];

    <span class="enscript-comment">// NAT-Traversal fields
</span>    NATTraversalInfo LLQNAT;                    <span class="enscript-comment">// Single shared NAT Traversal to receive inbound LLQ notifications
</span>    NATTraversalInfo *NATTraversals;
    NATTraversalInfo *CurrentNATTraversal;
    mDNSs32 retryIntervalGetAddr;               <span class="enscript-comment">// delta between time sent and retry for NAT-PMP &amp; UPnP/IGD external address request
</span>    mDNSs32 retryGetAddr;                       <span class="enscript-comment">// absolute time when we retry for NAT-PMP &amp; UPnP/IGD external address request
</span>    mDNSv4Addr ExtAddress;                      <span class="enscript-comment">// the external address discovered via NAT-PMP or UPnP/IGD
</span>    mDNSu32 PCPNonce[3];                        <span class="enscript-comment">// the nonce if using PCP
</span>
    UDPSocket        *NATMcastRecvskt;          <span class="enscript-comment">// For receiving PCP &amp; NAT-PMP announcement multicasts from router on port 5350
</span>    mDNSu32 LastNATupseconds;                   <span class="enscript-comment">// NAT engine uptime in seconds, from most recent NAT packet
</span>    mDNSs32 LastNATReplyLocalTime;              <span class="enscript-comment">// Local time in ticks when most recent NAT packet was received
</span>    mDNSu16 LastNATMapResultCode;               <span class="enscript-comment">// Most recent error code for mappings
</span>
    tcpLNTInfo tcpAddrInfo;                     <span class="enscript-comment">// legacy NAT traversal TCP connection info for external address
</span>    tcpLNTInfo tcpDeviceInfo;                   <span class="enscript-comment">// legacy NAT traversal TCP connection info for device info
</span>    tcpLNTInfo       *tcpInfoUnmapList;         <span class="enscript-comment">// list of pending unmap requests
</span>    mDNSInterfaceID UPnPInterfaceID;
    UDPSocket        *SSDPSocket;               <span class="enscript-comment">// For SSDP request/response
</span>    mDNSBool SSDPWANPPPConnection;              <span class="enscript-comment">// whether we should send the SSDP query for WANIPConnection or WANPPPConnection
</span>    mDNSIPPort UPnPRouterPort;                  <span class="enscript-comment">// port we send discovery messages to
</span>    mDNSIPPort UPnPSOAPPort;                    <span class="enscript-comment">// port we send SOAP messages to
</span>    <span class="enscript-type">char</span>             *UPnPRouterURL;            <span class="enscript-comment">// router's URL string
</span>    mDNSBool UPnPWANPPPConnection;              <span class="enscript-comment">// whether we're using WANIPConnection or WANPPPConnection
</span>    <span class="enscript-type">char</span>             *UPnPSOAPURL;              <span class="enscript-comment">// router's SOAP control URL string
</span>    <span class="enscript-type">char</span>             *UPnPRouterAddressString;  <span class="enscript-comment">// holds both the router's address and port
</span>    <span class="enscript-type">char</span>             *UPnPSOAPAddressString;    <span class="enscript-comment">// holds both address and port for SOAP messages
</span>
    <span class="enscript-comment">// DNS Push Notification fields
</span>    DNSPushNotificationServer *DNSPushServers;  <span class="enscript-comment">// DNS Push Notification Servers
</span>    DNSPushNotificationZone   *DNSPushZones;

    <span class="enscript-comment">// Sleep Proxy client fields
</span>    AuthRecord *SPSRRSet;                       <span class="enscript-comment">// To help the client keep track of the records registered with the sleep proxy
</span>
    <span class="enscript-comment">// Sleep Proxy Server fields
</span>    mDNSu8 SPSType;                             <span class="enscript-comment">// 0 = off, 10-99 encodes desirability metric
</span>    mDNSu8 SPSPortability;                      <span class="enscript-comment">// 10-99
</span>    mDNSu8 SPSMarginalPower;                    <span class="enscript-comment">// 10-99
</span>    mDNSu8 SPSTotalPower;                       <span class="enscript-comment">// 10-99
</span>    mDNSu8 SPSFeatureFlags;                     <span class="enscript-comment">// Features supported. Currently 1 = TCP KeepAlive supported.
</span>    mDNSu8 SPSState;                            <span class="enscript-comment">// 0 = off, 1 = running, 2 = shutting down, 3 = suspended during sleep
</span>    mDNSInterfaceID SPSProxyListChanged;
    UDPSocket        *SPSSocket;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">SPC_DISABLED</span>
    ServiceRecordSet SPSRecords;
#<span class="enscript-reference">endif</span>
    mDNSQuestionCallback *SPSBrowseCallback;    <span class="enscript-comment">// So the platform layer can do something useful with SPS browse results
</span>    <span class="enscript-type">int</span> ProxyRecords;                           <span class="enscript-comment">// Total number of records we're holding as proxy
</span>    #define           MAX_PROXY_RECORDS 10000   <span class="enscript-comment">/* DOS protection: 400 machines at 25 records each */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">WEB_CONTENT_FILTER</span>)
    WCFConnection    *WCF;
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">// DNS Proxy fields
</span>    mDNSu32 dp_ipintf[MaxIp];                   <span class="enscript-comment">// input interface index list from the DNS Proxy Client
</span>    mDNSu32 dp_opintf;                          <span class="enscript-comment">// output interface index from the DNS Proxy Client
</span>
    TrustAnchor     *TrustAnchors;
    <span class="enscript-type">int</span>             notifyToken;
    <span class="enscript-type">int</span>             uds_listener_skt;           <span class="enscript-comment">// Listening socket for incoming UDS clients. This should not be here -- it's private to uds_daemon.c and nothing to do with mDNSCore -- SC
</span>    mDNSu32         AutoTargetServices;         <span class="enscript-comment">// # of services that have AutoTarget set
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-comment">// Counters used in Bonjour on Demand logic.
</span>    mDNSu32         NumAllInterfaceRecords;     <span class="enscript-comment">// Right now we count *all* multicast records here. Later we may want to change to count interface-specific records separately. (This count includes records on the DuplicateRecords list too.)
</span>    mDNSu32         NumAllInterfaceQuestions;   <span class="enscript-comment">// Right now we count *all* multicast questions here. Later we may want to change to count interface-specific questions separately.
</span>#<span class="enscript-reference">endif</span>

    DNSSECStatistics DNSSECStats;
    mDNSStatistics   mDNSStats;

    <span class="enscript-comment">// Fixed storage, to avoid creating large objects on the stack
</span>    <span class="enscript-comment">// The imsg is declared as a union with a pointer type to enforce CPU-appropriate alignment
</span>    <span class="enscript-type">union</span> { DNSMessage m; <span class="enscript-type">void</span> *p; } imsg;  <span class="enscript-comment">// Incoming message received from wire
</span>    DNSMessage omsg;                        <span class="enscript-comment">// Outgoing message we're building
</span>    LargeCacheRecord rec;                   <span class="enscript-comment">// Resource Record extracted from received message
</span>
    mDNSu32 next_request_id;
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FORALL_CACHERECORDS</span>(SLOT,CG,CR)                           \
    for ((SLOT) = 0; (SLOT) &lt; CACHE_HASH_SLOTS; (SLOT)++)         \
        for ((CG)=m-&gt;rrcache_hash[(SLOT)]; (CG); (CG)=(CG)-&gt;next) \
            for ((CR) = (CG)-&gt;members; (CR); (CR)=(CR)-&gt;next)

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Useful</span> <span class="enscript-variable-name">Static</span> <span class="enscript-variable-name">Constants</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_Any;             <span class="enscript-comment">// Zero
</span><span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_LocalOnly;       <span class="enscript-comment">// Special value
</span><span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterfaceMark;             <span class="enscript-comment">// Special value
</span><span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_P2P;             <span class="enscript-comment">// Special value
</span><span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID uDNSInterfaceMark;             <span class="enscript-comment">// Special value
</span><span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_BLE;             <span class="enscript-comment">// Special value
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LocalOnlyOrP2PInterface</span>(INTERFACE)  (((INTERFACE) == mDNSInterface_LocalOnly) || ((INTERFACE) == mDNSInterface_P2P) || ((INTERFACE) == mDNSInterface_BLE))

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort DiscardPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort SSHPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort UnicastDNSPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort SSDPPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort IPSECPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort NSIPCPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort NATPMPAnnouncementPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort NATPMPPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort DNSEXTPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort MulticastDNSPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort LoopbackIPCPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort PrivateDNSPort;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OwnerOptData zeroOwner;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSIPPort zeroIPPort;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv4Addr zerov4Addr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv6Addr zerov6Addr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSEthAddr zeroEthAddr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv4Addr onesIPv4Addr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv6Addr onesIPv6Addr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSEthAddr onesEthAddr;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSAddr zeroAddr;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv4Addr AllDNSAdminGroup;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv4Addr AllHosts_v4;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv6Addr AllHosts_v6;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSv6Addr NDP_prefix;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSEthAddr AllHosts_v6_Eth;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSAddr AllDNSLinkGroup_v4;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSAddr AllDNSLinkGroup_v6;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 zeroID;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 onesID;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 QueryFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 uQueryFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 DNSSecQFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 ResponseFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 UpdateReqFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 UpdateRespFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 SubscribeFlags;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque16 UnSubscribeFlags;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque64 zeroOpaque64;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSOpaque128 zeroOpaque128;
    
<span class="enscript-type">extern</span> mDNSBool StrictUnicastOrdering;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">localdomain</span>           (*(const domainname *)<span class="enscript-string">&quot;\x5&quot;</span> <span class="enscript-string">&quot;local&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DeviceInfoName</span>        (*(const domainname *)<span class="enscript-string">&quot;\xC&quot;</span> <span class="enscript-string">&quot;_device-info&quot;</span> <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_tcp&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LocalDeviceInfoName</span>   (*(const domainname *)<span class="enscript-string">&quot;\xC&quot;</span> <span class="enscript-string">&quot;_device-info&quot;</span> <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_tcp&quot;</span> <span class="enscript-string">&quot;\x5&quot;</span> <span class="enscript-string">&quot;local&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SleepProxyServiceType</span> (*(const domainname *)<span class="enscript-string">&quot;\xC&quot;</span> <span class="enscript-string">&quot;_sleep-proxy&quot;</span> <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;_udp&quot;</span>)

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Inline</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>))
    #define mDNSinline <span class="enscript-type">static</span> __inline
#<span class="enscript-reference">elif</span> ((<span class="enscript-variable-name">__GNUC__</span> &gt; 2) || ((<span class="enscript-variable-name">__GNUC__</span> == 2) &amp;&amp; (<span class="enscript-variable-name">__GNUC_MINOR__</span> &gt;= 9)))
    #define mDNSinline <span class="enscript-type">static</span> inline
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// If we're not doing inline functions, then this header needs to have the extern declarations
</span>#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">mDNSinline</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>          <span class="enscript-function-name">CountOfUnicastDNSServers</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> mDNSs32      <span class="enscript-function-name">NonZeroTime</span>(mDNSs32 t);
<span class="enscript-type">extern</span> mDNSu16      <span class="enscript-function-name">mDNSVal16</span>(mDNSOpaque16 x);
<span class="enscript-type">extern</span> mDNSOpaque16 <span class="enscript-function-name">mDNSOpaque16fromIntVal</span>(mDNSu16 v);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// If we're compiling the particular C file that instantiates our inlines, then we
</span><span class="enscript-comment">// define &quot;mDNSinline&quot; (to empty string) so that we generate code in the following section
</span>#<span class="enscript-reference">if</span> (!<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">mDNSinline</span>) &amp;&amp; <span class="enscript-variable-name">mDNS_InstantiateInlines</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSinline</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">mDNSinline</span>

mDNSinline <span class="enscript-type">int</span> <span class="enscript-function-name">CountOfUnicastDNSServers</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-type">int</span> count = 0;
    DNSServer *ptr = m-&gt;DNSServers;
    <span class="enscript-keyword">while</span>(ptr) { <span class="enscript-keyword">if</span>(!(ptr-&gt;flags &amp; DNSServerFlag_Delete)) count++; ptr = ptr-&gt;next; }
    <span class="enscript-keyword">return</span> (count);
}

mDNSinline mDNSs32 <span class="enscript-function-name">NonZeroTime</span>(mDNSs32 t) { <span class="enscript-keyword">if</span> (t) <span class="enscript-keyword">return</span>(t);<span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(1);}

mDNSinline mDNSu16 <span class="enscript-function-name">mDNSVal16</span>(mDNSOpaque16 x) { <span class="enscript-keyword">return</span>((mDNSu16)((mDNSu16)x.b[0] &lt;&lt;  8 | (mDNSu16)x.b[1])); }

mDNSinline mDNSOpaque16 <span class="enscript-function-name">mDNSOpaque16fromIntVal</span>(mDNSu16 v)
{
    mDNSOpaque16 x;
    x.b[0] = (mDNSu8)(v &gt;&gt; 8);
    x.b[1] = (mDNSu8)(v &amp; 0xFF);
    <span class="enscript-keyword">return</span>(x);
}

#<span class="enscript-reference">endif</span>
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUSPICIOUS_REPLY_DEFENSE_SECS</span>   10
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Main</span> <span class="enscript-variable-name">Client</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Every client should call mDNS_Init, passing in storage for the mDNS object and the mDNS_PlatformSupport object.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Clients that are only advertising services should use mDNS_Init_NoCache and mDNS_Init_ZeroCacheSize.
</span><span class="enscript-comment">// Clients that plan to perform queries (mDNS_StartQuery, mDNS_StartBrowse, etc.)
</span><span class="enscript-comment">// need to provide storage for the resource record cache, or the query calls will return 'mStatus_NoCache'.
</span><span class="enscript-comment">// The rrcachestorage parameter is the address of memory for the resource record cache, and
</span><span class="enscript-comment">// the rrcachesize parameter is the number of entries in the CacheRecord array passed in.
</span><span class="enscript-comment">// (i.e. the size of the cache memory needs to be sizeof(CacheRecord) * rrcachesize).
</span><span class="enscript-comment">// OS X 10.3 Panther uses an initial cache size of 64 entries, and then mDNSCore sends an
</span><span class="enscript-comment">// mStatus_GrowCache message if it needs more.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Most clients should use mDNS_Init_AdvertiseLocalAddresses. This causes mDNSCore to automatically
</span><span class="enscript-comment">// create the correct address records for all the hosts interfaces. If you plan to advertise
</span><span class="enscript-comment">// services being offered by the local machine, this is almost always what you want.
</span><span class="enscript-comment">// There are two cases where you might use mDNS_Init_DontAdvertiseLocalAddresses:
</span><span class="enscript-comment">// 1. A client-only device, that browses for services but doesn't advertise any of its own.
</span><span class="enscript-comment">// 2. A proxy-registration service, that advertises services being offered by other machines, and takes
</span><span class="enscript-comment">//    the appropriate steps to manually create the correct address records for those other machines.
</span><span class="enscript-comment">// In principle, a proxy-like registration service could manually create address records for its own machine too,
</span><span class="enscript-comment">// but this would be pointless extra effort when using mDNS_Init_AdvertiseLocalAddresses does that for you.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Note that a client-only device that wishes to prohibit multicast advertisements (e.g. from
</span><span class="enscript-comment">// higher-layer API calls) must also set DivertMulticastAdvertisements in the mDNS structure and
</span><span class="enscript-comment">// advertise local address(es) on a loopback interface.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// When mDNS has finished setting up the client's callback is called
</span><span class="enscript-comment">// A client can also spin and poll the mDNSPlatformStatus field to see when it changes from mStatus_Waiting to mStatus_NoError
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Call mDNS_StartExit to tidy up before exiting
</span><span class="enscript-comment">// Because exiting may be an asynchronous process (e.g. if unicast records need to be deregistered)
</span><span class="enscript-comment">// client layer may choose to wait until mDNS_ExitNow() returns true before calling mDNS_FinalExit().
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Call mDNS_Register with a completed AuthRecord object to register a resource record
</span><span class="enscript-comment">// If the resource record type is kDNSRecordTypeUnique (or kDNSknownunique) then if a conflicting resource record is discovered,
</span><span class="enscript-comment">// the resource record's mDNSRecordCallback will be called with error code mStatus_NameConflict. The callback should deregister
</span><span class="enscript-comment">// the record, and may then try registering the record again after picking a new name (e.g. by automatically appending a number).
</span><span class="enscript-comment">// Following deregistration, the RecordCallback will be called with result mStatus_MemFree to signal that it is safe to deallocate
</span><span class="enscript-comment">// the record's storage (memory must be freed asynchronously to allow for goodbye packets and dynamic update deregistration).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Call mDNS_StartQuery to initiate a query. mDNS will proceed to issue Multicast DNS query packets, and any time a response
</span><span class="enscript-comment">// is received containing a record which matches the question, the DNSQuestion's mDNSAnswerCallback function will be called
</span><span class="enscript-comment">// Call mDNS_StopQuery when no more answers are required
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Care should be taken on multi-threaded or interrupt-driven environments.
</span><span class="enscript-comment">// The main mDNS routines call mDNSPlatformLock() on entry and mDNSPlatformUnlock() on exit;
</span><span class="enscript-comment">// each platform layer needs to implement these appropriately for its respective platform.
</span><span class="enscript-comment">// For example, if the support code on a particular platform implements timer callbacks at interrupt time, then
</span><span class="enscript-comment">// mDNSPlatformLock/Unlock need to disable interrupts or do similar concurrency control to ensure that the mDNS
</span><span class="enscript-comment">// code is not entered by an interrupt-time timer callback while in the middle of processing a client call.
</span>
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Init</span>      (mDNS *<span class="enscript-type">const</span> m, mDNS_PlatformSupport *<span class="enscript-type">const</span> p,
                               CacheEntity *rrcachestorage, mDNSu32 rrcachesize,
                               mDNSBool AdvertiseLocalAddresses,
                               mDNSCallback *Callback, <span class="enscript-type">void</span> *Context);
<span class="enscript-comment">// See notes above on use of NoCache/ZeroCacheSize
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_NoCache</span>                     mDNSNULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_ZeroCacheSize</span>               0
<span class="enscript-comment">// See notes above on use of Advertise/DontAdvertiseLocalAddresses
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_AdvertiseLocalAddresses</span>     mDNStrue
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_DontAdvertiseLocalAddresses</span> mDNSfalse
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_NoInitCallback</span>              mDNSNULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_Init_NoInitCallbackContext</span>       mDNSNULL

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_ConfigChanged</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_GrowCache</span> (mDNS *<span class="enscript-type">const</span> m, CacheEntity *storage, mDNSu32 numrecords);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_StartExit</span> (mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_FinalExit</span> (mDNS *<span class="enscript-type">const</span> m);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_Close</span>(m) do { mDNS_StartExit(m); mDNS_FinalExit(m); } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_ExitNow</span>(m, now) ((now) - (m)-&gt;ShutdownTime &gt;= 0 || (!(m)-&gt;ResourceRecords))

<span class="enscript-type">extern</span> mDNSs32 <span class="enscript-function-name">mDNS_Execute</span>   (mDNS *<span class="enscript-type">const</span> m);

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Register</span>  (mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Update</span>    (mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mDNSu32 newttl,
                               <span class="enscript-type">const</span> mDNSu16 newrdlength, RData *<span class="enscript-type">const</span> newrdata, mDNSRecordUpdateCallback *Callback);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Deregister</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr);

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StartQuery</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StopQuery</span> (mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StopQueryWithRemoves</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Reconfirm</span> (mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> cacherr);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_Reconfirm_internal</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr, mDNSu32 interval);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_ReconfirmByValue</span>(mDNS *<span class="enscript-type">const</span> m, ResourceRecord *<span class="enscript-type">const</span> rr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_PurgeCacheResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *rr);
<span class="enscript-type">extern</span> mDNSs32 <span class="enscript-function-name">mDNS_TimeNow</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m);

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StartNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StopNATOperation</span>(mDNS *<span class="enscript-type">const</span> m, NATTraversalInfo *traversal);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StopNATOperation_internal</span>(mDNS *m, NATTraversalInfo *traversal);

<span class="enscript-type">extern</span> DomainAuthInfo *<span class="enscript-function-name">GetAuthInfoForName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_UpdateAllowSleep</span>(mDNS *<span class="enscript-type">const</span> m);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Platform</span> <span class="enscript-variable-name">support</span> <span class="enscript-variable-name">functions</span> <span class="enscript-variable-name">that</span> <span class="enscript-variable-name">are</span> <span class="enscript-variable-name">accessible</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">the</span> <span class="enscript-variable-name">client</span> <span class="enscript-variable-name">layer</span> <span class="enscript-variable-name">too</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> mDNSs32 mDNSPlatformOneSecond;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">utility</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">helper</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// mDNS_Dereg_normal is used for most calls to mDNS_Deregister_internal
</span><span class="enscript-comment">// mDNS_Dereg_rapid is used to send one goodbye instead of three, when we want the memory available for reuse sooner
</span><span class="enscript-comment">// mDNS_Dereg_conflict is used to indicate that this record is being forcibly deregistered because of a conflict
</span><span class="enscript-comment">// mDNS_Dereg_repeat is used when cleaning up, for records that may have already been forcibly deregistered
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { mDNS_Dereg_normal, mDNS_Dereg_rapid, mDNS_Dereg_conflict, mDNS_Dereg_repeat } mDNS_Dereg_type;

<span class="enscript-comment">// mDNS_RegisterService is a single call to register the set of resource records associated with a given named service.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_AddRecordToService adds an additional record to a Service Record Set.  This record may be deregistered
</span><span class="enscript-comment">// via mDNS_RemoveRecordFromService, or by deregistering the service.  mDNS_RemoveRecordFromService is passed a
</span><span class="enscript-comment">// callback to free the memory associated with the extra RR when it is safe to do so.  The ExtraResourceRecord
</span><span class="enscript-comment">// object can be found in the record's context pointer.
</span>
<span class="enscript-comment">// mDNS_GetBrowseDomains is a special case of the mDNS_StartQuery call, where the resulting answers
</span><span class="enscript-comment">// are a list of PTR records indicating (in the rdata) domains that are recommended for browsing.
</span><span class="enscript-comment">// After getting the list of domains to browse, call mDNS_StopQuery to end the search.
</span><span class="enscript-comment">// mDNS_GetDefaultBrowseDomain returns the name of the domain that should be highlighted by default.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_GetRegistrationDomains and mDNS_GetDefaultRegistrationDomain are the equivalent calls to get the list
</span><span class="enscript-comment">// of one or more domains that should be offered to the user as choices for where they may register their service,
</span><span class="enscript-comment">// and the default domain in which to register in the case where the user has made no selection.
</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>    <span class="enscript-function-name">mDNS_SetupResourceRecord</span>(AuthRecord *rr, RData *RDataStorage, mDNSInterfaceID InterfaceID,
                                        mDNSu16 rrtype, mDNSu32 ttl, mDNSu8 RecordType, AuthRecType artype, mDNSRecordCallback Callback, <span class="enscript-type">void</span> *Context);

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_RegisterService</span>  (mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr,
                                      <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                      <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> host, mDNSIPPort port, RData *txtrdata, <span class="enscript-type">const</span> mDNSu8 txtinfo[], mDNSu16 txtlen,
                                      AuthRecord *SubTypes, mDNSu32 NumSubTypes,
                                      mDNSInterfaceID InterfaceID, mDNSServiceCallback Callback, <span class="enscript-type">void</span> *Context, mDNSu32 flags);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_AddRecordToService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr, ExtraResourceRecord *extra, RData *rdata, mDNSu32 ttl,  mDNSu32 flags);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_RemoveRecordFromService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr, ExtraResourceRecord *extra, mDNSRecordCallback MemFreeCallback, <span class="enscript-type">void</span> *Context);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_RenameAndReregisterService</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *<span class="enscript-type">const</span> sr, <span class="enscript-type">const</span> domainlabel *newname);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_DeregisterService_drt</span>(mDNS *<span class="enscript-type">const</span> m, ServiceRecordSet *sr, mDNS_Dereg_type drt);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_DeregisterService</span>(M,S) mDNS_DeregisterService_drt((M), (S), mDNS_Dereg_normal)

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_RegisterNoSuchService</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr,
                                          <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                          <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> host,
                                          <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSRecordCallback Callback, <span class="enscript-type">void</span> *Context, mDNSu32 flags);
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">mDNS_DeregisterNoSuchService</span> mDNS_Deregister

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetupQuestion</span>(DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name,
                               <span class="enscript-type">const</span> mDNSu16 qtype, mDNSQuestionCallback *<span class="enscript-type">const</span> callback, <span class="enscript-type">void</span> *<span class="enscript-type">const</span> context);

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_StartBrowse</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question,
                                <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> srv, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain,
                                <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu32 flags,
                                mDNSBool ForceMCast, mDNSBool useBackgroundTrafficClass,
                                mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context);
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">mDNS_StopBrowse</span> mDNS_StopQuery


<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mDNS_DomainTypeBrowse              = 0,
    mDNS_DomainTypeBrowseDefault       = 1,
    mDNS_DomainTypeBrowseAutomatic     = 2,
    mDNS_DomainTypeRegistration        = 3,
    mDNS_DomainTypeRegistrationDefault = 4,

    mDNS_DomainTypeMax = 4
} mDNS_DomainType;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> mDNS_DomainTypeNames[];

<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_GetDomains</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *<span class="enscript-type">const</span> question, mDNS_DomainType DomainType, <span class="enscript-type">const</span> domainname *dom,
                               <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSQuestionCallback *Callback, <span class="enscript-type">void</span> *Context);
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">mDNS_StopGetDomains</span> mDNS_StopQuery
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_AdvertiseDomains</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, mDNS_DomainType DomainType, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">char</span> *domname);
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">mDNS_StopAdvertiseDomains</span> mDNS_Deregister

<span class="enscript-type">extern</span> mDNSOpaque16 <span class="enscript-function-name">mDNS_NewMessageID</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNS_AddressIsLocalSubnet</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> mDNSAddr *addr);

<span class="enscript-type">extern</span> DNSServer *<span class="enscript-function-name">GetServerForQuestion</span>(mDNS *m, DNSQuestion *question);
<span class="enscript-type">extern</span> mDNSu32 <span class="enscript-function-name">SetValidDNSServers</span>(mDNS *m, DNSQuestion *question);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">name</span> <span class="enscript-variable-name">utility</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// In order to expose the full capabilities of the DNS protocol (which allows any arbitrary eight-bit values
</span><span class="enscript-comment">// in domain name labels, including unlikely characters like ascii nulls and even dots) all the mDNS APIs
</span><span class="enscript-comment">// work with DNS's native length-prefixed strings. For convenience in C, the following utility functions
</span><span class="enscript-comment">// are provided for converting between C's null-terminated strings and DNS's length-prefixed strings.
</span>
<span class="enscript-comment">// Assignment
</span><span class="enscript-comment">// A simple C structure assignment of a domainname can cause a protection fault by accessing unmapped memory,
</span><span class="enscript-comment">// because that object is defined to be 256 bytes long, but not all domainname objects are truly the full size.
</span><span class="enscript-comment">// This macro uses mDNSPlatformMemCopy() to make sure it only touches the actual bytes that are valid.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">AssignDomainName</span>(DST, SRC) do { mDNSu16 len__ = DomainNameLength((SRC)); \
    if (len__ &lt;= MAX_DOMAIN_NAME) mDNSPlatformMemCopy((DST)-&gt;c, (SRC)-&gt;c, len__); else (DST)-&gt;c[0] = 0; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AssignConstStringDomainName</span>(DST, SRC) do { \
    mDNSu16 len__ = DomainNameLengthLimit((domainname *)(SRC), (mDNSu8 *)(SRC) + sizeof (SRC)); \
    if (len__ &lt;= MAX_DOMAIN_NAME) \
        mDNSPlatformMemCopy((DST)-&gt;c, (SRC), len__); else (DST)-&gt;c[0] = 0; } while(0)

<span class="enscript-comment">// Comparison functions
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">SameDomainLabelCS</span>(A,B) ((A)[0] == (B)[0] &amp;&amp; mDNSPlatformMemSame((A)+1, (B)+1, (A)[0]))
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">SameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">SameDomainName</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">SameDomainNameCS</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2);
<span class="enscript-type">typedef</span> mDNSBool <span class="enscript-function-name">DomainNameComparisonFn</span> (<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">IsLocalDomain</span>(<span class="enscript-type">const</span> domainname *d);     <span class="enscript-comment">// returns true for domains that by default should be looked up using link-local multicast
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">StripFirstLabel</span>(X) ((const domainname *)&amp; (X)-&gt;c[(X)-&gt;c[0] ? 1 + (X)-&gt;c[0] : 0])

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FirstLabel</span>(X)  ((const domainlabel *)(X))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SecondLabel</span>(X) ((const domainlabel *)StripFirstLabel(X))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ThirdLabel</span>(X)  ((const domainlabel *)StripFirstLabel(StripFirstLabel(X)))

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LastLabel</span>(<span class="enscript-type">const</span> domainname *d);

<span class="enscript-comment">// Get total length of domain name, in native DNS format, including terminal root label
</span><span class="enscript-comment">//   (e.g. length of &quot;com.&quot; is 5 (length byte, three data bytes, final zero)
</span><span class="enscript-type">extern</span> mDNSu16  <span class="enscript-function-name">DomainNameLengthLimit</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu8 *limit);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DomainNameLength</span>(name) DomainNameLengthLimit((name), (name)-&gt;c + MAX_DOMAIN_NAME)

<span class="enscript-comment">// Append functions to append one or more labels to an existing native format domain name:
</span><span class="enscript-comment">//   AppendLiteralLabelString adds a single label from a literal C string, with no escape character interpretation.
</span><span class="enscript-comment">//   AppendDNSNameString      adds zero or more labels from a C string using conventional DNS dots-and-escaping interpretation
</span><span class="enscript-comment">//   AppendDomainLabel        adds a single label from a native format domainlabel
</span><span class="enscript-comment">//   AppendDomainName         adds zero or more labels from a native format domainname
</span><span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">AppendLiteralLabelString</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr);
<span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">AppendDNSNameString</span>     (domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr);
<span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">AppendDomainLabel</span>       (domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> label);
<span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">AppendDomainName</span>        (domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> append);

<span class="enscript-comment">// Convert from null-terminated string to native DNS format:
</span><span class="enscript-comment">//   The DomainLabel form makes a single label from a literal C string, with no escape character interpretation.
</span><span class="enscript-comment">//   The DomainName form makes native format domain name from a C string using conventional DNS interpretation:
</span><span class="enscript-comment">//     dots separate labels, and within each label, '\.' represents a literal dot, '\\' represents a literal
</span><span class="enscript-comment">//     backslash and backslash with three decimal digits (e.g. \000) represents an arbitrary byte value.
</span><span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">MakeDomainLabelFromLiteralString</span>(domainlabel *<span class="enscript-type">const</span> label, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr);
<span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">MakeDomainNameFromDNSNameString</span> (domainname  *<span class="enscript-type">const</span> name,  <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr);

<span class="enscript-comment">// Convert native format domainlabel or domainname back to C string format
</span><span class="enscript-comment">// IMPORTANT:
</span><span class="enscript-comment">// When using ConvertDomainLabelToCString, the target buffer must be MAX_ESCAPED_DOMAIN_LABEL (254) bytes long
</span><span class="enscript-comment">// to guarantee there will be no buffer overrun. It is only safe to use a buffer shorter than this in rare cases
</span><span class="enscript-comment">// where the label is known to be constrained somehow (for example, if the label is known to be either &quot;_tcp&quot; or &quot;_udp&quot;).
</span><span class="enscript-comment">// Similarly, when using ConvertDomainNameToCString, the target buffer must be MAX_ESCAPED_DOMAIN_NAME (1009) bytes long.
</span><span class="enscript-comment">// See definitions of MAX_ESCAPED_DOMAIN_LABEL and MAX_ESCAPED_DOMAIN_NAME for more detailed explanation.
</span><span class="enscript-type">extern</span> <span class="enscript-type">char</span>    *<span class="enscript-function-name">ConvertDomainLabelToCString_withescape</span>(<span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">char</span> *cstr, <span class="enscript-type">char</span> esc);
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">ConvertDomainLabelToCString_unescaped</span>(D,C) ConvertDomainLabelToCString_withescape((D), (C), 0)
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">ConvertDomainLabelToCString</span>(D,C)           ConvertDomainLabelToCString_withescape((D), (C), <span class="enscript-string">'\\'</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>    *<span class="enscript-function-name">ConvertDomainNameToCString_withescape</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">char</span> *cstr, <span class="enscript-type">char</span> esc);
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">ConvertDomainNameToCString_unescaped</span>(D,C) ConvertDomainNameToCString_withescape((D), (C), 0)
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">ConvertDomainNameToCString</span>(D,C)           ConvertDomainNameToCString_withescape((D), (C), <span class="enscript-string">'\\'</span>)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">ConvertUTF8PstringToRFC1034HostLabel</span>(<span class="enscript-type">const</span> mDNSu8 UTF8Name[], domainlabel *<span class="enscript-type">const</span> hostlabel);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ValidTransportProtocol</span>(X) ( (X)[0] == 4 &amp;&amp; (X)[1] == <span class="enscript-string">'_'</span> &amp;&amp; \
                                    ((((X)[2] | 0x20) == <span class="enscript-string">'u'</span> &amp;&amp; ((X)[3] | 0x20) == <span class="enscript-string">'d'</span>) || (((X)[2] | 0x20) == <span class="enscript-string">'t'</span> &amp;&amp; ((X)[3] | 0x20) == <span class="enscript-string">'c'</span>)) &amp;&amp; \
                                    ((X)[4] | 0x20) == <span class="enscript-string">'p'</span>)

<span class="enscript-type">extern</span> mDNSu8  *<span class="enscript-function-name">ConstructServiceName</span>(domainname *<span class="enscript-type">const</span> fqdn, <span class="enscript-type">const</span> domainlabel *name, <span class="enscript-type">const</span> domainname *type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">DeconstructServiceName</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> fqdn, domainlabel *<span class="enscript-type">const</span> name, domainname *<span class="enscript-type">const</span> type, domainname *<span class="enscript-type">const</span> domain);

<span class="enscript-comment">// Note: Some old functions have been replaced by more sensibly-named versions.
</span><span class="enscript-comment">// You can uncomment the hash-defines below if you don't want to have to change your source code right away.
</span><span class="enscript-comment">// When updating your code, note that (unlike the old versions) *all* the new routines take the target object
</span><span class="enscript-comment">// as their first parameter.
</span><span class="enscript-comment">//#define ConvertCStringToDomainName(SRC,DST)  MakeDomainNameFromDNSNameString((DST),(SRC))
</span><span class="enscript-comment">//#define ConvertCStringToDomainLabel(SRC,DST) MakeDomainLabelFromLiteralString((DST),(SRC))
</span><span class="enscript-comment">//#define AppendStringLabelToName(DST,SRC)     AppendLiteralLabelString((DST),(SRC))
</span><span class="enscript-comment">//#define AppendStringNameToName(DST,SRC)      AppendDNSNameString((DST),(SRC))
</span><span class="enscript-comment">//#define AppendDomainLabelToName(DST,SRC)     AppendDomainLabel((DST),(SRC))
</span><span class="enscript-comment">//#define AppendDomainNameToName(DST,SRC)      AppendDomainName((DST),(SRC))
</span>
<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Other</span> <span class="enscript-variable-name">utility</span> <span class="enscript-variable-name">functions</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">macros</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// mDNS_vsnprintf/snprintf return the number of characters written, excluding the final terminating null.
</span><span class="enscript-comment">// The output is always null-terminated: for example, if the output turns out to be exactly buflen long,
</span><span class="enscript-comment">// then the output will be truncated by one character to allow space for the terminating null.
</span><span class="enscript-comment">// Unlike standard C vsnprintf/snprintf, they return the number of characters *actually* written,
</span><span class="enscript-comment">// not the number of characters that *would* have been printed were buflen unlimited.
</span><span class="enscript-type">extern</span> mDNSu32 <span class="enscript-function-name">mDNS_vsnprintf</span>(<span class="enscript-type">char</span> *sbuffer, mDNSu32 buflen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, va_list arg) IS_A_PRINTF_STYLE_FUNCTION(3,0);
<span class="enscript-type">extern</span> mDNSu32 <span class="enscript-function-name">mDNS_snprintf</span>(<span class="enscript-type">char</span> *sbuffer, mDNSu32 buflen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...) IS_A_PRINTF_STYLE_FUNCTION(3,4);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_snprintf_add</span>(<span class="enscript-type">char</span> **dst, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lim, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...) IS_A_PRINTF_STYLE_FUNCTION(3,4);
<span class="enscript-type">extern</span> mDNSu32 <span class="enscript-function-name">NumCacheRecordsForInterfaceID</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID id);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSTypeName</span>(mDNSu16 rrtype);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">GetRRDisplayString_rdb</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> RDataBody *<span class="enscript-type">const</span> rd1, <span class="enscript-type">char</span> *<span class="enscript-type">const</span> buffer);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RRDisplayString</span>(m, rr) GetRRDisplayString_rdb(rr, &amp;(rr)-&gt;rdata-&gt;u, (m)-&gt;MsgBuffer)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ARDisplayString</span>(m, rr) GetRRDisplayString_rdb(&amp;(rr)-&gt;resrec, &amp;(rr)-&gt;resrec.rdata-&gt;u, (m)-&gt;MsgBuffer)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CRDisplayString</span>(m, rr) GetRRDisplayString_rdb(&amp;(rr)-&gt;resrec, &amp;(rr)-&gt;resrec.rdata-&gt;u, (m)-&gt;MsgBuffer)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MortalityDisplayString</span>(M) (M == Mortality_Mortal ? <span class="enscript-string">&quot;mortal&quot;</span> : (M == Mortality_Immortal ? <span class="enscript-string">&quot;immortal&quot;</span> : <span class="enscript-string">&quot;ghost&quot;</span>))
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSSameAddress</span>(<span class="enscript-type">const</span> mDNSAddr *ip1, <span class="enscript-type">const</span> mDNSAddr *ip2);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IncrementLabelSuffix</span>(domainlabel *name, mDNSBool RichText);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSv4AddrIsRFC1918</span>(<span class="enscript-type">const</span> mDNSv4Addr * <span class="enscript-type">const</span> addr);  <span class="enscript-comment">// returns true for RFC1918 private addresses
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddrIsRFC1918</span>(X) ((X)-&gt;type == mDNSAddrType_IPv4 &amp;&amp; mDNSv4AddrIsRFC1918(&amp;(X)-&gt;ip.v4))
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSScopeToString</span>(mDNSu32 scope);

<span class="enscript-comment">// For PCP
</span><span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSAddrMapIPv4toIPv6</span>(mDNSv4Addr* in, mDNSv6Addr* out);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSAddrIPv4FromMappedIPv6</span>(mDNSv6Addr *in, mDNSv4Addr *out);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameIPPort</span>(A,B)      ((A).NotAnInteger == (B).NotAnInteger)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameOpaque16</span>(A,B)    ((A).NotAnInteger == (B).NotAnInteger)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameOpaque32</span>(A,B)    ((A).NotAnInteger == (B).NotAnInteger)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameOpaque64</span>(A,B)    ((A)-&gt;l[0] == (B)-&gt;l[0] &amp;&amp; (A)-&gt;l[1] == (B)-&gt;l[1])

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameIPv4Address</span>(A,B) ((A).NotAnInteger == (B).NotAnInteger)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameIPv6Address</span>(A,B) ((A).l[0] == (B).l[0] &amp;&amp; (A).l[1] == (B).l[1] &amp;&amp; (A).l[2] == (B).l[2] &amp;&amp; (A).l[3] == (B).l[3])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameIPv6NetworkPart</span>(A,B) ((A).l[0] == (B).l[0] &amp;&amp; (A).l[1] == (B).l[1])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSSameEthAddress</span>(A,B)  ((A)-&gt;w[0] == (B)-&gt;w[0] &amp;&amp; (A)-&gt;w[1] == (B)-&gt;w[1] &amp;&amp; (A)-&gt;w[2] == (B)-&gt;w[2])

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIPPortIsZero</span>(A)      ((A).NotAnInteger                            == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSOpaque16IsZero</span>(A)    ((A).NotAnInteger                            == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSOpaque64IsZero</span>(A)    (((A)-&gt;l[0] | (A)-&gt;l[1]                    ) == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSOpaque128IsZero</span>(A)   (((A)-&gt;l[0] | (A)-&gt;l[1] | (A)-&gt;l[2] | (A)-&gt;l[3]) == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIPv4AddressIsZero</span>(A) ((A).NotAnInteger                            == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIPv6AddressIsZero</span>(A) (((A).l[0] | (A).l[1] | (A).l[2] | (A).l[3]) == 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSEthAddressIsZero</span>(A)  (((A).w[0] | (A).w[1] | (A).w[2]           ) == 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIPv4AddressIsOnes</span>(A) ((A).NotAnInteger == 0xFFFFFFFF)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSIPv6AddressIsOnes</span>(A) (((A).l[0] &amp; (A).l[1] &amp; (A).l[2] &amp; (A).l[3]) == 0xFFFFFFFF)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsAllDNSLinkGroup</span>(X) (                                                            \
        ((X)-&gt;type == mDNSAddrType_IPv4 &amp;&amp; mDNSSameIPv4Address((X)-&gt;ip.v4, AllDNSLinkGroup_v4.ip.v4)) || \
        ((X)-&gt;type == mDNSAddrType_IPv6 &amp;&amp; mDNSSameIPv6Address((X)-&gt;ip.v6, AllDNSLinkGroup_v6.ip.v6))    )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsZero</span>(X) (                                                \
        ((X)-&gt;type == mDNSAddrType_IPv4 &amp;&amp; mDNSIPv4AddressIsZero((X)-&gt;ip.v4))  || \
        ((X)-&gt;type == mDNSAddrType_IPv6 &amp;&amp; mDNSIPv6AddressIsZero((X)-&gt;ip.v6))     )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsValidNonZero</span>(X) (                                        \
        ((X)-&gt;type == mDNSAddrType_IPv4 &amp;&amp; !mDNSIPv4AddressIsZero((X)-&gt;ip.v4)) || \
        ((X)-&gt;type == mDNSAddrType_IPv6 &amp;&amp; !mDNSIPv6AddressIsZero((X)-&gt;ip.v6))    )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsOnes</span>(X) (                                                \
        ((X)-&gt;type == mDNSAddrType_IPv4 &amp;&amp; mDNSIPv4AddressIsOnes((X)-&gt;ip.v4))  || \
        ((X)-&gt;type == mDNSAddrType_IPv6 &amp;&amp; mDNSIPv6AddressIsOnes((X)-&gt;ip.v6))     )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsValid</span>(X) (                                                                                             \
        ((X)-&gt;type == mDNSAddrType_IPv4) ? !(mDNSIPv4AddressIsZero((X)-&gt;ip.v4) || mDNSIPv4AddressIsOnes((X)-&gt;ip.v4)) :          \
        ((X)-&gt;type == mDNSAddrType_IPv6) ? !(mDNSIPv6AddressIsZero((X)-&gt;ip.v6) || mDNSIPv6AddressIsOnes((X)-&gt;ip.v6)) : mDNSfalse)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSv4AddressIsLinkLocal</span>(X) ((X)-&gt;b[0] ==  169 &amp;&amp;  (X)-&gt;b[1]         ==  254)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSv6AddressIsLinkLocal</span>(X) ((X)-&gt;b[0] == 0xFE &amp;&amp; ((X)-&gt;b[1] &amp; 0xC0) == 0x80)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSAddressIsLinkLocal</span>(X)  (                                                    \
        ((X)-&gt;type == mDNSAddrType_IPv4) ? mDNSv4AddressIsLinkLocal(&amp;(X)-&gt;ip.v4) :          \
        ((X)-&gt;type == mDNSAddrType_IPv6) ? mDNSv6AddressIsLinkLocal(&amp;(X)-&gt;ip.v6) : mDNSfalse)


<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Authentication</span> <span class="enscript-variable-name">Support</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Unicast DNS and Dynamic Update specific Client Calls
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_SetSecretForDomain tells the core to authenticate (via TSIG with an HMAC_MD5 hash of the shared secret)
</span><span class="enscript-comment">// when dynamically updating a given zone (and its subdomains).  The key used in authentication must be in
</span><span class="enscript-comment">// domain name format.  The shared secret must be a null-terminated base64 encoded string.  A minimum size of
</span><span class="enscript-comment">// 16 bytes (128 bits) is recommended for an MD5 hash as per RFC 2485.
</span><span class="enscript-comment">// Calling this routine multiple times for a zone replaces previously entered values.  Call with a NULL key
</span><span class="enscript-comment">// to disable authentication for the zone.  A non-NULL autoTunnelPrefix means this is an AutoTunnel domain,
</span><span class="enscript-comment">// and the value is prepended to the IPSec identifier (used for key lookup)
</span>
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNS_SetSecretForDomain</span>(mDNS *m, DomainAuthInfo *info,
                                       <span class="enscript-type">const</span> domainname *domain, <span class="enscript-type">const</span> domainname *keyname, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64keydata, <span class="enscript-type">const</span> domainname *hostname, mDNSIPPort *port);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">RecreateNATMappings</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 waitTicks);

<span class="enscript-comment">// Hostname/Unicast Interface Configuration
</span>
<span class="enscript-comment">// All hostnames advertised point to one IPv4 address and/or one IPv6 address, set via SetPrimaryInterfaceInfo.  Invoking this routine
</span><span class="enscript-comment">// updates all existing hostnames to point to the new address.
</span>
<span class="enscript-comment">// A hostname is added via AddDynDNSHostName, which points to the primary interface's v4 and/or v6 addresss
</span>
<span class="enscript-comment">// The status callback is invoked to convey success or failure codes - the callback should not modify the AuthRecord or free memory.
</span><span class="enscript-comment">// Added hostnames may be removed (deregistered) via mDNS_RemoveDynDNSHostName.
</span>
<span class="enscript-comment">// Host domains added prior to specification of the primary interface address and computer name will be deferred until
</span><span class="enscript-comment">// these values are initialized.
</span>
<span class="enscript-comment">// DNS servers used to resolve unicast queries are specified by mDNS_AddDNSServer.
</span><span class="enscript-comment">// For &quot;split&quot; DNS configurations, in which queries for different domains are sent to different servers (e.g. VPN and external),
</span><span class="enscript-comment">// a domain may be associated with a DNS server.  For standard configurations, specify the root label (&quot;.&quot;) or NULL.
</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn, mDNSRecordCallback *StatusCallback, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *StatusContext);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_RemoveDynDNSHostName</span>(mDNS *m, <span class="enscript-type">const</span> domainname *fqdn);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetPrimaryInterfaceInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSAddr *v4addr,  <span class="enscript-type">const</span> mDNSAddr *v6addr, <span class="enscript-type">const</span> mDNSAddr *router);
<span class="enscript-type">extern</span> DNSServer *<span class="enscript-function-name">mDNS_AddDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">const</span> mDNSInterfaceID interface, mDNSs32 serviceID, <span class="enscript-type">const</span> mDNSAddr *addr,
                                    <span class="enscript-type">const</span> mDNSIPPort port, ScopeType scopeType, mDNSu32 timeout, mDNSBool cellIntf, mDNSBool isExpensive, mDNSBool isConstrained, mDNSBool isCLAT46,
                                    mDNSu32 resGroupID, mDNSBool reqA, mDNSBool reqAAAA, mDNSBool reqDO);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">PenalizeDNSServer</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSOpaque16 responseFlags);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_AddSearchDomain</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain, mDNSInterfaceID InterfaceID);

<span class="enscript-type">extern</span> McastResolver *<span class="enscript-function-name">mDNS_AddMcastResolver</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *d, <span class="enscript-type">const</span> mDNSInterfaceID interface, mDNSu32 timeout);

<span class="enscript-comment">// We use ((void *)0) here instead of mDNSNULL to avoid compile warnings on gcc 4.2
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_AddSearchDomain_CString</span>(X, I) \
    do { domainname d__; if (((X) != (void*)0) &amp;&amp; MakeDomainNameFromDNSNameString(&amp;d__, (X)) &amp;&amp; d__.c[0]) mDNS_AddSearchDomain(&amp;d__, I);} while(0)

<span class="enscript-comment">// Routines called by the core, exported by DNSDigest.c
</span>
<span class="enscript-comment">// Convert an arbitrary base64 encoded key key into an HMAC key (stored in AuthInfo struct)
</span><span class="enscript-type">extern</span> mDNSs32 <span class="enscript-function-name">DNSDigest_ConstructHMACKeyfromBase64</span>(DomainAuthInfo *info, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *b64key);

<span class="enscript-comment">// sign a DNS message.  The message must be complete, with all values in network byte order.  end points to the end
</span><span class="enscript-comment">// of the message, and is modified by this routine.  numAdditionals is a pointer to the number of additional
</span><span class="enscript-comment">// records in HOST byte order, which is incremented upon successful completion of this routine.  The function returns
</span><span class="enscript-comment">// the new end pointer on success, and NULL on failure.
</span><span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSDigest_SignMessage</span>(DNSMessage *msg, mDNSu8 **end, DomainAuthInfo *info, mDNSu16 tcode);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SwapDNSHeaderBytes</span>(M) do { \
    (M)-&gt;h.numQuestions   = (mDNSu16)((mDNSu8 *)&amp;(M)-&gt;h.numQuestions  )[0] &lt;&lt; 8 | ((mDNSu8 *)&amp;(M)-&gt;h.numQuestions  )[1]; \
    (M)-&gt;h.numAnswers     = (mDNSu16)((mDNSu8 *)&amp;(M)-&gt;h.numAnswers    )[0] &lt;&lt; 8 | ((mDNSu8 *)&amp;(M)-&gt;h.numAnswers    )[1]; \
    (M)-&gt;h.numAuthorities = (mDNSu16)((mDNSu8 *)&amp;(M)-&gt;h.numAuthorities)[0] &lt;&lt; 8 | ((mDNSu8 *)&amp;(M)-&gt;h.numAuthorities)[1]; \
    (M)-&gt;h.numAdditionals = (mDNSu16)((mDNSu8 *)&amp;(M)-&gt;h.numAdditionals)[0] &lt;&lt; 8 | ((mDNSu8 *)&amp;(M)-&gt;h.numAdditionals)[1]; \
} while (0)

<span class="enscript-comment">// verify a DNS message.  The message must be complete, with all values in network byte order.  end points to the
</span><span class="enscript-comment">// end of the record.  tsig is a pointer to the resource record that contains the TSIG OPT record.  info is
</span><span class="enscript-comment">// the matching key to use for verifying the message.  This function expects that the additionals member
</span><span class="enscript-comment">// of the DNS message header has already had one subtracted from it.
</span><span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">DNSDigest_VerifyMessage</span>(DNSMessage *msg, mDNSu8 *end, LargeCacheRecord *tsig, DomainAuthInfo *info, mDNSu16 *rcode, mDNSu16 *tcode);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">PlatformSupport</span> <span class="enscript-variable-name">interface</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// This section defines the interface to the Platform Support layer.
</span><span class="enscript-comment">// Normal client code should not use any of types defined here, or directly call any of the functions defined here.
</span><span class="enscript-comment">// The definitions are placed here because sometimes clients do use these calls indirectly, via other supported client operations.
</span><span class="enscript-comment">// For example, AssignDomainName is a macro defined using mDNSPlatformMemCopy()
</span>
<span class="enscript-comment">// Every platform support module must provide the following functions.
</span><span class="enscript-comment">// mDNSPlatformInit() typically opens a communication endpoint, and starts listening for mDNS packets.
</span><span class="enscript-comment">// When Setup is complete, the platform support layer calls mDNSCoreInitComplete().
</span><span class="enscript-comment">// mDNSPlatformSendUDP() sends one UDP packet
</span><span class="enscript-comment">// When a packet is received, the PlatformSupport code calls mDNSCoreReceive()
</span><span class="enscript-comment">// mDNSPlatformClose() tidies up on exit
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Note: mDNSPlatformMemAllocate/mDNSPlatformMemFree are only required for handling oversized resource records and unicast DNS.
</span><span class="enscript-comment">// If your target platform has a well-defined specialized application, and you know that all the records it uses
</span><span class="enscript-comment">// are InlineCacheRDSize or less, then you can just make a simple mDNSPlatformMemAllocate() stub that always returns
</span><span class="enscript-comment">// NULL. InlineCacheRDSize is a compile-time constant, which is set by default to 68. If you need to handle records
</span><span class="enscript-comment">// a little larger than this and you don't want to have to implement run-time allocation and freeing, then you
</span><span class="enscript-comment">// can raise the value of this constant to a suitable value (at the expense of increased memory usage).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// USE CAUTION WHEN CALLING mDNSPlatformRawTime: The m-&gt;timenow_adjust correction factor needs to be added
</span><span class="enscript-comment">// Generally speaking:
</span><span class="enscript-comment">// Code that's protected by the main mDNS lock should just use the m-&gt;timenow value
</span><span class="enscript-comment">// Code outside the main mDNS lock should use mDNS_TimeNow(m) to get properly adjusted time
</span><span class="enscript-comment">// In certain cases there may be reasons why it's necessary to get the time without taking the lock first
</span><span class="enscript-comment">// (e.g. inside the routines that are doing the locking and unlocking, where a call to get the lock would result in a
</span><span class="enscript-comment">// recursive loop); in these cases use mDNS_TimeNow_NoLock(m) to get mDNSPlatformRawTime with the proper correction factor added.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNSPlatformUTC returns the time, in seconds, since Jan 1st 1970 UTC and is required for generating TSIG records
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSListValidationFunction</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> listValidator mDNSListValidator;
<span class="enscript-type">struct</span> listValidator {
    <span class="enscript-type">struct</span> listValidator *next;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *validationFunctionName;
    mDNSListValidationFunction *validator;
    <span class="enscript-type">void</span> *context;
};
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>

<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">mDNSPlatformInit</span>        (mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformClose</span>       (mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">mDNSPlatformSendUDP</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                    mDNSInterfaceID InterfaceID, UDPSocket *src, <span class="enscript-type">const</span> mDNSAddr *dst,
                                    mDNSIPPort dstport, mDNSBool useBackgroundTrafficClass);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformLock</span>        (<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformUnlock</span>      (<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m);

<span class="enscript-type">extern</span> mDNSu32  <span class="enscript-function-name">mDNSPlatformStrLCopy</span>    (      <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len);
<span class="enscript-type">extern</span> mDNSu32  <span class="enscript-function-name">mDNSPlatformStrLen</span>      (                 <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformMemCopy</span>     (      <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSPlatformMemSame</span>     (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>      <span class="enscript-function-name">mDNSPlatformMemCmp</span>      (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *dst, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, mDNSu32 len);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformMemZero</span>     (      <span class="enscript-type">void</span> *dst,                  mDNSu32 len);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformQsort</span>       (<span class="enscript-type">void</span> *base, <span class="enscript-type">int</span> nel, <span class="enscript-type">int</span> width, <span class="enscript-type">int</span> (*compar)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">mDNSPlatformMemAllocate</span>(X)      mallocL(# X, X)
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">mDNSPlatformMemAllocateClear</span>(X)	callocL(# X, X)
#<span class="enscript-reference">define</span>         <span class="enscript-function-name">mDNSPlatformMemFree</span>(X)          freeL(# X, X)
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformValidateLists</span> (<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformAddListValidator</span>(mDNSListValidator *validator,
                                             mDNSListValidationFunction *vf, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *vfName, <span class="enscript-type">void</span> *context);
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *   <span class="enscript-function-name">mDNSPlatformMemAllocate</span>(mDNSu32 len);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *   <span class="enscript-function-name">mDNSPlatformMemAllocateClear</span>(mDNSu32 len);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSPlatformMemFree</span>(<span class="enscript-type">void</span> *mem);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">MDNS_MALLOC_DEBUGGING</span>

<span class="enscript-comment">// If the platform doesn't have a strong PRNG, we define a naive multiply-and-add based on a seed
</span><span class="enscript-comment">// from the platform layer.  Long-term, we should embed an arc4 implementation, but the strength
</span><span class="enscript-comment">// will still depend on the randomness of the seed.
</span>#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span>) &amp;&amp; (<span class="enscript-variable-name">_BUILDING_XCODE_PROJECT_</span> || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_WIN32</span>))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span> 1
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span>
<span class="enscript-type">extern</span> mDNSu32  <span class="enscript-function-name">mDNSPlatformRandomNumber</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> mDNSu32  <span class="enscript-function-name">mDNSPlatformRandomSeed</span>  (<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span>

<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">mDNSPlatformTimeInit</span>    (<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> mDNSs32  <span class="enscript-function-name">mDNSPlatformRawTime</span>     (<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> mDNSs32  <span class="enscript-function-name">mDNSPlatformUTC</span>         (<span class="enscript-type">void</span>);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNS_TimeNow_NoLock</span>(m) (mDNSPlatformRawTime() + (m)-&gt;timenow_adjust)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNS_DEBUGMSGS</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformWriteDebugMsg</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformWriteLogMsg</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ident, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, mDNSLogLevel_t loglevel);

<span class="enscript-comment">// Platform support modules should provide the following functions to map between opaque interface IDs
</span><span class="enscript-comment">// and interface indexes in order to support the DNS-SD API. If your target platform does not support
</span><span class="enscript-comment">// multiple interfaces and/or does not support the DNS-SD API, these functions can be empty.
</span><span class="enscript-type">extern</span> mDNSInterfaceID <span class="enscript-function-name">mDNSPlatformInterfaceIDfromInterfaceIndex</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu32 ifindex);
<span class="enscript-type">extern</span> mDNSu32 <span class="enscript-function-name">mDNSPlatformInterfaceIndexfromInterfaceID</span>(mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID id, mDNSBool suppressNetworkChange);

<span class="enscript-comment">// Every platform support module must provide the following functions if it is to support unicast DNS
</span><span class="enscript-comment">// and Dynamic Update.
</span><span class="enscript-comment">// All TCP socket operations implemented by the platform layer MUST NOT BLOCK.
</span><span class="enscript-comment">// mDNSPlatformTCPConnect initiates a TCP connection with a peer, adding the socket descriptor to the
</span><span class="enscript-comment">// main event loop.  The return value indicates whether the connection succeeded, failed, or is pending
</span><span class="enscript-comment">// (i.e. the call would block.)  On return, the descriptor parameter is set to point to the connected socket.
</span><span class="enscript-comment">// The TCPConnectionCallback is subsequently invoked when the connection
</span><span class="enscript-comment">// completes (in which case the ConnectionEstablished parameter is true), or data is available for
</span><span class="enscript-comment">// reading on the socket (indicated by the ConnectionEstablished parameter being false.)  If the connection
</span><span class="enscript-comment">// asynchronously fails, the TCPConnectionCallback should be invoked as usual, with the error being
</span><span class="enscript-comment">// returned in subsequent calls to PlatformReadTCP or PlatformWriteTCP.  (This allows for platforms
</span><span class="enscript-comment">// with limited asynchronous error detection capabilities.)  PlatformReadTCP and PlatformWriteTCP must
</span><span class="enscript-comment">// return the number of bytes read/written, 0 if the call would block, and -1 if an error.  PlatformReadTCP
</span><span class="enscript-comment">// should set the closed argument if the socket has been closed.
</span><span class="enscript-comment">// PlatformTCPCloseConnection must close the connection to the peer and remove the descriptor from the
</span><span class="enscript-comment">// event loop.  CloseConnectin may be called at any time, including in a ConnectionCallback.
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    kTCPSocketFlags_Zero   = 0,
    kTCPSocketFlags_UseTLS = (1 &lt;&lt; 0)
} TCPSocketFlags;

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*TCPConnectionCallback)(TCPSocket *sock, <span class="enscript-type">void</span> *context, mDNSBool ConnectionEstablished, mStatus err);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*TCPAcceptedCallback)(TCPSocket *sock, mDNSAddr *addr, mDNSIPPort *port,
									<span class="enscript-type">const</span> <span class="enscript-type">char</span> *remoteName, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> TCPSocket *<span class="enscript-function-name">mDNSPlatformTCPSocket</span>(TCPSocketFlags flags, mDNSAddr_Type addrtype, mDNSIPPort *port, domainname *hostname, mDNSBool useBackgroundTrafficClass); <span class="enscript-comment">// creates a TCP socket
</span><span class="enscript-type">extern</span> TCPListener *<span class="enscript-function-name">mDNSPlatformTCPListen</span>(mDNSAddr_Type addrtype, mDNSIPPort *port, mDNSAddr *addr,
										  TCPSocketFlags socketFlags, mDNSBool reuseAddr, <span class="enscript-type">int</span> queueLength,
										  TCPAcceptedCallback callback, <span class="enscript-type">void</span> *context); <span class="enscript-comment">// Listen on a port
</span><span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">mDNSPlatformTCPSocketSetCallback</span>(TCPSocket *sock, TCPConnectionCallback callback, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> TCPSocket *<span class="enscript-function-name">mDNSPlatformTCPAccept</span>(TCPSocketFlags flags, <span class="enscript-type">int</span> sd);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>        <span class="enscript-function-name">mDNSPlatformTCPGetFD</span>(TCPSocket *sock);
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformTCPWritable</span>(TCPSocket *sock);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformTCPConnect</span>(TCPSocket *sock, <span class="enscript-type">const</span> mDNSAddr *dst, mDNSOpaque16 dstport,
                                         mDNSInterfaceID InterfaceID, TCPConnectionCallback callback, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformTCPCloseConnection</span>(TCPSocket *sock);
<span class="enscript-type">extern</span> <span class="enscript-type">long</span>       <span class="enscript-function-name">mDNSPlatformReadTCP</span>(TCPSocket *sock, <span class="enscript-type">void</span> *buf, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> buflen, mDNSBool *closed);
<span class="enscript-type">extern</span> <span class="enscript-type">long</span>       <span class="enscript-function-name">mDNSPlatformWriteTCP</span>(TCPSocket *sock, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> len);
<span class="enscript-type">extern</span> UDPSocket *<span class="enscript-function-name">mDNSPlatformUDPSocket</span>(<span class="enscript-type">const</span> mDNSIPPort requestedport);
<span class="enscript-type">extern</span> mDNSu16    <span class="enscript-function-name">mDNSPlatformGetUDPPort</span>(UDPSocket *sock);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformUDPClose</span>(UDPSocket *sock);
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformUDPSocketEncounteredEOF</span>(<span class="enscript-type">const</span> UDPSocket *sock);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformReceiveBPF_fd</span>(<span class="enscript-type">int</span> fd);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformUpdateProxyList</span>(<span class="enscript-type">const</span> mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSendRawPacket</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSetLocalAddressCacheEntry</span>(<span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> tpa, <span class="enscript-type">const</span> mDNSEthAddr *<span class="enscript-type">const</span> tha, mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSourceAddrForDest</span>(mDNSAddr *<span class="enscript-type">const</span> src, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> dst);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSendKeepalive</span>(mDNSAddr *sadd, mDNSAddr *dadd, mDNSIPPort *lport, mDNSIPPort *rport, mDNSu32 seq, mDNSu32 ack, mDNSu16 win);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformRetrieveTCPInfo</span>(mDNSAddr *laddr, mDNSIPPort *lport, mDNSAddr *raddr,  mDNSIPPort *rport, mDNSTCPInfo *mti);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformGetRemoteMacAddr</span>(mDNSAddr *raddr);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformStoreSPSMACAddr</span>(mDNSAddr *spsaddr, <span class="enscript-type">char</span> *ifname);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformClearSPSData</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformStoreOwnerOptRecord</span>(<span class="enscript-type">char</span> *ifname, DNSMessage *msg, <span class="enscript-type">int</span> length);

<span class="enscript-comment">// mDNSPlatformTLSSetupCerts/mDNSPlatformTLSTearDownCerts used by dnsextd
</span><span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformTLSSetupCerts</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformTLSTearDownCerts</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">// Platforms that support unicast browsing and dynamic update registration for clients who do not specify a domain
</span><span class="enscript-comment">// in browse/registration calls must implement these routines to get the &quot;default&quot; browse/registration list.
</span>
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformSetDNSConfig</span>(mDNSBool setservers, mDNSBool setsearch, domainname *<span class="enscript-type">const</span> fqdn, DNameListElem **RegDomains,
                                           DNameListElem **BrowseDomains, mDNSBool ackConfig);
<span class="enscript-type">extern</span> mStatus    <span class="enscript-function-name">mDNSPlatformGetPrimaryInterface</span>(mDNSAddr *v4, mDNSAddr *v6, mDNSAddr *router);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformDynDNSHostNameStatusChanged</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> dname, <span class="enscript-type">const</span> mStatus status);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSetAllowSleep</span>(mDNSBool allowSleep, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformPreventSleep</span>(mDNSu32 timeout, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>       <span class="enscript-function-name">mDNSPlatformSendWakeupPacket</span>(mDNSInterfaceID InterfaceID, <span class="enscript-type">char</span> *EthAddr, <span class="enscript-type">char</span> *IPAddr, <span class="enscript-type">int</span> iteration);

<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformInterfaceIsD2D</span>(mDNSInterfaceID InterfaceID);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformInterfaceIsAWDL</span>(mDNSInterfaceID interfaceID);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformValidRecordForQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q);
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformValidRecordForInterface</span>(<span class="enscript-type">const</span> AuthRecord *rr, mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> mDNSBool   <span class="enscript-function-name">mDNSPlatformValidQuestionForInterface</span>(DNSQuestion *q, <span class="enscript-type">const</span> NetworkInterfaceInfo *intf);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformFormatTime</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> t, mDNSu8 *buf, <span class="enscript-type">int</span> bufsize);

<span class="enscript-comment">// Platform event API
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>
<span class="enscript-comment">// Support for legacy NAT traversal protocols, implemented by the platform layer and callable by the core.
</span><span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">LNT_SendDiscoveryMsg</span>(mDNS *m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">LNT_ConfigureRouterInfo</span>(mDNS *m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> data, <span class="enscript-type">const</span> mDNSu16 len);
<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">LNT_GetExternalAddress</span>(mDNS *m);
<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">LNT_MapPort</span>(mDNS *m, NATTraversalInfo *<span class="enscript-type">const</span> n);
<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">LNT_UnmapPort</span>(mDNS *m, NATTraversalInfo *<span class="enscript-type">const</span> n);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">LNT_ClearState</span>(mDNS *<span class="enscript-type">const</span> m);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_LEGACY_NAT_TRAVERSAL_</span>

<span class="enscript-comment">// The core mDNS code provides these functions, for the platform support code to call at appropriate times
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_SetFQDN() is called once on startup (typically from mDNSPlatformInit())
</span><span class="enscript-comment">// and then again on each subsequent change of the host name.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_RegisterInterface() is used by the platform support layer to inform mDNSCore of what
</span><span class="enscript-comment">// physical and/or logical interfaces are available for sending and receiving packets.
</span><span class="enscript-comment">// Typically it is called on startup for each available interface, but register/deregister may be
</span><span class="enscript-comment">// called again later, on multiple occasions, to inform the core of interface configuration changes.
</span><span class="enscript-comment">// If set-&gt;Advertise is set non-zero, then mDNS_RegisterInterface() also registers the standard
</span><span class="enscript-comment">// resource records that should be associated with every publicised IP address/interface:
</span><span class="enscript-comment">// -- Name-to-address records (A/AAAA)
</span><span class="enscript-comment">// -- Address-to-name records (PTR)
</span><span class="enscript-comment">// -- Host information (HINFO)
</span><span class="enscript-comment">// IMPORTANT: The specified mDNSInterfaceID MUST NOT be 0, -1, or -2; these values have special meaning
</span><span class="enscript-comment">// mDNS_RegisterInterface does not result in the registration of global hostnames via dynamic update -
</span><span class="enscript-comment">// see mDNS_SetPrimaryInterfaceInfo, mDNS_AddDynDNSHostName, etc. for this purpose.
</span><span class="enscript-comment">// Note that the set may be deallocated immediately after it is deregistered via mDNS_DeegisterInterface.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNS_RegisterDNS() is used by the platform support layer to provide the core with the addresses of
</span><span class="enscript-comment">// available domain name servers for unicast queries/updates.  RegisterDNS() should be called once for
</span><span class="enscript-comment">// each name server, typically at startup, or when a new name server becomes available.  DeregiterDNS()
</span><span class="enscript-comment">// must be called whenever a registered name server becomes unavailable.  DeregisterDNSList deregisters
</span><span class="enscript-comment">// all registered servers.  mDNS_DNSRegistered() returns true if one or more servers are registered in the core.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNSCoreInitComplete() is called when the platform support layer is finished.
</span><span class="enscript-comment">// Typically this is at the end of mDNSPlatformInit(), but may be later
</span><span class="enscript-comment">// (on platforms like OT that allow asynchronous initialization of the networking stack).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNSCoreReceive() is called when a UDP packet is received
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// mDNSCoreMachineSleep() is called when the machine sleeps or wakes
</span><span class="enscript-comment">// (This refers to heavyweight laptop-style sleep/wake that disables network access,
</span><span class="enscript-comment">// not lightweight second-by-second CPU power management modes.)
</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNS_SetFQDN</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNS_ActivateNetWake_internal</span>  (mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNS_DeactivateNetWake_internal</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set);

<span class="enscript-comment">// Attributes that controls the Bonjour operation initiation and response speed for an interface.
</span><span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    FastActivation,     <span class="enscript-comment">// For p2p* and DirectLink type interfaces
</span>    NormalActivation,   <span class="enscript-comment">// For standard interface timing
</span>    SlowActivation      <span class="enscript-comment">// For flapping interfaces
</span>} InterfaceActivationSpeed;

<span class="enscript-type">extern</span> mStatus  <span class="enscript-function-name">mDNS_RegisterInterface</span>  (mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed probeDelay);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNS_DeregisterInterface</span>(mDNS *<span class="enscript-type">const</span> m, NetworkInterfaceInfo *set, InterfaceActivationSpeed probeDelay);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreInitComplete</span>(mDNS *<span class="enscript-type">const</span> m, mStatus result);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreReceive</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr, <span class="enscript-type">const</span> mDNSIPPort srcport,
                                <span class="enscript-type">const</span> mDNSAddr *dstaddr, <span class="enscript-type">const</span> mDNSIPPort dstport, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> CacheRecord *<span class="enscript-function-name">mDNSCheckCacheFlushRecords</span>(mDNS *m, CacheRecord *CacheFlushRecords, mDNSBool id_is_zero, <span class="enscript-type">int</span> numAnswers,
											   DNSQuestion *unicastQuestion, CacheRecord *NSECCachePtr, CacheRecord *NSECRecords,
											   mDNSu8 rcode);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreRestartQueries</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreRestartQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreRestartRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord  *rr, <span class="enscript-type">int</span> announceCount);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*FlushCache)(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*CallbackBeforeStartQuery)(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreRestartAddressQueries</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool SearchDomainsChanged, FlushCache flushCacheRecords,
                                              CallbackBeforeStartQuery beforeQueryStart, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSCoreHaveAdvertisedMulticastServices</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreMachineSleep</span>(mDNS *<span class="enscript-type">const</span> m, mDNSBool wake);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSCoreReadyForSleep</span>(mDNS *m, mDNSs32 now);
<span class="enscript-type">extern</span> mDNSs32  <span class="enscript-function-name">mDNSCoreIntervalToNextWake</span>(mDNS *<span class="enscript-type">const</span> m, mDNSs32 now);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">mDNSCoreReceiveRawPacket</span>  (mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> p, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID);

<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSAddrIsDNSMulticast</span>(<span class="enscript-type">const</span> mDNSAddr *ip);

<span class="enscript-type">extern</span> CacheRecord *<span class="enscript-function-name">CreateNewCacheEntry</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, CacheGroup *cg, mDNSs32 delay, mDNSBool Add, <span class="enscript-type">const</span> mDNSAddr *sourceAddress);
<span class="enscript-type">extern</span> CacheGroup *<span class="enscript-function-name">CacheGroupForName</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *r);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ScheduleNextCacheCheckTime</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSu32 slot, <span class="enscript-type">const</span> mDNSs32 event);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">SetNextCacheCheckTimeForRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">GrantCacheExtensions</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, mDNSu32 lease);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">MakeNegativeCacheRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> cr,
                                    <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> mDNSu16 rrtype, <span class="enscript-type">const</span> mDNSu16 rrclass, mDNSu32 ttl_seconds,
                                    mDNSInterfaceID InterfaceID, DNSServer *dnsserver);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">CompleteDeregistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerCurrentQuestionWithResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> QC_result AddRecord);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">AnswerQuestionByFollowingCNAME</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, ResourceRecord *rr);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">InterfaceNameForID</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">DNSServerChangeForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q, DNSServer *newServer);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ActivateUnicastRegistration</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">CheckSuppressUnusableQuestions</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">RetrySearchDomainQuestions</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">DomainEnumQuery</span>(<span class="enscript-type">const</span> domainname *qname);
<span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">UpdateKeepaliveRData</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *rr, NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSBool updateMac, <span class="enscript-type">char</span> *ethAddr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">UpdateKeepaliveRMACAsync</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">UpdateRMAC</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context);

<span class="enscript-comment">// Used only in logging to restrict the number of /etc/hosts entries printed
</span><span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">FreeEtcHosts</span>(mDNS *<span class="enscript-type">const</span> m, AuthRecord *<span class="enscript-type">const</span> rr, mStatus result);
<span class="enscript-comment">// exported for using the hash for /etc/hosts AuthRecords
</span><span class="enscript-type">extern</span> AuthGroup *<span class="enscript-function-name">AuthGroupForName</span>(AuthHash *r, <span class="enscript-type">const</span> mDNSu32 namehash, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name);
<span class="enscript-type">extern</span> AuthGroup *<span class="enscript-function-name">AuthGroupForRecord</span>(AuthHash *r, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr);
<span class="enscript-type">extern</span> AuthGroup *<span class="enscript-function-name">InsertAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthHash *r, AuthRecord *rr);
<span class="enscript-type">extern</span> AuthGroup *<span class="enscript-function-name">RemoveAuthRecord</span>(mDNS *<span class="enscript-type">const</span> m, AuthHash *r, AuthRecord *rr);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-comment">// For now this LocalSleepProxy stuff is specific to Mac OS X.
</span><span class="enscript-comment">// In the future, if there's demand, we may see if we can abstract it out cleanly into the platform layer
</span><span class="enscript-type">extern</span> mStatus <span class="enscript-function-name">ActivateLocalProxy</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf, mDNSBool offloadKeepAlivesOnly, mDNSBool *keepaliveOnly);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">SupportsInNICProxy</span>(NetworkInterfaceInfo *<span class="enscript-type">const</span> intf);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ProxyCallback</span> (<span class="enscript-type">void</span> *socket, DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSAddr *<span class="enscript-type">const</span> srcaddr,
    <span class="enscript-type">const</span> mDNSIPPort srcport, <span class="enscript-type">const</span> mDNSAddr *dstaddr, <span class="enscript-type">const</span> mDNSIPPort dstport, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformInitDNSProxySkts</span>(ProxyCallback *UDPCallback, ProxyCallback *TCPCallback);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformCloseDNSProxySkts</span>(mDNS *<span class="enscript-type">const</span> m);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformDisposeProxyContext</span>(<span class="enscript-type">void</span> *context);
<span class="enscript-type">extern</span> mDNSu8 *<span class="enscript-function-name">DNSProxySetAttributes</span>(DNSQuestion *q, DNSMessageHeader *h, DNSMessage *msg, mDNSu8 *start, mDNSu8 *limit);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformGetDNSRoutePolicy</span>(DNSQuestion *q, mDNSBool *isBlocked);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSPlatformSetSocktOpt</span>(<span class="enscript-type">void</span> *sock, mDNSTransport_Type transType, mDNSAddr_Type addrType, <span class="enscript-type">const</span> DNSQuestion *q);
<span class="enscript-type">extern</span> mDNSs32 <span class="enscript-function-name">mDNSPlatformGetPID</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">mDNSValidKeepAliveRecord</span>(AuthRecord *rr);
<span class="enscript-type">extern</span> mDNSBool <span class="enscript-function-name">CacheRecordRmvEventsForQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *q);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">GetRandomUUIDLabel</span>(domainlabel *label);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">GetRandomUUIDLocalHostname</span>(domainname *hostname);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Sleep</span> <span class="enscript-variable-name">Proxy</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Sleep Proxy Server Property Encoding
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Sleep Proxy Servers are advertised using a structured service name, consisting of four
</span><span class="enscript-comment">// metrics followed by a human-readable name. The metrics assist clients in deciding which
</span><span class="enscript-comment">// Sleep Proxy Server(s) to use when multiple are available on the network. Each metric
</span><span class="enscript-comment">// is a two-digit decimal number in the range 10-99. Lower metrics are generally better.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   AA-BB-CC-DD.FF Name
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Metrics:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// AA = Intent
</span><span class="enscript-comment">// BB = Portability
</span><span class="enscript-comment">// CC = Marginal Power
</span><span class="enscript-comment">// DD = Total Power
</span><span class="enscript-comment">// FF = Features Supported (Currently TCP Keepalive only)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// ** Intent Metric **
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 20 = Dedicated Sleep Proxy Server -- a device, permanently powered on,
</span><span class="enscript-comment">//      installed for the express purpose of providing Sleep Proxy Service.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 30 = Primary Network Infrastructure Hardware -- a router, DHCP server, NAT gateway,
</span><span class="enscript-comment">//      or similar permanently installed device which is permanently powered on.
</span><span class="enscript-comment">//      This is hardware designed for the express purpose of being network
</span><span class="enscript-comment">//      infrastructure, and for most home users is typically a single point
</span><span class="enscript-comment">//      of failure for the local network -- e.g. most home users only have
</span><span class="enscript-comment">//      a single NAT gateway / DHCP server. Even though in principle the
</span><span class="enscript-comment">//      hardware might technically be capable of running different software,
</span><span class="enscript-comment">//      a typical user is unlikely to do that. e.g. AirPort base station.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 40 = Primary Network Infrastructure Software -- a general-purpose computer
</span><span class="enscript-comment">//      (e.g. Mac, Windows, Linux, etc.) which is currently running DHCP server
</span><span class="enscript-comment">//      or NAT gateway software, but the user could choose to turn that off
</span><span class="enscript-comment">//      fairly easily. e.g. iMac running Internet Sharing
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 50 = Secondary Network Infrastructure Hardware -- like primary infrastructure
</span><span class="enscript-comment">//      hardware, except not a single point of failure for the entire local network.
</span><span class="enscript-comment">//      For example, an AirPort base station in bridge mode. This may have clients
</span><span class="enscript-comment">//      associated with it, and if it goes away those clients will be inconvenienced,
</span><span class="enscript-comment">//      but unlike the NAT gateway / DHCP server, the entire local network is not
</span><span class="enscript-comment">//      dependent on it.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 60 = Secondary Network Infrastructure Software -- like 50, but in a general-
</span><span class="enscript-comment">//      purpose CPU.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 70 = Incidentally Available Hardware -- a device which has no power switch
</span><span class="enscript-comment">//      and is generally left powered on all the time. Even though it is not a
</span><span class="enscript-comment">//      part of what we conventionally consider network infrastructure (router,
</span><span class="enscript-comment">//      DHCP, NAT, DNS, etc.), and the rest of the network can operate fine
</span><span class="enscript-comment">//      without it, since it's available and unlikely to be turned off, it is a
</span><span class="enscript-comment">//      reasonable candidate for providing Sleep Proxy Service e.g. Apple TV,
</span><span class="enscript-comment">//      or an AirPort base station in client mode, associated with an existing
</span><span class="enscript-comment">//      wireless network (e.g. AirPort Express connected to a music system, or
</span><span class="enscript-comment">//      being used to share a USB printer).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 80 = Incidentally Available Software -- a general-purpose computer which
</span><span class="enscript-comment">//      happens at this time to be set to &quot;never sleep&quot;, and as such could be
</span><span class="enscript-comment">//      useful as a Sleep Proxy Server, but has not been intentionally provided
</span><span class="enscript-comment">//      for this purpose. Of all the Intent Metric categories this is the
</span><span class="enscript-comment">//      one most likely to be shut down or put to sleep without warning.
</span><span class="enscript-comment">//      However, if nothing else is availalable, it may be better than nothing.
</span><span class="enscript-comment">//      e.g. Office computer in the workplace which has been set to &quot;never sleep&quot;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// ** Portability Metric **
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Inversely related to mass of device, on the basis that, all other things
</span><span class="enscript-comment">// being equal, heavier devices are less likely to be moved than lighter devices.
</span><span class="enscript-comment">// E.g. A MacBook running Internet Sharing is probably more likely to be
</span><span class="enscript-comment">// put to sleep and taken away than a Mac Pro running Internet Sharing.
</span><span class="enscript-comment">// The Portability Metric is a logarithmic decibel scale, computed by taking the
</span><span class="enscript-comment">// (approximate) mass of the device in milligrammes, taking the base 10 logarithm
</span><span class="enscript-comment">// of that, multiplying by 10, and subtracting the result from 100:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   Portability Metric = 100 - (log10(mg) * 10)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The Portability Metric is not necessarily computed literally from the actual
</span><span class="enscript-comment">// mass of the device; the intent is just that lower numbers indicate more
</span><span class="enscript-comment">// permanent devices, and higher numbers indicate devices more likely to be
</span><span class="enscript-comment">// removed from the network, e.g., in order of increasing portability:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Mac Pro &lt; iMac &lt; Laptop &lt; iPhone
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Example values:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 10 = 1 metric tonne
</span><span class="enscript-comment">// 40 = 1kg
</span><span class="enscript-comment">// 70 = 1g
</span><span class="enscript-comment">// 90 = 10mg
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// ** Marginal Power and Total Power Metrics **
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The Marginal Power Metric is the power difference between sleeping and staying awake
</span><span class="enscript-comment">// to be a Sleep Proxy Server.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The Total Power Metric is the total power consumption when being Sleep Proxy Server.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The Power Metrics use a logarithmic decibel scale, computed as ten times the
</span><span class="enscript-comment">// base 10 logarithm of the (approximate) power in microwatts:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   Power Metric = log10(uW) * 10
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Higher values indicate higher power consumption. Example values:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 10 =  10 uW
</span><span class="enscript-comment">// 20 = 100 uW
</span><span class="enscript-comment">// 30 =   1 mW
</span><span class="enscript-comment">// 60 =   1 W
</span><span class="enscript-comment">// 90 =   1 kW
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mDNSSleepProxyMetric_Dedicated          = 20,
    mDNSSleepProxyMetric_PrimaryHardware    = 30,
    mDNSSleepProxyMetric_PrimarySoftware    = 40,
    mDNSSleepProxyMetric_SecondaryHardware  = 50,
    mDNSSleepProxyMetric_SecondarySoftware  = 60,
    mDNSSleepProxyMetric_IncidentalHardware = 70,
    mDNSSleepProxyMetric_IncidentalSoftware = 80
} mDNSSleepProxyMetric;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span>
{
    mDNS_NoWake        = 0, <span class="enscript-comment">// System does not support Wake on LAN
</span>    mDNS_WakeOnAC      = 1, <span class="enscript-comment">// System supports Wake on LAN when connected to AC power only
</span>    mDNS_WakeOnBattery = 2  <span class="enscript-comment">// System supports Wake on LAN on battery
</span>} mDNSWakeForNetworkAccess;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSCoreBeSleepProxyServer_internal</span>(mDNS *<span class="enscript-type">const</span> m, mDNSu8 sps, mDNSu8 port, mDNSu8 marginalpower, mDNSu8 totpower, mDNSu8 features);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mDNSCoreBeSleepProxyServer</span>(M,S,P,MP,TP,F)                       \
    do { mDNS_Lock(m); mDNSCoreBeSleepProxyServer_internal((M),(S),(P),(MP),(TP),(F)); mDNS_Unlock(m); } while(0)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">FindSPSInCache</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> CacheRecord *sps[3]);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PrototypeSPSName</span>(X) ((X)[0] &gt;= 11 &amp;&amp; (X)[3] == <span class="enscript-string">'-'</span> &amp;&amp; (X)[ 4] == <span class="enscript-string">'9'</span> &amp;&amp; (X)[ 5] == <span class="enscript-string">'9'</span> &amp;&amp; \
                             (X)[6] == <span class="enscript-string">'-'</span> &amp;&amp; (X)[ 7] == <span class="enscript-string">'9'</span> &amp;&amp; (X)[ 8] == <span class="enscript-string">'9'</span> &amp;&amp; \
                             (X)[9] == <span class="enscript-string">'-'</span> &amp;&amp; (X)[10] == <span class="enscript-string">'9'</span> &amp;&amp; (X)[11] == <span class="enscript-string">'9'</span>    )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ValidSPSName</span>(X) ((X)[0] &gt;= 5 &amp;&amp; mDNSIsDigit((X)[1]) &amp;&amp; mDNSIsDigit((X)[2]) &amp;&amp; mDNSIsDigit((X)[4]) &amp;&amp; mDNSIsDigit((X)[5]))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SPSMetric</span>(X) (!ValidSPSName(X) || PrototypeSPSName(X) ? 1000000 : \
                      ((X)[1]-<span class="enscript-string">'0'</span>) * 100000 + ((X)[2]-<span class="enscript-string">'0'</span>) * 10000 + ((X)[4]-<span class="enscript-string">'0'</span>) * 1000 + ((X)[5]-<span class="enscript-string">'0'</span>) * 100 + ((X)[7]-<span class="enscript-string">'0'</span>) * 10 + ((X)[8]-<span class="enscript-string">'0'</span>))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LocalSPSMetric</span>(X) ( (X)-&gt;SPSType * 10000 + (X)-&gt;SPSPortability * 100 + (X)-&gt;SPSMarginalPower)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SPSFeatures</span>(X) ((X)[0] &gt;= 13 &amp;&amp; (X)[12] ==<span class="enscript-string">'.'</span> ? ((X)[13]-<span class="enscript-string">'0'</span>) : 0 )

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_DIGEST_LENGTH</span>   16          <span class="enscript-comment">/* digest length in bytes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_BLOCK_BYTES</span>     64          <span class="enscript-comment">/* block size in bytes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MD5_BLOCK_LONG</span>       (MD5_BLOCK_BYTES / sizeof(mDNSu32))

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> MD5state_st
{
    mDNSu32 A,B,C,D;
    mDNSu32 Nl,Nh;
    mDNSu32 data[MD5_BLOCK_LONG];
    mDNSu32 num;
} MD5_CTX;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">MD5_Init</span>(MD5_CTX *c);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">MD5_Update</span>(MD5_CTX *c, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> len);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">MD5_Final</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *md, MD5_CTX *c);

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Compile</span>-<span class="enscript-variable-name">Time</span> <span class="enscript-variable-name">assertion</span> <span class="enscript-variable-name">checks</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Some C compiler cleverness. We can make the compiler check certain things for
</span><span class="enscript-comment">// us, and report compile-time errors if anything is wrong. The usual way to do
</span><span class="enscript-comment">// this would be to use a run-time &quot;if&quot; statement, but then you don't find out
</span><span class="enscript-comment">// what's wrong until you run the software. This way, if the assertion condition
</span><span class="enscript-comment">// is false, the array size is negative, and the complier complains immediately.
</span>
<span class="enscript-type">struct</span> CompileTimeAssertionChecks_mDNS
{
    <span class="enscript-comment">// Check that the compiler generated our on-the-wire packet format structure definitions
</span>    <span class="enscript-comment">// properly packed, without adding padding bytes to align fields on 32-bit or 64-bit boundaries.
</span>    <span class="enscript-type">char</span> assert0[(<span class="enscript-keyword">sizeof</span>(rdataSRV)         == 262                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert1[(<span class="enscript-keyword">sizeof</span>(DNSMessageHeader) ==  12                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert2[(<span class="enscript-keyword">sizeof</span>(DNSMessage)       ==  12+AbsoluteMaxDNSMessageData) ? 1 : -1];
    <span class="enscript-type">char</span> assert3[(<span class="enscript-keyword">sizeof</span>(mDNSs8)           ==   1                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert4[(<span class="enscript-keyword">sizeof</span>(mDNSu8)           ==   1                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert5[(<span class="enscript-keyword">sizeof</span>(mDNSs16)          ==   2                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert6[(<span class="enscript-keyword">sizeof</span>(mDNSu16)          ==   2                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert7[(<span class="enscript-keyword">sizeof</span>(mDNSs32)          ==   4                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert8[(<span class="enscript-keyword">sizeof</span>(mDNSu32)          ==   4                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assert9[(<span class="enscript-keyword">sizeof</span>(mDNSOpaque16)     ==   2                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assertA[(<span class="enscript-keyword">sizeof</span>(mDNSOpaque32)     ==   4                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assertB[(<span class="enscript-keyword">sizeof</span>(mDNSOpaque128)    ==  16                          ) ? 1 : -1];
    <span class="enscript-type">char</span> assertC[(<span class="enscript-keyword">sizeof</span>(CacheRecord  )    ==  <span class="enscript-keyword">sizeof</span>(CacheGroup)          ) ? 1 : -1];
    <span class="enscript-type">char</span> assertD[(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)              &gt;=  4                           ) ? 1 : -1];
    <span class="enscript-type">char</span> assertE[(StandardAuthRDSize       &gt;=  256                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertF[(<span class="enscript-keyword">sizeof</span>(EthernetHeader)   ==   14                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertG[(<span class="enscript-keyword">sizeof</span>(ARP_EthIP     )   ==   28                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertH[(<span class="enscript-keyword">sizeof</span>(IPv4Header    )   ==   20                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertI[(<span class="enscript-keyword">sizeof</span>(IPv6Header    )   ==   40                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertJ[(<span class="enscript-keyword">sizeof</span>(IPv6NDP       )   ==   24                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertK[(<span class="enscript-keyword">sizeof</span>(UDPHeader     )   ==    8                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertL[(<span class="enscript-keyword">sizeof</span>(IKEHeader     )   ==   28                         ) ? 1 : -1];
    <span class="enscript-type">char</span> assertM[(<span class="enscript-keyword">sizeof</span>(TCPHeader     )   ==   20                         ) ? 1 : -1];
	<span class="enscript-type">char</span> assertN[(<span class="enscript-keyword">sizeof</span>(rdataOPT)		   ==   24                         ) ? 1 : -1];
	<span class="enscript-type">char</span> assertO[(<span class="enscript-keyword">sizeof</span>(rdataRRSig)	   ==   20                         ) ? 1 : -1];
	<span class="enscript-type">char</span> assertP[(<span class="enscript-keyword">sizeof</span>(PCPMapRequest)    ==   60                         ) ? 1 : -1];
	<span class="enscript-type">char</span> assertQ[(<span class="enscript-keyword">sizeof</span>(PCPMapReply)      ==   60                         ) ? 1 : -1];


    <span class="enscript-comment">// Check our structures are reasonable sizes. Including overly-large buffers, or embedding
</span>    <span class="enscript-comment">// other overly-large structures instead of having a pointer to them, can inadvertently
</span>    <span class="enscript-comment">// cause structure sizes (and therefore memory usage) to balloon unreasonably.
</span>    <span class="enscript-type">char</span> sizecheck_RDataBody           [(<span class="enscript-keyword">sizeof</span>(RDataBody)            ==   264) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_ResourceRecord      [(<span class="enscript-keyword">sizeof</span>(ResourceRecord)       &lt;=    72) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_AuthRecord          [(<span class="enscript-keyword">sizeof</span>(AuthRecord)           &lt;=  1168) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_CacheRecord         [(<span class="enscript-keyword">sizeof</span>(CacheRecord)          &lt;=   232) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_CacheGroup          [(<span class="enscript-keyword">sizeof</span>(CacheGroup)           &lt;=   232) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_DNSQuestion         [(<span class="enscript-keyword">sizeof</span>(DNSQuestion)          &lt;=  1136) ? 1 : -1];

    <span class="enscript-type">char</span> sizecheck_ZoneData            [(<span class="enscript-keyword">sizeof</span>(ZoneData)             &lt;=  2000) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_NATTraversalInfo    [(<span class="enscript-keyword">sizeof</span>(NATTraversalInfo)     &lt;=   200) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_HostnameInfo        [(<span class="enscript-keyword">sizeof</span>(HostnameInfo)         &lt;=  3050) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_DNSServer           [(<span class="enscript-keyword">sizeof</span>(DNSServer)            &lt;=   328) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_NetworkInterfaceInfo[(<span class="enscript-keyword">sizeof</span>(NetworkInterfaceInfo) &lt;=  8272) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_ServiceRecordSet    [(<span class="enscript-keyword">sizeof</span>(ServiceRecordSet)     &lt;=  4728) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_DomainAuthInfo      [(<span class="enscript-keyword">sizeof</span>(DomainAuthInfo)       &lt;=   944) ? 1 : -1];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-type">char</span> sizecheck_ClientTunnel        [(<span class="enscript-keyword">sizeof</span>(ClientTunnel)         &lt;=  1512) ? 1 : -1];
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">OS_LOG</span>)
    <span class="enscript-comment">// structure size is assumed by LogRedact routine.
</span>    <span class="enscript-type">char</span> sizecheck_mDNSAddr            [(<span class="enscript-keyword">sizeof</span>(mDNSAddr)             ==    20) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_mDNSv4Addr          [(<span class="enscript-keyword">sizeof</span>(mDNSv4Addr)           ==     4) ? 1 : -1];
    <span class="enscript-type">char</span> sizecheck_mDNSv6Addr          [(<span class="enscript-keyword">sizeof</span>(mDNSv6Addr)           ==    16) ? 1 : -1];
#<span class="enscript-reference">endif</span>
};

<span class="enscript-comment">// Routine to initialize device-info TXT record contents
</span>mDNSu32 <span class="enscript-function-name">initializeDeviceInfoTXT</span>(mDNS *m, mDNSu8 *ptr);

<span class="enscript-comment">// ***************************************************************************
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>