<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>DNSCommon.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">DNSCommon.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="DNSCommon.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4; c-file-style: &quot;bsd&quot;; c-basic-offset: 4; fill-column: 108; indent-tabs-mode: nil; -*-
 *
 * Copyright (c) 2002-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="enscript-comment">// Set mDNS_InstantiateInlines to tell mDNSEmbeddedAPI.h to instantiate inline functions, if necessary
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNS_InstantiateInlines</span> 1
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoAlg.h&quot;</span>

<span class="enscript-comment">// Disable certain benign warnings with Microsoft compilers
</span>#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_MSC_VER</span>))
<span class="enscript-comment">// Disable &quot;conditional expression is constant&quot; warning for debug macros.
</span><span class="enscript-comment">// Otherwise, this generates warnings for the perfectly natural construct &quot;while(1)&quot;
</span><span class="enscript-comment">// If someone knows a variant way of writing &quot;while(1)&quot; that doesn't generate warning messages, please let us know
</span>    #pragma warning(disable:4127)
<span class="enscript-comment">// Disable &quot;array is too small to include a terminating null character&quot; warning
</span><span class="enscript-comment">// -- domain labels have an initial length byte, not a terminating null character
</span>    #pragma warning(disable:4295)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Program</span> <span class="enscript-variable-name">Constants</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_Any       = 0;
mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterfaceMark       = (mDNSInterfaceID)-1;
mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_LocalOnly = (mDNSInterfaceID)-2;
mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_P2P       = (mDNSInterfaceID)-3;
mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID uDNSInterfaceMark       = (mDNSInterfaceID)-4;
mDNSexport <span class="enscript-type">const</span> mDNSInterfaceID mDNSInterface_BLE       = (mDNSInterfaceID)-5;

<span class="enscript-comment">// Note: Microsoft's proposed &quot;Link Local Multicast Name Resolution Protocol&quot; (LLMNR) is essentially a limited version of
</span><span class="enscript-comment">// Multicast DNS, using the same packet formats, naming syntax, and record types as Multicast DNS, but on a different UDP
</span><span class="enscript-comment">// port and multicast address, which means it won't interoperate with the existing installed base of Multicast DNS responders.
</span><span class="enscript-comment">// LLMNR uses IPv4 multicast address 224.0.0.252, IPv6 multicast address FF02::0001:0003, and UDP port 5355.
</span><span class="enscript-comment">// Uncomment the appropriate lines below to build a special Multicast DNS responder for testing interoperability
</span><span class="enscript-comment">// with Microsoft's LLMNR client code.
</span>
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">DiscardPortAsNumber</span>               9
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">SSHPortAsNumber</span>                  22
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">UnicastDNSPortAsNumber</span>           53
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">SSDPPortAsNumber</span>               1900
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">IPSECPortAsNumber</span>              4500
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">NSIPCPortAsNumber</span>              5030       // Port used for dnsextd to talk to local nameserver bound to loopback
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">NATPMPAnnouncementPortAsNumber</span> 5350
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">NATPMPPortAsNumber</span>             5351
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">DNSEXTPortAsNumber</span>             5352       // Port used for end-to-end DNS operations like LLQ, Updates with Leases, etc.
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">MulticastDNSPortAsNumber</span>       5353
#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">LoopbackIPCPortAsNumber</span>        5354
<span class="enscript-comment">//#define MulticastDNSPortAsNumber       5355		// LLMNR
</span>#<span class="enscript-reference">define</span>   <span class="enscript-variable-name">PrivateDNSPortAsNumber</span>         5533

mDNSexport <span class="enscript-type">const</span> mDNSIPPort DiscardPort            = { { DiscardPortAsNumber            &gt;&gt; 8, DiscardPortAsNumber            &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort SSHPort                = { { SSHPortAsNumber                &gt;&gt; 8, SSHPortAsNumber                &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort UnicastDNSPort         = { { UnicastDNSPortAsNumber         &gt;&gt; 8, UnicastDNSPortAsNumber         &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort SSDPPort               = { { SSDPPortAsNumber               &gt;&gt; 8, SSDPPortAsNumber               &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort IPSECPort              = { { IPSECPortAsNumber              &gt;&gt; 8, IPSECPortAsNumber              &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort NSIPCPort              = { { NSIPCPortAsNumber              &gt;&gt; 8, NSIPCPortAsNumber              &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort NATPMPAnnouncementPort = { { NATPMPAnnouncementPortAsNumber &gt;&gt; 8, NATPMPAnnouncementPortAsNumber &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort NATPMPPort             = { { NATPMPPortAsNumber             &gt;&gt; 8, NATPMPPortAsNumber             &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort DNSEXTPort             = { { DNSEXTPortAsNumber             &gt;&gt; 8, DNSEXTPortAsNumber             &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort MulticastDNSPort       = { { MulticastDNSPortAsNumber       &gt;&gt; 8, MulticastDNSPortAsNumber       &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort LoopbackIPCPort        = { { LoopbackIPCPortAsNumber        &gt;&gt; 8, LoopbackIPCPortAsNumber        &amp; 0xFF } };
mDNSexport <span class="enscript-type">const</span> mDNSIPPort PrivateDNSPort         = { { PrivateDNSPortAsNumber         &gt;&gt; 8, PrivateDNSPortAsNumber         &amp; 0xFF } };

mDNSexport <span class="enscript-type">const</span> OwnerOptData zeroOwner         = { 0, 0, { { 0 } }, { { 0 } }, { { 0 } } };

mDNSexport <span class="enscript-type">const</span> mDNSIPPort zeroIPPort        = { { 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSv4Addr zerov4Addr        = { { 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSv6Addr zerov6Addr        = { { 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSEthAddr zeroEthAddr       = { { 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSv4Addr onesIPv4Addr      = { { 255, 255, 255, 255 } };
mDNSexport <span class="enscript-type">const</span> mDNSv6Addr onesIPv6Addr      = { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } };
mDNSexport <span class="enscript-type">const</span> mDNSEthAddr onesEthAddr       = { { 255, 255, 255, 255, 255, 255 } };
mDNSexport <span class="enscript-type">const</span> mDNSAddr zeroAddr          = { mDNSAddrType_None, {{{ 0 }}} };

mDNSexport <span class="enscript-type">const</span> mDNSv4Addr AllDNSAdminGroup   = { { 239, 255, 255, 251 } };
mDNSexport <span class="enscript-type">const</span> mDNSv4Addr AllHosts_v4        = { { 224,   0,   0,   1 } };  <span class="enscript-comment">// For NAT-PMP &amp; PCP Annoucements
</span>mDNSexport <span class="enscript-type">const</span> mDNSv6Addr AllHosts_v6        = { { 0xFF,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x01 } };
mDNSexport <span class="enscript-type">const</span> mDNSv6Addr NDP_prefix         = { { 0xFF,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x01, 0xFF,0x00,0x00,0xFB } };  <span class="enscript-comment">// FF02:0:0:0:0:1:FF00::/104
</span>mDNSexport <span class="enscript-type">const</span> mDNSEthAddr AllHosts_v6_Eth    = { { 0x33, 0x33, 0x00, 0x00, 0x00, 0x01 } };
mDNSexport <span class="enscript-type">const</span> mDNSAddr AllDNSLinkGroup_v4 = { mDNSAddrType_IPv4, { { { 224,   0,   0, 251 } } } };
<span class="enscript-comment">//mDNSexport const mDNSAddr  AllDNSLinkGroup_v4 = { mDNSAddrType_IPv4, { { { 224,   0,   0, 252 } } } }; // LLMNR
</span>mDNSexport <span class="enscript-type">const</span> mDNSAddr AllDNSLinkGroup_v6 = { mDNSAddrType_IPv6, { { { 0xFF,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0xFB } } } };
<span class="enscript-comment">//mDNSexport const mDNSAddr  AllDNSLinkGroup_v6 = { mDNSAddrType_IPv6, { { { 0xFF,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x01,0x00,0x03 } } } }; // LLMNR
</span>
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 zeroID          = { { 0, 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 onesID          = { { 255, 255 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 QueryFlags      = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery,                0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 uQueryFlags     = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery | kDNSFlag0_RD, 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 DNSSecQFlags    = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery | kDNSFlag0_RD, kDNSFlag1_CD } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 ResponseFlags   = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery | kDNSFlag0_AA, 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 UpdateReqFlags  = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_Update,                  0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque16 UpdateRespFlags = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_Update,                  0 } };

mDNSexport <span class="enscript-type">const</span> mDNSOpaque64  zeroOpaque64     = { { 0 } };
mDNSexport <span class="enscript-type">const</span> mDNSOpaque128 zeroOpaque128    = { { 0 } };

<span class="enscript-type">extern</span> mDNS mDNSStorage;

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">General</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// return true for RFC1918 private addresses
</span>mDNSexport mDNSBool <span class="enscript-function-name">mDNSv4AddrIsRFC1918</span>(<span class="enscript-type">const</span> mDNSv4Addr * <span class="enscript-type">const</span> addr)
{
    <span class="enscript-keyword">return</span> ((addr-&gt;b[0] == 10) ||                                 <span class="enscript-comment">// 10/8 prefix
</span>            (addr-&gt;b[0] == 172 &amp;&amp; (addr-&gt;b[1] &amp; 0xF0) == 16) ||   <span class="enscript-comment">// 172.16/12
</span>            (addr-&gt;b[0] == 192 &amp;&amp; addr-&gt;b[1] == 168));            <span class="enscript-comment">// 192.168/16
</span>}

mDNSexport <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSScopeToString</span>(mDNSu32 scope)
{
    <span class="enscript-keyword">switch</span> (scope)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeNone</span>:
            <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Unscoped&quot;</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeInterfaceID</span>:
            <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;InterfaceScoped&quot;</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kScopeServiceID</span>:
            <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;ServiceScoped&quot;</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Unknown&quot;</span>;
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNSAddrMapIPv4toIPv6</span>(mDNSv4Addr* in, mDNSv6Addr* out)
{
    out-&gt;l[0] = 0;
    out-&gt;l[1] = 0;
    out-&gt;w[4] = 0;
    out-&gt;w[5] = 0xffff;
    out-&gt;b[12] = in-&gt;b[0];
    out-&gt;b[13] = in-&gt;b[1];
    out-&gt;b[14] = in-&gt;b[2];
    out-&gt;b[15] = in-&gt;b[3];
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSAddrIPv4FromMappedIPv6</span>(mDNSv6Addr *in, mDNSv4Addr* out)
{
    <span class="enscript-keyword">if</span> (in-&gt;l[0] != 0 || in-&gt;l[1] != 0 || in-&gt;w[4] != 0 || in-&gt;w[5] != 0xffff)
        <span class="enscript-keyword">return</span> mDNSfalse;

    out-&gt;NotAnInteger = in-&gt;l[3];
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSexport NetworkInterfaceInfo *<span class="enscript-function-name">GetFirstActiveInterface</span>(NetworkInterfaceInfo *intf)
{
    <span class="enscript-keyword">while</span> (intf &amp;&amp; !intf-&gt;InterfaceActive) intf = intf-&gt;next;
    <span class="enscript-keyword">return</span>(intf);
}

mDNSexport mDNSInterfaceID <span class="enscript-function-name">GetNextActiveInterfaceID</span>(<span class="enscript-type">const</span> NetworkInterfaceInfo *intf)
{
    <span class="enscript-type">const</span> NetworkInterfaceInfo *next = GetFirstActiveInterface(intf-&gt;next);
    <span class="enscript-keyword">if</span> (next) <span class="enscript-keyword">return</span>(next-&gt;InterfaceID);<span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(mDNSNULL);
}

mDNSexport mDNSu32 <span class="enscript-function-name">NumCacheRecordsForInterfaceID</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m, mDNSInterfaceID id)
{
    mDNSu32 slot, used = 0;
    CacheGroup *cg;
    <span class="enscript-type">const</span> CacheRecord *rr;
    FORALL_CACHERECORDS(slot, cg, rr)
    {
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.InterfaceID == id)
            used++;
    }
    <span class="enscript-keyword">return</span>(used);
}

mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSTypeName</span>(mDNSu16 rrtype)
{
    <span class="enscript-keyword">switch</span> (rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:    <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;Addr&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:   <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;NS&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;CNAME&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:  <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;SOA&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NULL</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;NULL&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:  <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;PTR&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;HINFO&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:  <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;TXT&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;AAAA&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:  <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;SRV&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;OPT&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;NSEC&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;NSEC3&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3PARAM</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;NSEC3PARAM&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;TSIG&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RRSIG</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;RRSIG&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNSKEY</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;DNSKEY&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DS</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;DS&quot;</span>);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSQType_ANY</span>: <span class="enscript-keyword">return</span>(<span class="enscript-string">&quot;ANY&quot;</span>);
    <span class="enscript-reference">default</span>:            {
        <span class="enscript-type">static</span> <span class="enscript-type">char</span> buffer[16];
        mDNS_snprintf(buffer, <span class="enscript-keyword">sizeof</span>(buffer), <span class="enscript-string">&quot;TYPE%d&quot;</span>, rrtype);
        <span class="enscript-keyword">return</span>(buffer);
    }
    }
}

mDNSlocal <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSSECAlgName</span>(mDNSu8 alg)
{
    <span class="enscript-keyword">switch</span> (alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;RSA_SHA1&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_DSA_NSEC3_SHA1</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;DSA_NSEC3_SHA1&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;RSA_NSEC3_SHA1&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;RSA_SHA256&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;RSA_SHA512&quot;</span>;
    <span class="enscript-reference">default</span>: {
        <span class="enscript-type">static</span> <span class="enscript-type">char</span> algbuffer[16];
        mDNS_snprintf(algbuffer, <span class="enscript-keyword">sizeof</span>(algbuffer), <span class="enscript-string">&quot;ALG%d&quot;</span>, alg);
        <span class="enscript-keyword">return</span>(algbuffer);
    }
    }
}

mDNSlocal <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSSECDigestName</span>(mDNSu8 digest)
{
    <span class="enscript-keyword">switch</span> (digest)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;SHA1&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;SHA256&quot;</span>;
    <span class="enscript-reference">default</span>:
        {
        <span class="enscript-type">static</span> <span class="enscript-type">char</span> digbuffer[16];
        mDNS_snprintf(digbuffer, <span class="enscript-keyword">sizeof</span>(digbuffer), <span class="enscript-string">&quot;DIG%d&quot;</span>, digest);
        <span class="enscript-keyword">return</span>(digbuffer);
        }
    }
}

mDNSexport mDNSu32 <span class="enscript-function-name">swap32</span>(mDNSu32 x)
{
    mDNSu8 *ptr = (mDNSu8 *)&amp;x;
    <span class="enscript-keyword">return</span> (mDNSu32)((mDNSu32)ptr[0] &lt;&lt; 24 | (mDNSu32)ptr[1] &lt;&lt; 16 | (mDNSu32)ptr[2] &lt;&lt; 8 | ptr[3]);
}

mDNSexport mDNSu16 <span class="enscript-function-name">swap16</span>(mDNSu16 x)
{
    mDNSu8 *ptr = (mDNSu8 *)&amp;x;
    <span class="enscript-keyword">return</span> (mDNSu16)((mDNSu16)ptr[0] &lt;&lt; 8 | ptr[1]);
}

<span class="enscript-comment">// RFC 4034 Appendix B: Get the keyid of a DNS KEY. It is not transmitted
</span><span class="enscript-comment">// explicitly on the wire.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Note: This just helps narrow down the list of keys to look at. It is possible
</span><span class="enscript-comment">// for two DNS keys to have the same ID i.e., key ID is not a unqiue tag. We ignore
</span><span class="enscript-comment">// MD5 keys.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 1st argument - the RDATA part of the DNSKEY RR
</span><span class="enscript-comment">// 2nd argument - the RDLENGTH
</span><span class="enscript-comment">//
</span>mDNSlocal mDNSu32 <span class="enscript-function-name">keytag</span>(mDNSu8 *key, mDNSu32 keysize)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ac;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">for</span> (ac = 0, i = 0; i &lt; keysize; ++i)
        ac += (i &amp; 1) ? key[i] : key[i] &lt;&lt; 8;
    ac += (ac &gt;&gt; 16) &amp; 0xFFFF;
    <span class="enscript-keyword">return</span> ac &amp; 0xFFFF;
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">baseEncode</span>(<span class="enscript-type">char</span> *buffer, <span class="enscript-type">int</span> blen, <span class="enscript-type">const</span> mDNSu8 *data, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> encAlg)
{
    AlgContext *ctx;
    mDNSu8 *outputBuffer;
    <span class="enscript-type">int</span> length;

    ctx = AlgCreate(ENC_ALG, encAlg);
    <span class="enscript-keyword">if</span> (!ctx)
    {
        LogMsg(<span class="enscript-string">&quot;baseEncode: AlgCreate failed\n&quot;</span>);
        <span class="enscript-keyword">return</span> 0;
    }
    AlgAdd(ctx, data, len);
    outputBuffer = AlgEncode(ctx);
    length = 0;
    <span class="enscript-keyword">if</span> (outputBuffer)
    {
        <span class="enscript-comment">// Note: don't include any spaces in the format string below. This
</span>        <span class="enscript-comment">// is also used by NSEC3 code for proving non-existence where it
</span>        <span class="enscript-comment">// needs the base32 encoding without any spaces etc.
</span>        length = mDNS_snprintf(buffer, blen, <span class="enscript-string">&quot;%s&quot;</span>, outputBuffer);
    }
    AlgDestroy(ctx);
    <span class="enscript-keyword">return</span> length;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintTypeBitmap</span>(<span class="enscript-type">const</span> mDNSu8 *bmap, <span class="enscript-type">int</span> bitmaplen, <span class="enscript-type">char</span> *<span class="enscript-type">const</span> buffer, mDNSu32 length)
{
    <span class="enscript-type">int</span> win, wlen, type;

    <span class="enscript-keyword">while</span> (bitmaplen &gt; 0)
    {
        <span class="enscript-type">int</span> i;

        <span class="enscript-keyword">if</span> (bitmaplen &lt; 3)
        {
            LogMsg(<span class="enscript-string">&quot;PrintTypeBitmap: malformed bitmap, bitmaplen %d short&quot;</span>, bitmaplen);
            <span class="enscript-keyword">break</span>;
        }

        win = *bmap++;
        wlen = *bmap++;
        bitmaplen -= 2;
        <span class="enscript-keyword">if</span> (bitmaplen &lt; wlen || wlen &lt; 1 || wlen &gt; 32)
        {
            LogInfo(<span class="enscript-string">&quot;PrintTypeBitmap: malformed nsec, bitmaplen %d wlen %d&quot;</span>, bitmaplen, wlen);
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">if</span> (win &lt; 0 || win &gt;= 256)
        {
            LogInfo(<span class="enscript-string">&quot;PrintTypeBitmap: malformed nsec, bad window win %d&quot;</span>, win);
            <span class="enscript-keyword">break</span>;
        }
        type = win * 256;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; wlen * 8; i++)
        {
            <span class="enscript-keyword">if</span> (bmap[i&gt;&gt;3] &amp; (128 &gt;&gt; (i&amp;7)))
                length += mDNS_snprintf(buffer+length, (MaxMsg - 1) - length, <span class="enscript-string">&quot;%s &quot;</span>, DNSTypeName(type + i));
        }
        bmap += wlen;
        bitmaplen -= wlen;
    }
}

<span class="enscript-comment">// Parse the fields beyond the base header. NSEC3 should have been validated.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">NSEC3Parse</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSu8 **salt, <span class="enscript-type">int</span> *hashLength, mDNSu8 **nxtName, <span class="enscript-type">int</span> *bitmaplen, mDNSu8 **bitmap)
{
	<span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
	rdataNSEC3 *nsec3 = (rdataNSEC3 *)rdb-&gt;data;
    mDNSu8 *p = (mDNSu8 *)&amp;nsec3-&gt;salt;
    <span class="enscript-type">int</span> hlen;

    <span class="enscript-keyword">if</span> (salt)
    {
        <span class="enscript-keyword">if</span> (nsec3-&gt;saltLength)
            *salt = p;
        <span class="enscript-keyword">else</span>
            *salt = mDNSNULL;
    }
    p += nsec3-&gt;saltLength;
    <span class="enscript-comment">// p is pointing at hashLength
</span>    hlen = (<span class="enscript-type">int</span>)*p;
    <span class="enscript-keyword">if</span> (hashLength)
        *hashLength = hlen;
    p++;
    <span class="enscript-keyword">if</span> (nxtName)
        *nxtName = p;
    p += hlen;
    <span class="enscript-keyword">if</span> (bitmaplen)
        *bitmaplen = rr-&gt;rdlength - (<span class="enscript-type">int</span>)(p - rdb-&gt;data);
    <span class="enscript-keyword">if</span> (bitmap)
        *bitmap = p;
}

<span class="enscript-comment">// Note slight bug: this code uses the rdlength from the ResourceRecord object, to display
</span><span class="enscript-comment">// the rdata from the RDataBody object. Sometimes this could be the wrong length -- but as
</span><span class="enscript-comment">// long as this routine is only used for debugging messages, it probably isn't a big problem.
</span>mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">GetRRDisplayString_rdb</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> RDataBody *<span class="enscript-type">const</span> rd1, <span class="enscript-type">char</span> *<span class="enscript-type">const</span> buffer)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rd = (RDataBody2 *)rd1;
    #define RemSpc (MaxMsg-1-length)
    <span class="enscript-type">char</span> *ptr = buffer;
    mDNSu32 length = mDNS_snprintf(buffer, MaxMsg-1, <span class="enscript-string">&quot;%4d %##s %s &quot;</span>, rr-&gt;rdlength, rr-&gt;name-&gt;c, DNSTypeName(rr-&gt;rrtype));
    <span class="enscript-keyword">if</span> (rr-&gt;RecordType == kDNSRecordTypePacketNegative) <span class="enscript-keyword">return</span>(buffer);
    <span class="enscript-keyword">if</span> (!rr-&gt;rdlength &amp;&amp; rr-&gt;rrtype != kDNSType_OPT) { mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;&lt;&lt; ZERO RDATA LENGTH &gt;&gt;&quot;</span>); <span class="enscript-keyword">return</span>(buffer); }

    <span class="enscript-keyword">switch</span> (rr-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:    mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%.4a&quot;</span>, &amp;rd-&gt;ipv4);          <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:    <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:  mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%##s&quot;</span>, rd-&gt;name.c);       <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:  mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%##s %##s %d %d %d %d %d&quot;</span>,
                                      rd-&gt;soa.mname.c, rd-&gt;soa.rname.c,
                                      rd-&gt;soa.serial, rd-&gt;soa.refresh, rd-&gt;soa.retry, rd-&gt;soa.expire, rd-&gt;soa.min);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>:    <span class="enscript-comment">// Display this the same as TXT (show all constituent strings)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:  {
        <span class="enscript-type">const</span> mDNSu8 *t = rd-&gt;txt.c;
        <span class="enscript-keyword">while</span> (t &lt; rd-&gt;txt.c + rr-&gt;rdlength)
        {
            length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%s%#s&quot;</span>, t &gt; rd-&gt;txt.c ? <span class="enscript-string">&quot;Â¦&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, t);
            t += 1 + t[0];
        }
    } <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>: mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%.16a&quot;</span>, &amp;rd-&gt;ipv6);       <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:  mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%u %u %u %##s&quot;</span>,
                                      rd-&gt;srv.priority, rd-&gt;srv.weight, mDNSVal16(rd-&gt;srv.port), rd-&gt;srv.target.c); <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  {
        <span class="enscript-type">const</span> rdataOPT *opt;
        <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> end = (<span class="enscript-type">const</span> rdataOPT *)&amp;rd-&gt;data[rr-&gt;rdlength];
        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;Max %d&quot;</span>, rr-&gt;rrclass);
        <span class="enscript-keyword">for</span> (opt = &amp;rd-&gt;opt[0]; opt &lt; end; opt++)
        {
            <span class="enscript-keyword">switch</span>(opt-&gt;opt)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_LLQ</span>:
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; LLQ&quot;</span>);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Vers %d&quot;</span>,     opt-&gt;u.llq.vers);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Op %d&quot;</span>,       opt-&gt;u.llq.llqOp);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Err/Port %d&quot;</span>, opt-&gt;u.llq.err);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; ID %08X%08X&quot;</span>, opt-&gt;u.llq.id.l[0], opt-&gt;u.llq.id.l[1]);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Lease %d&quot;</span>,    opt-&gt;u.llq.llqlease);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Lease</span>:
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Lease %d&quot;</span>,    opt-&gt;u.updatelease);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Owner</span>:
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Owner&quot;</span>);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Vers %d&quot;</span>,     opt-&gt;u.owner.vers);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Seq %3d&quot;</span>, (mDNSu8)opt-&gt;u.owner.seq);                           <span class="enscript-comment">// Display as unsigned
</span>                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; MAC %.6a&quot;</span>,    opt-&gt;u.owner.HMAC.b);
                <span class="enscript-keyword">if</span> (opt-&gt;optlen &gt;= DNSOpt_OwnerData_ID_Wake_Space-4)
                {
                    length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; I-MAC %.6a&quot;</span>, opt-&gt;u.owner.IMAC.b);
                    <span class="enscript-keyword">if</span> (opt-&gt;optlen &gt; DNSOpt_OwnerData_ID_Wake_Space-4)
                        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Password %.6a&quot;</span>, opt-&gt;u.owner.password.b);
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Trace</span>:
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Trace&quot;</span>);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Platform %d&quot;</span>,    opt-&gt;u.tracer.platf);
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; mDNSVers %d&quot;</span>,    opt-&gt;u.tracer.mDNSv);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; Unknown %d&quot;</span>,  opt-&gt;opt);
                <span class="enscript-keyword">break</span>;
            }
        }
    }
    <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
        domainname *next = (domainname *)rd-&gt;data;
        <span class="enscript-type">int</span> len, bitmaplen;
        mDNSu8 *bmap;
        len = DomainNameLength(next);
        bitmaplen = rr-&gt;rdlength - len;
        bmap = (mDNSu8 *)((mDNSu8 *)next + len);

        <span class="enscript-keyword">if</span> (UNICAST_NSEC(rr))
            length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%##s &quot;</span>, next-&gt;c);
        PrintTypeBitmap(bmap, bitmaplen, buffer, length);

    }
    <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3</span>: {
        rdataNSEC3 *nsec3 = (rdataNSEC3 *)rd-&gt;data;
        <span class="enscript-type">const</span> mDNSu8 *p = (mDNSu8 *)&amp;nsec3-&gt;salt;
        <span class="enscript-type">int</span> hashLength, bitmaplen, i;

        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;\t%s  %d  %d &quot;</span>, 
                                DNSSECDigestName(nsec3-&gt;alg), nsec3-&gt;flags, swap16(nsec3-&gt;iterations));
        
        <span class="enscript-keyword">if</span> (!nsec3-&gt;saltLength)
        {
            length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;-&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">for</span> (i = 0; i &lt; nsec3-&gt;saltLength; i++)
            {
                length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%x&quot;</span>, p[i]);
            }
        }

        <span class="enscript-comment">// put a space at the end
</span>        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; &quot;</span>);

        p += nsec3-&gt;saltLength;
        <span class="enscript-comment">// p is pointing at hashLength
</span>        hashLength = (<span class="enscript-type">int</span>)*p++;
        
        length += baseEncode(buffer + length, RemSpc, p, hashLength, ENC_BASE32);

        <span class="enscript-comment">// put a space at the end
</span>        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot; &quot;</span>);

        p += hashLength;
        bitmaplen = rr-&gt;rdlength - (<span class="enscript-type">int</span>)(p - rd-&gt;data);
        PrintTypeBitmap(p, bitmaplen, buffer, length);
    }
    <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RRSIG</span>:    {
        rdataRRSig *rrsig = (rdataRRSig *)rd-&gt;data;
        mDNSu8 expTimeBuf[64];
        mDNSu8 inceptTimeBuf[64];
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> inceptClock;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> expClock;
        <span class="enscript-type">int</span> len;

        expClock = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)swap32(rrsig-&gt;sigExpireTime);
        mDNSPlatformFormatTime(expClock, expTimeBuf, <span class="enscript-keyword">sizeof</span>(expTimeBuf));

        inceptClock = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)swap32(rrsig-&gt;sigInceptTime);
        mDNSPlatformFormatTime(inceptClock, inceptTimeBuf, <span class="enscript-keyword">sizeof</span>(inceptTimeBuf));

        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;\t%s  %s  %d  %d  %s  %s  %d  %##s &quot;</span>,
                                DNSTypeName(swap16(rrsig-&gt;typeCovered)), DNSSECAlgName(rrsig-&gt;alg), rrsig-&gt;labels, swap32(rrsig-&gt;origTTL),
                                expTimeBuf, inceptTimeBuf, swap16(rrsig-&gt;keyTag), rrsig-&gt;signerName);

        len = DomainNameLength((domainname *)&amp;rrsig-&gt;signerName);
        baseEncode(buffer + length, RemSpc, (<span class="enscript-type">const</span> mDNSu8 *)(rd-&gt;data + len + RRSIG_FIXED_SIZE),
                               rr-&gt;rdlength - (len + RRSIG_FIXED_SIZE), ENC_BASE64);
    }
    <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNSKEY</span>:   {
        rdataDNSKey *rrkey = (rdataDNSKey *)rd-&gt;data;
        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;\t%d  %d  %s  %u &quot;</span>, swap16(rrkey-&gt;flags), rrkey-&gt;proto,
                                DNSSECAlgName(rrkey-&gt;alg), (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)keytag((mDNSu8 *)rrkey, rr-&gt;rdlength));
        baseEncode(buffer + length, RemSpc, (<span class="enscript-type">const</span> mDNSu8 *)(rd-&gt;data + DNSKEY_FIXED_SIZE),
                               rr-&gt;rdlength - DNSKEY_FIXED_SIZE, ENC_BASE64);
    }
    <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DS</span>:       {
        mDNSu8 *p;
        <span class="enscript-type">int</span> i;
        rdataDS *rrds = (rdataDS *)rd-&gt;data;

        length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;\t%s\t%d\t%s &quot;</span>, DNSSECAlgName(rrds-&gt;alg), swap16(rrds-&gt;keyTag),
                                DNSSECDigestName(rrds-&gt;digestType));

        p = (mDNSu8 *)(rd-&gt;data + DS_FIXED_SIZE);
        <span class="enscript-keyword">for</span> (i = 0; i &lt; (rr-&gt;rdlength - DS_FIXED_SIZE); i++)
        {
            length += mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;%x&quot;</span>, p[i]);
        }
    }
    <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:            mDNS_snprintf(buffer+length, RemSpc, <span class="enscript-string">&quot;RDLen %d: %.*s&quot;</span>, rr-&gt;rdlength, rr-&gt;rdlength, rd-&gt;data);
        <span class="enscript-comment">// Really should scan buffer to check if text is valid UTF-8 and only replace with dots if not
</span>        <span class="enscript-keyword">for</span> (ptr = buffer; *ptr; ptr++) <span class="enscript-keyword">if</span> (*ptr &lt; <span class="enscript-string">' '</span>) *ptr = <span class="enscript-string">'.'</span>;
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>(buffer);
}

<span class="enscript-comment">// See comments in mDNSEmbeddedAPI.h
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mDNSRandomNumber</span> mDNSPlatformRandomNumber
#<span class="enscript-reference">else</span>
mDNSlocal mDNSu32 <span class="enscript-function-name">mDNSRandomFromSeed</span>(mDNSu32 seed)
{
    <span class="enscript-keyword">return</span> seed * 21 + 1;
}

mDNSlocal mDNSu32 <span class="enscript-function-name">mDNSMixRandomSeed</span>(mDNSu32 seed, mDNSu8 iteration)
{
    <span class="enscript-keyword">return</span> iteration ? mDNSMixRandomSeed(mDNSRandomFromSeed(seed), --iteration) : seed;
}

mDNSlocal mDNSu32 <span class="enscript-function-name">mDNSRandomNumber</span>()
{
    <span class="enscript-type">static</span> mDNSBool seeded = mDNSfalse;
    <span class="enscript-type">static</span> mDNSu32 seed = 0;
    <span class="enscript-keyword">if</span> (!seeded)
    {
        seed = mDNSMixRandomSeed(mDNSPlatformRandomSeed(), 100);
        seeded = mDNStrue;
    }
    <span class="enscript-keyword">return</span> (seed = mDNSRandomFromSeed(seed));
}
#<span class="enscript-reference">endif</span> // ! <span class="enscript-variable-name">_PLATFORM_HAS_STRONG_PRNG_</span>

mDNSexport mDNSu32 <span class="enscript-function-name">mDNSRandom</span>(mDNSu32 max)      <span class="enscript-comment">// Returns pseudo-random result from zero to max inclusive
</span>{
    mDNSu32 ret = 0;
    mDNSu32 mask = 1;

    <span class="enscript-keyword">while</span> (mask &lt; max) mask = (mask &lt;&lt; 1) | 1;

    <span class="enscript-keyword">do</span> ret = mDNSRandomNumber() &amp; mask;
    <span class="enscript-keyword">while</span> (ret &gt; max);

    <span class="enscript-keyword">return</span> ret;
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSSameAddress</span>(<span class="enscript-type">const</span> mDNSAddr *ip1, <span class="enscript-type">const</span> mDNSAddr *ip2)
{
    <span class="enscript-keyword">if</span> (ip1-&gt;type == ip2-&gt;type)
    {
        <span class="enscript-keyword">switch</span> (ip1-&gt;type)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_None</span>: <span class="enscript-keyword">return</span>(mDNStrue);      <span class="enscript-comment">// Empty addresses have no data and are therefore always equal
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv4</span>: <span class="enscript-keyword">return</span> (mDNSBool)(mDNSSameIPv4Address(ip1-&gt;ip.v4, ip2-&gt;ip.v4));
        <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv6</span>: <span class="enscript-keyword">return</span> (mDNSBool)(mDNSSameIPv6Address(ip1-&gt;ip.v6, ip2-&gt;ip.v6));
        }
    }
    <span class="enscript-keyword">return</span>(mDNSfalse);
}

mDNSexport mDNSBool <span class="enscript-function-name">mDNSAddrIsDNSMulticast</span>(<span class="enscript-type">const</span> mDNSAddr *ip)
{
    <span class="enscript-keyword">switch</span>(ip-&gt;type)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv4</span>: <span class="enscript-keyword">return</span> (mDNSBool)(mDNSSameIPv4Address(ip-&gt;ip.v4, AllDNSLinkGroup_v4.ip.v4));
    <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv6</span>: <span class="enscript-keyword">return</span> (mDNSBool)(mDNSSameIPv6Address(ip-&gt;ip.v6, AllDNSLinkGroup_v6.ip.v6));
    <span class="enscript-reference">default</span>: <span class="enscript-keyword">return</span>(mDNSfalse);
    }
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Domain</span> <span class="enscript-variable-name">Name</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSexport mDNSBool <span class="enscript-function-name">SameDomainLabel</span>(<span class="enscript-type">const</span> mDNSu8 *a, <span class="enscript-type">const</span> mDNSu8 *b)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> len = *a++;

    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL)
    { debugf(<span class="enscript-string">&quot;Malformed label (too long)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }

    <span class="enscript-keyword">if</span> (len != *b++) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">for</span> (i=0; i&lt;len; i++)
    {
        mDNSu8 ac = *a++;
        mDNSu8 bc = *b++;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(bc)) bc += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (ac != bc) <span class="enscript-keyword">return</span>(mDNSfalse);
    }
    <span class="enscript-keyword">return</span>(mDNStrue);
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

mDNSexport mDNSBool <span class="enscript-function-name">SameDomainName</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2)
{
    <span class="enscript-type">const</span> mDNSu8 *      a   = d1-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *      b   = d2-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> max = d1-&gt;c + MAX_DOMAIN_NAME;          <span class="enscript-comment">// Maximum that's valid
</span>
    <span class="enscript-keyword">while</span> (*a || *b)
    {
        <span class="enscript-keyword">if</span> (a + 1 + *a &gt;= max)
        { debugf(<span class="enscript-string">&quot;Malformed domain name (more than 256 characters)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
        <span class="enscript-keyword">if</span> (!SameDomainLabel(a, b)) <span class="enscript-keyword">return</span>(mDNSfalse);
        a += 1 + *a;
        b += 1 + *b;
    }

    <span class="enscript-keyword">return</span>(mDNStrue);
}

mDNSexport mDNSBool <span class="enscript-function-name">SameDomainNameCS</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2)
{
    mDNSu16 l1 = DomainNameLength(d1);
    mDNSu16 l2 = DomainNameLength(d2);
    <span class="enscript-keyword">return</span>(l1 &lt;= MAX_DOMAIN_NAME &amp;&amp; l1 == l2 &amp;&amp; mDNSPlatformMemSame(d1, d2, l1));
}

mDNSexport mDNSBool <span class="enscript-function-name">IsLocalDomain</span>(<span class="enscript-type">const</span> domainname *d)
{
    <span class="enscript-comment">// Domains that are defined to be resolved via link-local multicast are:
</span>    <span class="enscript-comment">// local., 254.169.in-addr.arpa., and {8,9,A,B}.E.F.ip6.arpa.
</span>    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *nL = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x5&quot;</span> <span class="enscript-string">&quot;local&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *nR = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;254&quot;</span> <span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;169&quot;</span>         <span class="enscript-string">&quot;\x7&quot;</span> <span class="enscript-string">&quot;in-addr&quot;</span> <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *n8 = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;8&quot;</span>   <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;e&quot;</span> <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;f&quot;</span> <span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;ip6&quot;</span>     <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *n9 = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;9&quot;</span>   <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;e&quot;</span> <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;f&quot;</span> <span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;ip6&quot;</span>     <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *nA = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;a&quot;</span>   <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;e&quot;</span> <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;f&quot;</span> <span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;ip6&quot;</span>     <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> domainname *nB = (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;b&quot;</span>   <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;e&quot;</span> <span class="enscript-string">&quot;\x1&quot;</span> <span class="enscript-string">&quot;f&quot;</span> <span class="enscript-string">&quot;\x3&quot;</span> <span class="enscript-string">&quot;ip6&quot;</span>     <span class="enscript-string">&quot;\x4&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>;

    <span class="enscript-type">const</span> domainname *d1, *d2, *d3, *d4, *d5;   <span class="enscript-comment">// Top-level domain, second-level domain, etc.
</span>    d1 = d2 = d3 = d4 = d5 = mDNSNULL;
    <span class="enscript-keyword">while</span> (d-&gt;c[0])
    {
        d5 = d4; d4 = d3; d3 = d2; d2 = d1; d1 = d;
        d = (<span class="enscript-type">const</span> domainname*)(d-&gt;c + 1 + d-&gt;c[0]);
    }

    <span class="enscript-keyword">if</span> (d1 &amp;&amp; SameDomainName(d1, nL)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">if</span> (d4 &amp;&amp; SameDomainName(d4, nR)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">if</span> (d5 &amp;&amp; SameDomainName(d5, n8)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">if</span> (d5 &amp;&amp; SameDomainName(d5, n9)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">if</span> (d5 &amp;&amp; SameDomainName(d5, nA)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">if</span> (d5 &amp;&amp; SameDomainName(d5, nB)) <span class="enscript-keyword">return</span>(mDNStrue);
    <span class="enscript-keyword">return</span>(mDNSfalse);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LastLabel</span>(<span class="enscript-type">const</span> domainname *d)
{
    <span class="enscript-type">const</span> mDNSu8 *p = d-&gt;c;
    <span class="enscript-keyword">while</span> (d-&gt;c[0])
    {
        p = d-&gt;c;
        d = (<span class="enscript-type">const</span> domainname*)(d-&gt;c + 1 + d-&gt;c[0]);
    }
    <span class="enscript-keyword">return</span>(p);
}

<span class="enscript-comment">// Returns length of a domain name INCLUDING the byte for the final null label
</span><span class="enscript-comment">// e.g. for the root label &quot;.&quot; it returns one
</span><span class="enscript-comment">// For the FQDN &quot;com.&quot; it returns 5 (length byte, three data bytes, final zero)
</span><span class="enscript-comment">// Legal results are 1 (just root label) to 256 (MAX_DOMAIN_NAME)
</span><span class="enscript-comment">// If the given domainname is invalid, result is 257 (MAX_DOMAIN_NAME+1)
</span>mDNSexport mDNSu16 <span class="enscript-function-name">DomainNameLengthLimit</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSu8 *limit)
{
    <span class="enscript-type">const</span> mDNSu8 *src = name-&gt;c;
    <span class="enscript-keyword">while</span> (src &lt; limit &amp;&amp; *src &lt;= MAX_DOMAIN_LABEL)
    {
        <span class="enscript-keyword">if</span> (*src == 0) <span class="enscript-keyword">return</span>((mDNSu16)(src - name-&gt;c + 1));
        src += 1 + *src;
    }
    <span class="enscript-keyword">return</span>(MAX_DOMAIN_NAME+1);
}

<span class="enscript-comment">// CompressedDomainNameLength returns the length of a domain name INCLUDING the byte
</span><span class="enscript-comment">// for the final null label, e.g. for the root label &quot;.&quot; it returns one.
</span><span class="enscript-comment">// E.g. for the FQDN &quot;foo.com.&quot; it returns 9
</span><span class="enscript-comment">// (length, three data bytes, length, three more data bytes, final zero).
</span><span class="enscript-comment">// In the case where a parent domain name is provided, and the given name is a child
</span><span class="enscript-comment">// of that parent, CompressedDomainNameLength returns the length of the prefix portion
</span><span class="enscript-comment">// of the child name, plus TWO bytes for the compression pointer.
</span><span class="enscript-comment">// E.g. for the name &quot;foo.com.&quot; with parent &quot;com.&quot;, it returns 6
</span><span class="enscript-comment">// (length, three data bytes, two-byte compression pointer).
</span>mDNSexport mDNSu16 <span class="enscript-function-name">CompressedDomainNameLength</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *parent)
{
    <span class="enscript-type">const</span> mDNSu8 *src = name-&gt;c;
    <span class="enscript-keyword">if</span> (parent &amp;&amp; parent-&gt;c[0] == 0) parent = mDNSNULL;
    <span class="enscript-keyword">while</span> (*src)
    {
        <span class="enscript-keyword">if</span> (*src &gt; MAX_DOMAIN_LABEL) <span class="enscript-keyword">return</span>(MAX_DOMAIN_NAME+1);
        <span class="enscript-keyword">if</span> (parent &amp;&amp; SameDomainName((<span class="enscript-type">const</span> domainname *)src, parent)) <span class="enscript-keyword">return</span>((mDNSu16)(src - name-&gt;c + 2));
        src += 1 + *src;
        <span class="enscript-keyword">if</span> (src - name-&gt;c &gt;= MAX_DOMAIN_NAME) <span class="enscript-keyword">return</span>(MAX_DOMAIN_NAME+1);
    }
    <span class="enscript-keyword">return</span>((mDNSu16)(src - name-&gt;c + 1));
}

<span class="enscript-comment">// CountLabels() returns number of labels in name, excluding final root label
</span><span class="enscript-comment">// (e.g. for &quot;apple.com.&quot; CountLabels returns 2.)
</span>mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">CountLabels</span>(<span class="enscript-type">const</span> domainname *d)
{
    <span class="enscript-type">int</span> count = 0;
    <span class="enscript-type">const</span> mDNSu8 *ptr;
    <span class="enscript-keyword">for</span> (ptr = d-&gt;c; *ptr; ptr = ptr + ptr[0] + 1) count++;
    <span class="enscript-keyword">return</span> count;
}

<span class="enscript-comment">// SkipLeadingLabels skips over the first 'skip' labels in the domainname,
</span><span class="enscript-comment">// returning a pointer to the suffix with 'skip' labels removed.
</span>mDNSexport <span class="enscript-type">const</span> domainname *<span class="enscript-function-name">SkipLeadingLabels</span>(<span class="enscript-type">const</span> domainname *d, <span class="enscript-type">int</span> skip)
{
    <span class="enscript-keyword">while</span> (skip &gt; 0 &amp;&amp; d-&gt;c[0]) { d = (<span class="enscript-type">const</span> domainname *)(d-&gt;c + 1 + d-&gt;c[0]); skip--; }
    <span class="enscript-keyword">return</span>(d);
}

<span class="enscript-comment">// AppendLiteralLabelString appends a single label to an existing (possibly empty) domainname.
</span><span class="enscript-comment">// The C string contains the label as-is, with no escaping, etc.
</span><span class="enscript-comment">// Any dots in the name are literal dots, not label separators
</span><span class="enscript-comment">// If successful, AppendLiteralLabelString returns a pointer to the next unused byte
</span><span class="enscript-comment">// in the domainname bufer (i.e. the next byte after the terminating zero).
</span><span class="enscript-comment">// If unable to construct a legal domain name (i.e. label more than 63 bytes, or total more than 256 bytes)
</span><span class="enscript-comment">// AppendLiteralLabelString returns mDNSNULL.
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">AppendLiteralLabelString</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr)
{
    mDNSu8       *      ptr  = name-&gt;c + DomainNameLength(name) - 1;    <span class="enscript-comment">// Find end of current name
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim1 = name-&gt;c + MAX_DOMAIN_NAME - 1;           <span class="enscript-comment">// Limit of how much we can add (not counting final zero)
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim2 = ptr + 1 + MAX_DOMAIN_LABEL;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim  = (lim1 &lt; lim2) ? lim1 : lim2;
    mDNSu8       *lengthbyte = ptr++;                                   <span class="enscript-comment">// Record where the length is going to go
</span>
    <span class="enscript-keyword">while</span> (*cstr &amp;&amp; ptr &lt; lim) *ptr++ = (mDNSu8)*cstr++;    <span class="enscript-comment">// Copy the data
</span>    *lengthbyte = (mDNSu8)(ptr - lengthbyte - 1);           <span class="enscript-comment">// Fill in the length byte
</span>    *ptr++ = 0;                                             <span class="enscript-comment">// Put the null root label on the end
</span>    <span class="enscript-keyword">if</span> (*cstr) <span class="enscript-keyword">return</span>(mDNSNULL);                            <span class="enscript-comment">// Failure: We didn't successfully consume all input
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(ptr);                                       <span class="enscript-comment">// Success: return new value of ptr
</span>}

<span class="enscript-comment">// AppendDNSNameString appends zero or more labels to an existing (possibly empty) domainname.
</span><span class="enscript-comment">// The C string is in conventional DNS syntax:
</span><span class="enscript-comment">// Textual labels, escaped as necessary using the usual DNS '\' notation, separated by dots.
</span><span class="enscript-comment">// If successful, AppendDNSNameString returns a pointer to the next unused byte
</span><span class="enscript-comment">// in the domainname bufer (i.e. the next byte after the terminating zero).
</span><span class="enscript-comment">// If unable to construct a legal domain name (i.e. label more than 63 bytes, or total more than 256 bytes)
</span><span class="enscript-comment">// AppendDNSNameString returns mDNSNULL.
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">AppendDNSNameString</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstring)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>   *cstr      = cstring;
    mDNSu8       *      ptr = name-&gt;c + DomainNameLength(name) - 1; <span class="enscript-comment">// Find end of current name
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim = name-&gt;c + MAX_DOMAIN_NAME - 1;        <span class="enscript-comment">// Limit of how much we can add (not counting final zero)
</span>    <span class="enscript-keyword">while</span> (*cstr &amp;&amp; ptr &lt; lim)                                      <span class="enscript-comment">// While more characters, and space to put them...
</span>    {
        mDNSu8 *lengthbyte = ptr++;                                 <span class="enscript-comment">// Record where the length is going to go
</span>        <span class="enscript-keyword">if</span> (*cstr == <span class="enscript-string">'.'</span>) { LogMsg(<span class="enscript-string">&quot;AppendDNSNameString: Illegal empty label in name \&quot;%s\&quot;&quot;</span>, cstring); <span class="enscript-keyword">return</span>(mDNSNULL); }
        <span class="enscript-keyword">while</span> (*cstr &amp;&amp; *cstr != <span class="enscript-string">'.'</span> &amp;&amp; ptr &lt; lim)                  <span class="enscript-comment">// While we have characters in the label...
</span>        {
            mDNSu8 c = (mDNSu8)*cstr++;                             <span class="enscript-comment">// Read the character
</span>            <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\\'</span>)                                          <span class="enscript-comment">// If escape character, check next character
</span>            {
                <span class="enscript-keyword">if</span> (*cstr == <span class="enscript-string">'\0'</span>) <span class="enscript-keyword">break</span>;                           <span class="enscript-comment">// If this is the end of the string, then break
</span>                c = (mDNSu8)*cstr++;                                <span class="enscript-comment">// Assume we'll just take the next character
</span>                <span class="enscript-keyword">if</span> (mDNSIsDigit(cstr[-1]) &amp;&amp; mDNSIsDigit(cstr[0]) &amp;&amp; mDNSIsDigit(cstr[1]))
                {                                                   <span class="enscript-comment">// If three decimal digits,
</span>                    <span class="enscript-type">int</span> v0 = cstr[-1] - <span class="enscript-string">'0'</span>;                        <span class="enscript-comment">// then interpret as three-digit decimal
</span>                    <span class="enscript-type">int</span> v1 = cstr[ 0] - <span class="enscript-string">'0'</span>;
                    <span class="enscript-type">int</span> v2 = cstr[ 1] - <span class="enscript-string">'0'</span>;
                    <span class="enscript-type">int</span> val = v0 * 100 + v1 * 10 + v2;
                    <span class="enscript-keyword">if</span> (val &lt;= 255) { c = (mDNSu8)val; cstr += 2; } <span class="enscript-comment">// If valid three-digit decimal value, use it
</span>                }
            }
            *ptr++ = c;                                             <span class="enscript-comment">// Write the character
</span>        }
        <span class="enscript-keyword">if</span> (*cstr == <span class="enscript-string">'.'</span>) cstr++;                                   <span class="enscript-comment">// Skip over the trailing dot (if present)
</span>        <span class="enscript-keyword">if</span> (ptr - lengthbyte - 1 &gt; MAX_DOMAIN_LABEL)                <span class="enscript-comment">// If illegal label, abort
</span>            <span class="enscript-keyword">return</span>(mDNSNULL);
        *lengthbyte = (mDNSu8)(ptr - lengthbyte - 1);               <span class="enscript-comment">// Fill in the length byte
</span>    }

    *ptr++ = 0;                                                     <span class="enscript-comment">// Put the null root label on the end
</span>    <span class="enscript-keyword">if</span> (*cstr) <span class="enscript-keyword">return</span>(mDNSNULL);                                    <span class="enscript-comment">// Failure: We didn't successfully consume all input
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(ptr);                                               <span class="enscript-comment">// Success: return new value of ptr
</span>}

<span class="enscript-comment">// AppendDomainLabel appends a single label to a name.
</span><span class="enscript-comment">// If successful, AppendDomainLabel returns a pointer to the next unused byte
</span><span class="enscript-comment">// in the domainname bufer (i.e. the next byte after the terminating zero).
</span><span class="enscript-comment">// If unable to construct a legal domain name (i.e. label more than 63 bytes, or total more than 256 bytes)
</span><span class="enscript-comment">// AppendDomainLabel returns mDNSNULL.
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">AppendDomainLabel</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> label)
{
    <span class="enscript-type">int</span> i;
    mDNSu8 *ptr = name-&gt;c + DomainNameLength(name) - 1;

    <span class="enscript-comment">// Check label is legal
</span>    <span class="enscript-keyword">if</span> (label-&gt;c[0] &gt; MAX_DOMAIN_LABEL) <span class="enscript-keyword">return</span>(mDNSNULL);

    <span class="enscript-comment">// Check that ptr + length byte + data bytes + final zero does not exceed our limit
</span>    <span class="enscript-keyword">if</span> (ptr + 1 + label-&gt;c[0] + 1 &gt; name-&gt;c + MAX_DOMAIN_NAME) <span class="enscript-keyword">return</span>(mDNSNULL);

    <span class="enscript-keyword">for</span> (i=0; i&lt;=label-&gt;c[0]; i++) *ptr++ = label-&gt;c[i];    <span class="enscript-comment">// Copy the label data
</span>    *ptr++ = 0;                             <span class="enscript-comment">// Put the null root label on the end
</span>    <span class="enscript-keyword">return</span>(ptr);
}

mDNSexport mDNSu8 *<span class="enscript-function-name">AppendDomainName</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> append)
{
    mDNSu8       *      ptr = name-&gt;c + DomainNameLength(name) - 1; <span class="enscript-comment">// Find end of current name
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim = name-&gt;c + MAX_DOMAIN_NAME - 1;        <span class="enscript-comment">// Limit of how much we can add (not counting final zero)
</span>    <span class="enscript-type">const</span> mDNSu8 *      src = append-&gt;c;
    <span class="enscript-keyword">while</span> (src[0])
    {
        <span class="enscript-type">int</span> i;
        <span class="enscript-keyword">if</span> (ptr + 1 + src[0] &gt; lim) <span class="enscript-keyword">return</span>(mDNSNULL);
        <span class="enscript-keyword">for</span> (i=0; i&lt;=src[0]; i++) *ptr++ = src[i];
        *ptr = 0;   <span class="enscript-comment">// Put the null root label on the end
</span>        src += i;
    }
    <span class="enscript-keyword">return</span>(ptr);
}

<span class="enscript-comment">// MakeDomainLabelFromLiteralString makes a single domain label from a single literal C string (with no escaping).
</span><span class="enscript-comment">// If successful, MakeDomainLabelFromLiteralString returns mDNStrue.
</span><span class="enscript-comment">// If unable to convert the whole string to a legal domain label (i.e. because length is more than 63 bytes) then
</span><span class="enscript-comment">// MakeDomainLabelFromLiteralString makes a legal domain label from the first 63 bytes of the string and returns mDNSfalse.
</span><span class="enscript-comment">// In some cases silently truncated oversized names to 63 bytes is acceptable, so the return result may be ignored.
</span><span class="enscript-comment">// In other cases silent truncation may not be acceptable, so in those cases the calling function needs to check the return result.
</span>mDNSexport mDNSBool <span class="enscript-function-name">MakeDomainLabelFromLiteralString</span>(domainlabel *<span class="enscript-type">const</span> label, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr)
{
    mDNSu8       *      ptr   = label-&gt;c + 1;                       <span class="enscript-comment">// Where we're putting it
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = label-&gt;c + 1 + MAX_DOMAIN_LABEL;    <span class="enscript-comment">// The maximum we can put
</span>    <span class="enscript-keyword">while</span> (*cstr &amp;&amp; ptr &lt; limit) *ptr++ = (mDNSu8)*cstr++;          <span class="enscript-comment">// Copy the label
</span>    label-&gt;c[0] = (mDNSu8)(ptr - label-&gt;c - 1);                     <span class="enscript-comment">// Set the length byte
</span>    <span class="enscript-keyword">return</span>(*cstr == 0);                                             <span class="enscript-comment">// Return mDNStrue if we successfully consumed all input
</span>}

<span class="enscript-comment">// MakeDomainNameFromDNSNameString makes a native DNS-format domainname from a C string.
</span><span class="enscript-comment">// The C string is in conventional DNS syntax:
</span><span class="enscript-comment">// Textual labels, escaped as necessary using the usual DNS '\' notation, separated by dots.
</span><span class="enscript-comment">// If successful, MakeDomainNameFromDNSNameString returns a pointer to the next unused byte
</span><span class="enscript-comment">// in the domainname bufer (i.e. the next byte after the terminating zero).
</span><span class="enscript-comment">// If unable to construct a legal domain name (i.e. label more than 63 bytes, or total more than 256 bytes)
</span><span class="enscript-comment">// MakeDomainNameFromDNSNameString returns mDNSNULL.
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">MakeDomainNameFromDNSNameString</span>(domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cstr)
{
    name-&gt;c[0] = 0;                                 <span class="enscript-comment">// Make an empty domain name
</span>    <span class="enscript-keyword">return</span>(AppendDNSNameString(name, cstr));        <span class="enscript-comment">// And then add this string to it
</span>}

mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">ConvertDomainLabelToCString_withescape</span>(<span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> label, <span class="enscript-type">char</span> *ptr, <span class="enscript-type">char</span> esc)
{
    <span class="enscript-type">const</span> mDNSu8 *      src = label-&gt;c;                         <span class="enscript-comment">// Domain label we're reading
</span>    <span class="enscript-type">const</span> mDNSu8 len = *src++;                                  <span class="enscript-comment">// Read length of this (non-null) label
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end = src + len;                        <span class="enscript-comment">// Work out where the label ends
</span>    <span class="enscript-keyword">if</span> (len &gt; MAX_DOMAIN_LABEL) <span class="enscript-keyword">return</span>(mDNSNULL);               <span class="enscript-comment">// If illegal label, abort
</span>    <span class="enscript-keyword">while</span> (src &lt; end)                                           <span class="enscript-comment">// While we have characters in the label
</span>    {
        mDNSu8 c = *src++;
        <span class="enscript-keyword">if</span> (esc)
        {
            <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'.'</span> || c == esc)                           <span class="enscript-comment">// If character is a dot or the escape character
</span>                *ptr++ = esc;                                   <span class="enscript-comment">// Output escape character
</span>            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c &lt;= <span class="enscript-string">' '</span>)                                  <span class="enscript-comment">// If non-printing ascii,
</span>            {                                                   <span class="enscript-comment">// Output decimal escape sequence
</span>                *ptr++ = esc;
                *ptr++ = (<span class="enscript-type">char</span>)  (<span class="enscript-string">'0'</span> + (c / 100)     );
                *ptr++ = (<span class="enscript-type">char</span>)  (<span class="enscript-string">'0'</span> + (c /  10) % 10);
                c      = (mDNSu8)(<span class="enscript-string">'0'</span> + (c      ) % 10);
            }
        }
        *ptr++ = (<span class="enscript-type">char</span>)c;                                       <span class="enscript-comment">// Copy the character
</span>    }
    *ptr = 0;                                                   <span class="enscript-comment">// Null-terminate the string
</span>    <span class="enscript-keyword">return</span>(ptr);                                                <span class="enscript-comment">// and return
</span>}

<span class="enscript-comment">// Note: To guarantee that there will be no possible overrun, cstr must be at least MAX_ESCAPED_DOMAIN_NAME (1009 bytes)
</span>mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">ConvertDomainNameToCString_withescape</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, <span class="enscript-type">char</span> *ptr, <span class="enscript-type">char</span> esc)
{
    <span class="enscript-type">const</span> mDNSu8 *src         = name-&gt;c;                            <span class="enscript-comment">// Domain name we're reading
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> max   = name-&gt;c + MAX_DOMAIN_NAME;          <span class="enscript-comment">// Maximum that's valid
</span>
    <span class="enscript-keyword">if</span> (*src == 0) *ptr++ = <span class="enscript-string">'.'</span>;                                    <span class="enscript-comment">// Special case: For root, just write a dot
</span>
    <span class="enscript-keyword">while</span> (*src)                                                    <span class="enscript-comment">// While more characters in the domain name
</span>    {
        <span class="enscript-keyword">if</span> (src + 1 + *src &gt;= max) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = ConvertDomainLabelToCString_withescape((<span class="enscript-type">const</span> domainlabel *)src, ptr, esc);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span>(mDNSNULL);
        src += 1 + *src;
        *ptr++ = <span class="enscript-string">'.'</span>;                                               <span class="enscript-comment">// Write the dot after the label
</span>    }

    *ptr++ = 0;                                                     <span class="enscript-comment">// Null-terminate the string
</span>    <span class="enscript-keyword">return</span>(ptr);                                                    <span class="enscript-comment">// and return
</span>}

<span class="enscript-comment">// RFC 1034 rules:
</span><span class="enscript-comment">// Host names must start with a letter, end with a letter or digit,
</span><span class="enscript-comment">// and have as interior characters only letters, digits, and hyphen.
</span><span class="enscript-comment">// This was subsequently modified in RFC 1123 to allow the first character to be either a letter or a digit
</span>
mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ConvertUTF8PstringToRFC1034HostLabel</span>(<span class="enscript-type">const</span> mDNSu8 UTF8Name[], domainlabel *<span class="enscript-type">const</span> hostlabel)
{
    <span class="enscript-type">const</span> mDNSu8 *      src  = &amp;UTF8Name[1];
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end  = &amp;UTF8Name[1] + UTF8Name[0];
    mDNSu8 *      ptr  = &amp;hostlabel-&gt;c[1];
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> lim  = &amp;hostlabel-&gt;c[1] + MAX_DOMAIN_LABEL;
    <span class="enscript-keyword">while</span> (src &lt; end)
    {
        <span class="enscript-comment">// Delete apostrophes from source name
</span>        <span class="enscript-keyword">if</span> (src[0] == <span class="enscript-string">'\''</span>) { src++; <span class="enscript-keyword">continue</span>; }        <span class="enscript-comment">// Standard straight single quote
</span>        <span class="enscript-keyword">if</span> (src + 2 &lt; end &amp;&amp; src[0] == 0xE2 &amp;&amp; src[1] == 0x80 &amp;&amp; src[2] == 0x99)
        { src += 3; <span class="enscript-keyword">continue</span>; }     <span class="enscript-comment">// Unicode curly apostrophe
</span>        <span class="enscript-keyword">if</span> (ptr &lt; lim)
        {
            <span class="enscript-keyword">if</span> (mDNSValidHostChar(*src, (ptr &gt; &amp;hostlabel-&gt;c[1]), (src &lt; end-1))) *ptr++ = *src;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr &gt; &amp;hostlabel-&gt;c[1] &amp;&amp; ptr[-1] != <span class="enscript-string">'-'</span>) *ptr++ = <span class="enscript-string">'-'</span>;
        }
        src++;
    }
    <span class="enscript-keyword">while</span> (ptr &gt; &amp;hostlabel-&gt;c[1] &amp;&amp; ptr[-1] == <span class="enscript-string">'-'</span>) ptr--; <span class="enscript-comment">// Truncate trailing '-' marks
</span>    hostlabel-&gt;c[0] = (mDNSu8)(ptr - &amp;hostlabel-&gt;c[1]);
}

mDNSexport mDNSu8 *<span class="enscript-function-name">ConstructServiceName</span>(domainname *<span class="enscript-type">const</span> fqdn,
                                        <span class="enscript-type">const</span> domainlabel *name, <span class="enscript-type">const</span> domainname *type, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> domain)
{
    <span class="enscript-type">int</span> i, len;
    mDNSu8 *dst = fqdn-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *src;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *errormsg;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    mDNSBool loggedUnderscore = mDNSfalse;
    <span class="enscript-type">static</span> <span class="enscript-type">char</span> typeBuf[MAX_ESCAPED_DOMAIN_NAME];
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// In the case where there is no name (and ONLY in that case),
</span>    <span class="enscript-comment">// a single-label subtype is allowed as the first label of a three-part &quot;type&quot;
</span>    <span class="enscript-keyword">if</span> (!name)
    {
        <span class="enscript-type">const</span> mDNSu8 *s0 = type-&gt;c;
        <span class="enscript-keyword">if</span> (s0[0] &amp;&amp; s0[0] &lt; 0x40)      <span class="enscript-comment">// If legal first label (at least one character, and no more than 63)
</span>        {
            <span class="enscript-type">const</span> mDNSu8 * s1 = s0 + 1 + s0[0];
            <span class="enscript-keyword">if</span> (s1[0] &amp;&amp; s1[0] &lt; 0x40)  <span class="enscript-comment">// and legal second label (at least one character, and no more than 63)
</span>            {
                <span class="enscript-type">const</span> mDNSu8 *s2 = s1 + 1 + s1[0];
                <span class="enscript-keyword">if</span> (s2[0] &amp;&amp; s2[0] &lt; 0x40 &amp;&amp; s2[1+s2[0]] == 0)  <span class="enscript-comment">// and we have three and only three labels
</span>                {
                    <span class="enscript-type">static</span> <span class="enscript-type">const</span> mDNSu8 SubTypeLabel[5] = mDNSSubTypeLabel;
                    src = s0;                                   <span class="enscript-comment">// Copy the first label
</span>                    len = *src;
                    <span class="enscript-keyword">for</span> (i=0; i &lt;= len;                      i++) *dst++ = *src++;
                    <span class="enscript-keyword">for</span> (i=0; i &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(SubTypeLabel); i++) *dst++ = SubTypeLabel[i];
                    type = (<span class="enscript-type">const</span> domainname *)s1;

                    <span class="enscript-comment">// Special support to enable the DNSServiceBrowse call made by Bonjour Browser
</span>                    <span class="enscript-comment">// For these queries, we retract the &quot;._sub&quot; we just added between the subtype and the main type
</span>                    <span class="enscript-comment">// Remove after Bonjour Browser is updated to use DNSServiceQueryRecord instead of DNSServiceBrowse
</span>                    <span class="enscript-keyword">if</span> (SameDomainName((domainname*)s0, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x09_services\x07_dns-sd\x04_udp&quot;</span>))
                        dst -= <span class="enscript-keyword">sizeof</span>(SubTypeLabel);
                }
            }
        }
    }

    <span class="enscript-keyword">if</span> (name &amp;&amp; name-&gt;c[0])
    {
        src = name-&gt;c;                                  <span class="enscript-comment">// Put the service name into the domain name
</span>        len = *src;
        <span class="enscript-keyword">if</span> (len &gt;= 0x40) { errormsg = <span class="enscript-string">&quot;Service instance name too long&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
        <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;
    }
    <span class="enscript-keyword">else</span>
        name = (domainlabel*)<span class="enscript-string">&quot;&quot;</span>;    <span class="enscript-comment">// Set this up to be non-null, to avoid errors if we have to call LogMsg() below
</span>
    src = type-&gt;c;                                      <span class="enscript-comment">// Put the service type into the domain name
</span>    len = *src;
    <span class="enscript-keyword">if</span> (len &lt; 2 || len &gt; 16)
    {
        LogMsg(<span class="enscript-string">&quot;Bad service type in %#s.%##s%##s Application protocol name must be underscore plus 1-15 characters. &quot;</span>
               <span class="enscript-string">&quot;See &lt;<a href="http://www.dns-sd.org/ServiceTypes.html">http://www.dns-sd.org/ServiceTypes.html</a>&gt;&quot;</span>, name-&gt;c, type-&gt;c, domain-&gt;c);
    }
    <span class="enscript-keyword">if</span> (len &lt; 2 || len &gt;= 0x40 || (len &gt; 16 &amp;&amp; !SameDomainName(domain, &amp;localdomain))) <span class="enscript-keyword">return</span>(mDNSNULL);
    <span class="enscript-keyword">if</span> (src[1] != <span class="enscript-string">'_'</span>) { errormsg = <span class="enscript-string">&quot;Application protocol name must begin with underscore&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    <span class="enscript-keyword">for</span> (i=2; i&lt;=len; i++)
    {
        <span class="enscript-comment">// Letters and digits are allowed anywhere
</span>        <span class="enscript-keyword">if</span> (mDNSIsLetter(src[i]) || mDNSIsDigit(src[i])) <span class="enscript-keyword">continue</span>;
        <span class="enscript-comment">// Hyphens are only allowed as interior characters
</span>        <span class="enscript-comment">// Underscores are not supposed to be allowed at all, but for backwards compatibility with some old products we do allow them,
</span>        <span class="enscript-comment">// with the same rule as hyphens
</span>        <span class="enscript-keyword">if</span> ((src[i] == <span class="enscript-string">'-'</span> || src[i] == <span class="enscript-string">'_'</span>) &amp;&amp; i &gt; 2 &amp;&amp; i &lt; len)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
            <span class="enscript-keyword">if</span> (src[i] == <span class="enscript-string">'_'</span> &amp;&amp; loggedUnderscore == mDNSfalse)
            {
                ConvertDomainNameToCString(type, typeBuf);
                LogInfo(<span class="enscript-string">&quot;ConstructServiceName: Service type with non-leading underscore %s&quot;</span>, typeBuf);
                loggedUnderscore = mDNStrue;
            }
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">continue</span>;
        }
        errormsg = <span class="enscript-string">&quot;Application protocol name must contain only letters, digits, and hyphens&quot;</span>;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }
    <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;

    len = *src;
    <span class="enscript-keyword">if</span> (!ValidTransportProtocol(src)) { errormsg = <span class="enscript-string">&quot;Transport protocol name must be _udp or _tcp&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;

    <span class="enscript-keyword">if</span> (*src) { errormsg = <span class="enscript-string">&quot;Service type must have only two labels&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }

    *dst = 0;
    <span class="enscript-keyword">if</span> (!domain-&gt;c[0]) { errormsg = <span class="enscript-string">&quot;Service domain must be non-empty&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    <span class="enscript-keyword">if</span> (SameDomainName(domain, (<span class="enscript-type">const</span> domainname*)<span class="enscript-string">&quot;\x05&quot;</span> <span class="enscript-string">&quot;local&quot;</span> <span class="enscript-string">&quot;\x04&quot;</span> <span class="enscript-string">&quot;arpa&quot;</span>))
    { errormsg = <span class="enscript-string">&quot;Illegal domain \&quot;local.arpa.\&quot; Use \&quot;local.\&quot; (or empty string)&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    dst = AppendDomainName(fqdn, domain);
    <span class="enscript-keyword">if</span> (!dst) { errormsg = <span class="enscript-string">&quot;Service domain too long&quot;</span>; <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
    <span class="enscript-keyword">return</span>(dst);

<span class="enscript-reference">fail</span>:
    LogMsg(<span class="enscript-string">&quot;ConstructServiceName: %s: %#s.%##s%##s&quot;</span>, errormsg, name-&gt;c, type-&gt;c, domain-&gt;c);
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// A service name has the form: instance.application-protocol.transport-protocol.domain
</span><span class="enscript-comment">// DeconstructServiceName is currently fairly forgiving: It doesn't try to enforce character
</span><span class="enscript-comment">// set or length limits for the protocol names, and the final domain is allowed to be empty.
</span><span class="enscript-comment">// However, if the given FQDN doesn't contain at least three labels,
</span><span class="enscript-comment">// DeconstructServiceName will reject it and return mDNSfalse.
</span>mDNSexport mDNSBool <span class="enscript-function-name">DeconstructServiceName</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> fqdn,
                                           domainlabel *<span class="enscript-type">const</span> name, domainname *<span class="enscript-type">const</span> type, domainname *<span class="enscript-type">const</span> domain)
{
    <span class="enscript-type">int</span> i, len;
    <span class="enscript-type">const</span> mDNSu8 *src = fqdn-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *max = fqdn-&gt;c + MAX_DOMAIN_NAME;
    mDNSu8 *dst;

    dst = name-&gt;c;                                      <span class="enscript-comment">// Extract the service name
</span>    len = *src;
    <span class="enscript-keyword">if</span> (!len)         { debugf(<span class="enscript-string">&quot;DeconstructServiceName: FQDN empty!&quot;</span>);                             <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (len &gt;= 0x40)  { debugf(<span class="enscript-string">&quot;DeconstructServiceName: Instance name too long&quot;</span>);                  <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;

    dst = type-&gt;c;                                      <span class="enscript-comment">// Extract the service type
</span>    len = *src;
    <span class="enscript-keyword">if</span> (!len)         { debugf(<span class="enscript-string">&quot;DeconstructServiceName: FQDN contains only one label!&quot;</span>);           <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (len &gt;= 0x40)  { debugf(<span class="enscript-string">&quot;DeconstructServiceName: Application protocol name too long&quot;</span>);      <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (src[1] != <span class="enscript-string">'_'</span>) { debugf(<span class="enscript-string">&quot;DeconstructServiceName: No _ at start of application protocol&quot;</span>);   <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;

    len = *src;
    <span class="enscript-keyword">if</span> (!len)         { debugf(<span class="enscript-string">&quot;DeconstructServiceName: FQDN contains only two labels!&quot;</span>);          <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">if</span> (!ValidTransportProtocol(src))
    { debugf(<span class="enscript-string">&quot;DeconstructServiceName: Transport protocol must be _udp or _tcp&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
    <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;
    *dst++ = 0;                                         <span class="enscript-comment">// Put terminator on the end of service type
</span>
    dst = domain-&gt;c;                                    <span class="enscript-comment">// Extract the service domain
</span>    <span class="enscript-keyword">while</span> (*src)
    {
        len = *src;
        <span class="enscript-keyword">if</span> (len &gt;= 0x40)
        { debugf(<span class="enscript-string">&quot;DeconstructServiceName: Label in service domain too long&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
        <span class="enscript-keyword">if</span> (src + 1 + len + 1 &gt;= max)
        { debugf(<span class="enscript-string">&quot;DeconstructServiceName: Total service domain too long&quot;</span>); <span class="enscript-keyword">return</span>(mDNSfalse); }
        <span class="enscript-keyword">for</span> (i=0; i&lt;=len; i++) *dst++ = *src++;
    }
    *dst++ = 0;     <span class="enscript-comment">// Put the null root label on the end
</span>
    <span class="enscript-keyword">return</span>(mDNStrue);
}

mDNSexport mStatus <span class="enscript-function-name">DNSNameToLowerCase</span>(domainname *d, domainname *result)
{
    <span class="enscript-type">const</span> mDNSu8 *a = d-&gt;c;
    mDNSu8 *b = result-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> max = d-&gt;c + MAX_DOMAIN_NAME;
    <span class="enscript-type">int</span> i, len;

    <span class="enscript-keyword">while</span> (*a)
    {
        <span class="enscript-keyword">if</span> (a + 1 + *a &gt;= max)
        {
            LogMsg(<span class="enscript-string">&quot;DNSNameToLowerCase: ERROR!! Malformed Domain name&quot;</span>);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }
        len = *a++;
        *b++ = len;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; len; i++)
        {
            mDNSu8 ac = *a++;
            <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
            *b++ = ac;
        }
    }
    *b = 0;

    <span class="enscript-keyword">return</span> mStatus_NoError;
}

<span class="enscript-comment">// Notes on UTF-8:
</span><span class="enscript-comment">// 0xxxxxxx represents a 7-bit ASCII value from 0x00 to 0x7F
</span><span class="enscript-comment">// 10xxxxxx is a continuation byte of a multi-byte character
</span><span class="enscript-comment">// 110xxxxx is the first byte of a 2-byte character (11 effective bits; values 0x     80 - 0x     800-1)
</span><span class="enscript-comment">// 1110xxxx is the first byte of a 3-byte character (16 effective bits; values 0x    800 - 0x   10000-1)
</span><span class="enscript-comment">// 11110xxx is the first byte of a 4-byte character (21 effective bits; values 0x  10000 - 0x  200000-1)
</span><span class="enscript-comment">// 111110xx is the first byte of a 5-byte character (26 effective bits; values 0x 200000 - 0x 4000000-1)
</span><span class="enscript-comment">// 1111110x is the first byte of a 6-byte character (31 effective bits; values 0x4000000 - 0x80000000-1)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// UTF-16 surrogate pairs are used in UTF-16 to encode values larger than 0xFFFF.
</span><span class="enscript-comment">// Although UTF-16 surrogate pairs are not supposed to appear in legal UTF-8, we want to be defensive
</span><span class="enscript-comment">// about that too. (See &lt;<a href="http://www.unicode.org/faq/utf_bom.html#34">http://www.unicode.org/faq/utf_bom.html#34</a>&gt;, &quot;What are surrogates?&quot;)
</span><span class="enscript-comment">// The first of pair is a UTF-16 value in the range 0xD800-0xDBFF (11101101 1010xxxx 10xxxxxx in UTF-8),
</span><span class="enscript-comment">// and the second    is a UTF-16 value in the range 0xDC00-0xDFFF (11101101 1011xxxx 10xxxxxx in UTF-8).
</span>
mDNSexport mDNSu32 <span class="enscript-function-name">TruncateUTF8ToLength</span>(mDNSu8 *string, mDNSu32 length, mDNSu32 max)
{
    <span class="enscript-keyword">if</span> (length &gt; max)
    {
        mDNSu8 c1 = string[max];                                        <span class="enscript-comment">// First byte after cut point
</span>        mDNSu8 c2 = (max+1 &lt; length) ? string[max+1] : (mDNSu8)0xB0;    <span class="enscript-comment">// Second byte after cut point
</span>        length = max;   <span class="enscript-comment">// Trim length down
</span>        <span class="enscript-keyword">while</span> (length &gt; 0)
        {
            <span class="enscript-comment">// Check if the byte right after the chop point is a UTF-8 continuation byte,
</span>            <span class="enscript-comment">// or if the character right after the chop point is the second of a UTF-16 surrogate pair.
</span>            <span class="enscript-comment">// If so, then we continue to chop more bytes until we get to a legal chop point.
</span>            mDNSBool continuation    = ((c1 &amp; 0xC0) == 0x80);
            mDNSBool secondsurrogate = (c1 == 0xED &amp;&amp; (c2 &amp; 0xF0) == 0xB0);
            <span class="enscript-keyword">if</span> (!continuation &amp;&amp; !secondsurrogate) <span class="enscript-keyword">break</span>;
            c2 = c1;
            c1 = string[--length];
        }
        <span class="enscript-comment">// Having truncated characters off the end of our string, also cut off any residual white space
</span>        <span class="enscript-keyword">while</span> (length &gt; 0 &amp;&amp; string[length-1] &lt;= <span class="enscript-string">' '</span>) length--;
    }
    <span class="enscript-keyword">return</span>(length);
}

<span class="enscript-comment">// Returns true if a rich text label ends in &quot; (nnn)&quot;, or if an RFC 1034
</span><span class="enscript-comment">// name ends in &quot;-nnn&quot;, where n is some decimal number.
</span>mDNSexport mDNSBool <span class="enscript-function-name">LabelContainsSuffix</span>(<span class="enscript-type">const</span> domainlabel *<span class="enscript-type">const</span> name, <span class="enscript-type">const</span> mDNSBool RichText)
{
    mDNSu16 l = name-&gt;c[0];

    <span class="enscript-keyword">if</span> (RichText)
    {
        <span class="enscript-keyword">if</span> (l &lt; 4) <span class="enscript-keyword">return</span> mDNSfalse;                            <span class="enscript-comment">// Need at least &quot; (2)&quot;
</span>        <span class="enscript-keyword">if</span> (name-&gt;c[l--] != <span class="enscript-string">')'</span>) <span class="enscript-keyword">return</span> mDNSfalse;              <span class="enscript-comment">// Last char must be ')'
</span>        <span class="enscript-keyword">if</span> (!mDNSIsDigit(name-&gt;c[l])) <span class="enscript-keyword">return</span> mDNSfalse;         <span class="enscript-comment">// Preceeded by a digit
</span>        l--;
        <span class="enscript-keyword">while</span> (l &gt; 2 &amp;&amp; mDNSIsDigit(name-&gt;c[l])) l--;           <span class="enscript-comment">// Strip off digits
</span>        <span class="enscript-keyword">return</span> (name-&gt;c[l] == <span class="enscript-string">'('</span> &amp;&amp; name-&gt;c[l - 1] == <span class="enscript-string">' '</span>);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (l &lt; 2) <span class="enscript-keyword">return</span> mDNSfalse;                            <span class="enscript-comment">// Need at least &quot;-2&quot;
</span>        <span class="enscript-keyword">if</span> (!mDNSIsDigit(name-&gt;c[l])) <span class="enscript-keyword">return</span> mDNSfalse;         <span class="enscript-comment">// Last char must be a digit
</span>        l--;
        <span class="enscript-keyword">while</span> (l &gt; 2 &amp;&amp; mDNSIsDigit(name-&gt;c[l])) l--;           <span class="enscript-comment">// Strip off digits
</span>        <span class="enscript-keyword">return</span> (name-&gt;c[l] == <span class="enscript-string">'-'</span>);
    }
}

<span class="enscript-comment">// removes an auto-generated suffix (appended on a name collision) from a label.  caller is
</span><span class="enscript-comment">// responsible for ensuring that the label does indeed contain a suffix.  returns the number
</span><span class="enscript-comment">// from the suffix that was removed.
</span>mDNSexport mDNSu32 <span class="enscript-function-name">RemoveLabelSuffix</span>(domainlabel *name, mDNSBool RichText)
{
    mDNSu32 val = 0, multiplier = 1;

    <span class="enscript-comment">// Chop closing parentheses from RichText suffix
</span>    <span class="enscript-keyword">if</span> (RichText &amp;&amp; name-&gt;c[0] &gt;= 1 &amp;&amp; name-&gt;c[name-&gt;c[0]] == <span class="enscript-string">')'</span>) name-&gt;c[0]--;

    <span class="enscript-comment">// Get any existing numerical suffix off the name
</span>    <span class="enscript-keyword">while</span> (mDNSIsDigit(name-&gt;c[name-&gt;c[0]]))
    { val += (name-&gt;c[name-&gt;c[0]] - <span class="enscript-string">'0'</span>) * multiplier; multiplier *= 10; name-&gt;c[0]--; }

    <span class="enscript-comment">// Chop opening parentheses or dash from suffix
</span>    <span class="enscript-keyword">if</span> (RichText)
    {
        <span class="enscript-keyword">if</span> (name-&gt;c[0] &gt;= 2 &amp;&amp; name-&gt;c[name-&gt;c[0]] == <span class="enscript-string">'('</span> &amp;&amp; name-&gt;c[name-&gt;c[0]-1] == <span class="enscript-string">' '</span>) name-&gt;c[0] -= 2;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (name-&gt;c[0] &gt;= 1 &amp;&amp; name-&gt;c[name-&gt;c[0]] == <span class="enscript-string">'-'</span>) name-&gt;c[0] -= 1;
    }

    <span class="enscript-keyword">return</span>(val);
}

<span class="enscript-comment">// appends a numerical suffix to a label, with the number following a whitespace and enclosed
</span><span class="enscript-comment">// in parentheses (rich text) or following two consecutive hyphens (RFC 1034 domain label).
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">AppendLabelSuffix</span>(domainlabel *<span class="enscript-type">const</span> name, mDNSu32 val, <span class="enscript-type">const</span> mDNSBool RichText)
{
    mDNSu32 divisor = 1, chars = 2; <span class="enscript-comment">// Shortest possible RFC1034 name suffix is 2 characters (&quot;-2&quot;)
</span>    <span class="enscript-keyword">if</span> (RichText) chars = 4;        <span class="enscript-comment">// Shortest possible RichText suffix is 4 characters (&quot; (2)&quot;)
</span>
    <span class="enscript-comment">// Truncate trailing spaces from RichText names
</span>    <span class="enscript-keyword">if</span> (RichText) <span class="enscript-keyword">while</span> (name-&gt;c[name-&gt;c[0]] == <span class="enscript-string">' '</span>) name-&gt;c[0]--;

    <span class="enscript-keyword">while</span> (divisor &lt; 0xFFFFFFFFUL/10 &amp;&amp; val &gt;= divisor * 10) { divisor *= 10; chars++; }

    name-&gt;c[0] = (mDNSu8) TruncateUTF8ToLength(name-&gt;c+1, name-&gt;c[0], MAX_DOMAIN_LABEL - chars);

    <span class="enscript-keyword">if</span> (RichText) { name-&gt;c[++name-&gt;c[0]] = <span class="enscript-string">' '</span>; name-&gt;c[++name-&gt;c[0]] = <span class="enscript-string">'('</span>; }
    <span class="enscript-keyword">else</span>          { name-&gt;c[++name-&gt;c[0]] = <span class="enscript-string">'-'</span>; }

    <span class="enscript-keyword">while</span> (divisor)
    {
        name-&gt;c[++name-&gt;c[0]] = (mDNSu8)(<span class="enscript-string">'0'</span> + val / divisor);
        val     %= divisor;
        divisor /= 10;
    }

    <span class="enscript-keyword">if</span> (RichText) name-&gt;c[++name-&gt;c[0]] = <span class="enscript-string">')'</span>;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">IncrementLabelSuffix</span>(domainlabel *name, mDNSBool RichText)
{
    mDNSu32 val = 0;

    <span class="enscript-keyword">if</span> (LabelContainsSuffix(name, RichText))
        val = RemoveLabelSuffix(name, RichText);

    <span class="enscript-comment">// If no existing suffix, start by renaming &quot;Foo&quot; as &quot;Foo (2)&quot; or &quot;Foo-2&quot; as appropriate.
</span>    <span class="enscript-comment">// If existing suffix in the range 2-9, increment it.
</span>    <span class="enscript-comment">// If we've had ten conflicts already, there are probably too many hosts trying to use the same name,
</span>    <span class="enscript-comment">// so add a random increment to improve the chances of finding an available name next time.
</span>    <span class="enscript-keyword">if</span>      (val == 0) val = 2;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (val &lt; 10) val++;
    <span class="enscript-keyword">else</span> val += 1 + mDNSRandom(99);

    AppendLabelSuffix(name, val, RichText);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Resource</span> <span class="enscript-variable-name">Record</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Set up a AuthRecord with sensible default values.
</span><span class="enscript-comment">// These defaults may be overwritten with new values before mDNS_Register is called
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetupResourceRecord</span>(AuthRecord *rr, RData *RDataStorage, mDNSInterfaceID InterfaceID,
                                         mDNSu16 rrtype, mDNSu32 ttl, mDNSu8 RecordType, AuthRecType artype, mDNSRecordCallback Callback, <span class="enscript-type">void</span> *Context)
{
    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// LocalOnly auth record can be created with LocalOnly InterfaceID or a valid InterfaceID.
</span>    <span class="enscript-comment">// Most of the applications normally create with LocalOnly InterfaceID and we store them as
</span>    <span class="enscript-comment">// such, so that we can deliver the response to questions that specify LocalOnly InterfaceID.
</span>    <span class="enscript-comment">// LocalOnly resource records can also be created with valid InterfaceID which happens today
</span>    <span class="enscript-comment">// when we create LocalOnly records for /etc/hosts.
</span>
    <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_LocalOnly &amp;&amp; artype != AuthRecordLocalOnly)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_SetupResourceRecord: ERROR!! Mismatch LocalOnly record InterfaceID %p called with artype %d&quot;</span>, InterfaceID, artype);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (InterfaceID == mDNSInterface_P2P &amp;&amp; artype != AuthRecordP2P)
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_SetupResourceRecord: ERROR!! Mismatch P2P record InterfaceID %p called with artype %d&quot;</span>, InterfaceID, artype);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!InterfaceID &amp;&amp; (artype == AuthRecordP2P || artype == AuthRecordLocalOnly))
    {
        LogMsg(<span class="enscript-string">&quot;mDNS_SetupResourceRecord: ERROR!! Mismatch InterfaceAny record InterfaceID %p called with artype %d&quot;</span>, InterfaceID, artype);
    }

    <span class="enscript-comment">// Don't try to store a TTL bigger than we can represent in platform time units
</span>    <span class="enscript-keyword">if</span> (ttl &gt; 0x7FFFFFFFUL / mDNSPlatformOneSecond)
        ttl = 0x7FFFFFFFUL / mDNSPlatformOneSecond;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ttl == 0)      <span class="enscript-comment">// And Zero TTL is illegal
</span>        ttl = DefaultTTLforRRType(rrtype);

    <span class="enscript-comment">// Field Group 1: The actual information pertaining to this resource record
</span>    rr-&gt;resrec.RecordType        = RecordType;
    rr-&gt;resrec.InterfaceID       = InterfaceID;
    rr-&gt;resrec.name              = &amp;rr-&gt;namestorage;
    rr-&gt;resrec.rrtype            = rrtype;
    rr-&gt;resrec.rrclass           = kDNSClass_IN;
    rr-&gt;resrec.rroriginalttl     = ttl;
    rr-&gt;resrec.rDNSServer        = mDNSNULL;
<span class="enscript-comment">//	rr-&gt;resrec.rdlength          = MUST set by client and/or in mDNS_Register_internal
</span><span class="enscript-comment">//	rr-&gt;resrec.rdestimate        = set in mDNS_Register_internal
</span><span class="enscript-comment">//	rr-&gt;resrec.rdata             = MUST be set by client
</span>
    <span class="enscript-keyword">if</span> (RDataStorage)
        rr-&gt;resrec.rdata = RDataStorage;
    <span class="enscript-keyword">else</span>
    {
        rr-&gt;resrec.rdata = &amp;rr-&gt;rdatastorage;
        rr-&gt;resrec.rdata-&gt;MaxRDLength = <span class="enscript-keyword">sizeof</span>(RDataBody);
    }

    <span class="enscript-comment">// Field Group 2: Persistent metadata for Authoritative Records
</span>    rr-&gt;Additional1       = mDNSNULL;
    rr-&gt;Additional2       = mDNSNULL;
    rr-&gt;DependentOn       = mDNSNULL;
    rr-&gt;RRSet             = mDNSNULL;
    rr-&gt;RecordCallback    = Callback;
    rr-&gt;RecordContext     = Context;

    rr-&gt;AutoTarget        = Target_Manual;
    rr-&gt;AllowRemoteQuery  = mDNSfalse;
    rr-&gt;ForceMCast        = mDNSfalse;

    rr-&gt;WakeUp            = zeroOwner;
    rr-&gt;AddressProxy      = zeroAddr;
    rr-&gt;TimeRcvd          = 0;
    rr-&gt;TimeExpire        = 0;
    rr-&gt;ARType            = artype;
    rr-&gt;AuthFlags         = 0;

    <span class="enscript-comment">// Field Group 3: Transient state for Authoritative Records (set in mDNS_Register_internal)
</span>    <span class="enscript-comment">// Field Group 4: Transient uDNS state for Authoritative Records (set in mDNS_Register_internal)
</span>
    <span class="enscript-comment">// For now, until the uDNS code is fully integrated, it's helpful to zero the uDNS state fields here too, just in case
</span>    <span class="enscript-comment">// (e.g. uDNS_RegisterService short-circuits the usual mDNS_Register_internal record registration calls, so a bunch
</span>    <span class="enscript-comment">// of fields don't get set up properly. In particular, if we don't zero rr-&gt;QueuedRData then the uDNS code crashes.)
</span>    rr-&gt;state             = regState_Zero;
    rr-&gt;uselease          = 0;
    rr-&gt;expire            = 0;
    rr-&gt;Private           = 0;
    rr-&gt;updateid          = zeroID;
    rr-&gt;zone              = rr-&gt;resrec.name;
    rr-&gt;nta               = mDNSNULL;
    rr-&gt;tcp               = mDNSNULL;
    rr-&gt;OrigRData         = 0;
    rr-&gt;OrigRDLen         = 0;
    rr-&gt;InFlightRData     = 0;
    rr-&gt;InFlightRDLen     = 0;
    rr-&gt;QueuedRData       = 0;
    rr-&gt;QueuedRDLen       = 0;
    mDNSPlatformMemZero(&amp;rr-&gt;NATinfo, <span class="enscript-keyword">sizeof</span>(rr-&gt;NATinfo));
    rr-&gt;SRVChanged = mDNSfalse;
    rr-&gt;mState = mergeState_Zero;

    rr-&gt;namestorage.c[0]  = 0;      <span class="enscript-comment">// MUST be set by client before calling mDNS_Register()
</span>}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_SetupQuestion</span>(DNSQuestion *<span class="enscript-type">const</span> q, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name,
                                   <span class="enscript-type">const</span> mDNSu16 qtype, mDNSQuestionCallback *<span class="enscript-type">const</span> callback, <span class="enscript-type">void</span> *<span class="enscript-type">const</span> context)
{
    q-&gt;InterfaceID         = InterfaceID;
    q-&gt;flags               = 0;
    AssignDomainName(&amp;q-&gt;qname, name);
    q-&gt;qtype               = qtype;
    q-&gt;qclass              = kDNSClass_IN;
    q-&gt;LongLived           = (qtype == kDNSType_PTR);
    q-&gt;ExpectUnique        = (qtype != kDNSType_PTR);
    q-&gt;ForceMCast          = mDNSfalse;
    q-&gt;ReturnIntermed      = mDNSfalse;
    q-&gt;SuppressUnusable    = mDNSfalse;
    q-&gt;AppendSearchDomains = 0;
    q-&gt;TimeoutQuestion     = 0;
    q-&gt;WakeOnResolve       = 0;
    q-&gt;UseBackgroundTraffic = mDNSfalse;
    q-&gt;ValidationRequired  = 0;
    q-&gt;ValidatingResponse  = 0;
    q-&gt;ProxyQuestion       = 0;
    q-&gt;pid                 = mDNSPlatformGetPID();
    q-&gt;euid                = 0;
    q-&gt;BlockedByPolicy     = mDNSfalse;
    q-&gt;ServiceID           = -1;
    q-&gt;QuestionCallback    = callback;
    q-&gt;QuestionContext     = context;
}

mDNSexport mDNSu32 <span class="enscript-function-name">RDataHashValue</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-type">int</span> len = rr-&gt;rdlength;
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
    <span class="enscript-type">const</span> mDNSu8 *ptr = rdb-&gt;data;
    mDNSu32 sum = 0;

    <span class="enscript-keyword">switch</span>(rr-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSAP_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>: <span class="enscript-keyword">return</span> DomainNameHashValue(&amp;rdb-&gt;name);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:   <span class="enscript-keyword">return</span> rdb-&gt;soa.serial  +
               rdb-&gt;soa.refresh +
               rdb-&gt;soa.retry   +
               rdb-&gt;soa.expire  +
               rdb-&gt;soa.min     +
               DomainNameHashValue(&amp;rdb-&gt;soa.mname) +
               DomainNameHashValue(&amp;rdb-&gt;soa.rname);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:    <span class="enscript-keyword">return</span> DomainNameHashValue(&amp;rdb-&gt;mx.exchange);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:    <span class="enscript-keyword">return</span> DomainNameHashValue(&amp;rdb-&gt;rp.mbox)   + DomainNameHashValue(&amp;rdb-&gt;rp.txt);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:    <span class="enscript-keyword">return</span> DomainNameHashValue(&amp;rdb-&gt;px.map822) + DomainNameHashValue(&amp;rdb-&gt;px.mapx400);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:   <span class="enscript-keyword">return</span> DomainNameHashValue(&amp;rdb-&gt;srv.target);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:   <span class="enscript-keyword">return</span> 0;      <span class="enscript-comment">// OPT is a pseudo-RR container structure; makes no sense to compare
</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
        <span class="enscript-type">int</span> dlen;
        dlen = DomainNameLength((domainname *)rdb-&gt;data);
        sum = DomainNameHashValue((domainname *)rdb-&gt;data);
        ptr += dlen;
        len -= dlen;
        fallthrough();
        <span class="enscript-comment">/* FALLTHROUGH */</span>
    }

    <span class="enscript-reference">default</span>:
    {
        <span class="enscript-type">int</span> i;
        <span class="enscript-keyword">for</span> (i=0; i+1 &lt; len; i+=2)
        {
            sum += (((mDNSu32)(ptr[i])) &lt;&lt; 8) | ptr[i+1];
            sum = (sum&lt;&lt;3) | (sum&gt;&gt;29);
        }
        <span class="enscript-keyword">if</span> (i &lt; len)
        {
            sum += ((mDNSu32)(ptr[i])) &lt;&lt; 8;
        }
        <span class="enscript-keyword">return</span>(sum);
    }
    }
}

<span class="enscript-comment">// r1 has to be a full ResourceRecord including rrtype and rdlength
</span><span class="enscript-comment">// r2 is just a bare RDataBody, which MUST be the same rrtype and rdlength as r1
</span>mDNSexport mDNSBool <span class="enscript-function-name">SameRDataBody</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> r1, <span class="enscript-type">const</span> RDataBody *<span class="enscript-type">const</span> r2, DomainNameComparisonFn *samename)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> b1 = (RDataBody2 *)r1-&gt;rdata-&gt;u.data;
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> b2 = (RDataBody2 *)r2;
    <span class="enscript-keyword">switch</span>(r1-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSAP_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>: <span class="enscript-keyword">return</span>(SameDomainName(&amp;b1-&gt;name, &amp;b2-&gt;name));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:  <span class="enscript-keyword">return</span> (mDNSBool)(   b1-&gt;soa.serial   == b2-&gt;soa.serial             &amp;&amp;
                                             b1-&gt;soa.refresh  == b2-&gt;soa.refresh            &amp;&amp;
                                             b1-&gt;soa.retry    == b2-&gt;soa.retry              &amp;&amp;
                                             b1-&gt;soa.expire   == b2-&gt;soa.expire             &amp;&amp;
                                             b1-&gt;soa.min      == b2-&gt;soa.min                &amp;&amp;
                                             samename(&amp;b1-&gt;soa.mname, &amp;b2-&gt;soa.mname) &amp;&amp;
                                             samename(&amp;b1-&gt;soa.rname, &amp;b2-&gt;soa.rname));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:   <span class="enscript-keyword">return</span> (mDNSBool)(   b1-&gt;mx.preference == b2-&gt;mx.preference &amp;&amp;
                                             samename(&amp;b1-&gt;mx.exchange, &amp;b2-&gt;mx.exchange));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:   <span class="enscript-keyword">return</span> (mDNSBool)(   samename(&amp;b1-&gt;rp.mbox, &amp;b2-&gt;rp.mbox) &amp;&amp;
                                             samename(&amp;b1-&gt;rp.txt,  &amp;b2-&gt;rp.txt));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:   <span class="enscript-keyword">return</span> (mDNSBool)(   b1-&gt;px.preference == b2-&gt;px.preference          &amp;&amp;
                                             samename(&amp;b1-&gt;px.map822,  &amp;b2-&gt;px.map822) &amp;&amp;
                                             samename(&amp;b1-&gt;px.mapx400, &amp;b2-&gt;px.mapx400));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:  <span class="enscript-keyword">return</span> (mDNSBool)(   b1-&gt;srv.priority == b2-&gt;srv.priority       &amp;&amp;
                                             b1-&gt;srv.weight   == b2-&gt;srv.weight         &amp;&amp;
                                             mDNSSameIPPort(b1-&gt;srv.port, b2-&gt;srv.port) &amp;&amp;
                                             samename(&amp;b1-&gt;srv.target, &amp;b2-&gt;srv.target));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  <span class="enscript-keyword">return</span> mDNSfalse;       <span class="enscript-comment">// OPT is a pseudo-RR container structure; makes no sense to compare
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
        <span class="enscript-comment">// If the &quot;nxt&quot; name changes in case, we want to delete the old
</span>        <span class="enscript-comment">// and store just the new one. If the caller passes in SameDomainCS for &quot;samename&quot;,
</span>        <span class="enscript-comment">// we would return &quot;false&quot; when the only change between the two rdata is the case
</span>        <span class="enscript-comment">// change in &quot;nxt&quot;.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Note: rdlength of both the RData are same (ensured by the caller) and hence we can
</span>        <span class="enscript-comment">// use just r1-&gt;rdlength below
</span>
        <span class="enscript-type">int</span> dlen1 = DomainNameLength((domainname *)b1-&gt;data);
        <span class="enscript-type">int</span> dlen2 = DomainNameLength((domainname *)b2-&gt;data);
        <span class="enscript-keyword">return</span> (mDNSBool)(dlen1 == dlen2 &amp;&amp;
                          samename((domainname *)b1-&gt;data, (domainname *)b2-&gt;data) &amp;&amp;
                          mDNSPlatformMemSame(b1-&gt;data + dlen1, b2-&gt;data + dlen2, r1-&gt;rdlength - dlen1));
    }

    <span class="enscript-reference">default</span>:            <span class="enscript-keyword">return</span>(mDNSPlatformMemSame(b1-&gt;data, b2-&gt;data, r1-&gt;rdlength));
    }
}

mDNSexport mDNSBool <span class="enscript-function-name">BitmapTypeCheck</span>(mDNSu8 *bmap, <span class="enscript-type">int</span> bitmaplen, mDNSu16 type)
{
    <span class="enscript-type">int</span> win, wlen;
    <span class="enscript-type">int</span> wintype;

    <span class="enscript-comment">// The window that this type belongs to. NSEC has 256 windows that
</span>    <span class="enscript-comment">// comprises of 256 types.
</span>    wintype = type &gt;&gt; 8;

    <span class="enscript-keyword">while</span> (bitmaplen &gt; 0)
    {
        <span class="enscript-keyword">if</span> (bitmaplen &lt; 3)
        {
            LogInfo(<span class="enscript-string">&quot;BitmapTypeCheck: malformed nsec, bitmaplen %d short&quot;</span>, bitmaplen);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }

        win = *bmap++;
        wlen = *bmap++;
        bitmaplen -= 2;
        <span class="enscript-keyword">if</span> (bitmaplen &lt; wlen || wlen &lt; 1 || wlen &gt; 32)
        {
            LogInfo(<span class="enscript-string">&quot;BitmapTypeCheck: malformed nsec, bitmaplen %d wlen %d, win %d&quot;</span>, bitmaplen, wlen, win);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-keyword">if</span> (win &lt; 0 || win &gt;= 256)
        {
            LogInfo(<span class="enscript-string">&quot;BitmapTypeCheck: malformed nsec, wlen %d&quot;</span>, wlen);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-keyword">if</span> (win == wintype)
        {
            <span class="enscript-comment">// First byte in the window serves 0 to 7, the next one serves 8 to 15 and so on.
</span>            <span class="enscript-comment">// Calculate the right byte offset first.
</span>            <span class="enscript-type">int</span> boff = (type &amp; 0xff ) &gt;&gt; 3;
            <span class="enscript-keyword">if</span> (wlen &lt;= boff)
                <span class="enscript-keyword">return</span> mDNSfalse;
            <span class="enscript-comment">// The last three bits values 0 to 7 corresponds to bit positions
</span>            <span class="enscript-comment">// within the byte.
</span>            <span class="enscript-keyword">return</span> (bmap[boff] &amp; (0x80 &gt;&gt; (type &amp; 7)));
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// If the windows are ordered, then we could check to see
</span>            <span class="enscript-comment">// if wintype &gt; win and then return early.
</span>            bmap += wlen;
            bitmaplen -= wlen;
        }
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

<span class="enscript-comment">// Don't call this function if the resource record is not NSEC. It will return false
</span><span class="enscript-comment">// which means that the type does not exist.
</span>mDNSexport mDNSBool <span class="enscript-function-name">RRAssertsExistence</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSu16 type)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
    mDNSu8 *nsec = (mDNSu8 *)rdb-&gt;data;
    <span class="enscript-type">int</span> len, bitmaplen;
    mDNSu8 *bmap;

    <span class="enscript-keyword">if</span> (rr-&gt;rrtype != kDNSType_NSEC) <span class="enscript-keyword">return</span> mDNSfalse;

    len = DomainNameLength((domainname *)nsec);

    bitmaplen = rr-&gt;rdlength - len;
    bmap = nsec + len;
    <span class="enscript-keyword">return</span> (BitmapTypeCheck(bmap, bitmaplen, type));
}

<span class="enscript-comment">// Don't call this function if the resource record is not NSEC. It will return false
</span><span class="enscript-comment">// which means that the type exists.
</span>mDNSexport mDNSBool <span class="enscript-function-name">RRAssertsNonexistence</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSu16 type)
{
    <span class="enscript-keyword">if</span> (rr-&gt;rrtype != kDNSType_NSEC) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">return</span> !RRAssertsExistence(rr, type);
}

<span class="enscript-comment">// Checks whether the RRSIG or NSEC record answers the question &quot;q&quot;.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">DNSSECRecordAnswersQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q, mDNSBool *checkType)
{
    *checkType = mDNStrue;

    <span class="enscript-comment">// This function is called for all questions and as long as the type matches,
</span>    <span class="enscript-comment">// return true. For the types (RRSIG and NSEC) that are specifically checked in
</span>    <span class="enscript-comment">// this function, returning true still holds good.
</span>    <span class="enscript-keyword">if</span> (q-&gt;qtype == rr-&gt;rrtype)
        <span class="enscript-keyword">return</span> mDNStrue;

    <span class="enscript-comment">// For DS and DNSKEY questions, the types should match i.e., don't answer using CNAME
</span>    <span class="enscript-comment">// records as it answers any question type.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - DS record comes from the parent zone where CNAME record cannot coexist and hence
</span>    <span class="enscript-comment">//  cannot possibly answer it.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - For DNSKEY, one could potentially follow CNAME but there could be a DNSKEY at
</span>    <span class="enscript-comment">//   the &quot;qname&quot; itself. To keep it simple, we don't follow CNAME.
</span>
    <span class="enscript-keyword">if</span> ((q-&gt;qtype == kDNSType_DS || q-&gt;qtype == kDNSType_DNSKEY) &amp;&amp; (q-&gt;qtype != rr-&gt;rrtype))
    {
        debugf(<span class="enscript-string">&quot;DNSSECRecordAnswersQuestion: %d type resource record matched question %##s (%s), ignoring&quot;</span>, rr-&gt;rrtype,
            q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// If we are validating a response using DNSSEC, we might already have the records
</span>    <span class="enscript-comment">// for the &quot;q-&gt;qtype&quot; in the cache but we issued a query with DO bit set
</span>    <span class="enscript-comment">// to get the RRSIGs e.g., if you have two questions one of which does not require
</span>    <span class="enscript-comment">// DNSSEC validation. When the RRSIG is added to the cache, we need to deliver
</span>    <span class="enscript-comment">// the response to the question. The RRSIG type won't match the q-&gt;qtype and hence
</span>    <span class="enscript-comment">// we need to bypass the check in that case.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_RRSIG &amp;&amp; q-&gt;ValidatingResponse)
    {
        <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
        rdataRRSig *rrsig = (rdataRRSig *)rdb-&gt;data;
        mDNSu16 typeCovered = swap16(rrsig-&gt;typeCovered);
        debugf(<span class="enscript-string">&quot;DNSSECRecordAnswersQuestion: Matching RRSIG typeCovered %s&quot;</span>, DNSTypeName(typeCovered));
        <span class="enscript-keyword">if</span> (typeCovered != kDNSType_CNAME &amp;&amp; typeCovered != q-&gt;qtype)
        {
            debugf(<span class="enscript-string">&quot;DNSSECRecordAnswersQuestion: RRSIG did not match question %##s (%s)&quot;</span>, q-&gt;qname.c,
                    DNSTypeName(q-&gt;qtype));
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        LogInfo(<span class="enscript-string">&quot;DNSSECRecordAnswersQuestion: RRSIG matched question %##s (%s)&quot;</span>, q-&gt;qname.c,
                DNSTypeName(q-&gt;qtype));
        *checkType = mDNSfalse;
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-comment">// If the NSEC record asserts the non-existence of a name looked up by the question, we would
</span>    <span class="enscript-comment">// typically answer that e.g., the bitmap asserts that q-&gt;qtype does not exist. If we have
</span>    <span class="enscript-comment">// to prove the non-existence as required by ValidatingResponse and ValidationRequired question,
</span>    <span class="enscript-comment">// then we should not answer that as it may not be the right one always. We may need more than
</span>    <span class="enscript-comment">// one NSEC to prove the non-existence.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_NSEC &amp;&amp; DNSSECQuestion(q))
    {
        debugf(<span class="enscript-string">&quot;DNSSECRecordAnswersQuestion: Question %##s (%s) matched record %##s (NSEC)&quot;</span>, q-&gt;qname.c,
                DNSTypeName(q-&gt;qtype), rr-&gt;name-&gt;c);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// ResourceRecordAnswersQuestion returns mDNStrue if the given resource record is a valid answer to the given question.
</span><span class="enscript-comment">// SameNameRecordAnswersQuestion is the same, except it skips the expensive SameDomainName() call.
</span><span class="enscript-comment">// SameDomainName() is generally cheap when the names don't match, but expensive when they do match,
</span><span class="enscript-comment">// because it has to check all the way to the end of the names to be sure.
</span><span class="enscript-comment">// In cases where we know in advance that the names match it's especially advantageous to skip the
</span><span class="enscript-comment">// SameDomainName() call because that's precisely the time when it's most expensive and least useful.
</span>
mDNSlocal mDNSBool <span class="enscript-function-name">SameNameRecordAnswersQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSBool isAuthRecord, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    mDNSBool checkType = mDNStrue;

    <span class="enscript-comment">// LocalOnly/P2P questions can be answered with AuthRecordAny in this function. LocalOnly/P2P records
</span>    <span class="enscript-comment">// are handled in LocalOnlyRecordAnswersQuestion
</span>    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(rr-&gt;InterfaceID))
    {
        LogMsg(<span class="enscript-string">&quot;SameNameRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p&quot;</span>, rr-&gt;InterfaceID, q-&gt;InterfaceID);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (q-&gt;Suppressed)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp;
        q-&gt;InterfaceID &amp;&amp; q-&gt;InterfaceID != mDNSInterface_LocalOnly &amp;&amp;
        rr-&gt;InterfaceID != q-&gt;InterfaceID) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// Resource record received via unicast, the resolver group ID should match ?
</span>    <span class="enscript-keyword">if</span> (!isAuthRecord &amp;&amp; !rr-&gt;InterfaceID)
    {
        <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">return</span>(mDNSfalse);
        <span class="enscript-type">const</span> mDNSu32 idr = rr-&gt;rDNSServer ? rr-&gt;rDNSServer-&gt;resGroupID : 0;
        <span class="enscript-type">const</span> mDNSu32 idq = q-&gt;qDNSServer ? q-&gt;qDNSServer-&gt;resGroupID : 0;
        <span class="enscript-keyword">if</span> (idr != idq) <span class="enscript-keyword">return</span>(mDNSfalse);
        <span class="enscript-keyword">if</span> (!DNSSECRecordAnswersQuestion(rr, q, &amp;checkType)) <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// If ResourceRecord received via multicast, but question was unicast, then shouldn't use record to answer this question
</span>    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// CNAME answers question of any type and a negative cache record should not prevent us from querying other
</span>    <span class="enscript-comment">// valid types at the same name.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;rrtype == kDNSType_CNAME &amp;&amp; rr-&gt;RecordType == kDNSRecordTypePacketNegative &amp;&amp; rr-&gt;rrtype != q-&gt;qtype)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// RR type CNAME matches any query type. QTYPE ANY matches any RR type. QCLASS ANY matches any RR class.
</span>    <span class="enscript-keyword">if</span> (checkType &amp;&amp; !RRTypeAnswersQuestionType(rr,q-&gt;qtype)) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">if</span> (rr-&gt;rrclass != q-&gt;qclass &amp;&amp; q-&gt;qclass != kDNSQClass_ANY) <span class="enscript-keyword">return</span>(mDNSfalse);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-keyword">if</span> (!mDNSPlatformValidRecordForQuestion(rr, q))
        <span class="enscript-keyword">return</span> mDNSfalse;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    <span class="enscript-keyword">return</span>(mDNStrue);
}

mDNSexport mDNSBool <span class="enscript-function-name">SameNameCacheRecordAnswersQuestion</span>(<span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> cr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">return</span> SameNameRecordAnswersQuestion(&amp;cr-&gt;resrec, mDNSfalse, q);
}

mDNSlocal mDNSBool <span class="enscript-function-name">RecordAnswersQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSBool isAuthRecord, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">if</span> (!SameNameRecordAnswersQuestion(rr, isAuthRecord, q))
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-keyword">return</span>(rr-&gt;namehash == q-&gt;qnamehash &amp;&amp; SameDomainName(rr-&gt;name, &amp;q-&gt;qname));
}

mDNSexport mDNSBool <span class="enscript-function-name">ResourceRecordAnswersQuestion</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">return</span> RecordAnswersQuestion(rr, mDNSfalse, q);
}

mDNSexport mDNSBool <span class="enscript-function-name">AuthRecordAnswersQuestion</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> ar, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">return</span> RecordAnswersQuestion(&amp;ar-&gt;resrec, mDNStrue, q);
}

mDNSexport mDNSBool <span class="enscript-function-name">CacheRecordAnswersQuestion</span>(<span class="enscript-type">const</span> CacheRecord *<span class="enscript-type">const</span> cr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-keyword">return</span> RecordAnswersQuestion(&amp;cr-&gt;resrec, mDNSfalse, q);
}

<span class="enscript-comment">// We have a separate function to handle LocalOnly AuthRecords because they can be created with
</span><span class="enscript-comment">// a valid InterfaceID (e.g., scoped /etc/hosts) and can be used to answer unicast questions unlike
</span><span class="enscript-comment">// multicast resource records (which has a valid InterfaceID) which can't be used to answer
</span><span class="enscript-comment">// unicast questions. ResourceRecordAnswersQuestion/SameNameRecordAnswersQuestion can't tell whether
</span><span class="enscript-comment">// a resource record is multicast or LocalOnly by just looking at the ResourceRecord because
</span><span class="enscript-comment">// LocalOnly records are truly identified by ARType in the AuthRecord.  As P2P and LocalOnly record
</span><span class="enscript-comment">// are kept in the same hash table, we use the same function to make it easy for the callers when
</span><span class="enscript-comment">// they walk the hash table to answer LocalOnly/P2P questions
</span><span class="enscript-comment">//
</span>mDNSexport mDNSBool <span class="enscript-function-name">LocalOnlyRecordAnswersQuestion</span>(AuthRecord *<span class="enscript-type">const</span> ar, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    ResourceRecord *rr = &amp;ar-&gt;resrec;

    <span class="enscript-comment">// mDNSInterface_Any questions can be answered with LocalOnly/P2P records in this function. AuthRecord_Any
</span>    <span class="enscript-comment">// records are handled in ResourceRecordAnswersQuestion/SameNameRecordAnswersQuestion
</span>    <span class="enscript-keyword">if</span> (RRAny(ar))
    {
        LogMsg(<span class="enscript-string">&quot;LocalOnlyRecordAnswersQuestion: ERROR!! called with regular AuthRecordAny %##s&quot;</span>, rr-&gt;name-&gt;c);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// Questions with mDNSInterface_LocalOnly InterfaceID should be answered with all resource records that are
</span>    <span class="enscript-comment">// *local* to the machine. These include resource records that have InterfaceID set to mDNSInterface_LocalOnly,
</span>    <span class="enscript-comment">// mDNSInterface_Any and any other real InterfaceID. Hence, LocalOnly questions should not be checked against
</span>    <span class="enscript-comment">// the InterfaceID in the resource record.
</span>
    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp;
        q-&gt;InterfaceID != mDNSInterface_LocalOnly &amp;&amp;
        ((q-&gt;InterfaceID &amp;&amp; rr-&gt;InterfaceID != q-&gt;InterfaceID) ||
        (!q-&gt;InterfaceID &amp;&amp; !LocalOnlyOrP2PInterface(rr-&gt;InterfaceID)))) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// Entries in /etc/hosts are added as LocalOnly resource records. The LocalOnly resource records
</span>    <span class="enscript-comment">// may have a scope e.g., fe80::1%en0. The question may be scoped or not: the InterfaceID may be set
</span>    <span class="enscript-comment">// to mDNSInterface_Any, mDNSInterface_LocalOnly or a real InterfaceID (scoped).
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) Question: Any, LocalOnly Record: no scope. This question should be answered with this record.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2) Question: Any, LocalOnly Record: scoped.  This question should be answered with the record because
</span>    <span class="enscript-comment">//    traditionally applications never specify scope e.g., getaddrinfo, but need to be able
</span>    <span class="enscript-comment">//    to get to /etc/hosts entries.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 3) Question: Scoped (LocalOnly or InterfaceID), LocalOnly Record: no scope. This is the inverse of (2).
</span>    <span class="enscript-comment">//    If we register a LocalOnly record, we need to answer a LocalOnly question. If the /etc/hosts has a
</span>    <span class="enscript-comment">//    non scoped entry, it may not make sense to answer a scoped question. But we can't tell these two
</span>    <span class="enscript-comment">//    cases apart. As we currently answer LocalOnly question with LocalOnly record, we continue to do so.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 4) Question: Scoped (LocalOnly or InterfaceID), LocalOnly Record: scoped. LocalOnly questions should be
</span>    <span class="enscript-comment">//    answered with any resource record where as if it has a valid InterfaceID, the scope should match.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// (1) and (2) is bypassed because we check for a non-NULL InterfaceID above. For (3), the InterfaceID is NULL
</span>    <span class="enscript-comment">// and hence bypassed above. For (4) we bypassed LocalOnly questions and checked the scope of the record
</span>    <span class="enscript-comment">// against the question.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// For P2P, InterfaceIDs of the question and the record should match.
</span>
    <span class="enscript-comment">// If ResourceRecord received via multicast, but question was unicast, then shouldn't use record to answer this question.
</span>    <span class="enscript-comment">// LocalOnly authoritative answers are exempt. LocalOnly authoritative answers are used for /etc/host entries.
</span>    <span class="enscript-comment">// We don't want a local process to be able to create a fake LocalOnly address record for &quot;www.bigbank.com&quot; which would then
</span>    <span class="enscript-comment">// cause other applications (e.g. Safari) to connect to the wrong address. The rpc to register records filters out records
</span>    <span class="enscript-comment">// with names that don't end in local and have mDNSInterface_LocalOnly set.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Note: The check is bypassed for LocalOnly and for P2P it is not needed as only .local records are registered and for
</span>    <span class="enscript-comment">// a question to match its names, it also has to end in .local and that question can't be a unicast question (See
</span>    <span class="enscript-comment">// Question_uDNS macro and its usage). As P2P does not enforce .local only registrations we still make this check
</span>    <span class="enscript-comment">// and also makes it future proof.
</span>
    <span class="enscript-keyword">if</span> (ar-&gt;ARType != AuthRecordLocalOnly &amp;&amp; rr-&gt;InterfaceID &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// RR type CNAME matches any query type. QTYPE ANY matches any RR type. QCLASS ANY matches any RR class.
</span>    <span class="enscript-keyword">if</span> (!RRTypeAnswersQuestionType(rr,q-&gt;qtype)) <span class="enscript-keyword">return</span>(mDNSfalse);
    <span class="enscript-keyword">if</span> (rr-&gt;rrclass != q-&gt;qclass &amp;&amp; q-&gt;qclass != kDNSQClass_ANY) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">return</span>(rr-&gt;namehash == q-&gt;qnamehash &amp;&amp; SameDomainName(rr-&gt;name, &amp;q-&gt;qname));
}

mDNSexport mDNSBool <span class="enscript-function-name">AnyTypeRecordAnswersQuestion</span>(<span class="enscript-type">const</span> AuthRecord *<span class="enscript-type">const</span> ar, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr = &amp;ar-&gt;resrec;
    <span class="enscript-comment">// LocalOnly/P2P questions can be answered with AuthRecordAny in this function. LocalOnly/P2P records
</span>    <span class="enscript-comment">// are handled in LocalOnlyRecordAnswersQuestion
</span>    <span class="enscript-keyword">if</span> (LocalOnlyOrP2PInterface(rr-&gt;InterfaceID))
    {
        LogMsg(<span class="enscript-string">&quot;AnyTypeRecordAnswersQuestion: ERROR!! called with LocalOnly ResourceRecord %p, Question %p&quot;</span>, rr-&gt;InterfaceID, q-&gt;InterfaceID);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp;
        q-&gt;InterfaceID &amp;&amp; q-&gt;InterfaceID != mDNSInterface_LocalOnly &amp;&amp;
        rr-&gt;InterfaceID != q-&gt;InterfaceID) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// Resource record received via unicast, the resolver group ID should match ?
</span>    <span class="enscript-comment">// Note that Auth Records are normally setup with NULL InterfaceID and
</span>    <span class="enscript-comment">// both the DNSServers are assumed to be NULL in that case
</span>    <span class="enscript-keyword">if</span> (!rr-&gt;InterfaceID)
    {
        <span class="enscript-type">const</span> mDNSu32 idr = rr-&gt;rDNSServer ? rr-&gt;rDNSServer-&gt;resGroupID : 0;
        <span class="enscript-type">const</span> mDNSu32 idq = q-&gt;qDNSServer ? q-&gt;qDNSServer-&gt;resGroupID : 0;
        <span class="enscript-keyword">if</span> (idr != idq) <span class="enscript-keyword">return</span>(mDNSfalse);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">RANDOM_AWDL_HOSTNAME</span>)
        <span class="enscript-keyword">if</span> (!mDNSPlatformValidRecordForInterface(ar, q-&gt;InterfaceID)) <span class="enscript-keyword">return</span>(mDNSfalse);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-comment">// If ResourceRecord received via multicast, but question was unicast, then shouldn't use record to answer this question
</span>    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">if</span> (rr-&gt;rrclass != q-&gt;qclass &amp;&amp; q-&gt;qclass != kDNSQClass_ANY) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">return</span>(rr-&gt;namehash == q-&gt;qnamehash &amp;&amp; SameDomainName(rr-&gt;name, &amp;q-&gt;qname));
}

<span class="enscript-comment">// This is called with both unicast resource record and multicast resource record. The question that
</span><span class="enscript-comment">// received the unicast response could be the regular unicast response from a DNS server or a response
</span><span class="enscript-comment">// to a mDNS QU query. The main reason we need this function is that we can't compare DNSServers between the
</span><span class="enscript-comment">// question and the resource record because the resource record is not completely initialized in
</span><span class="enscript-comment">// mDNSCoreReceiveResponse when this function is called.
</span>mDNSexport mDNSBool <span class="enscript-function-name">ResourceRecordAnswersUnicastResponse</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, <span class="enscript-type">const</span> DNSQuestion *<span class="enscript-type">const</span> q)
{
    mDNSBool checkType = mDNStrue;

    <span class="enscript-keyword">if</span> (q-&gt;Suppressed)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// For resource records created using multicast, the InterfaceIDs have to match
</span>    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp;
        q-&gt;InterfaceID &amp;&amp; rr-&gt;InterfaceID != q-&gt;InterfaceID) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-comment">// If ResourceRecord received via multicast, but question was unicast, then shouldn't use record to answer this question.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;InterfaceID &amp;&amp; !mDNSOpaque16IsZero(q-&gt;TargetQID)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">if</span> (!DNSSECRecordAnswersQuestion(rr, q, &amp;checkType)) <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// RR type CNAME matches any query type. QTYPE ANY matches any RR type. QCLASS ANY matches any RR class.
</span>    <span class="enscript-keyword">if</span> (checkType &amp;&amp; !RRTypeAnswersQuestionType(rr,q-&gt;qtype)) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">if</span> (rr-&gt;rrclass != q-&gt;qclass &amp;&amp; q-&gt;qclass != kDNSQClass_ANY) <span class="enscript-keyword">return</span>(mDNSfalse);

    <span class="enscript-keyword">return</span>(rr-&gt;namehash == q-&gt;qnamehash &amp;&amp; SameDomainName(rr-&gt;name, &amp;q-&gt;qname));
}

mDNSexport mDNSu16 <span class="enscript-function-name">GetRDLength</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mDNSBool estimate)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rd = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
    <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name = estimate ? rr-&gt;name : mDNSNULL;
    <span class="enscript-keyword">if</span> (rr-&gt;rrclass == kDNSQClass_ANY) <span class="enscript-keyword">return</span>(rr-&gt;rdlength);    <span class="enscript-comment">// Used in update packets to mean &quot;Delete An RRset&quot; (RFC 2136)
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">switch</span> (rr-&gt;rrtype)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:    <span class="enscript-keyword">return</span>(<span class="enscript-keyword">sizeof</span>(rd-&gt;ipv4));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>: <span class="enscript-keyword">return</span>(CompressedDomainNameLength(&amp;rd-&gt;name, name));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:  <span class="enscript-keyword">return</span> (mDNSu16)(CompressedDomainNameLength(&amp;rd-&gt;soa.mname, name) +
                                             CompressedDomainNameLength(&amp;rd-&gt;soa.rname, name) +
                                             5 * <span class="enscript-keyword">sizeof</span>(mDNSOpaque32));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NULL</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_X25</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_ISDN</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_LOC</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DHCID</span>: <span class="enscript-keyword">return</span>(rr-&gt;rdlength); <span class="enscript-comment">// Not self-describing, so have to just trust rdlength
</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>: <span class="enscript-keyword">return</span> (mDNSu16)(2 + (<span class="enscript-type">int</span>)rd-&gt;data[0] + (<span class="enscript-type">int</span>)rd-&gt;data[1 + (<span class="enscript-type">int</span>)rd-&gt;data[0]]);

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:   <span class="enscript-keyword">return</span> (mDNSu16)(2 + CompressedDomainNameLength(&amp;rd-&gt;mx.exchange, name));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:   <span class="enscript-keyword">return</span> (mDNSu16)(CompressedDomainNameLength(&amp;rd-&gt;rp.mbox, name) +
                                             CompressedDomainNameLength(&amp;rd-&gt;rp.txt, name));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:   <span class="enscript-keyword">return</span> (mDNSu16)(2 + CompressedDomainNameLength(&amp;rd-&gt;px.map822, name) +
                                             CompressedDomainNameLength(&amp;rd-&gt;px.mapx400, name));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>: <span class="enscript-keyword">return</span>(<span class="enscript-keyword">sizeof</span>(rd-&gt;ipv6));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:  <span class="enscript-keyword">return</span> (mDNSu16)(6 + CompressedDomainNameLength(&amp;rd-&gt;srv.target, name));

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  <span class="enscript-keyword">return</span>(rr-&gt;rdlength);

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
            domainname *next = (domainname *)rd-&gt;data;
            <span class="enscript-type">int</span> dlen = DomainNameLength(next);
            <span class="enscript-comment">//
</span>            <span class="enscript-keyword">if</span> (UNICAST_NSEC(rr))
                <span class="enscript-keyword">return</span> (mDNSu16)(CompressedDomainNameLength(next, name) + rr-&gt;rdlength - dlen);
            <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">return</span> (mDNSu16)((estimate ? 2 : dlen) + rr-&gt;rdlength - dlen);
        }

        <span class="enscript-reference">default</span>:            debugf(<span class="enscript-string">&quot;Warning! Don't know how to get length of resource type %d&quot;</span>, rr-&gt;rrtype);
            <span class="enscript-keyword">return</span>(rr-&gt;rdlength);
        }
}

<span class="enscript-comment">// When a local client registers (or updates) a record, we use this routine to do some simple validation checks
</span><span class="enscript-comment">// to help reduce the risk of bogus malformed data on the network
</span>mDNSexport mDNSBool <span class="enscript-function-name">ValidateRData</span>(<span class="enscript-type">const</span> mDNSu16 rrtype, <span class="enscript-type">const</span> mDNSu16 rdlength, <span class="enscript-type">const</span> RData *<span class="enscript-type">const</span> rd)
{
    mDNSu16 len;

    <span class="enscript-keyword">switch</span>(rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:    <span class="enscript-keyword">return</span>(rdlength == <span class="enscript-keyword">sizeof</span>(mDNSv4Addr));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:    <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-comment">//case kDNSType_SOA not checked
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:       <span class="enscript-comment">// Same as PTR
</span>    <span class="enscript-comment">//case kDNSType_NULL not checked (no specified format, so always valid)
</span>    <span class="enscript-comment">//case kDNSType_WKS not checked
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:  len = DomainNameLengthLimit(&amp;rd-&gt;u.name, rd-&gt;u.data + rdlength);
        <span class="enscript-keyword">return</span>(len &lt;= MAX_DOMAIN_NAME &amp;&amp; rdlength == len);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>:    <span class="enscript-comment">// Same as TXT (roughly)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:    <span class="enscript-comment">// Same as TXT (roughly)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:  <span class="enscript-keyword">if</span> (!rdlength) <span class="enscript-keyword">return</span>(mDNSfalse);     <span class="enscript-comment">// TXT record has to be at least one byte (RFC 1035)
</span>        {
            <span class="enscript-type">const</span> mDNSu8 *ptr = rd-&gt;u.txt.c;
            <span class="enscript-type">const</span> mDNSu8 *end = rd-&gt;u.txt.c + rdlength;
            <span class="enscript-keyword">while</span> (ptr &lt; end) ptr += 1 + ptr[0];
            <span class="enscript-keyword">return</span> (ptr == end);
        }

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>: <span class="enscript-keyword">return</span>(rdlength == <span class="enscript-keyword">sizeof</span>(mDNSv6Addr));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:       <span class="enscript-comment">// Must be at least two-byte preference, plus domainname
</span>                            <span class="enscript-comment">// Call to DomainNameLengthLimit() implicitly enforces both requirements for us
</span>        len = DomainNameLengthLimit(&amp;rd-&gt;u.mx.exchange, rd-&gt;u.data + rdlength);
        <span class="enscript-keyword">return</span>(len &lt;= MAX_DOMAIN_NAME &amp;&amp; rdlength == 2+len);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:      <span class="enscript-comment">// Must be at least priority+weight+port, plus domainname
</span>                            <span class="enscript-comment">// Call to DomainNameLengthLimit() implicitly enforces both requirements for us
</span>        len = DomainNameLengthLimit(&amp;rd-&gt;u.srv.target, rd-&gt;u.data + rdlength);
        <span class="enscript-keyword">return</span>(len &lt;= MAX_DOMAIN_NAME &amp;&amp; rdlength == 6+len);

    <span class="enscript-comment">//case kDNSType_NSEC not checked
</span>
    <span class="enscript-reference">default</span>:            <span class="enscript-keyword">return</span>(mDNStrue);       <span class="enscript-comment">// Allow all other types without checking
</span>    }
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">Message</span> <span class="enscript-variable-name">Creation</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">InitializeDNSMessage</span>(DNSMessageHeader *h, mDNSOpaque16 id, mDNSOpaque16 flags)
{
    h-&gt;id             = id;
    h-&gt;flags          = flags;
    h-&gt;numQuestions   = 0;
    h-&gt;numAnswers     = 0;
    h-&gt;numAuthorities = 0;
    h-&gt;numAdditionals = 0;
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">FindCompressionPointer</span>(<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> base, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> domname)
{
    <span class="enscript-type">const</span> mDNSu8 *result = end - *domname - 1;

    <span class="enscript-keyword">if</span> (*domname == 0) <span class="enscript-keyword">return</span>(mDNSNULL);    <span class="enscript-comment">// There's no point trying to match just the root label
</span>
    <span class="enscript-comment">// This loop examines each possible starting position in packet, starting end of the packet and working backwards
</span>    <span class="enscript-keyword">while</span> (result &gt;= base)
    {
        <span class="enscript-comment">// If the length byte and first character of the label match, then check further to see
</span>        <span class="enscript-comment">// if this location in the packet will yield a useful name compression pointer.
</span>        <span class="enscript-keyword">if</span> (result[0] == domname[0] &amp;&amp; result[1] == domname[1])
        {
            <span class="enscript-type">const</span> mDNSu8 *name = domname;
            <span class="enscript-type">const</span> mDNSu8 *targ = result;
            <span class="enscript-keyword">while</span> (targ + *name &lt; end)
            {
                <span class="enscript-comment">// First see if this label matches
</span>                <span class="enscript-type">int</span> i;
                <span class="enscript-type">const</span> mDNSu8 *pointertarget;
                <span class="enscript-keyword">for</span> (i=0; i &lt;= *name; i++) <span class="enscript-keyword">if</span> (targ[i] != name[i]) <span class="enscript-keyword">break</span>;
                <span class="enscript-keyword">if</span> (i &lt;= *name) <span class="enscript-keyword">break</span>;                          <span class="enscript-comment">// If label did not match, bail out
</span>                targ += 1 + *name;                              <span class="enscript-comment">// Else, did match, so advance target pointer
</span>                name += 1 + *name;                              <span class="enscript-comment">// and proceed to check next label
</span>                <span class="enscript-keyword">if</span> (*name == 0 &amp;&amp; *targ == 0) <span class="enscript-keyword">return</span>(result);   <span class="enscript-comment">// If no more labels, we found a match!
</span>                <span class="enscript-keyword">if</span> (*name == 0) <span class="enscript-keyword">break</span>;                          <span class="enscript-comment">// If no more labels to match, we failed, so bail out
</span>
                <span class="enscript-comment">// The label matched, so now follow the pointer (if appropriate) and then see if the next label matches
</span>                <span class="enscript-keyword">if</span> (targ[0] &lt; 0x40) <span class="enscript-keyword">continue</span>;                   <span class="enscript-comment">// If length value, continue to check next label
</span>                <span class="enscript-keyword">if</span> (targ[0] &lt; 0xC0) <span class="enscript-keyword">break</span>;                      <span class="enscript-comment">// If 40-BF, not valid
</span>                <span class="enscript-keyword">if</span> (targ+1 &gt;= end) <span class="enscript-keyword">break</span>;                       <span class="enscript-comment">// Second byte not present!
</span>                pointertarget = base + (((mDNSu16)(targ[0] &amp; 0x3F)) &lt;&lt; 8) + targ[1];
                <span class="enscript-keyword">if</span> (targ &lt; pointertarget) <span class="enscript-keyword">break</span>;                <span class="enscript-comment">// Pointertarget must point *backwards* in the packet
</span>                <span class="enscript-keyword">if</span> (pointertarget[0] &gt;= 0x40) <span class="enscript-keyword">break</span>;            <span class="enscript-comment">// Pointertarget must point to a valid length byte
</span>                targ = pointertarget;
            }
        }
        result--;   <span class="enscript-comment">// We failed to match at this search position, so back up the tentative result pointer and try again
</span>    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// domainname is a fully-qualified name (i.e. assumed to be ending in a dot, even if it doesn't)
</span><span class="enscript-comment">// msg points to the message we're building (pass mDNSNULL if we don't want to use compression pointers)
</span><span class="enscript-comment">// end points to the end of the message so far
</span><span class="enscript-comment">// ptr points to where we want to put the name
</span><span class="enscript-comment">// limit points to one byte past the end of the buffer that we must not overrun
</span><span class="enscript-comment">// domainname is the name to put
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putDomainNameAsLabels</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg,
                                         mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> base        = (<span class="enscript-type">const</span> mDNSu8 *)msg;
    <span class="enscript-type">const</span> mDNSu8 *      np          = name-&gt;c;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> max         = name-&gt;c + MAX_DOMAIN_NAME;    <span class="enscript-comment">// Maximum that's valid
</span>    <span class="enscript-type">const</span> mDNSu8 *      pointer     = mDNSNULL;
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> searchlimit = ptr;

    <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;putDomainNameAsLabels %##s ptr is null&quot;</span>, name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }

    <span class="enscript-keyword">if</span> (!*np)       <span class="enscript-comment">// If just writing one-byte root label, make sure we have space for that
</span>    {
        <span class="enscript-keyword">if</span> (ptr &gt;= limit) <span class="enscript-keyword">return</span>(mDNSNULL);
    }
    <span class="enscript-keyword">else</span>            <span class="enscript-comment">// else, loop through writing labels and/or a compression offset
</span>    {
        <span class="enscript-keyword">do</span>  {
            <span class="enscript-keyword">if</span> (*np &gt; MAX_DOMAIN_LABEL)
            { LogMsg(<span class="enscript-string">&quot;Malformed domain name %##s (label more than 63 bytes)&quot;</span>, name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }

            <span class="enscript-comment">// This check correctly allows for the final trailing root label:
</span>            <span class="enscript-comment">// e.g.
</span>            <span class="enscript-comment">// Suppose our domain name is exactly 256 bytes long, including the final trailing root label.
</span>            <span class="enscript-comment">// Suppose np is now at name-&gt;c[249], and we're about to write our last non-null label (&quot;local&quot;).
</span>            <span class="enscript-comment">// We know that max will be at name-&gt;c[256]
</span>            <span class="enscript-comment">// That means that np + 1 + 5 == max - 1, so we (just) pass the &quot;if&quot; test below, write our
</span>            <span class="enscript-comment">// six bytes, then exit the loop, write the final terminating root label, and the domain
</span>            <span class="enscript-comment">// name we've written is exactly 256 bytes long, exactly at the correct legal limit.
</span>            <span class="enscript-comment">// If the name is one byte longer, then we fail the &quot;if&quot; test below, and correctly bail out.
</span>            <span class="enscript-keyword">if</span> (np + 1 + *np &gt;= max)
            { LogMsg(<span class="enscript-string">&quot;Malformed domain name %##s (more than 256 bytes)&quot;</span>, name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }

            <span class="enscript-keyword">if</span> (base) pointer = FindCompressionPointer(base, searchlimit, np);
            <span class="enscript-keyword">if</span> (pointer)                    <span class="enscript-comment">// Use a compression pointer if we can
</span>            {
                <span class="enscript-type">const</span> mDNSu16 offset = (mDNSu16)(pointer - base);
                <span class="enscript-keyword">if</span> (ptr+2 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);    <span class="enscript-comment">// If we don't have two bytes of space left, give up
</span>                *ptr++ = (mDNSu8)(0xC0 | (offset &gt;&gt; 8));
                *ptr++ = (mDNSu8)(        offset &amp;  0xFF);
                <span class="enscript-keyword">return</span>(ptr);
            }
            <span class="enscript-keyword">else</span>                            <span class="enscript-comment">// Else copy one label and try again
</span>            {
                <span class="enscript-type">int</span> i;
                mDNSu8 len = *np++;
                <span class="enscript-comment">// If we don't at least have enough space for this label *plus* a terminating zero on the end, give up
</span>                <span class="enscript-keyword">if</span> (ptr + 1 + len &gt;= limit) <span class="enscript-keyword">return</span>(mDNSNULL);
                *ptr++ = len;
                <span class="enscript-keyword">for</span> (i=0; i&lt;len; i++) *ptr++ = *np++;
            }
        } <span class="enscript-keyword">while</span> (*np);                      <span class="enscript-comment">// While we've got characters remaining in the name, continue
</span>    }

    *ptr++ = 0;     <span class="enscript-comment">// Put the final root label
</span>    <span class="enscript-keyword">return</span>(ptr);
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">putVal16</span>(mDNSu8 *ptr, mDNSu16 val)
{
    ptr[0] = (mDNSu8)((val &gt;&gt; 8 ) &amp; 0xFF);
    ptr[1] = (mDNSu8)((val      ) &amp; 0xFF);
    <span class="enscript-keyword">return</span> ptr + <span class="enscript-keyword">sizeof</span>(mDNSOpaque16);
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">putVal32</span>(mDNSu8 *ptr, mDNSu32 val)
{
    ptr[0] = (mDNSu8)((val &gt;&gt; 24) &amp; 0xFF);
    ptr[1] = (mDNSu8)((val &gt;&gt; 16) &amp; 0xFF);
    ptr[2] = (mDNSu8)((val &gt;&gt;  8) &amp; 0xFF);
    ptr[3] = (mDNSu8)((val      ) &amp; 0xFF);
    <span class="enscript-keyword">return</span> ptr + <span class="enscript-keyword">sizeof</span>(mDNSu32);
}

<span class="enscript-comment">// Copy the RDATA information. The actual in memory storage for the data might be bigger than what the rdlength
</span><span class="enscript-comment">// says. Hence, the only way to copy out the data from a resource record is to use putRData.
</span><span class="enscript-comment">// msg points to the message we're building (pass mDNSNULL for &quot;msg&quot; if we don't want to use compression pointers)
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putRData</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;rdata-&gt;u.data;
    <span class="enscript-keyword">switch</span> (rr-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:    <span class="enscript-keyword">if</span> (rr-&gt;rdlength != 4)
        { debugf(<span class="enscript-string">&quot;putRData: Illegal length %d for kDNSType_A&quot;</span>, rr-&gt;rdlength); <span class="enscript-keyword">return</span>(mDNSNULL); }
        <span class="enscript-keyword">if</span> (ptr + 4 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        *ptr++ = rdb-&gt;ipv4.b[0];
        *ptr++ = rdb-&gt;ipv4.b[1];
        *ptr++ = rdb-&gt;ipv4.b[2];
        *ptr++ = rdb-&gt;ipv4.b[3];
        <span class="enscript-keyword">return</span>(ptr);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>: <span class="enscript-keyword">return</span>(putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;name));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:  ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;soa.mname);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;soa.rname);
        <span class="enscript-keyword">if</span> (!ptr || ptr + 20 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putVal32(ptr, rdb-&gt;soa.serial);
        ptr = putVal32(ptr, rdb-&gt;soa.refresh);
        ptr = putVal32(ptr, rdb-&gt;soa.retry);
        ptr = putVal32(ptr, rdb-&gt;soa.expire);
        ptr = putVal32(ptr, rdb-&gt;soa.min);
        <span class="enscript-keyword">return</span>(ptr);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NULL</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_X25</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_ISDN</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_LOC</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DHCID</span>: <span class="enscript-keyword">if</span> (ptr + rr-&gt;rdlength &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        mDNSPlatformMemCopy(ptr, rdb-&gt;data, rr-&gt;rdlength);
        <span class="enscript-keyword">return</span>(ptr + rr-&gt;rdlength);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:   <span class="enscript-keyword">if</span> (ptr + 3 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putVal16(ptr, rdb-&gt;mx.preference);
        <span class="enscript-keyword">return</span>(putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;mx.exchange));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:   ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;rp.mbox);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;rp.txt);
        <span class="enscript-keyword">return</span>(ptr);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:   <span class="enscript-keyword">if</span> (ptr + 5 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putVal16(ptr, rdb-&gt;px.preference);
        ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;px.map822);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">return</span>(mDNSNULL);
        ptr = putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;px.mapx400);
        <span class="enscript-keyword">return</span>(ptr);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>: <span class="enscript-keyword">if</span> (rr-&gt;rdlength != <span class="enscript-keyword">sizeof</span>(rdb-&gt;ipv6))
        { debugf(<span class="enscript-string">&quot;putRData: Illegal length %d for kDNSType_AAAA&quot;</span>, rr-&gt;rdlength); <span class="enscript-keyword">return</span>(mDNSNULL); }
        <span class="enscript-keyword">if</span> (ptr + <span class="enscript-keyword">sizeof</span>(rdb-&gt;ipv6) &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        mDNSPlatformMemCopy(ptr, &amp;rdb-&gt;ipv6, <span class="enscript-keyword">sizeof</span>(rdb-&gt;ipv6));
        <span class="enscript-keyword">return</span>(ptr + <span class="enscript-keyword">sizeof</span>(rdb-&gt;ipv6));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:  <span class="enscript-keyword">if</span> (ptr + 7 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        *ptr++ = (mDNSu8)(rdb-&gt;srv.priority &gt;&gt; 8);
        *ptr++ = (mDNSu8)(rdb-&gt;srv.priority &amp;  0xFF);
        *ptr++ = (mDNSu8)(rdb-&gt;srv.weight   &gt;&gt; 8);
        *ptr++ = (mDNSu8)(rdb-&gt;srv.weight   &amp;  0xFF);
        *ptr++ = rdb-&gt;srv.port.b[0];
        *ptr++ = rdb-&gt;srv.port.b[1];
        <span class="enscript-keyword">return</span>(putDomainNameAsLabels(msg, ptr, limit, &amp;rdb-&gt;srv.target));

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  {
        <span class="enscript-type">int</span> len = 0;
        <span class="enscript-type">const</span> rdataOPT *opt;
        <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> end = (<span class="enscript-type">const</span> rdataOPT *)&amp;rr-&gt;rdata-&gt;u.data[rr-&gt;rdlength];
        <span class="enscript-keyword">for</span> (opt = &amp;rr-&gt;rdata-&gt;u.opt[0]; opt &lt; end; opt++) 
            len += DNSOpt_Data_Space(opt);
        <span class="enscript-keyword">if</span> (ptr + len &gt; limit) 
        { 
            LogMsg(<span class="enscript-string">&quot;ERROR: putOptRData - out of space&quot;</span>); 
            <span class="enscript-keyword">return</span> mDNSNULL; 
        }
        <span class="enscript-keyword">for</span> (opt = &amp;rr-&gt;rdata-&gt;u.opt[0]; opt &lt; end; opt++)
        {
            <span class="enscript-type">const</span> <span class="enscript-type">int</span> space = DNSOpt_Data_Space(opt);
            ptr = putVal16(ptr, opt-&gt;opt);
            ptr = putVal16(ptr, (mDNSu16)space - 4);
            <span class="enscript-keyword">switch</span> (opt-&gt;opt)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_LLQ</span>:
                ptr = putVal16(ptr, opt-&gt;u.llq.vers);
                ptr = putVal16(ptr, opt-&gt;u.llq.llqOp);
                ptr = putVal16(ptr, opt-&gt;u.llq.err);
                mDNSPlatformMemCopy(ptr, opt-&gt;u.llq.id.b, 8);                          <span class="enscript-comment">// 8-byte id
</span>                ptr += 8;
                ptr = putVal32(ptr, opt-&gt;u.llq.llqlease);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Lease</span>:
                ptr = putVal32(ptr, opt-&gt;u.updatelease);
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Owner</span>:
                *ptr++ = opt-&gt;u.owner.vers;
                *ptr++ = opt-&gt;u.owner.seq;
                mDNSPlatformMemCopy(ptr, opt-&gt;u.owner.HMAC.b, 6);                          <span class="enscript-comment">// 6-byte Host identifier
</span>                ptr += 6;
                <span class="enscript-keyword">if</span> (space &gt;= DNSOpt_OwnerData_ID_Wake_Space)
                {
                    mDNSPlatformMemCopy(ptr, opt-&gt;u.owner.IMAC.b, 6);                           <span class="enscript-comment">// 6-byte interface MAC
</span>                    ptr += 6;
                    <span class="enscript-keyword">if</span> (space &gt; DNSOpt_OwnerData_ID_Wake_Space)
                    {
                        mDNSPlatformMemCopy(ptr, opt-&gt;u.owner.password.b, space - DNSOpt_OwnerData_ID_Wake_Space);
                        ptr += space - DNSOpt_OwnerData_ID_Wake_Space;
                    }
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Trace</span>:
                *ptr++ = opt-&gt;u.tracer.platf;
                ptr    = putVal32(ptr, opt-&gt;u.tracer.mDNSv);
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">return</span> ptr;
    }

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
        <span class="enscript-comment">// For NSEC records, rdlength represents the exact number of bytes
</span>        <span class="enscript-comment">// of in memory storage.
</span>        mDNSu8 *nsec = (mDNSu8 *)rdb-&gt;data;
        domainname *name = (domainname *)nsec;
        <span class="enscript-type">const</span> <span class="enscript-type">int</span> dlen = DomainNameLength(name);
        nsec += dlen;
        <span class="enscript-comment">// This function is called when we are sending a NSEC record as part of mDNS,
</span>        <span class="enscript-comment">// or to copy the data to any other buffer needed which could be a mDNS or uDNS
</span>        <span class="enscript-comment">// NSEC record. The only time compression is used that when we are sending it
</span>        <span class="enscript-comment">// in mDNS (indicated by non-NULL &quot;msg&quot;) and hence we handle mDNS case
</span>        <span class="enscript-comment">// separately.
</span>        <span class="enscript-keyword">if</span> (!UNICAST_NSEC(rr))
        {
            mDNSu8 *save = ptr;
            <span class="enscript-type">int</span> i, j, wlen;
            wlen = *(nsec + 1);
            nsec += 2;                     <span class="enscript-comment">// Skip the window number and len
</span>
            <span class="enscript-comment">// For our simplified use of NSEC synthetic records:
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// nextname is always the record's own name,
</span>            <span class="enscript-comment">// the block number is always 0,
</span>            <span class="enscript-comment">// the count byte is a value in the range 1-32,
</span>            <span class="enscript-comment">// followed by the 1-32 data bytes
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Note: When we send the NSEC record in mDNS, the window size is set to 32.
</span>            <span class="enscript-comment">// We need to find out what the last non-NULL byte is.  If we are copying out
</span>            <span class="enscript-comment">// from an RDATA, we have the right length. As we need to handle both the case,
</span>            <span class="enscript-comment">// we loop to find the right value instead of blindly using len to copy.
</span>
            <span class="enscript-keyword">for</span> (i=wlen; i&gt;0; i--) <span class="enscript-keyword">if</span> (nsec[i-1]) <span class="enscript-keyword">break</span>;

            ptr = putDomainNameAsLabels(msg, ptr, limit, rr-&gt;name);
            <span class="enscript-keyword">if</span> (!ptr) { LogInfo(<span class="enscript-string">&quot;putRData: Can't put name, Length %d, record %##s&quot;</span>, limit - save, rr-&gt;name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }
            <span class="enscript-keyword">if</span> (i)                          <span class="enscript-comment">// Only put a block if at least one type exists for this name
</span>            {
                <span class="enscript-keyword">if</span> (ptr + 2 + i &gt; limit) { LogInfo(<span class="enscript-string">&quot;putRData: Can't put window, Length %d, i %d, record %##s&quot;</span>, limit - ptr, i, rr-&gt;name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL); }
                *ptr++ = 0;
                *ptr++ = (mDNSu8)i;
                <span class="enscript-keyword">for</span> (j=0; j&lt;i; j++) *ptr++ = nsec[j];
            }
            <span class="enscript-keyword">return</span> ptr;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-type">int</span> win, wlen;
            <span class="enscript-type">int</span> len = rr-&gt;rdlength - dlen;

            <span class="enscript-comment">// Sanity check whether the bitmap is good
</span>            <span class="enscript-keyword">while</span> (len)
            {
                <span class="enscript-keyword">if</span> (len &lt; 3)
                { LogMsg(<span class="enscript-string">&quot;putRData: invalid length %d&quot;</span>, len); <span class="enscript-keyword">return</span> mDNSNULL; }

                win = *nsec++;
                wlen = *nsec++;
                len -= 2;
                <span class="enscript-keyword">if</span> (len &lt; wlen || wlen &lt; 1 || wlen &gt; 32)
                { LogMsg(<span class="enscript-string">&quot;putRData: invalid window length %d&quot;</span>, wlen); <span class="enscript-keyword">return</span> mDNSNULL; }
                <span class="enscript-keyword">if</span> (win &lt; 0 || win &gt;= 256)
                { LogMsg(<span class="enscript-string">&quot;putRData: invalid window %d&quot;</span>, win); <span class="enscript-keyword">return</span> mDNSNULL; }

                nsec += wlen;
                len -= wlen;
            }
            <span class="enscript-keyword">if</span> (ptr + rr-&gt;rdlength &gt; limit) { LogMsg(<span class="enscript-string">&quot;putRData: NSEC rdlength beyond limit %##s (%s), ptr %p, rdlength %d, limit %p&quot;</span>, rr-&gt;name-&gt;c, DNSTypeName(rr-&gt;rrtype), ptr, rr-&gt;rdlength, limit); <span class="enscript-keyword">return</span>(mDNSNULL);}

            <span class="enscript-comment">// No compression allowed for &quot;nxt&quot;, just copy the data.
</span>            mDNSPlatformMemCopy(ptr, rdb-&gt;data, rr-&gt;rdlength);
            <span class="enscript-keyword">return</span>(ptr + rr-&gt;rdlength);
        }
    }

    <span class="enscript-reference">default</span>:            debugf(<span class="enscript-string">&quot;putRData: Warning! Writing unknown resource type %d as raw data&quot;</span>, rr-&gt;rrtype);
        <span class="enscript-keyword">if</span> (ptr + rr-&gt;rdlength &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);
        mDNSPlatformMemCopy(ptr, rdb-&gt;data, rr-&gt;rdlength);
        <span class="enscript-keyword">return</span>(ptr + rr-&gt;rdlength);
    }
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IsUnicastUpdate</span>(X) (!mDNSOpaque16IsZero((X)-&gt;h.id) &amp;&amp; ((X)-&gt;h.flags.b[0] &amp; kDNSFlag0_OP_Mask) == kDNSFlag0_OP_Update)

mDNSexport mDNSu8 *<span class="enscript-function-name">PutResourceRecordTTLWithLimit</span>(DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, mDNSu16 *count, ResourceRecord *rr, mDNSu32 ttl, <span class="enscript-type">const</span> mDNSu8 *limit)
{
    mDNSu8 *endofrdata;
    mDNSu16 actualLength;
    <span class="enscript-comment">// When sending SRV to conventional DNS server (i.e. in DNS update requests) we should not do name compression on the rdata (RFC 2782)
</span>    <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> rdatacompressionbase = (IsUnicastUpdate(msg) &amp;&amp; rr-&gt;rrtype == kDNSType_SRV) ? mDNSNULL : msg;

    <span class="enscript-keyword">if</span> (rr-&gt;RecordType == kDNSRecordTypeUnregistered)
    {
        LogMsg(<span class="enscript-string">&quot;PutResourceRecordTTLWithLimit ERROR! Attempt to put kDNSRecordTypeUnregistered %##s (%s)&quot;</span>, rr-&gt;name-&gt;c, DNSTypeName(rr-&gt;rrtype));
        <span class="enscript-keyword">return</span>(ptr);
    }

    <span class="enscript-keyword">if</span> (!ptr)
    {
        LogMsg(<span class="enscript-string">&quot;PutResourceRecordTTLWithLimit ptr is null %##s (%s)&quot;</span>, rr-&gt;name-&gt;c, DNSTypeName(rr-&gt;rrtype));
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }

    ptr = putDomainNameAsLabels(msg, ptr, limit, rr-&gt;name);
    <span class="enscript-comment">// If we're out-of-space, return mDNSNULL
</span>    <span class="enscript-keyword">if</span> (!ptr || ptr + 10 &gt;= limit)
    {
        LogInfo(<span class="enscript-string">&quot;PutResourceRecordTTLWithLimit: can't put name, out of space %##s (%s), ptr %p, limit %p&quot;</span>, rr-&gt;name-&gt;c,
            DNSTypeName(rr-&gt;rrtype), ptr, limit);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }
    ptr[0] = (mDNSu8)(rr-&gt;rrtype  &gt;&gt; 8);
    ptr[1] = (mDNSu8)(rr-&gt;rrtype  &amp;  0xFF);
    ptr[2] = (mDNSu8)(rr-&gt;rrclass &gt;&gt; 8);
    ptr[3] = (mDNSu8)(rr-&gt;rrclass &amp;  0xFF);
    ptr[4] = (mDNSu8)((ttl &gt;&gt; 24) &amp;  0xFF);
    ptr[5] = (mDNSu8)((ttl &gt;&gt; 16) &amp;  0xFF);
    ptr[6] = (mDNSu8)((ttl &gt;&gt;  8) &amp;  0xFF);
    ptr[7] = (mDNSu8)( ttl        &amp;  0xFF);
    <span class="enscript-comment">// ptr[8] and ptr[9] filled in *after* we find out how much space the rdata takes
</span>
    endofrdata = putRData(rdatacompressionbase, ptr+10, limit, rr);
    <span class="enscript-keyword">if</span> (!endofrdata)
    {
        LogInfo(<span class="enscript-string">&quot;PutResourceRecordTTLWithLimit: Ran out of space in PutResourceRecord for %##s (%s), ptr %p, limit %p&quot;</span>, rr-&gt;name-&gt;c,
            DNSTypeName(rr-&gt;rrtype), ptr+10, limit);
        <span class="enscript-keyword">return</span>(mDNSNULL);
    }

    <span class="enscript-comment">// Go back and fill in the actual number of data bytes we wrote
</span>    <span class="enscript-comment">// (actualLength can be less than rdlength when domain name compression is used)
</span>    actualLength = (mDNSu16)(endofrdata - ptr - 10);
    ptr[8] = (mDNSu8)(actualLength &gt;&gt; 8);
    ptr[9] = (mDNSu8)(actualLength &amp;  0xFF);

    <span class="enscript-keyword">if</span> (count) (*count)++;
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;PutResourceRecordTTL: ERROR: No target count to update for %##s (%s)&quot;</span>, rr-&gt;name-&gt;c, DNSTypeName(rr-&gt;rrtype));
    <span class="enscript-keyword">return</span>(endofrdata);
}

mDNSlocal mDNSu8 *<span class="enscript-function-name">putEmptyResourceRecord</span>(DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit, mDNSu16 *count, <span class="enscript-type">const</span> AuthRecord *rr)
{
    ptr = putDomainNameAsLabels(msg, ptr, limit, rr-&gt;resrec.name);
    <span class="enscript-keyword">if</span> (!ptr || ptr + 10 &gt; limit) <span class="enscript-keyword">return</span>(mDNSNULL);     <span class="enscript-comment">// If we're out-of-space, return mDNSNULL
</span>    ptr[0] = (mDNSu8)(rr-&gt;resrec.rrtype  &gt;&gt; 8);             <span class="enscript-comment">// Put type
</span>    ptr[1] = (mDNSu8)(rr-&gt;resrec.rrtype  &amp;  0xFF);
    ptr[2] = (mDNSu8)(rr-&gt;resrec.rrclass &gt;&gt; 8);             <span class="enscript-comment">// Put class
</span>    ptr[3] = (mDNSu8)(rr-&gt;resrec.rrclass &amp;  0xFF);
    ptr[4] = ptr[5] = ptr[6] = ptr[7] = 0;              <span class="enscript-comment">// TTL is zero
</span>    ptr[8] = ptr[9] = 0;                                <span class="enscript-comment">// RDATA length is zero
</span>    (*count)++;
    <span class="enscript-keyword">return</span>(ptr + 10);
}

mDNSexport mDNSu8 *<span class="enscript-function-name">putQuestion</span>(DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, mDNSu16 rrtype, mDNSu16 rrclass)
{
    ptr = putDomainNameAsLabels(msg, ptr, limit, name);
    <span class="enscript-keyword">if</span> (!ptr || ptr+4 &gt;= limit) <span class="enscript-keyword">return</span>(mDNSNULL);           <span class="enscript-comment">// If we're out-of-space, return mDNSNULL
</span>    ptr[0] = (mDNSu8)(rrtype  &gt;&gt; 8);
    ptr[1] = (mDNSu8)(rrtype  &amp;  0xFF);
    ptr[2] = (mDNSu8)(rrclass &gt;&gt; 8);
    ptr[3] = (mDNSu8)(rrclass &amp;  0xFF);
    msg-&gt;h.numQuestions++;
    <span class="enscript-keyword">return</span>(ptr+4);
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putZone</span>(DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *ptr, mDNSu8 *limit, <span class="enscript-type">const</span> domainname *zone, mDNSOpaque16 zoneClass)
{
    ptr = putDomainNameAsLabels(msg, ptr, limit, zone);
    <span class="enscript-keyword">if</span> (!ptr || ptr + 4 &gt; limit) <span class="enscript-keyword">return</span> mDNSNULL;       <span class="enscript-comment">// If we're out-of-space, return NULL
</span>    *ptr++ = (mDNSu8)(kDNSType_SOA  &gt;&gt; 8);
    *ptr++ = (mDNSu8)(kDNSType_SOA  &amp;  0xFF);
    *ptr++ = zoneClass.b[0];
    *ptr++ = zoneClass.b[1];
    msg-&gt;h.mDNS_numZones++;
    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putPrereqNameNotInUse</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name, DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *<span class="enscript-type">const</span> ptr, mDNSu8 *<span class="enscript-type">const</span> end)
{
    AuthRecord prereq;
    mDNS_SetupResourceRecord(&amp;prereq, mDNSNULL, mDNSInterface_Any, kDNSQType_ANY, kStandardTTL, 0, AuthRecordAny, mDNSNULL, mDNSNULL);
    AssignDomainName(&amp;prereq.namestorage, name);
    prereq.resrec.rrtype = kDNSQType_ANY;
    prereq.resrec.rrclass = kDNSClass_NONE;
    <span class="enscript-keyword">return</span> putEmptyResourceRecord(msg, ptr, end, &amp;msg-&gt;h.mDNS_numPrereqs, &amp;prereq);
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putDeletionRecord</span>(DNSMessage *msg, mDNSu8 *ptr, ResourceRecord *rr)
{
    <span class="enscript-comment">// deletion: specify record w/ TTL 0, class NONE
</span>    <span class="enscript-type">const</span> mDNSu16 origclass = rr-&gt;rrclass;
    rr-&gt;rrclass = kDNSClass_NONE;
    ptr = PutResourceRecordTTLJumbo(msg, ptr, &amp;msg-&gt;h.mDNS_numUpdates, rr, 0);
    rr-&gt;rrclass = origclass;
    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putDeletionRecordWithLimit</span>(DNSMessage *msg, mDNSu8 *ptr, ResourceRecord *rr, mDNSu8 *limit)
{
    <span class="enscript-comment">// deletion: specify record w/ TTL 0, class NONE
</span>    <span class="enscript-type">const</span> mDNSu16 origclass = rr-&gt;rrclass;
    rr-&gt;rrclass = kDNSClass_NONE;
    ptr = PutResourceRecordTTLWithLimit(msg, ptr, &amp;msg-&gt;h.mDNS_numUpdates, rr, 0, limit);
    rr-&gt;rrclass = origclass;
    <span class="enscript-keyword">return</span> ptr;
}

mDNSexport mDNSu8 *<span class="enscript-function-name">putDeleteRRSetWithLimit</span>(DNSMessage *msg, mDNSu8 *ptr, <span class="enscript-type">const</span> domainname *name, mDNSu16 rrtype, mDNSu8 *limit)
{
    mDNSu16 class = kDNSQClass_ANY;

    ptr = putDomainNameAsLabels(msg, ptr, limit, name);
    <span class="enscript-keyword">if</span> (!ptr || ptr + 10 &gt;= limit) <span class="enscript-keyword">return</span> mDNSNULL; <span class="enscript-comment">// If we're out-of-space, return mDNSNULL
</span>    ptr[0] = (mDNSu8)(rrtype  &gt;&gt; 8);
    ptr[1] = (mDNSu8)(rrtype  &amp;  0xFF);
    ptr[2] = (mDNSu8)(class &gt;&gt; 8);
    ptr[3] = (mDNSu8)(class &amp;  0xFF);
    ptr[4] = ptr[5] = ptr[6] = ptr[7] = 0; <span class="enscript-comment">// zero ttl
</span>    ptr[8] = ptr[9] = 0; <span class="enscript-comment">// zero rdlength/rdata
</span>
    msg-&gt;h.mDNS_numUpdates++;
    <span class="enscript-keyword">return</span> ptr + 10;
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putDeleteAllRRSets</span>(DNSMessage *msg, mDNSu8 *ptr, <span class="enscript-type">const</span> domainname *name)
{
    <span class="enscript-type">const</span> mDNSu8 *limit = msg-&gt;data + AbsoluteMaxDNSMessageData;
    mDNSu16 class = kDNSQClass_ANY;
    mDNSu16 rrtype = kDNSQType_ANY;

    ptr = putDomainNameAsLabels(msg, ptr, limit, name);
    <span class="enscript-keyword">if</span> (!ptr || ptr + 10 &gt;= limit) <span class="enscript-keyword">return</span> mDNSNULL; <span class="enscript-comment">// If we're out-of-space, return mDNSNULL
</span>    ptr[0] = (mDNSu8)(rrtype &gt;&gt; 8);
    ptr[1] = (mDNSu8)(rrtype &amp;  0xFF);
    ptr[2] = (mDNSu8)(class &gt;&gt; 8);
    ptr[3] = (mDNSu8)(class &amp;  0xFF);
    ptr[4] = ptr[5] = ptr[6] = ptr[7] = 0; <span class="enscript-comment">// zero ttl
</span>    ptr[8] = ptr[9] = 0; <span class="enscript-comment">// zero rdlength/rdata
</span>
    msg-&gt;h.mDNS_numUpdates++;
    <span class="enscript-keyword">return</span> ptr + 10;
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putUpdateLease</span>(DNSMessage *msg, mDNSu8 *ptr, mDNSu32 lease)
{
    AuthRecord rr;
    mDNS_SetupResourceRecord(&amp;rr, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    rr.resrec.rrclass    = NormalMaxDNSMessageData;
    rr.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);    <span class="enscript-comment">// One option in this OPT record
</span>    rr.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
    rr.resrec.rdata-&gt;u.opt[0].opt           = kDNSOpt_Lease;
    rr.resrec.rdata-&gt;u.opt[0].u.updatelease = lease;
    ptr = PutResourceRecordTTLJumbo(msg, ptr, &amp;msg-&gt;h.numAdditionals, &amp;rr.resrec, 0);
    <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;ERROR: putUpdateLease - PutResourceRecordTTL&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }
    <span class="enscript-keyword">return</span> ptr;
}

<span class="enscript-comment">// for dynamic updates
</span>mDNSexport mDNSu8 *<span class="enscript-function-name">putUpdateLeaseWithLimit</span>(DNSMessage *msg, mDNSu8 *ptr, mDNSu32 lease, mDNSu8 *limit)
{
    AuthRecord rr;
    mDNS_SetupResourceRecord(&amp;rr, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    rr.resrec.rrclass    = NormalMaxDNSMessageData;
    rr.resrec.rdlength   = <span class="enscript-keyword">sizeof</span>(rdataOPT);    <span class="enscript-comment">// One option in this OPT record
</span>    rr.resrec.rdestimate = <span class="enscript-keyword">sizeof</span>(rdataOPT);
    rr.resrec.rdata-&gt;u.opt[0].opt           = kDNSOpt_Lease;
    rr.resrec.rdata-&gt;u.opt[0].u.updatelease = lease;
    ptr = PutResourceRecordTTLWithLimit(msg, ptr, &amp;msg-&gt;h.numAdditionals, &amp;rr.resrec, 0, limit);
    <span class="enscript-keyword">if</span> (!ptr) { LogMsg(<span class="enscript-string">&quot;ERROR: putUpdateLeaseWithLimit - PutResourceRecordTTLWithLimit&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }
    <span class="enscript-keyword">return</span> ptr;
}

mDNSexport mDNSu8 *<span class="enscript-function-name">putDNSSECOption</span>(DNSMessage *msg, mDNSu8 *end, mDNSu8 *limit)
{
    AuthRecord rr;
    mDNSu32 ttl = 0;

    mDNS_SetupResourceRecord(&amp;rr, mDNSNULL, mDNSInterface_Any, kDNSType_OPT, kStandardTTL, kDNSRecordTypeKnownUnique, AuthRecordAny, mDNSNULL, mDNSNULL);
    <span class="enscript-comment">// It is still not clear what the right size is. We will have to fine tune this once we do
</span>    <span class="enscript-comment">// a lot of testing with DNSSEC.
</span>    rr.resrec.rrclass    = 4096;
    rr.resrec.rdlength   = 0;
    rr.resrec.rdestimate = 0;
    <span class="enscript-comment">// set the DO bit
</span>    ttl |= 0x8000;
    end = PutResourceRecordTTLWithLimit(msg, end, &amp;msg-&gt;h.numAdditionals, &amp;rr.resrec, ttl, limit);
    <span class="enscript-keyword">if</span> (!end) { LogMsg(<span class="enscript-string">&quot;ERROR: putDNSSECOption - PutResourceRecordTTLWithLimit&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }
    <span class="enscript-keyword">return</span> end;
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">DNS</span> <span class="enscript-variable-name">Message</span> <span class="enscript-variable-name">Parsing</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

mDNSexport mDNSu32 <span class="enscript-function-name">DomainNameHashValue</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    mDNSu32 sum = 0;
    <span class="enscript-type">const</span> mDNSu8 *c;

    <span class="enscript-keyword">for</span> (c = name-&gt;c; c[0] != 0 &amp;&amp; c[1] != 0; c += 2)
    {
        sum += ((mDNSIsUpperCase(c[0]) ? c[0] + <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span> : c[0]) &lt;&lt; 8) |
               (mDNSIsUpperCase(c[1]) ? c[1] + <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span> : c[1]);
        sum = (sum&lt;&lt;3) | (sum&gt;&gt;29);
    }
    <span class="enscript-keyword">if</span> (c[0]) sum += ((mDNSIsUpperCase(c[0]) ? c[0] + <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span> : c[0]) &lt;&lt; 8);
    <span class="enscript-keyword">return</span>(sum);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">SetNewRData</span>(ResourceRecord *<span class="enscript-type">const</span> rr, RData *NewRData, mDNSu16 rdlength)
{
    domainname *target;
    <span class="enscript-keyword">if</span> (NewRData)
    {
        rr-&gt;rdata    = NewRData;
        rr-&gt;rdlength = rdlength;
    }
    <span class="enscript-comment">// Must not try to get target pointer until after updating rr-&gt;rdata
</span>    target = GetRRDomainNameTarget(rr);
    rr-&gt;rdlength   = GetRDLength(rr, mDNSfalse);
    rr-&gt;rdestimate = GetRDLength(rr, mDNStrue);
    rr-&gt;rdatahash  = target ? DomainNameHashValue(target) : RDataHashValue(rr);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">skipDomainName</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    mDNSu16 total = 0;

    <span class="enscript-keyword">if</span> (ptr &lt; (mDNSu8*)msg || ptr &gt;= end)
    { debugf(<span class="enscript-string">&quot;skipDomainName: Illegal ptr not within packet boundaries&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    <span class="enscript-keyword">while</span> (1)                       <span class="enscript-comment">// Read sequence of labels
</span>    {
        <span class="enscript-type">const</span> mDNSu8 len = *ptr++;  <span class="enscript-comment">// Read length of this label
</span>        <span class="enscript-keyword">if</span> (len == 0) <span class="enscript-keyword">return</span>(ptr);  <span class="enscript-comment">// If length is zero, that means this name is complete
</span>        <span class="enscript-keyword">switch</span> (len &amp; 0xC0)
        {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x00</span>:  <span class="enscript-keyword">if</span> (ptr + len &gt;= end)                       <span class="enscript-comment">// Remember: expect at least one more byte for the root label
</span>            { debugf(<span class="enscript-string">&quot;skipDomainName: Malformed domain name (overruns packet end)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            <span class="enscript-keyword">if</span> (total + 1 + len &gt;= MAX_DOMAIN_NAME)             <span class="enscript-comment">// Remember: expect at least one more byte for the root label
</span>            { debugf(<span class="enscript-string">&quot;skipDomainName: Malformed domain name (more than 256 characters)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            ptr += len;
            total += 1 + len;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x40</span>:  debugf(<span class="enscript-string">&quot;skipDomainName: Extended EDNS0 label types 0x%X not supported&quot;</span>, len); <span class="enscript-keyword">return</span>(mDNSNULL);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x80</span>:  debugf(<span class="enscript-string">&quot;skipDomainName: Illegal label length 0x%X&quot;</span>, len); <span class="enscript-keyword">return</span>(mDNSNULL);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0xC0</span>:  <span class="enscript-keyword">return</span>(ptr+1);
        }
    }
}

<span class="enscript-comment">// Routine to fetch an FQDN from the DNS message, following compression pointers if necessary.
</span>mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">getDomainName</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end,
                                       domainname *<span class="enscript-type">const</span> name)
{
    <span class="enscript-type">const</span> mDNSu8 *nextbyte = mDNSNULL;                  <span class="enscript-comment">// Record where we got to before we started following pointers
</span>    mDNSu8       *np = name-&gt;c;                         <span class="enscript-comment">// Name pointer
</span>    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> limit = np + MAX_DOMAIN_NAME;   <span class="enscript-comment">// Limit so we don't overrun buffer
</span>
    <span class="enscript-keyword">if</span> (ptr &lt; (mDNSu8*)msg || ptr &gt;= end)
    { debugf(<span class="enscript-string">&quot;getDomainName: Illegal ptr not within packet boundaries&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    *np = 0;                        <span class="enscript-comment">// Tentatively place the root label here (may be overwritten if we have more labels)
</span>
    <span class="enscript-keyword">while</span> (1)                       <span class="enscript-comment">// Read sequence of labels
</span>    {
		<span class="enscript-type">int</span> i;
		mDNSu16 offset;
        <span class="enscript-type">const</span> mDNSu8 len = *ptr++;  <span class="enscript-comment">// Read length of this label
</span>        <span class="enscript-keyword">if</span> (len == 0) <span class="enscript-keyword">break</span>;        <span class="enscript-comment">// If length is zero, that means this name is complete
</span>        <span class="enscript-keyword">switch</span> (len &amp; 0xC0)
        {

        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x00</span>:  <span class="enscript-keyword">if</span> (ptr + len &gt;= end)           <span class="enscript-comment">// Remember: expect at least one more byte for the root label
</span>            { debugf(<span class="enscript-string">&quot;getDomainName: Malformed domain name (overruns packet end)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            <span class="enscript-keyword">if</span> (np + 1 + len &gt;= limit)              <span class="enscript-comment">// Remember: expect at least one more byte for the root label
</span>            { debugf(<span class="enscript-string">&quot;getDomainName: Malformed domain name (more than 256 characters)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            *np++ = len;
            <span class="enscript-keyword">for</span> (i=0; i&lt;len; i++) *np++ = *ptr++;
            *np = 0;                <span class="enscript-comment">// Tentatively place the root label here (may be overwritten if we have more labels)
</span>            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x40</span>:  debugf(<span class="enscript-string">&quot;getDomainName: Extended EDNS0 label types 0x%X not supported in name %##s&quot;</span>, len, name-&gt;c);
            <span class="enscript-keyword">return</span>(mDNSNULL);

        <span class="enscript-keyword">case</span> <span class="enscript-reference">0x80</span>:  debugf(<span class="enscript-string">&quot;getDomainName: Illegal label length 0x%X in domain name %##s&quot;</span>, len, name-&gt;c); <span class="enscript-keyword">return</span>(mDNSNULL);

        <span class="enscript-keyword">case</span> <span class="enscript-reference">0xC0</span>:  <span class="enscript-keyword">if</span> (ptr &gt;= end)
            { debugf(<span class="enscript-string">&quot;getDomainName: Malformed compression label (overruns packet end)&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            offset = (mDNSu16)((((mDNSu16)(len &amp; 0x3F)) &lt;&lt; 8) | *ptr++);
            <span class="enscript-keyword">if</span> (!nextbyte) nextbyte = ptr;              <span class="enscript-comment">// Record where we got to before we started following pointers
</span>            ptr = (mDNSu8 *)msg + offset;
            <span class="enscript-keyword">if</span> (ptr &lt; (mDNSu8*)msg || ptr &gt;= end)
            { debugf(<span class="enscript-string">&quot;getDomainName: Illegal compression pointer not within packet boundaries&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            <span class="enscript-keyword">if</span> (*ptr &amp; 0xC0)
            { debugf(<span class="enscript-string">&quot;getDomainName: Compression pointer must point to real label&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span> (nextbyte) <span class="enscript-keyword">return</span>(nextbyte);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(ptr);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">skipResourceRecord</span>(<span class="enscript-type">const</span> DNSMessage *msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *end)
{
    mDNSu16 pktrdlength;

    ptr = skipDomainName(msg, ptr, end);
    <span class="enscript-keyword">if</span> (!ptr) { debugf(<span class="enscript-string">&quot;skipResourceRecord: Malformed RR name&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    <span class="enscript-keyword">if</span> (ptr + 10 &gt; end) { debugf(<span class="enscript-string">&quot;skipResourceRecord: Malformed RR -- no type/class/ttl/len!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    pktrdlength = (mDNSu16)((mDNSu16)ptr[8] &lt;&lt;  8 | ptr[9]);
    ptr += 10;
    <span class="enscript-keyword">if</span> (ptr + pktrdlength &gt; end) { debugf(<span class="enscript-string">&quot;skipResourceRecord: RDATA exceeds end of packet&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    <span class="enscript-keyword">return</span>(ptr + pktrdlength);
}

<span class="enscript-comment">// Sanity check whether the NSEC/NSEC3 bitmap is good
</span>mDNSlocal mDNSu8 *<span class="enscript-function-name">SanityCheckBitMap</span>(<span class="enscript-type">const</span> mDNSu8 *bmap, <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> win, wlen;

    <span class="enscript-keyword">while</span> (bmap &lt; end)
    {
        <span class="enscript-keyword">if</span> (len &lt; 3)
        {
            LogInfo(<span class="enscript-string">&quot;SanityCheckBitMap: invalid length %d&quot;</span>, len);
            <span class="enscript-keyword">return</span> mDNSNULL;
        }

        win = *bmap++;
        wlen = *bmap++;
        len -= 2;
        <span class="enscript-keyword">if</span> (len &lt; wlen || wlen &lt; 1 || wlen &gt; 32)
        {
            LogInfo(<span class="enscript-string">&quot;SanityCheckBitMap: invalid window length %d&quot;</span>, wlen);
            <span class="enscript-keyword">return</span> mDNSNULL;
        }
        <span class="enscript-keyword">if</span> (win &lt; 0 || win &gt;= 256)
        {
            LogInfo(<span class="enscript-string">&quot;SanityCheckBitMap: invalid window %d&quot;</span>, win);
            <span class="enscript-keyword">return</span> mDNSNULL;
        }

        bmap += wlen;
        len -= wlen;
    }
    <span class="enscript-keyword">return</span> (mDNSu8 *)bmap;
}

<span class="enscript-comment">// This function is called with &quot;msg&quot; when we receive a DNS message and needs to parse a single resource record
</span><span class="enscript-comment">// pointed to by &quot;ptr&quot;. Some resource records like SOA, SRV are converted to host order and also expanded
</span><span class="enscript-comment">// (domainnames are expanded to 256 bytes) when stored in memory.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This function can also be called with &quot;NULL&quot; msg to parse a single resource record pointed to by ptr.
</span><span class="enscript-comment">// The caller can do this only if the names in the resource records are not compressed and validity of the
</span><span class="enscript-comment">// resource record has already been done before. DNSSEC currently uses it this way.
</span>mDNSexport mDNSBool <span class="enscript-function-name">SetRData</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *end,
    LargeCacheRecord *<span class="enscript-type">const</span> largecr, mDNSu16 rdlength)
{
    CacheRecord *<span class="enscript-type">const</span> rr = &amp;largecr-&gt;r;
    RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)rr-&gt;smallrdatastorage.data;

    <span class="enscript-keyword">switch</span> (rr-&gt;resrec.rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:
        <span class="enscript-keyword">if</span> (rdlength != <span class="enscript-keyword">sizeof</span>(mDNSv4Addr))
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        rdb-&gt;ipv4.b[0] = ptr[0];
        rdb-&gt;ipv4.b[1] = ptr[1];
        rdb-&gt;ipv4.b[2] = ptr[2];
        rdb-&gt;ipv4.b[3] = ptr[3];
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSAP_PTR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>:
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;name);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;name, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;name);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed CNAME/PTR RDATA name&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;soa.mname);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;soa.mname, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;soa.mname);
        }
        <span class="enscript-keyword">if</span> (!ptr)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed SOA RDATA mname&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;soa.rname);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;soa.rname, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;soa.rname);
        }
        <span class="enscript-keyword">if</span> (!ptr)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed SOA RDATA rname&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (ptr + 0x14 != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed SOA RDATA&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        rdb-&gt;soa.serial  = (mDNSs32) ((mDNSs32)ptr[0x00] &lt;&lt; 24 | (mDNSs32)ptr[0x01] &lt;&lt; 16 | (mDNSs32)ptr[0x02] &lt;&lt; 8 | ptr[0x03]);
        rdb-&gt;soa.refresh = (mDNSu32) ((mDNSu32)ptr[0x04] &lt;&lt; 24 | (mDNSu32)ptr[0x05] &lt;&lt; 16 | (mDNSu32)ptr[0x06] &lt;&lt; 8 | ptr[0x07]);
        rdb-&gt;soa.retry   = (mDNSu32) ((mDNSu32)ptr[0x08] &lt;&lt; 24 | (mDNSu32)ptr[0x09] &lt;&lt; 16 | (mDNSu32)ptr[0x0A] &lt;&lt; 8 | ptr[0x0B]);
        rdb-&gt;soa.expire  = (mDNSu32) ((mDNSu32)ptr[0x0C] &lt;&lt; 24 | (mDNSu32)ptr[0x0D] &lt;&lt; 16 | (mDNSu32)ptr[0x0E] &lt;&lt; 8 | ptr[0x0F]);
        rdb-&gt;soa.min     = (mDNSu32) ((mDNSu32)ptr[0x10] &lt;&lt; 24 | (mDNSu32)ptr[0x11] &lt;&lt; 16 | (mDNSu32)ptr[0x12] &lt;&lt; 8 | ptr[0x13]);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NULL</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_X25</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_ISDN</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_LOC</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DHCID</span>:
        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:
        <span class="enscript-comment">// Preference + domainname
</span>        <span class="enscript-keyword">if</span> (rdlength &lt; 3)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        rdb-&gt;mx.preference = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
        ptr += 2;
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;mx.exchange);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;mx.exchange, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;mx.exchange);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed MX name&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:
        <span class="enscript-comment">// Domainname + domainname
</span>        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;rp.mbox);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;rp.mbox, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;rp.mbox);
        }
        <span class="enscript-keyword">if</span> (!ptr)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed RP mbox&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;rp.txt);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;rp.txt, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;rp.txt);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed RP txt&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:
        <span class="enscript-comment">// Preference + domainname + domainname
</span>        <span class="enscript-keyword">if</span> (rdlength &lt; 4)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        rdb-&gt;px.preference = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
        ptr += 2;
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;px.map822);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;px.map822, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;px.map822);
        }
        <span class="enscript-keyword">if</span> (!ptr)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed PX map822&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;px.mapx400);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;px.mapx400, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;px.mapx400);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed PX mapx400&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>:
        <span class="enscript-keyword">if</span> (rdlength != <span class="enscript-keyword">sizeof</span>(mDNSv6Addr))
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        mDNSPlatformMemCopy(&amp;rdb-&gt;ipv6, ptr, <span class="enscript-keyword">sizeof</span>(rdb-&gt;ipv6));
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:
        <span class="enscript-comment">// Priority + weight + port + domainname
</span>        <span class="enscript-keyword">if</span> (rdlength &lt; 7)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        rdb-&gt;srv.priority = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
        rdb-&gt;srv.weight   = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt;  8 | ptr[3]);
        rdb-&gt;srv.port.b[0] = ptr[4];
        rdb-&gt;srv.port.b[1] = ptr[5];
        ptr += 6;
        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;rdb-&gt;srv.target);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;rdb-&gt;srv.target, (domainname *)ptr);
            ptr += DomainNameLength(&amp;rdb-&gt;srv.target);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            debugf(<span class="enscript-string">&quot;SetRData: Malformed SRV RDATA name&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NAPTR</span>:
    {
        <span class="enscript-type">int</span> savelen, len;
        domainname name;
        <span class="enscript-type">const</span> mDNSu8 *orig = ptr;

        <span class="enscript-comment">// Make sure the data is parseable and within the limits. DNSSEC code looks at
</span>        <span class="enscript-comment">// the domain name in the end for a valid domainname.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// Fixed length: Order, preference (4 bytes)
</span>        <span class="enscript-comment">// Variable length: flags, service, regexp, domainname
</span>
        <span class="enscript-keyword">if</span> (rdlength &lt; 8)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        <span class="enscript-comment">// Order, preference.
</span>        ptr += 4;
        <span class="enscript-comment">// Parse flags, Service and Regexp
</span>        <span class="enscript-comment">// length in the first byte does not include the length byte itself
</span>        len = *ptr + 1;
        ptr += len;
        <span class="enscript-keyword">if</span> (ptr &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NAPTR flags&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        <span class="enscript-comment">// Service
</span>        len = *ptr + 1;
        ptr += len;
        <span class="enscript-keyword">if</span> (ptr &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NAPTR service&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        <span class="enscript-comment">// Regexp
</span>        len = *ptr + 1;
        ptr += len;
        <span class="enscript-keyword">if</span> (ptr &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NAPTR regexp&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        savelen = ptr - orig;

        <span class="enscript-comment">// RFC 2915 states that name compression is not allowed for this field. But RFC 3597
</span>        <span class="enscript-comment">// states that for NAPTR we should decompress. We make sure that we store the full
</span>        <span class="enscript-comment">// name rather than the compressed name
</span>        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;name);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;name, (domainname *)ptr);
            ptr += DomainNameLength(&amp;name);
        }
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NAPTR RDATA name&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        rr-&gt;resrec.rdlength = savelen + DomainNameLength(&amp;name);
        <span class="enscript-comment">// The uncompressed size should not exceed the limits
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdlength &gt; MaximumRDSize)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NAPTR rdlength %d, rr-&gt;resrec.rdlength %d, &quot;</span>
                    <span class="enscript-string">&quot;bmaplen %d, name %##s&quot;</span>, rdlength, rr-&gt;resrec.rdlength, name.c);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        mDNSPlatformMemCopy(rdb-&gt;data, orig, savelen);
        AssignDomainName((domainname *)(rdb-&gt;data + savelen), &amp;name);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:  {
        mDNSu8 *dataend     = rr-&gt;resrec.rdata-&gt;u.data;
        rdataOPT *opt = rr-&gt;resrec.rdata-&gt;u.opt;
        rr-&gt;resrec.rdlength = 0;
        <span class="enscript-keyword">while</span> (ptr &lt; end &amp;&amp; (mDNSu8 *)(opt+1) &lt; &amp;dataend[MaximumRDSize])
        {
            <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> currentopt = opt;
            <span class="enscript-keyword">if</span> (ptr + 4 &gt; end) { LogInfo(<span class="enscript-string">&quot;SetRData: OPT RDATA ptr + 4 &gt; end&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
            opt-&gt;opt    = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
            opt-&gt;optlen = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt;  8 | ptr[3]);
            ptr += 4;
            <span class="enscript-keyword">if</span> (ptr + opt-&gt;optlen &gt; end) { LogInfo(<span class="enscript-string">&quot;SetRData: ptr + opt-&gt;optlen &gt; end&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
            <span class="enscript-keyword">switch</span> (opt-&gt;opt)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_LLQ</span>:
                <span class="enscript-keyword">if</span> (opt-&gt;optlen == DNSOpt_LLQData_Space - 4)
                {
                    opt-&gt;u.llq.vers  = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
                    opt-&gt;u.llq.llqOp = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt;  8 | ptr[3]);
                    opt-&gt;u.llq.err   = (mDNSu16)((mDNSu16)ptr[4] &lt;&lt;  8 | ptr[5]);
                    mDNSPlatformMemCopy(opt-&gt;u.llq.id.b, ptr+6, 8);
                    opt-&gt;u.llq.llqlease = (mDNSu32) ((mDNSu32)ptr[14] &lt;&lt; 24 | (mDNSu32)ptr[15] &lt;&lt; 16 | (mDNSu32)ptr[16] &lt;&lt; 8 | ptr[17]);
                    <span class="enscript-keyword">if</span> (opt-&gt;u.llq.llqlease &gt; 0x70000000UL / mDNSPlatformOneSecond)
                        opt-&gt;u.llq.llqlease = 0x70000000UL / mDNSPlatformOneSecond;
                    opt++;
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Lease</span>:
                <span class="enscript-keyword">if</span> (opt-&gt;optlen == DNSOpt_LeaseData_Space - 4)
                {
                    opt-&gt;u.updatelease = (mDNSu32) ((mDNSu32)ptr[0] &lt;&lt; 24 | (mDNSu32)ptr[1] &lt;&lt; 16 | (mDNSu32)ptr[2] &lt;&lt; 8 | ptr[3]);
                    <span class="enscript-keyword">if</span> (opt-&gt;u.updatelease &gt; 0x70000000UL / mDNSPlatformOneSecond)
                        opt-&gt;u.updatelease = 0x70000000UL / mDNSPlatformOneSecond;
                    opt++;
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Owner</span>:
                <span class="enscript-keyword">if</span> (ValidOwnerLength(opt-&gt;optlen))
                {
                    opt-&gt;u.owner.vers = ptr[0];
                    opt-&gt;u.owner.seq  = ptr[1];
                    mDNSPlatformMemCopy(opt-&gt;u.owner.HMAC.b, ptr+2, 6);                         <span class="enscript-comment">// 6-byte MAC address
</span>                    mDNSPlatformMemCopy(opt-&gt;u.owner.IMAC.b, ptr+2, 6);                         <span class="enscript-comment">// 6-byte MAC address
</span>                    opt-&gt;u.owner.password = zeroEthAddr;
                    <span class="enscript-keyword">if</span> (opt-&gt;optlen &gt;= DNSOpt_OwnerData_ID_Wake_Space-4)
                    {
                        mDNSPlatformMemCopy(opt-&gt;u.owner.IMAC.b, ptr+8, 6);                     <span class="enscript-comment">// 6-byte MAC address
</span>                        <span class="enscript-comment">// This mDNSPlatformMemCopy is safe because the ValidOwnerLength(opt-&gt;optlen) check above
</span>                        <span class="enscript-comment">// ensures that opt-&gt;optlen is no more than DNSOpt_OwnerData_ID_Wake_PW6_Space - 4
</span>                        <span class="enscript-keyword">if</span> (opt-&gt;optlen &gt; DNSOpt_OwnerData_ID_Wake_Space-4)
                            mDNSPlatformMemCopy(opt-&gt;u.owner.password.b, ptr+14, opt-&gt;optlen - (DNSOpt_OwnerData_ID_Wake_Space-4));
                    }
                    opt++;
                }
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSOpt_Trace</span>:
                <span class="enscript-keyword">if</span> (opt-&gt;optlen == DNSOpt_TraceData_Space - 4)
                {
                    opt-&gt;u.tracer.platf   = ptr[0];
                    opt-&gt;u.tracer.mDNSv   = (mDNSu32) ((mDNSu32)ptr[1] &lt;&lt; 24 | (mDNSu32)ptr[2] &lt;&lt; 16 | (mDNSu32)ptr[3] &lt;&lt; 8 | ptr[4]);
                    opt++;
                }
                <span class="enscript-keyword">else</span>
                {
                    opt-&gt;u.tracer.platf   = 0xFF;
                    opt-&gt;u.tracer.mDNSv   = 0xFFFFFFFF;
                    opt++;
                }
                <span class="enscript-keyword">break</span>;
            }
            ptr += currentopt-&gt;optlen;
        }
        rr-&gt;resrec.rdlength = (mDNSu16)((mDNSu8*)opt - rr-&gt;resrec.rdata-&gt;u.data);
        <span class="enscript-keyword">if</span> (ptr != end) { LogInfo(<span class="enscript-string">&quot;SetRData: Malformed OptRdata&quot;</span>); <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; }
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>: {
        domainname name;
        <span class="enscript-type">int</span> len = rdlength;
        <span class="enscript-type">int</span> bmaplen, dlen;
        <span class="enscript-type">const</span> mDNSu8 *orig = ptr;
        <span class="enscript-type">const</span> mDNSu8 *bmap;

        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;name);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;name, (domainname *)ptr);
            ptr += DomainNameLength(&amp;name);
        }
        <span class="enscript-keyword">if</span> (!ptr)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NSEC nextname&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        dlen = DomainNameLength(&amp;name);

        <span class="enscript-comment">// Multicast NSECs use name compression for this field unlike the unicast case which
</span>        <span class="enscript-comment">// does not use compression. And multicast case always succeeds in compression. So,
</span>        <span class="enscript-comment">// the rdlength includes only the compressed space in that case. So, can't
</span>        <span class="enscript-comment">// use the DomainNameLength of name to reduce the length here.
</span>        len -= (ptr - orig);
        bmaplen = len;                  <span class="enscript-comment">// Save the length of the bitmap
</span>        bmap = ptr;
        ptr = SanityCheckBitMap(bmap, end, len);
        <span class="enscript-keyword">if</span> (!ptr)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        <span class="enscript-keyword">if</span> (ptr != end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NSEC length not right&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        <span class="enscript-comment">// Initialize the right length here. When we call SetNewRData below which in turn calls
</span>        <span class="enscript-comment">// GetRDLength and for NSEC case, it assumes that rdlength is intitialized
</span>        rr-&gt;resrec.rdlength = DomainNameLength(&amp;name) + bmaplen;

        <span class="enscript-comment">// Do we have space after the name expansion ?
</span>        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdlength &gt; MaximumRDSize)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed NSEC rdlength %d, rr-&gt;resrec.rdlength %d, &quot;</span>
                    <span class="enscript-string">&quot;bmaplen %d, name %##s&quot;</span>, rdlength, rr-&gt;resrec.rdlength, name.c);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        AssignDomainName((domainname *)rdb-&gt;data, &amp;name);
        mDNSPlatformMemCopy(rdb-&gt;data + dlen, bmap, bmaplen);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3</span>:
    {
        rdataNSEC3 *nsec3 = (rdataNSEC3 *)ptr;
        mDNSu8 *p = (mDNSu8 *)&amp;nsec3-&gt;salt;
        <span class="enscript-type">int</span> hashLength, bitmaplen;

        <span class="enscript-keyword">if</span> (rdlength &lt; NSEC3_FIXED_SIZE + 1)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: NSEC3 too small length %d&quot;</span>, rdlength);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (nsec3-&gt;alg != SHA1_DIGEST_TYPE)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: nsec3 alg %d not supported&quot;</span>, nsec3-&gt;alg);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (swap16(nsec3-&gt;iterations) &gt; NSEC3_MAX_ITERATIONS)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: nsec3 iteration count %d too big&quot;</span>, swap16(nsec3-&gt;iterations));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        } 
        p += nsec3-&gt;saltLength;
        <span class="enscript-comment">// There should at least be one byte beyond saltLength
</span>        <span class="enscript-keyword">if</span> (p &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: nsec3 too small, at saltlength %d, p %p, end %p&quot;</span>, nsec3-&gt;saltLength, p, end);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-comment">// p is pointing at hashLength
</span>        hashLength = (<span class="enscript-type">int</span>)*p++;
        <span class="enscript-keyword">if</span> (!hashLength)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: hashLength zero&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        p += hashLength;
        <span class="enscript-keyword">if</span> (p &gt; end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: nsec3 too small, at hashLength %d, p %p, end %p&quot;</span>, hashLength, p, end);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        bitmaplen = rdlength - (<span class="enscript-type">int</span>)(p - ptr);
        p = SanityCheckBitMap(p, end, bitmaplen);
        <span class="enscript-keyword">if</span> (!p)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TKEY</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>:
    {
        domainname name;
        <span class="enscript-type">int</span> dlen, rlen;

        <span class="enscript-comment">// The name should not be compressed. But we take the conservative approach
</span>        <span class="enscript-comment">// and uncompress the name before we store it.
</span>        <span class="enscript-keyword">if</span> (msg)
        {
            ptr = getDomainName(msg, ptr, end, &amp;name);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;name, (domainname *)ptr);
            ptr += DomainNameLength(&amp;name);
        }
        <span class="enscript-keyword">if</span> (!ptr || ptr &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed name for TSIG/TKEY type %d&quot;</span>, rr-&gt;resrec.rrtype);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        dlen = DomainNameLength(&amp;name);
        rlen = end - ptr;
        rr-&gt;resrec.rdlength = dlen + rlen;
        <span class="enscript-keyword">if</span> (rr-&gt;resrec.rdlength &gt; MaximumRDSize)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed TSIG/TKEY rdlength %d, rr-&gt;resrec.rdlength %d, &quot;</span>
                    <span class="enscript-string">&quot;bmaplen %d, name %##s&quot;</span>, rdlength, rr-&gt;resrec.rdlength, name.c);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        AssignDomainName((domainname *)rdb-&gt;data, &amp;name);
        mDNSPlatformMemCopy(rdb-&gt;data + dlen, ptr, rlen);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RRSIG</span>:
    {
        <span class="enscript-type">const</span> mDNSu8 *sig = ptr + RRSIG_FIXED_SIZE;
        <span class="enscript-type">const</span> mDNSu8 *orig = sig;
        domainname name;
        <span class="enscript-keyword">if</span> (rdlength &lt; RRSIG_FIXED_SIZE + 1)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: RRSIG too small length %d&quot;</span>, rdlength);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-keyword">if</span> (msg)
        {
            sig = getDomainName(msg, sig, end, &amp;name);
        }
        <span class="enscript-keyword">else</span>
        {
            AssignDomainName(&amp;name, (domainname *)sig);
            sig += DomainNameLength(&amp;name);
        }
        <span class="enscript-keyword">if</span> (!sig)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed RRSIG record&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }

        <span class="enscript-keyword">if</span> ((sig - orig) != DomainNameLength(&amp;name))
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Malformed RRSIG record, signer name compression&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        <span class="enscript-comment">// Just ensure that we have at least one byte of the signature
</span>        <span class="enscript-keyword">if</span> (sig + 1 &gt;= end)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: Not enough bytes for signature type %d&quot;</span>, rr-&gt;resrec.rrtype);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNSKEY</span>:
    {
        <span class="enscript-keyword">if</span> (rdlength &lt; DNSKEY_FIXED_SIZE + 1)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: DNSKEY too small length %d&quot;</span>, rdlength);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DS</span>:
    {
        <span class="enscript-keyword">if</span> (rdlength &lt; DS_FIXED_SIZE + 1)
        {
            LogInfo(<span class="enscript-string">&quot;SetRData: DS too small length %d&quot;</span>, rdlength);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-reference">default</span>:
        debugf(<span class="enscript-string">&quot;SetRData: Warning! Reading resource type %d (%s) as opaque data&quot;</span>,
               rr-&gt;resrec.rrtype, DNSTypeName(rr-&gt;resrec.rrtype));
        <span class="enscript-comment">// Note: Just because we don't understand the record type, that doesn't
</span>        <span class="enscript-comment">// mean we fail. The DNS protocol specifies rdlength, so we can
</span>        <span class="enscript-comment">// safely skip over unknown records and ignore them.
</span>        <span class="enscript-comment">// We also grab a binary copy of the rdata anyway, since the caller
</span>        <span class="enscript-comment">// might know how to interpret it even if we don't.
</span>        rr-&gt;resrec.rdlength = rdlength;
        mDNSPlatformMemCopy(rdb-&gt;data, ptr, rdlength);
        <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
<span class="enscript-reference">fail</span>:
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">GetLargeResourceRecord</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *ptr,
                                                <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID, mDNSu8 RecordType, LargeCacheRecord *<span class="enscript-type">const</span> largecr)
{
    CacheRecord *<span class="enscript-type">const</span> rr = &amp;largecr-&gt;r;
    mDNSu16 pktrdlength;
    mDNSu32 maxttl = (!InterfaceID) ? mDNSMaximumUnicastTTLSeconds : mDNSMaximumMulticastTTLSeconds;

    <span class="enscript-keyword">if</span> (largecr == &amp;m-&gt;rec &amp;&amp; m-&gt;rec.r.resrec.RecordType)
        LogFatalError(<span class="enscript-string">&quot;GetLargeResourceRecord: m-&gt;rec appears to be already in use for %s&quot;</span>, CRDisplayString(m, &amp;m-&gt;rec.r));

    rr-&gt;next              = mDNSNULL;
    rr-&gt;resrec.name       = &amp;largecr-&gt;namestorage;

    rr-&gt;NextInKAList      = mDNSNULL;
    rr-&gt;TimeRcvd          = m ? m-&gt;timenow : 0;
    rr-&gt;DelayDelivery     = 0;
    rr-&gt;NextRequiredQuery = m ? m-&gt;timenow : 0;     <span class="enscript-comment">// Will be updated to the real value when we call SetNextCacheCheckTimeForRecord()
</span>    rr-&gt;CRActiveQuestion  = mDNSNULL;
    rr-&gt;UnansweredQueries = 0;
    rr-&gt;LastUnansweredTime= 0;
    rr-&gt;NextInCFList      = mDNSNULL;

    rr-&gt;resrec.InterfaceID       = InterfaceID;
    rr-&gt;resrec.rDNSServer = mDNSNULL;

    ptr = getDomainName(msg, ptr, end, &amp;largecr-&gt;namestorage);      <span class="enscript-comment">// Will bail out correctly if ptr is NULL
</span>    <span class="enscript-keyword">if</span> (!ptr) { debugf(<span class="enscript-string">&quot;GetLargeResourceRecord: Malformed RR name&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    rr-&gt;resrec.namehash = DomainNameHashValue(rr-&gt;resrec.name);

    <span class="enscript-keyword">if</span> (ptr + 10 &gt; end) { debugf(<span class="enscript-string">&quot;GetLargeResourceRecord: Malformed RR -- no type/class/ttl/len!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    rr-&gt;resrec.rrtype            = (mDNSu16) ((mDNSu16)ptr[0] &lt;&lt;  8 | ptr[1]);
    rr-&gt;resrec.rrclass           = (mDNSu16)(((mDNSu16)ptr[2] &lt;&lt;  8 | ptr[3]) &amp; kDNSClass_Mask);
    rr-&gt;resrec.rroriginalttl     = (mDNSu32) ((mDNSu32)ptr[4] &lt;&lt; 24 | (mDNSu32)ptr[5] &lt;&lt; 16 | (mDNSu32)ptr[6] &lt;&lt; 8 | ptr[7]);
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rroriginalttl &gt; maxttl &amp;&amp; (mDNSs32)rr-&gt;resrec.rroriginalttl != -1)
        rr-&gt;resrec.rroriginalttl = maxttl;
    <span class="enscript-comment">// Note: We don't have to adjust m-&gt;NextCacheCheck here -- this is just getting a record into memory for
</span>    <span class="enscript-comment">// us to look at. If we decide to copy it into the cache, then we'll update m-&gt;NextCacheCheck accordingly.
</span>    pktrdlength           = (mDNSu16)((mDNSu16)ptr[8] &lt;&lt;  8 | ptr[9]);

    <span class="enscript-comment">// If mDNS record has cache-flush bit set, we mark it unique
</span>    <span class="enscript-comment">// For uDNS records, all are implicitly deemed unique (a single DNS server is always authoritative for the entire RRSet)
</span>    <span class="enscript-keyword">if</span> (ptr[2] &amp; (kDNSClass_UniqueRRSet &gt;&gt; 8) || !InterfaceID)
        RecordType |= kDNSRecordTypePacketUniqueMask;
    ptr += 10;
    <span class="enscript-keyword">if</span> (ptr + pktrdlength &gt; end) { debugf(<span class="enscript-string">&quot;GetLargeResourceRecord: RDATA exceeds end of packet&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    end = ptr + pktrdlength;        <span class="enscript-comment">// Adjust end to indicate the end of the rdata for this resource record
</span>
    rr-&gt;resrec.rdata = (RData*)&amp;rr-&gt;smallrdatastorage;
    rr-&gt;resrec.rdata-&gt;MaxRDLength = MaximumRDSize;

    <span class="enscript-keyword">if</span> (pktrdlength &gt; MaximumRDSize)
    {
        LogInfo(<span class="enscript-string">&quot;GetLargeResourceRecord: %s rdata size (%d) exceeds storage (%d)&quot;</span>,
                DNSTypeName(rr-&gt;resrec.rrtype), pktrdlength, rr-&gt;resrec.rdata-&gt;MaxRDLength);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }

    <span class="enscript-keyword">if</span> (!RecordType) LogMsg(<span class="enscript-string">&quot;GetLargeResourceRecord: No RecordType for %##s&quot;</span>, rr-&gt;resrec.name-&gt;c);

    <span class="enscript-comment">// IMPORTANT: Any record type we understand and unpack into a structure containing domainnames needs to have corresponding
</span>    <span class="enscript-comment">// cases in SameRDataBody() and RDataHashValue() to do a semantic comparison (or checksum) of the structure instead of a blind
</span>    <span class="enscript-comment">// bitwise memory compare (or sum). This is because a domainname is a fixed size structure holding variable-length data.
</span>    <span class="enscript-comment">// Any bytes past the logical end of the name are undefined, and a blind bitwise memory compare may indicate that
</span>    <span class="enscript-comment">// two domainnames are different when semantically they are the same name and it's only the unused bytes that differ.
</span>    <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrclass == kDNSQClass_ANY &amp;&amp; pktrdlength == 0)   <span class="enscript-comment">// Used in update packets to mean &quot;Delete An RRset&quot; (RFC 2136)
</span>        rr-&gt;resrec.rdlength = 0;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!SetRData(msg, ptr, end, largecr, pktrdlength))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

    SetNewRData(&amp;rr-&gt;resrec, mDNSNULL, 0);      <span class="enscript-comment">// Sets rdlength, rdestimate, rdatahash for us
</span>
    <span class="enscript-comment">// Success! Now fill in RecordType to show this record contains valid data
</span>    rr-&gt;resrec.RecordType = RecordType;
    <span class="enscript-keyword">return</span>(end);

<span class="enscript-reference">fail</span>:
    <span class="enscript-comment">// If we were unable to parse the rdata in this record, we indicate that by
</span>    <span class="enscript-comment">// returing a 'kDNSRecordTypePacketNegative' record with rdlength set to zero
</span>    rr-&gt;resrec.RecordType = kDNSRecordTypePacketNegative;
    rr-&gt;resrec.rdlength   = 0;
    rr-&gt;resrec.rdestimate = 0;
    rr-&gt;resrec.rdatahash  = 0;
    <span class="enscript-keyword">return</span>(end);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">skipQuestion</span>(<span class="enscript-type">const</span> DNSMessage *msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *end)
{
    ptr = skipDomainName(msg, ptr, end);
    <span class="enscript-keyword">if</span> (!ptr) { debugf(<span class="enscript-string">&quot;skipQuestion: Malformed domain name in DNS question section&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    <span class="enscript-keyword">if</span> (ptr+4 &gt; end) { debugf(<span class="enscript-string">&quot;skipQuestion: Malformed DNS question section -- no query type and class!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    <span class="enscript-keyword">return</span>(ptr+4);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">getQuestion</span>(<span class="enscript-type">const</span> DNSMessage *msg, <span class="enscript-type">const</span> mDNSu8 *ptr, <span class="enscript-type">const</span> mDNSu8 *end, <span class="enscript-type">const</span> mDNSInterfaceID InterfaceID,
                                     DNSQuestion *question)
{
    mDNSPlatformMemZero(question, <span class="enscript-keyword">sizeof</span>(*question));
    question-&gt;InterfaceID = InterfaceID;
    <span class="enscript-keyword">if</span> (!InterfaceID) question-&gt;TargetQID = onesID; <span class="enscript-comment">// In DNSQuestions we use TargetQID as the indicator of whether it's unicast or multicast
</span>    ptr = getDomainName(msg, ptr, end, &amp;question-&gt;qname);
    <span class="enscript-keyword">if</span> (!ptr) { debugf(<span class="enscript-string">&quot;Malformed domain name in DNS question section&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }
    <span class="enscript-keyword">if</span> (ptr+4 &gt; end) { debugf(<span class="enscript-string">&quot;Malformed DNS question section -- no query type and class!&quot;</span>); <span class="enscript-keyword">return</span>(mDNSNULL); }

    question-&gt;qnamehash = DomainNameHashValue(&amp;question-&gt;qname);
    question-&gt;qtype  = (mDNSu16)((mDNSu16)ptr[0] &lt;&lt; 8 | ptr[1]);            <span class="enscript-comment">// Get type
</span>    question-&gt;qclass = (mDNSu16)((mDNSu16)ptr[2] &lt;&lt; 8 | ptr[3]);            <span class="enscript-comment">// and class
</span>    <span class="enscript-keyword">return</span>(ptr+4);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LocateAnswers</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = msg-&gt;data;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;h.numQuestions &amp;&amp; ptr; i++) ptr = skipQuestion(msg, ptr, end);
    <span class="enscript-keyword">return</span>(ptr);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LocateAuthorities</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateAnswers(msg, end);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;h.numAnswers &amp;&amp; ptr; i++) ptr = skipResourceRecord(msg, ptr, end);
    <span class="enscript-keyword">return</span>(ptr);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LocateAdditionals</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateAuthorities(msg, end);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;h.numAuthorities; i++) ptr = skipResourceRecord(msg, ptr, end);
    <span class="enscript-keyword">return</span> (ptr);
}

mDNSexport <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">LocateOptRR</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, <span class="enscript-type">int</span> minsize)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateAdditionals(msg, end);

    <span class="enscript-comment">// Locate the OPT record.
</span>    <span class="enscript-comment">// According to RFC 2671, &quot;One OPT pseudo-RR can be added to the additional data section of either a request or a response.&quot;
</span>    <span class="enscript-comment">// This implies that there may be *at most* one OPT record per DNS message, in the Additional Section,
</span>    <span class="enscript-comment">// but not necessarily the *last* entry in the Additional Section.
</span>    <span class="enscript-keyword">for</span> (i = 0; ptr &amp;&amp; i &lt; msg-&gt;h.numAdditionals; i++)
    {
        <span class="enscript-keyword">if</span> (ptr + DNSOpt_Header_Space + minsize &lt;= end &amp;&amp;   <span class="enscript-comment">// Make sure we have 11+minsize bytes of data
</span>            ptr[0] == 0                                &amp;&amp;   <span class="enscript-comment">// Name must be root label
</span>            ptr[1] == (kDNSType_OPT &gt;&gt; 8  )            &amp;&amp;   <span class="enscript-comment">// rrtype OPT
</span>            ptr[2] == (kDNSType_OPT &amp; 0xFF)            &amp;&amp;
            ((mDNSu16)ptr[9] &lt;&lt; 8 | (mDNSu16)ptr[10]) &gt;= (mDNSu16)minsize)
            <span class="enscript-keyword">return</span>(ptr);
        <span class="enscript-keyword">else</span>
            ptr = skipResourceRecord(msg, ptr, end);
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// On success, GetLLQOptData returns pointer to storage within shared &quot;m-&gt;rec&quot;;
</span><span class="enscript-comment">// it is caller's responsibilty to clear m-&gt;rec.r.resrec.RecordType after use
</span><span class="enscript-comment">// Note: An OPT RDataBody actually contains one or more variable-length rdataOPT objects packed together
</span><span class="enscript-comment">// The code that currently calls this assumes there's only one, instead of iterating through the set
</span>mDNSexport <span class="enscript-type">const</span> rdataOPT *<span class="enscript-function-name">GetLLQOptData</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateOptRR(msg, end, DNSOpt_LLQData_Space);
    <span class="enscript-keyword">if</span> (ptr)
    {
        ptr = GetLargeResourceRecord(m, msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative) <span class="enscript-keyword">return</span>(&amp;m-&gt;rec.r.resrec.rdata-&gt;u.opt[0]);
    }
    <span class="enscript-keyword">return</span>(mDNSNULL);
}

<span class="enscript-comment">// Get the lease life of records in a dynamic update
</span>mDNSexport mDNSBool <span class="enscript-function-name">GetPktLease</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, mDNSu32 *<span class="enscript-type">const</span> lease)
{
    <span class="enscript-type">const</span> mDNSu8 *ptr = LocateOptRR(msg, end, DNSOpt_LeaseData_Space);
    <span class="enscript-keyword">if</span> (ptr)
    {
        ptr = GetLargeResourceRecord(m, msg, ptr, end, 0, kDNSRecordTypePacketAdd, &amp;m-&gt;rec);
        <span class="enscript-keyword">if</span> (ptr &amp;&amp; m-&gt;rec.r.resrec.RecordType != kDNSRecordTypePacketNegative &amp;&amp; m-&gt;rec.r.resrec.rrtype == kDNSType_OPT)
        {
            <span class="enscript-type">const</span> rdataOPT *o;
            <span class="enscript-type">const</span> rdataOPT *<span class="enscript-type">const</span> e = (<span class="enscript-type">const</span> rdataOPT *)&amp;m-&gt;rec.r.resrec.rdata-&gt;u.data[m-&gt;rec.r.resrec.rdlength];
            <span class="enscript-keyword">for</span> (o = &amp;m-&gt;rec.r.resrec.rdata-&gt;u.opt[0]; o &lt; e; o++)
                <span class="enscript-keyword">if</span> (o-&gt;opt == kDNSOpt_Lease)
                {
                    *lease = o-&gt;u.updatelease;
                    m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>                    <span class="enscript-keyword">return</span> mDNStrue;
                }
        }
        m-&gt;rec.r.resrec.RecordType = 0;     <span class="enscript-comment">// Clear RecordType to show we're not still using it
</span>    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNS_OP_Name</span>(X) (                              \
        (X) == kDNSFlag0_OP_StdQuery ? <span class="enscript-string">&quot;&quot;</span>         :       \
        (X) == kDNSFlag0_OP_Iquery   ? <span class="enscript-string">&quot;Iquery &quot;</span>  :       \
        (X) == kDNSFlag0_OP_Status   ? <span class="enscript-string">&quot;Status &quot;</span>  :       \
        (X) == kDNSFlag0_OP_Unused3  ? <span class="enscript-string">&quot;Unused3 &quot;</span> :       \
        (X) == kDNSFlag0_OP_Notify   ? <span class="enscript-string">&quot;Notify &quot;</span>  :       \
        (X) == kDNSFlag0_OP_Update   ? <span class="enscript-string">&quot;Update &quot;</span>  :       \
        (X) == kDNSFlag0_OP_DSO      ? <span class="enscript-string">&quot;DSO &quot;</span>  : <span class="enscript-string">&quot;?? &quot;</span> )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNS_RC_Name</span>(X) (                             \
        (X) == kDNSFlag1_RC_NoErr     ? <span class="enscript-string">&quot;NoErr&quot;</span>    :      \
        (X) == kDNSFlag1_RC_FormErr   ? <span class="enscript-string">&quot;FormErr&quot;</span>  :      \
        (X) == kDNSFlag1_RC_ServFail  ? <span class="enscript-string">&quot;ServFail&quot;</span> :      \
        (X) == kDNSFlag1_RC_NXDomain  ? <span class="enscript-string">&quot;NXDomain&quot;</span> :      \
        (X) == kDNSFlag1_RC_NotImpl   ? <span class="enscript-string">&quot;NotImpl&quot;</span>  :      \
        (X) == kDNSFlag1_RC_Refused   ? <span class="enscript-string">&quot;Refused&quot;</span>  :      \
        (X) == kDNSFlag1_RC_YXDomain  ? <span class="enscript-string">&quot;YXDomain&quot;</span> :      \
        (X) == kDNSFlag1_RC_YXRRSet   ? <span class="enscript-string">&quot;YXRRSet&quot;</span>  :      \
        (X) == kDNSFlag1_RC_NXRRSet   ? <span class="enscript-string">&quot;NXRRSet&quot;</span>  :      \
        (X) == kDNSFlag1_RC_NotAuth   ? <span class="enscript-string">&quot;NotAuth&quot;</span>  :      \
        (X) == kDNSFlag1_RC_NotZone   ? <span class="enscript-string">&quot;NotZone&quot;</span>  :      \
        (X) == kDNSFlag1_RC_DSOTypeNI ? <span class="enscript-string">&quot;DSOTypeNI&quot;</span> : <span class="enscript-string">&quot;??&quot;</span> )

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_snprintf_add</span>(<span class="enscript-type">char</span> **ptr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lim, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
    va_list args;
    mDNSu32 buflen, n;
    <span class="enscript-type">char</span> *<span class="enscript-type">const</span> dst = *ptr;

    buflen = (mDNSu32)(lim - dst);
    <span class="enscript-keyword">if</span> (buflen &gt; 0)
    {
        va_start(args, fmt);
        n = mDNS_vsnprintf(dst, buflen, fmt, args);
        va_end(args);
        *ptr = dst + n;
    }
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DNSTypeString</span>(X) (((X) == kDNSType_A) ? <span class="enscript-string">&quot;A&quot;</span> : DNSTypeName(X))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ReadField16</span>(PTR) ((mDNSu16)((((mDNSu16)((mDNSu8 *)(PTR))[0]) &lt;&lt; 8) | ((mDNSu16)((mDNSu8 *)(PTR))[1])))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ReadField32</span>(PTR) \
    ((mDNSu32)( \
        (((mDNSu32)((mDNSu8 *)(PTR))[0]) &lt;&lt; 24) | \
        (((mDNSu32)((mDNSu8 *)(PTR))[1]) &lt;&lt; 16) | \
        (((mDNSu32)((mDNSu8 *)(PTR))[2]) &lt;&lt;  8) | \
         ((mDNSu32)((mDNSu8 *)(PTR))[3])))

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSMessageDumpToLog</span>(<span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end)
{
    domainname *name = mDNSNULL;
    <span class="enscript-type">const</span> mDNSu8 *ptr = msg-&gt;data;
    domainname nameStorage[2];

    <span class="enscript-type">char</span> questions[512];
    questions[0] = <span class="enscript-string">'\0'</span>;
    <span class="enscript-type">char</span> *questions_dst = questions;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> questions_lim = &amp;questions[512];
    <span class="enscript-keyword">for</span> (mDNSu32 i = 0; i &lt; msg-&gt;h.numQuestions; i++)
    {
        mDNSu16 qtype, qclass;

        name = &amp;nameStorage[0];
        ptr = getDomainName(msg, ptr, end, name);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

        <span class="enscript-keyword">if</span> ((end - ptr) &lt; 4) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        qtype  = ReadField16(&amp;ptr[0]);
        qclass = ReadField16(&amp;ptr[2]);
        ptr += 4;

        mDNS_snprintf_add(&amp;questions_dst, questions_lim, <span class="enscript-string">&quot; %##s %s&quot;</span>, name-&gt;c, DNSTypeString(qtype));
        <span class="enscript-keyword">if</span> (qclass != kDNSClass_IN) mDNS_snprintf_add(&amp;questions_dst, questions_lim, <span class="enscript-string">&quot;/%u&quot;</span>, qclass);
        mDNS_snprintf_add(&amp;questions_dst, questions_lim, <span class="enscript-string">&quot;?&quot;</span>);
    }

    <span class="enscript-type">char</span> rrs[512];
    rrs[0] = <span class="enscript-string">'\0'</span>;
    <span class="enscript-type">char</span> *rrs_dst = rrs;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> rrs_lim = &amp;rrs[512];
    <span class="enscript-type">const</span> mDNSu32 rrcount = msg-&gt;h.numAnswers + msg-&gt;h.numAuthorities + msg-&gt;h.numAdditionals;
    <span class="enscript-keyword">for</span> (mDNSu32 i = 0; i &lt; rrcount; i++)
    {
        mDNSu16 rrtype, rrclass, rdlength;
        mDNSu32 ttl;
        <span class="enscript-type">int</span> handled;
        <span class="enscript-type">const</span> mDNSu8 *rdata;
        <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> previousName = name;

        name = &amp;nameStorage[(name == &amp;nameStorage[0]) ? 1 : 0];
        ptr = getDomainName(msg, ptr, end, name);
        <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

        <span class="enscript-keyword">if</span> ((end - ptr) &lt; 10) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        rrtype   = ReadField16(&amp;ptr[0]);
        rrclass  = ReadField16(&amp;ptr[2]);
        ttl      = ReadField32(&amp;ptr[4]);
        rdlength = ReadField16(&amp;ptr[8]);
        ptr += 10;

        <span class="enscript-keyword">if</span> ((end - ptr) &lt; rdlength) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        rdata = ptr;

        <span class="enscript-keyword">if</span> (i &gt; 0) mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;,&quot;</span>);
        <span class="enscript-keyword">if</span> (!previousName || !SameDomainName(name, previousName)) mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot; %##s&quot;</span>, name);

        mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot; %s&quot;</span>, DNSTypeString(rrtype));
        <span class="enscript-keyword">if</span> (rrclass != kDNSClass_IN) mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;/%u&quot;</span>, rrclass);
        mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot; &quot;</span>);

        handled = mDNSfalse;
        <span class="enscript-keyword">switch</span> (rrtype)
        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:
                <span class="enscript-keyword">if</span> (rdlength == 4)
                {
                    mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;%.4a&quot;</span>, rdata);
                    handled = mDNStrue;
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>:
                <span class="enscript-keyword">if</span> (rdlength == 16)
                {
                    mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;%.16a&quot;</span>, rdata);
                    handled = mDNStrue;
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:
                ptr = getDomainName(msg, rdata, end, name);
                <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

                mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;%##s&quot;</span>, name);
                handled = mDNStrue;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:
            {
                mDNSu32 serial, refresh, retry, expire, minimum;
                domainname *<span class="enscript-type">const</span> mname = &amp;nameStorage[0];
                domainname *<span class="enscript-type">const</span> rname = &amp;nameStorage[1];
                name = mDNSNULL;

                ptr = getDomainName(msg, rdata, end, mname);
                <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

                ptr = getDomainName(msg, ptr, end, rname);
                <span class="enscript-keyword">if</span> (!ptr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

                <span class="enscript-keyword">if</span> ((end - ptr) &lt; 20) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                serial  = ReadField32(&amp;ptr[0]);
                refresh = ReadField32(&amp;ptr[4]);
                retry   = ReadField32(&amp;ptr[8]);
                expire  = ReadField32(&amp;ptr[12]);
                minimum = ReadField32(&amp;ptr[16]);

                mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;%##s %##s %lu %lu %lu %lu %lu&quot;</span>, mname, rname, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)serial,
                                  (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)refresh, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)retry, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)expire, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)minimum);

                handled = mDNStrue;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-reference">default</span>:
                <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">if</span> (!handled) mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot;RDATA[%u]: %.*H&quot;</span>, rdlength, rdlength, rdata);
        mDNS_snprintf_add(&amp;rrs_dst, rrs_lim, <span class="enscript-string">&quot; (%lu)&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)ttl);
        ptr = rdata + rdlength;
    }

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;[Q%u] DNS &quot;</span> PUB_S PUB_S <span class="enscript-string">&quot; (%lu) (flags %02X%02X) RCODE: &quot;</span> PUB_S <span class="enscript-string">&quot; (%d)&quot;</span> PUB_S PUB_S PUB_S PUB_S PUB_S PUB_S <span class="enscript-string">&quot;:&quot;</span>
        PRI_S <span class="enscript-string">&quot; %u/%u/%u &quot;</span> PRI_S,
        mDNSVal16(msg-&gt;h.id),
        DNS_OP_Name(msg-&gt;h.flags.b[0] &amp; kDNSFlag0_OP_Mask),
        (msg-&gt;h.flags.b[0] &amp; kDNSFlag0_QR_Response) ? <span class="enscript-string">&quot;Response&quot;</span> : <span class="enscript-string">&quot;Query&quot;</span>,
        (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(end - (<span class="enscript-type">const</span> mDNSu8 *)msg),
        msg-&gt;h.flags.b[0], msg-&gt;h.flags.b[1],
        DNS_RC_Name(msg-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask),
        msg-&gt;h.flags.b[1] &amp; kDNSFlag1_RC_Mask,
        (msg-&gt;h.flags.b[0] &amp; kDNSFlag0_AA) ? <span class="enscript-string">&quot; AA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        (msg-&gt;h.flags.b[0] &amp; kDNSFlag0_TC) ? <span class="enscript-string">&quot; TC&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        (msg-&gt;h.flags.b[0] &amp; kDNSFlag0_RD) ? <span class="enscript-string">&quot; RD&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        (msg-&gt;h.flags.b[1] &amp; kDNSFlag1_RA) ? <span class="enscript-string">&quot; RA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        (msg-&gt;h.flags.b[1] &amp; kDNSFlag1_AD) ? <span class="enscript-string">&quot; AD&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        (msg-&gt;h.flags.b[1] &amp; kDNSFlag1_CD) ? <span class="enscript-string">&quot; CD&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
        questions, msg-&gt;h.numAnswers, msg-&gt;h.numAuthorities, msg-&gt;h.numAdditionals, rrs);

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// Note: DumpPacket expects the packet header fields in host byte order, not network byte order
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">DumpPacket</span>(mStatus status, mDNSBool sent, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *transport,
    <span class="enscript-type">const</span> mDNSAddr *srcaddr, mDNSIPPort srcport,<span class="enscript-type">const</span> mDNSAddr *dstaddr, mDNSIPPort dstport, <span class="enscript-type">const</span> DNSMessage *<span class="enscript-type">const</span> msg,
    <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> end, mDNSInterfaceID interfaceID)
{
    <span class="enscript-type">const</span> mDNSAddr zeroIPv4Addr = { mDNSAddrType_IPv4, {{{ 0 }}} };
    <span class="enscript-type">char</span> action[32];
    <span class="enscript-keyword">if</span> (!status) mDNS_snprintf(action, <span class="enscript-keyword">sizeof</span>(action), sent ? <span class="enscript-string">&quot;Sent&quot;</span> : <span class="enscript-string">&quot;Received&quot;</span>);
    <span class="enscript-keyword">else</span>         mDNS_snprintf(action, <span class="enscript-keyword">sizeof</span>(action), <span class="enscript-string">&quot;ERROR %d %sing&quot;</span>, status, sent ? <span class="enscript-string">&quot;Send&quot;</span> : <span class="enscript-string">&quot;Receiv&quot;</span>);

    LogRedact(MDNS_LOG_CATEGORY_DEFAULT, MDNS_LOG_INFO,
        <span class="enscript-string">&quot;[Q%u] &quot;</span> PUB_S <span class="enscript-string">&quot; &quot;</span> PUB_S <span class="enscript-string">&quot; DNS Message %lu bytes from &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d to &quot;</span> PRI_IP_ADDR <span class="enscript-string">&quot;:%d via &quot;</span> PUB_S <span class="enscript-string">&quot; (%p)&quot;</span>,
        mDNSVal16(msg-&gt;h.id), action, transport, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(end - (<span class="enscript-type">const</span> mDNSu8 *)msg),
        srcaddr ? srcaddr : &amp;zeroIPv4Addr, mDNSVal16(srcport), dstaddr ? dstaddr : &amp;zeroIPv4Addr, mDNSVal16(dstport),
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">OS_LOG</span>)
        InterfaceNameForID(&amp;mDNSStorage, interfaceID),
#<span class="enscript-reference">else</span>
        <span class="enscript-string">&quot;interface&quot;</span>,
#<span class="enscript-reference">endif</span>
        interfaceID);
    DNSMessageDumpToLog(msg, end);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Packet</span> <span class="enscript-variable-name">Sending</span> <span class="enscript-variable-name">Functions</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Stub definition of TCPSocket_struct so we can access flags field. (Rest of TCPSocket_struct is platform-dependent.)
</span><span class="enscript-type">struct</span> TCPSocket_struct { mDNSIPPort port; TCPSocketFlags flags; <span class="enscript-comment">/* ... */</span> };
<span class="enscript-comment">// Stub definition of UDPSocket_struct so we can access port field. (Rest of UDPSocket_struct is platform-dependent.)
</span><span class="enscript-type">struct</span> UDPSocket_struct { mDNSIPPort     port;  <span class="enscript-comment">/* ... */</span> };

<span class="enscript-comment">// Note: When we sign a DNS message using DNSDigest_SignMessage(), the current real-time clock value is used, which
</span><span class="enscript-comment">// is why we generally defer signing until we send the message, to ensure the signature is as fresh as possible.
</span>mDNSexport mStatus <span class="enscript-function-name">mDNSSendDNSMessage</span>(mDNS *<span class="enscript-type">const</span> m, DNSMessage *<span class="enscript-type">const</span> msg, mDNSu8 *end,
                                      mDNSInterfaceID InterfaceID, TCPSocket *tcpSrc, UDPSocket *udpSrc, <span class="enscript-type">const</span> mDNSAddr *dst,
                                      mDNSIPPort dstport, DomainAuthInfo *authInfo, mDNSBool useBackgroundTrafficClass)
{
    mStatus status = mStatus_NoError;
    <span class="enscript-type">const</span> mDNSu16 numAdditionals = msg-&gt;h.numAdditionals;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>
    <span class="enscript-comment">// maintain outbound packet statistics
</span>    <span class="enscript-keyword">if</span> (mDNSOpaque16IsZero(msg-&gt;h.id))
        m-&gt;MulticastPacketsSent++;
    <span class="enscript-keyword">else</span>
        m-&gt;UnicastPacketsSent++;
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">APPLE_OSX_mDNSResponder</span>

    <span class="enscript-comment">// Zero-length message data is okay (e.g. for a DNS Update ack, where all we need is an ID and an error code
</span>    <span class="enscript-keyword">if</span> (end &lt; msg-&gt;data || end - msg-&gt;data &gt; AbsoluteMaxDNSMessageData)
    {
        LogMsg(<span class="enscript-string">&quot;mDNSSendDNSMessage: invalid message %p %p %d&quot;</span>, msg-&gt;data, end, end - msg-&gt;data);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    <span class="enscript-comment">// Put all the integer values in IETF byte-order (MSB first, LSB second)
</span>    SwapDNSHeaderBytes(msg);

    <span class="enscript-keyword">if</span> (authInfo) DNSDigest_SignMessage(msg, &amp;end, authInfo, 0);    <span class="enscript-comment">// DNSDigest_SignMessage operates on message in network byte order
</span>    <span class="enscript-keyword">if</span> (!end) { LogMsg(<span class="enscript-string">&quot;mDNSSendDNSMessage: DNSDigest_SignMessage failed&quot;</span>); status = mStatus_NoMemoryErr; }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Send the packet on the wire
</span>        <span class="enscript-keyword">if</span> (!tcpSrc)
            status = mDNSPlatformSendUDP(m, msg, end, InterfaceID, udpSrc, dst, dstport, useBackgroundTrafficClass);
        <span class="enscript-keyword">else</span>
        {
            mDNSu16 msglen = (mDNSu16)(end - (mDNSu8 *)msg);
            mDNSu8 lenbuf[2] = { (mDNSu8)(msglen &gt;&gt; 8), (mDNSu8)(msglen &amp; 0xFF) };
            <span class="enscript-type">char</span> *buf;
            <span class="enscript-type">long</span> nsent;

            <span class="enscript-comment">// Try to send them in one packet if we can allocate enough memory
</span>            buf = (<span class="enscript-type">char</span> *) mDNSPlatformMemAllocate(msglen + 2);
            <span class="enscript-keyword">if</span> (buf)
            {
                buf[0] = lenbuf[0];
                buf[1] = lenbuf[1];
                mDNSPlatformMemCopy(buf+2, msg, msglen);
                nsent = mDNSPlatformWriteTCP(tcpSrc, buf, msglen+2);
                <span class="enscript-keyword">if</span> (nsent != (msglen + 2))
                {
                    LogMsg(<span class="enscript-string">&quot;mDNSSendDNSMessage: write message failed %d/%d&quot;</span>, nsent, msglen);
                    status = mStatus_ConnFailed;
                }
                mDNSPlatformMemFree(buf);
            }
            <span class="enscript-keyword">else</span>
            {
                nsent = mDNSPlatformWriteTCP(tcpSrc, (<span class="enscript-type">char</span>*)lenbuf, 2);
                <span class="enscript-keyword">if</span> (nsent != 2)
                {
                    LogMsg(<span class="enscript-string">&quot;mDNSSendDNSMessage: write msg length failed %d/%d&quot;</span>, nsent, 2);
                    status = mStatus_ConnFailed;
                }
                <span class="enscript-keyword">else</span>
                {
                    nsent = mDNSPlatformWriteTCP(tcpSrc, (<span class="enscript-type">char</span> *)msg, msglen);
                    <span class="enscript-keyword">if</span> (nsent != msglen)
                    {
                        LogMsg(<span class="enscript-string">&quot;mDNSSendDNSMessage: write msg body failed %d/%d&quot;</span>, nsent, msglen);
                        status = mStatus_ConnFailed;
                    }
                }
            }
        }
    }

    <span class="enscript-comment">// Swap the integer values back the way they were (remember that numAdditionals may have been changed by putHINFO and/or SignMessage)
</span>    SwapDNSHeaderBytes(msg);

    <span class="enscript-comment">// Dump the packet with the HINFO and TSIG
</span>    <span class="enscript-keyword">if</span> (mDNS_PacketLoggingEnabled &amp;&amp; !mDNSOpaque16IsZero(msg-&gt;h.id))
    {
        <span class="enscript-type">char</span> *transport = <span class="enscript-string">&quot;UDP&quot;</span>;
        mDNSIPPort portNumber = udpSrc ? udpSrc-&gt;port : MulticastDNSPort;
        <span class="enscript-keyword">if</span> (tcpSrc)
        {
            <span class="enscript-keyword">if</span> (tcpSrc-&gt;flags)
                transport = <span class="enscript-string">&quot;TLS&quot;</span>;
            <span class="enscript-keyword">else</span>
                transport = <span class="enscript-string">&quot;TCP&quot;</span>;
            portNumber = tcpSrc-&gt;port;
        }
        DumpPacket(status, mDNStrue, transport, mDNSNULL, portNumber, dst, dstport, msg, end, InterfaceID);
    }

    <span class="enscript-comment">// put the number of additionals back the way it was
</span>    msg-&gt;h.numAdditionals = numAdditionals;

    <span class="enscript-keyword">return</span>(status);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">RR</span> <span class="enscript-variable-name">List</span> <span class="enscript-variable-name">Management</span> &amp; <span class="enscript-variable-name">Task</span> <span class="enscript-variable-name">Management</span>
#<span class="enscript-reference">endif</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_Lock_</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-type">const</span> functionname)
{
    <span class="enscript-comment">// MUST grab the platform lock FIRST!
</span>    mDNSPlatformLock(m);

    <span class="enscript-comment">// Normally, mDNS_reentrancy is zero and so is mDNS_busy
</span>    <span class="enscript-comment">// However, when we call a client callback mDNS_busy is one, and we increment mDNS_reentrancy too
</span>    <span class="enscript-comment">// If that client callback does mDNS API calls, mDNS_reentrancy and mDNS_busy will both be one
</span>    <span class="enscript-comment">// If mDNS_busy != mDNS_reentrancy that's a bad sign
</span>    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy != m-&gt;mDNS_reentrancy)
        LogFatalError(<span class="enscript-string">&quot;%s: mDNS_Lock: Locking failure! mDNS_busy (%ld) != mDNS_reentrancy (%ld)&quot;</span>, functionname, m-&gt;mDNS_busy, m-&gt;mDNS_reentrancy);

    <span class="enscript-comment">// If this is an initial entry into the mDNSCore code, set m-&gt;timenow
</span>    <span class="enscript-comment">// else, if this is a re-entrant entry into the mDNSCore code, m-&gt;timenow should already be set
</span>    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy == 0)
    {
        <span class="enscript-keyword">if</span> (m-&gt;timenow)
            LogMsg(<span class="enscript-string">&quot;%s: mDNS_Lock: m-&gt;timenow already set (%ld/%ld)&quot;</span>, functionname, m-&gt;timenow, mDNS_TimeNow_NoLock(m));
        m-&gt;timenow = mDNS_TimeNow_NoLock(m);
        <span class="enscript-keyword">if</span> (m-&gt;timenow == 0) m-&gt;timenow = 1;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;timenow == 0)
    {
        LogMsg(<span class="enscript-string">&quot;%s: mDNS_Lock: m-&gt;mDNS_busy is %ld but m-&gt;timenow not set&quot;</span>, functionname, m-&gt;mDNS_busy);
        m-&gt;timenow = mDNS_TimeNow_NoLock(m);
        <span class="enscript-keyword">if</span> (m-&gt;timenow == 0) m-&gt;timenow = 1;
    }

    <span class="enscript-keyword">if</span> (m-&gt;timenow_last - m-&gt;timenow &gt; 0)
    {
        m-&gt;timenow_adjust += m-&gt;timenow_last - m-&gt;timenow;
        LogMsg(<span class="enscript-string">&quot;%s: mDNSPlatformRawTime went backwards by %ld ticks; setting correction factor to %ld&quot;</span>, functionname, m-&gt;timenow_last - m-&gt;timenow, m-&gt;timenow_adjust);
        m-&gt;timenow = m-&gt;timenow_last;
    }
    m-&gt;timenow_last = m-&gt;timenow;

    <span class="enscript-comment">// Increment mDNS_busy so we'll recognise re-entrant calls
</span>    m-&gt;mDNS_busy++;
}

mDNSlocal AuthRecord *<span class="enscript-function-name">AnyLocalRecordReady</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m)
{
    AuthRecord *rr;
    <span class="enscript-keyword">for</span> (rr = m-&gt;NewLocalRecords; rr; rr = rr-&gt;next)
        <span class="enscript-keyword">if</span> (LocalRecordReady(rr)) <span class="enscript-keyword">return</span> rr;
    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSlocal mDNSs32 <span class="enscript-function-name">GetNextScheduledEvent</span>(<span class="enscript-type">const</span> mDNS *<span class="enscript-type">const</span> m)
{
    mDNSs32 e = m-&gt;timenow + FutureTime;
    <span class="enscript-keyword">if</span> (m-&gt;mDNSPlatformStatus != mStatus_NoError) <span class="enscript-keyword">return</span>(e);
    <span class="enscript-keyword">if</span> (m-&gt;NewQuestions)
    {
        <span class="enscript-keyword">if</span> (m-&gt;NewQuestions-&gt;DelayAnswering) e = m-&gt;NewQuestions-&gt;DelayAnswering;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span>(m-&gt;timenow);
    }
    <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyQuestions) <span class="enscript-keyword">return</span>(m-&gt;timenow);
    <span class="enscript-keyword">if</span> (m-&gt;NewLocalRecords &amp;&amp; AnyLocalRecordReady(m)) <span class="enscript-keyword">return</span>(m-&gt;timenow);
    <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyRecords) <span class="enscript-keyword">return</span>(m-&gt;timenow);
    <span class="enscript-keyword">if</span> (m-&gt;SPSProxyListChanged) <span class="enscript-keyword">return</span>(m-&gt;timenow);
    <span class="enscript-keyword">if</span> (m-&gt;LocalRemoveEvents) <span class="enscript-keyword">return</span>(m-&gt;timenow);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (e - m-&gt;NextuDNSEvent         &gt; 0) e = m-&gt;NextuDNSEvent;
    <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledNATOp    &gt; 0) e = m-&gt;NextScheduledNATOp;
    <span class="enscript-keyword">if</span> (m-&gt;NextSRVUpdate &amp;&amp; e - m-&gt;NextSRVUpdate &gt; 0) e = m-&gt;NextSRVUpdate;
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (e - m-&gt;NextCacheCheck        &gt; 0) e = m-&gt;NextCacheCheck;
    <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledSPS      &gt; 0) e = m-&gt;NextScheduledSPS;
    <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledKA       &gt; 0) e = m-&gt;NextScheduledKA;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MDNSRESPONDER_SUPPORTS</span>(<span class="enscript-variable-name">APPLE</span>, <span class="enscript-variable-name">BONJOUR_ON_DEMAND</span>)
    <span class="enscript-keyword">if</span> (m-&gt;NextBonjourDisableTime &amp;&amp; (e - m-&gt;NextBonjourDisableTime &gt; 0)) e = m-&gt;NextBonjourDisableTime;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// NextScheduledSPRetry only valid when DelaySleep not set
</span>    <span class="enscript-keyword">if</span> (!m-&gt;DelaySleep &amp;&amp; m-&gt;SleepLimit &amp;&amp; e - m-&gt;NextScheduledSPRetry &gt; 0) e = m-&gt;NextScheduledSPRetry;
    <span class="enscript-keyword">if</span> (m-&gt;DelaySleep &amp;&amp; e - m-&gt;DelaySleep &gt; 0) e = m-&gt;DelaySleep;

    <span class="enscript-keyword">if</span> (m-&gt;SuppressSending)
    {
        <span class="enscript-keyword">if</span> (e - m-&gt;SuppressSending       &gt; 0) e = m-&gt;SuppressSending;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledQuery    &gt; 0) e = m-&gt;NextScheduledQuery;
        <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledProbe    &gt; 0) e = m-&gt;NextScheduledProbe;
        <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledResponse &gt; 0) e = m-&gt;NextScheduledResponse;
    }
    <span class="enscript-keyword">if</span> (e - m-&gt;NextScheduledStopTime &gt; 0) e = m-&gt;NextScheduledStopTime;

    <span class="enscript-keyword">if</span> (m-&gt;NextBLEServiceTime &amp;&amp; (e - m-&gt;NextBLEServiceTime &gt; 0)) e = m-&gt;NextBLEServiceTime;

    <span class="enscript-keyword">return</span>(e);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LogTSE</span> TSE++,LogMsg

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ShowTaskSchedulingError</span>(mDNS *<span class="enscript-type">const</span> m)
{
    <span class="enscript-type">int</span> TSE = 0;
    AuthRecord *rr;
    mDNS_Lock(m);

    LogMsg(<span class="enscript-string">&quot;Task Scheduling Error: *** Continuously busy for more than a second&quot;</span>);

    <span class="enscript-comment">// Note: To accurately diagnose *why* we're busy, the debugging code here needs to mirror the logic in GetNextScheduledEvent above
</span>
    <span class="enscript-keyword">if</span> (m-&gt;NewQuestions &amp;&amp; (!m-&gt;NewQuestions-&gt;DelayAnswering || m-&gt;timenow - m-&gt;NewQuestions-&gt;DelayAnswering &gt;= 0))
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: NewQuestion %##s (%s)&quot;</span>,
               m-&gt;NewQuestions-&gt;qname.c, DNSTypeName(m-&gt;NewQuestions-&gt;qtype));

    <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyQuestions)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: NewLocalOnlyQuestions %##s (%s)&quot;</span>,
               m-&gt;NewLocalOnlyQuestions-&gt;qname.c, DNSTypeName(m-&gt;NewLocalOnlyQuestions-&gt;qtype));

    <span class="enscript-keyword">if</span> (m-&gt;NewLocalRecords)
    {
        rr = AnyLocalRecordReady(m);
        <span class="enscript-keyword">if</span> (rr) LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: NewLocalRecords %s&quot;</span>, ARDisplayString(m, rr));
    }

    <span class="enscript-keyword">if</span> (m-&gt;NewLocalOnlyRecords) LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: NewLocalOnlyRecords&quot;</span>);

    <span class="enscript-keyword">if</span> (m-&gt;SPSProxyListChanged) LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: SPSProxyListChanged&quot;</span>);

    <span class="enscript-keyword">if</span> (m-&gt;LocalRemoveEvents) LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: LocalRemoveEvents&quot;</span>);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UNICAST_DISABLED</span>
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextuDNSEvent         &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextuDNSEvent %d&quot;</span>,         m-&gt;timenow - m-&gt;NextuDNSEvent);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledNATOp    &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledNATOp %d&quot;</span>,    m-&gt;timenow - m-&gt;NextScheduledNATOp);
    <span class="enscript-keyword">if</span> (m-&gt;NextSRVUpdate &amp;&amp; m-&gt;timenow - m-&gt;NextSRVUpdate &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextSRVUpdate %d&quot;</span>,         m-&gt;timenow - m-&gt;NextSRVUpdate);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextCacheCheck        &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextCacheCheck %d&quot;</span>,        m-&gt;timenow - m-&gt;NextCacheCheck);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledSPS      &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledSPS %d&quot;</span>,      m-&gt;timenow - m-&gt;NextScheduledSPS);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledKA       &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledKA %d&quot;</span>,      m-&gt;timenow - m-&gt;NextScheduledKA);
    <span class="enscript-keyword">if</span> (!m-&gt;DelaySleep &amp;&amp; m-&gt;SleepLimit &amp;&amp; m-&gt;timenow - m-&gt;NextScheduledSPRetry &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledSPRetry %d&quot;</span>,  m-&gt;timenow - m-&gt;NextScheduledSPRetry);
    <span class="enscript-keyword">if</span> (m-&gt;DelaySleep &amp;&amp; m-&gt;timenow - m-&gt;DelaySleep &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;DelaySleep %d&quot;</span>,            m-&gt;timenow - m-&gt;DelaySleep);

    <span class="enscript-keyword">if</span> (m-&gt;SuppressSending &amp;&amp; m-&gt;timenow - m-&gt;SuppressSending &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;SuppressSending %d&quot;</span>,       m-&gt;timenow - m-&gt;SuppressSending);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledQuery    &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledQuery %d&quot;</span>,    m-&gt;timenow - m-&gt;NextScheduledQuery);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledProbe    &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledProbe %d&quot;</span>,    m-&gt;timenow - m-&gt;NextScheduledProbe);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledResponse &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledResponse %d&quot;</span>, m-&gt;timenow - m-&gt;NextScheduledResponse);
    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledStopTime &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledStopTime %d&quot;</span>, m-&gt;timenow - m-&gt;NextScheduledStopTime);

    <span class="enscript-keyword">if</span> (m-&gt;timenow - m-&gt;NextScheduledEvent    &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: m-&gt;NextScheduledEvent %d&quot;</span>,    m-&gt;timenow - m-&gt;NextScheduledEvent);

    <span class="enscript-keyword">if</span> (m-&gt;NetworkChanged &amp;&amp; m-&gt;timenow - m-&gt;NetworkChanged &gt;= 0)
        LogTSE(<span class="enscript-string">&quot;Task Scheduling Error: NetworkChanged %d&quot;</span>,           m-&gt;timenow - m-&gt;NetworkChanged);

    <span class="enscript-keyword">if</span> (!TSE) LogMsg(<span class="enscript-string">&quot;Task Scheduling Error: *** No likely causes identified&quot;</span>);
    <span class="enscript-keyword">else</span> LogMsg(<span class="enscript-string">&quot;Task Scheduling Error: *** %d potential cause%s identified (significant only if the same cause consistently appears)&quot;</span>, TSE, TSE &gt; 1 ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

    mDNS_Unlock(m);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">mDNS_Unlock_</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> functionname)
{
    <span class="enscript-comment">// Decrement mDNS_busy
</span>    m-&gt;mDNS_busy--;

    <span class="enscript-comment">// Check for locking failures
</span>    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy != m-&gt;mDNS_reentrancy)
        LogFatalError(<span class="enscript-string">&quot;%s: mDNS_Unlock: Locking failure! mDNS_busy (%ld) != mDNS_reentrancy (%ld)&quot;</span>, functionname, m-&gt;mDNS_busy, m-&gt;mDNS_reentrancy);

    <span class="enscript-comment">// If this is a final exit from the mDNSCore code, set m-&gt;NextScheduledEvent and clear m-&gt;timenow
</span>    <span class="enscript-keyword">if</span> (m-&gt;mDNS_busy == 0)
    {
        m-&gt;NextScheduledEvent = GetNextScheduledEvent(m);
        <span class="enscript-keyword">if</span> (m-&gt;timenow == 0) LogMsg(<span class="enscript-string">&quot;%s: mDNS_Unlock: ERROR! m-&gt;timenow aready zero&quot;</span>, functionname);
        m-&gt;timenow = 0;
    }

    <span class="enscript-comment">// MUST release the platform lock LAST!
</span>    mDNSPlatformUnlock(m);
}

<span class="enscript-comment">// ***************************************************************************
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPILER_LIKES_PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> - <span class="enscript-variable-name">Specialized</span> <span class="enscript-variable-name">mDNS</span> <span class="enscript-variable-name">version</span> <span class="enscript-variable-name">of</span> <span class="enscript-variable-name">vsnprintf</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> mDNSprintf_format
{
    <span class="enscript-type">unsigned</span> leftJustify : 1;
    <span class="enscript-type">unsigned</span> forceSign : 1;
    <span class="enscript-type">unsigned</span> zeroPad : 1;
    <span class="enscript-type">unsigned</span> havePrecision : 1;
    <span class="enscript-type">unsigned</span> hSize : 1;
    <span class="enscript-type">unsigned</span> lSize : 1;
    <span class="enscript-type">char</span> altForm;
    <span class="enscript-type">char</span> sign;              <span class="enscript-comment">// +, - or space
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fieldWidth;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> precision;
} mDNSprintf_format_default = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHexDigitsLowercase</span> <span class="enscript-string">&quot;0123456789abcdef&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHexDigitsUppercase</span> <span class="enscript-string">&quot;0123456789ABCDEF&quot;</span>;

mDNSexport mDNSu32 <span class="enscript-function-name">mDNS_vsnprintf</span>(<span class="enscript-type">char</span> *sbuffer, mDNSu32 buflen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, va_list arg)
{
    mDNSu32 nwritten = 0;
    <span class="enscript-type">int</span> c;
    <span class="enscript-keyword">if</span> (buflen == 0) <span class="enscript-keyword">return</span>(0);
    buflen--;       <span class="enscript-comment">// Pre-reserve one space in the buffer for the terminating null
</span>    <span class="enscript-keyword">if</span> (buflen == 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">for</span> (c = *fmt; c != 0; c = *++fmt)
    {
        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> n;
        <span class="enscript-type">int</span> hexdump = mDNSfalse;
		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'%'</span>)
        {
            *sbuffer++ = (<span class="enscript-type">char</span>)c;
            <span class="enscript-keyword">if</span> (++nwritten &gt;= buflen) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i=0, j;
            <span class="enscript-comment">// The mDNS Vsprintf Argument Conversion Buffer is used as a temporary holding area for
</span>            <span class="enscript-comment">// generating decimal numbers, hexdecimal numbers, IP addresses, domain name strings, etc.
</span>            <span class="enscript-comment">// The size needs to be enough for a 256-byte domain name plus some error text.
</span>            #define mDNS_VACB_Size 300
            <span class="enscript-type">char</span> mDNS_VACB[mDNS_VACB_Size];
            #define mDNS_VACB_Lim (&amp;mDNS_VACB[mDNS_VACB_Size])
            #define mDNS_VACB_Remain(s) ((mDNSu32)(mDNS_VACB_Lim - s))
            <span class="enscript-type">char</span> *s = mDNS_VACB_Lim, *digits;
            <span class="enscript-type">struct</span> mDNSprintf_format F = mDNSprintf_format_default;

            <span class="enscript-keyword">while</span> (1)   <span class="enscript-comment">//  decode flags
</span>            {
                c = *++fmt;
                <span class="enscript-keyword">if</span>      (c == <span class="enscript-string">'-'</span>) F.leftJustify = 1;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'+'</span>) F.forceSign = 1;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">' '</span>) F.sign = <span class="enscript-string">' '</span>;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'#'</span>) F.altForm++;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'0'</span>) F.zeroPad = 1;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'*'</span>)   <span class="enscript-comment">//  decode field width
</span>            {
                <span class="enscript-type">int</span> f = va_arg(arg, <span class="enscript-type">int</span>);
                <span class="enscript-keyword">if</span> (f &lt; 0) { f = -f; F.leftJustify = 1; }
                F.fieldWidth = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)f;
                c = *++fmt;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">for</span> (; c &gt;= <span class="enscript-string">'0'</span> &amp;&amp; c &lt;= <span class="enscript-string">'9'</span>; c = *++fmt)
                    F.fieldWidth = (10 * F.fieldWidth) + (c - <span class="enscript-string">'0'</span>);
            }

            <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'.'</span>)   <span class="enscript-comment">//  decode precision
</span>            {
                <span class="enscript-keyword">if</span> ((c = *++fmt) == <span class="enscript-string">'*'</span>)
                { F.precision = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>); c = *++fmt; }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">for</span> (; c &gt;= <span class="enscript-string">'0'</span> &amp;&amp; c &lt;= <span class="enscript-string">'9'</span>; c = *++fmt)
                        F.precision = (10 * F.precision) + (c - <span class="enscript-string">'0'</span>);
                F.havePrecision = 1;
            }

            <span class="enscript-keyword">if</span> (F.leftJustify) F.zeroPad = 0;

<span class="enscript-reference">conv</span>:
            <span class="enscript-keyword">switch</span> (c)  <span class="enscript-comment">//  perform appropriate conversion
</span>            {
            <span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>:  F.hSize = 1; c = *++fmt; <span class="enscript-keyword">goto</span> <span class="enscript-reference">conv</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'l'</span>:       <span class="enscript-comment">// fall through
</span>            <span class="enscript-keyword">case</span> <span class="enscript-string">'L'</span>:  F.lSize = 1; c = *++fmt; <span class="enscript-keyword">goto</span> <span class="enscript-reference">conv</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-string">'i'</span>:  <span class="enscript-keyword">if</span> (F.lSize) n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)va_arg(arg, <span class="enscript-type">long</span>);
                <span class="enscript-keyword">else</span> n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)va_arg(arg, <span class="enscript-type">int</span>);
                <span class="enscript-keyword">if</span> (F.hSize) n = (<span class="enscript-type">short</span>) n;
                <span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span>) n &lt; 0) { n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)-(<span class="enscript-type">long</span>)n; F.sign = <span class="enscript-string">'-'</span>; }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (F.forceSign) F.sign = <span class="enscript-string">'+'</span>;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">decimal</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'u'</span>:  <span class="enscript-keyword">if</span> (F.lSize) n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>);
                <span class="enscript-keyword">else</span> n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
                <span class="enscript-keyword">if</span> (F.hSize) n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>) n;
                F.sign = 0;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">decimal</span>;
<span class="enscript-reference">decimal</span>:    <span class="enscript-keyword">if</span> (!F.havePrecision)
                {
                    <span class="enscript-keyword">if</span> (F.zeroPad)
                    {
                        F.precision = F.fieldWidth;
                        <span class="enscript-keyword">if</span> (F.sign) --F.precision;
                    }
                    <span class="enscript-keyword">if</span> (F.precision &lt; 1) F.precision = 1;
                }
                <span class="enscript-keyword">if</span> (F.precision &gt; mDNS_VACB_Size - 1)
                    F.precision = mDNS_VACB_Size - 1;
                <span class="enscript-keyword">for</span> (i = 0; n; n /= 10, i++) *--s = (<span class="enscript-type">char</span>)(n % 10 + <span class="enscript-string">'0'</span>);
                <span class="enscript-keyword">for</span> (; i &lt; F.precision; i++) *--s = <span class="enscript-string">'0'</span>;
                <span class="enscript-keyword">if</span> (F.sign) { *--s = F.sign; i++; }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'o'</span>:  <span class="enscript-keyword">if</span> (F.lSize) n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>);
                <span class="enscript-keyword">else</span> n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
                <span class="enscript-keyword">if</span> (F.hSize) n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>) n;
                <span class="enscript-keyword">if</span> (!F.havePrecision)
                {
                    <span class="enscript-keyword">if</span> (F.zeroPad) F.precision = F.fieldWidth;
                    <span class="enscript-keyword">if</span> (F.precision &lt; 1) F.precision = 1;
                }
                <span class="enscript-keyword">if</span> (F.precision &gt; mDNS_VACB_Size - 1)
                    F.precision = mDNS_VACB_Size - 1;
                <span class="enscript-keyword">for</span> (i = 0; n; n /= 8, i++) *--s = (<span class="enscript-type">char</span>)(n % 8 + <span class="enscript-string">'0'</span>);
                <span class="enscript-keyword">if</span> (F.altForm &amp;&amp; i &amp;&amp; *s != <span class="enscript-string">'0'</span>) { *--s = <span class="enscript-string">'0'</span>; i++; }
                <span class="enscript-keyword">for</span> (; i &lt; F.precision; i++) *--s = <span class="enscript-string">'0'</span>;
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'a'</span>:  {
                <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *a = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *);
                <span class="enscript-keyword">if</span> (!a) { <span class="enscript-type">static</span> <span class="enscript-type">char</span> emsg[] = <span class="enscript-string">&quot;&lt;&lt;NULL&gt;&gt;&quot;</span>; s = emsg; i = <span class="enscript-keyword">sizeof</span>(emsg)-1; }
                <span class="enscript-keyword">else</span>
                {
                    s = mDNS_VACB;              <span class="enscript-comment">// Adjust s to point to the start of the buffer, not the end
</span>                    <span class="enscript-keyword">if</span> (F.altForm)
                    {
                        mDNSAddr *ip = (mDNSAddr*)a;
                        <span class="enscript-keyword">switch</span> (ip-&gt;type)
                        {
                        <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv4</span>: F.precision =  4; a = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)&amp;ip-&gt;ip.v4; <span class="enscript-keyword">break</span>;
                        <span class="enscript-keyword">case</span> <span class="enscript-reference">mDNSAddrType_IPv6</span>: F.precision = 16; a = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)&amp;ip-&gt;ip.v6; <span class="enscript-keyword">break</span>;
                        <span class="enscript-reference">default</span>:                F.precision =  0; <span class="enscript-keyword">break</span>;
                        }
                    }
                    <span class="enscript-keyword">if</span> (F.altForm &amp;&amp; !F.precision)
                        i = mDNS_snprintf(mDNS_VACB, <span class="enscript-keyword">sizeof</span>(mDNS_VACB), <span class="enscript-string">&quot;Â«ZERO ADDRESSÂ»&quot;</span>);
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">switch</span> (F.precision)
                        {
                        <span class="enscript-keyword">case</span>  <span class="enscript-reference">4</span>: i = mDNS_snprintf(mDNS_VACB, <span class="enscript-keyword">sizeof</span>(mDNS_VACB), <span class="enscript-string">&quot;%d.%d.%d.%d&quot;</span>,
                                                   a[0], a[1], a[2], a[3]); <span class="enscript-keyword">break</span>;
                        <span class="enscript-keyword">case</span>  <span class="enscript-reference">6</span>: i = mDNS_snprintf(mDNS_VACB, <span class="enscript-keyword">sizeof</span>(mDNS_VACB), <span class="enscript-string">&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;</span>,
                                                   a[0], a[1], a[2], a[3], a[4], a[5]); <span class="enscript-keyword">break</span>;
                        <span class="enscript-keyword">case</span> <span class="enscript-reference">16</span>: {
                            <span class="enscript-comment">// Print IPv6 addresses according to RFC 5952, A Recommendation for IPv6 Address Text
</span>                            <span class="enscript-comment">// Representation. See &lt;<a href="https://tools.ietf.org/html/rfc5952">https://tools.ietf.org/html/rfc5952</a>&gt;.
</span>
                            <span class="enscript-type">int</span> idx, runLen = 0, runStart = 0, maxRunLen = 0, maxRunStart = 0, maxRunEnd;

                            <span class="enscript-comment">// Find the leftmost longest run of consecutive zero hextets.
</span>                            <span class="enscript-keyword">for</span> (idx = 0; idx &lt; 8; ++idx)
                            {
                                <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hextet = (a[idx * 2] &lt;&lt; 8) | a[(idx * 2) + 1];
                                <span class="enscript-keyword">if</span> (hextet == 0)
                                {
                                    <span class="enscript-keyword">if</span> (runLen++ == 0) runStart = idx;
                                    <span class="enscript-keyword">if</span> (runLen &gt; maxRunLen)
                                    {
                                        maxRunStart = runStart;
                                        maxRunLen   = runLen;
                                    }
                                }
                                <span class="enscript-keyword">else</span>
                                {
                                    <span class="enscript-comment">// If the number of remaining hextets is less than or equal to the length of the longest
</span>                                    <span class="enscript-comment">// run so far, then we've found the leftmost longest run.
</span>                                    <span class="enscript-keyword">if</span> ((8 - (idx + 1)) &lt;= maxRunLen) <span class="enscript-keyword">break</span>;
                                    runLen = 0;
                                }
                            }

                            <span class="enscript-comment">// Compress the leftmost longest run of two or more consecutive zero hextets as &quot;::&quot;.
</span>                            <span class="enscript-comment">// For each reminaing hextet, suppress zeros leading up to the least-significant nibble, which
</span>                            <span class="enscript-comment">// is always written, even if it's zero. Because of this requirement, it's easier to write the
</span>                            <span class="enscript-comment">// IPv6 address in reverse. Also, write a colon separator before each hextet except for the
</span>                            <span class="enscript-comment">// first one.
</span>                            s = mDNS_VACB_Lim;
                            maxRunEnd = (maxRunLen &gt;= 2) ? (maxRunStart + maxRunLen - 1) : -1;
                            <span class="enscript-keyword">for</span> (idx = 7; idx &gt;= 0; --idx)
                            {
                                <span class="enscript-keyword">if</span> (idx == maxRunEnd)
                                {
                                    <span class="enscript-keyword">if</span> (idx == 7) *--s = <span class="enscript-string">':'</span>;
                                    idx = maxRunStart;
                                    *--s = <span class="enscript-string">':'</span>;
                                }
                                <span class="enscript-keyword">else</span>
                                {
                                    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hextet = (a[idx * 2] &lt;&lt; 8) | a[(idx * 2) + 1];
                                    <span class="enscript-keyword">do</span> {
                                        *--s = kHexDigitsLowercase[hextet % 16];
                                        hextet /= 16;
                                    } <span class="enscript-keyword">while</span> (hextet);
                                    <span class="enscript-keyword">if</span> (idx &gt; 0) *--s = <span class="enscript-string">':'</span>;
                                }
                            }
                            i = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(mDNS_VACB_Lim - s);
                        }
                        <span class="enscript-keyword">break</span>;

                        <span class="enscript-reference">default</span>: i = mDNS_snprintf(mDNS_VACB, <span class="enscript-keyword">sizeof</span>(mDNS_VACB), <span class="enscript-string">&quot;%s&quot;</span>, <span class="enscript-string">&quot;&lt;&lt; ERROR: Must specify&quot;</span>
                                                   <span class="enscript-string">&quot; address size (i.e. %.4a=IPv4, %.6a=Ethernet, %.16a=IPv6) &gt;&gt;&quot;</span>); <span class="enscript-keyword">break</span>;
                        }
                }
            }
            <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:  F.havePrecision = F.lSize = 1;
                F.precision = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span>*) * 2;                <span class="enscript-comment">// 8 characters on 32-bit; 16 characters on 64-bit
</span>                fallthrough();
            <span class="enscript-keyword">case</span> <span class="enscript-string">'X'</span>:  digits = kHexDigitsUppercase;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">hexadecimal</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>:  digits = kHexDigitsLowercase;
<span class="enscript-reference">hexadecimal</span>: <span class="enscript-keyword">if</span> (F.lSize) n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>);
                <span class="enscript-keyword">else</span> n = va_arg(arg, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
                <span class="enscript-keyword">if</span> (F.hSize) n = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>) n;
                <span class="enscript-keyword">if</span> (!F.havePrecision)
                {
                    <span class="enscript-keyword">if</span> (F.zeroPad)
                    {
                        F.precision = F.fieldWidth;
                        <span class="enscript-keyword">if</span> (F.altForm) F.precision -= 2;
                    }
                    <span class="enscript-keyword">if</span> (F.precision &lt; 1) F.precision = 1;
                }
                <span class="enscript-keyword">if</span> (F.precision &gt; mDNS_VACB_Size - 1)
                    F.precision = mDNS_VACB_Size - 1;
                <span class="enscript-keyword">for</span> (i = 0; n; n /= 16, i++) *--s = digits[n % 16];
                <span class="enscript-keyword">for</span> (; i &lt; F.precision; i++) *--s = <span class="enscript-string">'0'</span>;
                <span class="enscript-keyword">if</span> (F.altForm) { *--s = (<span class="enscript-type">char</span>)c; *--s = <span class="enscript-string">'0'</span>; i += 2; }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:  *--s = (<span class="enscript-type">char</span>)va_arg(arg, <span class="enscript-type">int</span>); i = 1; <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:  s = va_arg(arg, <span class="enscript-type">char</span> *);
                <span class="enscript-keyword">if</span> (!s) { <span class="enscript-type">static</span> <span class="enscript-type">char</span> emsg[] = <span class="enscript-string">&quot;&lt;&lt;NULL&gt;&gt;&quot;</span>; s = emsg; i = <span class="enscript-keyword">sizeof</span>(emsg)-1; }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">switch</span> (F.altForm)
                    {
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: i=0;
                        <span class="enscript-keyword">if</span> (!F.havePrecision)                               <span class="enscript-comment">// C string
</span>                            <span class="enscript-keyword">while</span> (s[i]) i++;
                        <span class="enscript-keyword">else</span>
                        {
                            <span class="enscript-keyword">while</span> ((i &lt; F.precision) &amp;&amp; s[i]) i++;
                            <span class="enscript-comment">// Make sure we don't truncate in the middle of a UTF-8 character
</span>                            <span class="enscript-comment">// If last character we got was any kind of UTF-8 multi-byte character,
</span>                            <span class="enscript-comment">// then see if we have to back up.
</span>                            <span class="enscript-comment">// This is not as easy as the similar checks below, because
</span>                            <span class="enscript-comment">// here we can't assume it's safe to examine the *next* byte, so we
</span>                            <span class="enscript-comment">// have to confine ourselves to working only backwards in the string.
</span>                            j = i;                      <span class="enscript-comment">// Record where we got to
</span>                            <span class="enscript-comment">// Now, back up until we find first non-continuation-char
</span>                            <span class="enscript-keyword">while</span> (i&gt;0 &amp;&amp; (s[i-1] &amp; 0xC0) == 0x80) i--;
                            <span class="enscript-comment">// Now s[i-1] is the first non-continuation-char
</span>                            <span class="enscript-comment">// and (j-i) is the number of continuation-chars we found
</span>                            <span class="enscript-keyword">if</span> (i&gt;0 &amp;&amp; (s[i-1] &amp; 0xC0) == 0xC0)                 <span class="enscript-comment">// If we found a start-char
</span>                            {
                                i--;                        <span class="enscript-comment">// Tentatively eliminate this start-char as well
</span>                                <span class="enscript-comment">// Now (j-i) is the number of characters we're considering eliminating.
</span>                                <span class="enscript-comment">// To be legal UTF-8, the start-char must contain (j-i) one-bits,
</span>                                <span class="enscript-comment">// followed by a zero bit. If we shift it right by (7-(j-i)) bits
</span>                                <span class="enscript-comment">// (with sign extension) then the result has to be 0xFE.
</span>                                <span class="enscript-comment">// If this is right, then we reinstate the tentatively eliminated bytes.
</span>                                <span class="enscript-keyword">if</span> (((j-i) &lt; 7) &amp;&amp; (((s[i] &gt;&gt; (7-(j-i))) &amp; 0xFF) == 0xFE)) i = j;
                            }
                        }
                        <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>: i = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) *s++; <span class="enscript-keyword">break</span>;                <span class="enscript-comment">// Pascal string
</span>                    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>: {                                               <span class="enscript-comment">// DNS label-sequence name
</span>                        <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *a = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)s;
                        s = mDNS_VACB;                  <span class="enscript-comment">// Adjust s to point to the start of the buffer, not the end
</span>                        <span class="enscript-keyword">if</span> (*a == 0) *s++ = <span class="enscript-string">'.'</span>;                    <span class="enscript-comment">// Special case for root DNS name
</span>                        <span class="enscript-keyword">while</span> (*a)
                        {
                            <span class="enscript-type">char</span> buf[63*4+1];
                            <span class="enscript-keyword">if</span> (*a &gt; 63)
                            { s += mDNS_snprintf(s, mDNS_VACB_Remain(s), <span class="enscript-string">&quot;&lt;&lt;INVALID LABEL LENGTH %u&gt;&gt;&quot;</span>, *a); <span class="enscript-keyword">break</span>; }
                            <span class="enscript-keyword">if</span> (s + *a &gt;= &amp;mDNS_VACB[254])
                            { s += mDNS_snprintf(s, mDNS_VACB_Remain(s), <span class="enscript-string">&quot;&lt;&lt;NAME TOO LONG&gt;&gt;&quot;</span>); <span class="enscript-keyword">break</span>; }
                            <span class="enscript-comment">// Need to use ConvertDomainLabelToCString to do proper escaping here,
</span>                            <span class="enscript-comment">// so it's clear what's a literal dot and what's a label separator
</span>                            ConvertDomainLabelToCString((domainlabel*)a, buf);
                            s += mDNS_snprintf(s, mDNS_VACB_Remain(s), <span class="enscript-string">&quot;%s.&quot;</span>, buf);
                            a += 1 + *a;
                        }
                        i = (mDNSu32)(s - mDNS_VACB);
                        s = mDNS_VACB;                  <span class="enscript-comment">// Reset s back to the start of the buffer
</span>                        <span class="enscript-keyword">break</span>;
                    }
                    }
                <span class="enscript-comment">// Make sure we don't truncate in the middle of a UTF-8 character (see similar comment below)
</span>                <span class="enscript-keyword">if</span> (F.havePrecision &amp;&amp; i &gt; F.precision)
                { i = F.precision; <span class="enscript-keyword">while</span> (i&gt;0 &amp;&amp; (s[i] &amp; 0xC0) == 0x80) i--;}
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'H'</span>: {
                    s = va_arg(arg, <span class="enscript-type">char</span> *);
                    hexdump = mDNStrue;
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:  s = va_arg(arg, <span class="enscript-type">char</span> *);
                <span class="enscript-keyword">if</span>      (F.hSize) *(<span class="enscript-type">short</span> *) s = (<span class="enscript-type">short</span>)nwritten;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (F.lSize) *(<span class="enscript-type">long</span>  *) s = (<span class="enscript-type">long</span>)nwritten;
                <span class="enscript-keyword">else</span> *(<span class="enscript-type">int</span>   *) s = (<span class="enscript-type">int</span>)nwritten;
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-reference">default</span>:    s = mDNS_VACB;
                i = mDNS_snprintf(mDNS_VACB, <span class="enscript-keyword">sizeof</span>(mDNS_VACB), <span class="enscript-string">&quot;&lt;&lt;UNKNOWN FORMAT CONVERSION CODE %%%c&gt;&gt;&quot;</span>, c);
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-string">'%'</span>:  *sbuffer++ = (<span class="enscript-type">char</span>)c;
                <span class="enscript-keyword">if</span> (++nwritten &gt;= buflen) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">if</span> (i &lt; F.fieldWidth &amp;&amp; !F.leftJustify)         <span class="enscript-comment">// Pad on the left
</span>                <span class="enscript-keyword">do</span>  {
                    *sbuffer++ = <span class="enscript-string">' '</span>;
                    <span class="enscript-keyword">if</span> (++nwritten &gt;= buflen) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
                } <span class="enscript-keyword">while</span> (i &lt; --F.fieldWidth);

            <span class="enscript-keyword">if</span> (hexdump)
            {
                <span class="enscript-type">char</span> *dst = sbuffer;
                <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> lim = &amp;sbuffer[buflen - nwritten];
                <span class="enscript-keyword">if</span> (F.havePrecision)
                {
                    <span class="enscript-keyword">for</span> (i = 0; (i &lt; F.precision) &amp;&amp; (dst &lt; lim); i++)
                    {
                        <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) *s++;
                        <span class="enscript-keyword">if</span> (i &gt; 0)     *dst++ = <span class="enscript-string">' '</span>;
                        <span class="enscript-keyword">if</span> (dst &lt; lim) *dst++ = kHexDigitsLowercase[(b &gt;&gt; 4) &amp; 0xF];
                        <span class="enscript-keyword">if</span> (dst &lt; lim) *dst++ = kHexDigitsLowercase[ b       &amp; 0xF];
                    }
                }
                i = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(dst - sbuffer);
                sbuffer = dst;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Make sure we don't truncate in the middle of a UTF-8 character.
</span>                <span class="enscript-comment">// Note: s[i] is the first eliminated character; i.e. the next character *after* the last character of the
</span>                <span class="enscript-comment">// allowed output. If s[i] is a UTF-8 continuation character, then we've cut a unicode character in half,
</span>                <span class="enscript-comment">// so back up 'i' until s[i] is no longer a UTF-8 continuation character. (if the input was proprly
</span>                <span class="enscript-comment">// formed, s[i] will now be the UTF-8 start character of the multi-byte character we just eliminated).
</span>                <span class="enscript-keyword">if</span> (i &gt; buflen - nwritten)
                { i = buflen - nwritten; <span class="enscript-keyword">while</span> (i&gt;0 &amp;&amp; (s[i] &amp; 0xC0) == 0x80) i--;}
                <span class="enscript-keyword">for</span> (j=0; j&lt;i; j++) *sbuffer++ = *s++;          <span class="enscript-comment">// Write the converted result
</span>            }
            nwritten += i;
            <span class="enscript-keyword">if</span> (nwritten &gt;= buflen) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

            <span class="enscript-keyword">for</span> (; i &lt; F.fieldWidth; i++)                   <span class="enscript-comment">// Pad on the right
</span>            {
                *sbuffer++ = <span class="enscript-string">' '</span>;
                <span class="enscript-keyword">if</span> (++nwritten &gt;= buflen) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
            }
        }
    }
<span class="enscript-reference">exit</span>:
    *sbuffer++ = 0;
    <span class="enscript-keyword">return</span>(nwritten);
}

mDNSexport mDNSu32 <span class="enscript-function-name">mDNS_snprintf</span>(<span class="enscript-type">char</span> *sbuffer, mDNSu32 buflen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
    mDNSu32 length;

    va_list ptr;
    va_start(ptr,fmt);
    length = mDNS_vsnprintf(sbuffer, buflen, fmt, ptr);
    va_end(ptr);

    <span class="enscript-keyword">return</span>(length);
}

mDNSexport mDNSu32 <span class="enscript-function-name">mDNS_GetNextResolverGroupID</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">static</span> mDNSu32 lastID = 0;
    <span class="enscript-keyword">if</span> (++lastID == 0) lastID = 1; <span class="enscript-comment">// Valid resolver group IDs are non-zero.
</span>    <span class="enscript-keyword">return</span>(lastID);
}

</pre>
<hr />
</body></html>