<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dnssec.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dnssec.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="dnssec.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2011-2019 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSSECSupport.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;dnssec.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoAlg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nsec.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nsec3.h&quot;</span>

<span class="enscript-comment">// Define DNSSEC_DISABLED to remove all the DNSSEC functionality
</span><span class="enscript-comment">// and use the stub functions implemented later in this file.
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DNSSEC_DISABLED</span>

<span class="enscript-comment">//#define DNSSEC_DEBUG
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DNSSEC_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">debugdnssec</span> LogMsg
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">debugdnssec</span> debug_noop
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">//
</span><span class="enscript-comment">// Implementation Notes
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The entry point to DNSSEC Verification is VerifySignature. This function is called from the &quot;core&quot; when
</span><span class="enscript-comment">// the answer delivered to the application needs DNSSEC validation. If a question needs DNSSEC
</span><span class="enscript-comment">// validation, &quot;ValidationRequired&quot; would be set. As we need to issue more queries to validate the
</span><span class="enscript-comment">// original question, we create another question as part of the verification process (question is part of
</span><span class="enscript-comment">// DNSSECVerifier). This question sets &quot;ValidatingResponse&quot; to distinguish itself from the original
</span><span class="enscript-comment">// question. Without this, it will be a duplicate and never sent out. The &quot;core&quot; almost treats both the
</span><span class="enscript-comment">// types identically (like adding EDNS0 option with DO bit etc.) except for a few differences. When RRSIGs
</span><span class="enscript-comment">// are added to the cache, &quot;ValidatingResponse&quot; question gets called back as long as the typeCovered matches
</span><span class="enscript-comment">// the question's qtype. See the comment in DNSSECRecordAnswersQuestion for the details. The other big
</span><span class="enscript-comment">// difference is that &quot;ValidationRequired&quot; question kicks off the verification process by calling into
</span><span class="enscript-comment">// &quot;VerifySignature&quot; whereas ValidationResponse don't do that as it gets callback for its questions.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// VerifySignature does not retain the original question that started the verification process. It just
</span><span class="enscript-comment">// remembers the name and the type. It takes a snapshot of the cache at that instance which will be
</span><span class="enscript-comment">// verified using DNSSEC. If the cache changes subsequently e.g., network change etc., it will be detected
</span><span class="enscript-comment">// when the validation is completed. If there is a change, it will be revalidated.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The verification flow looks like this:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// VerifySignature -&gt; StartDNSSECVerification - GetAllRRSetsForVerification -&gt; FinishDNSSECVerification -&gt; VerifySignature
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Verification is a recursive process. It stops when we find a trust anchor or if we have recursed too deep.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If the original question resulted in NODATA/NXDOMAIN error, there should have been NSECs as part of the response.
</span><span class="enscript-comment">// These nsecs are cached along with the negative cache record. These are validated using ValidateWithNSECS called
</span><span class="enscript-comment">// from Verifysignature.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The flow in this case looks like this:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// VerifySignature -&gt; ValidateWithNSECS -&gt; {NoDataProof, NameErrorProof} -&gt; VerifyNSECS -&gt; StartDNSSECVerification
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Once the DNSSEC verification is started, it is similar to the previous flow described above. When the verification
</span><span class="enscript-comment">// is done, DNSSECPositiveValidationCB or DNSSECNegativeValidationCB will be called which will then deliver the
</span><span class="enscript-comment">// validation results to the original question that started the validation.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Insecure proofs are done when the verification ends up bogus. The flow would look like this
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// VerifySignature -&gt; StartDNSSECVerification - GetAllRRSetsForVerification -&gt; FinishDNSSECVerification -&gt; DNSSECValidationCB
</span><span class="enscript-comment">// {DNSSECPositiveValidationCB, DNSSECNegativeValidationCB} -&gt; ProveInsecure -&gt; VerifySignaure -&gt;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// ProveInsecure finds the break in trust in a top-down fashion.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Forward declaration
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">VerifySigCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord);
mDNSlocal mStatus <span class="enscript-function-name">TrustedKey</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv);
mDNSlocal mDNSBool <span class="enscript-function-name">TrustedKeyPresent</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv);
mDNSlocal mStatus <span class="enscript-function-name">ValidateDS</span>(DNSSECVerifier *dv);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECNegativeValidationCB</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheGroup *cg, ResourceRecord *answer, DNSSECStatus status);
mDNSlocal RRVerifier* <span class="enscript-function-name">CopyRRVerifier</span>(RRVerifier *from);
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeDNSSECAuthChainInfo</span>(AuthChain *ac);

<span class="enscript-comment">// Currently we use this to convert a RRVerifier to resource record so that we can
</span><span class="enscript-comment">// use the standard DNS utility functions
</span>LargeCacheRecord largerec;

<span class="enscript-comment">// Verification is a recursive process. We arbitrarily limit to 10 just to be cautious which should be
</span><span class="enscript-comment">// removed in the future.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_RECURSE_COUNT</span>   10

<span class="enscript-comment">// TTL (in seconds) when the DNSSEC status is Bogus
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RR_BOGUS_TTL</span>        60

<span class="enscript-comment">// RFC 4034 Appendix B: Get the keyid of a DNS KEY. It is not transmitted
</span><span class="enscript-comment">// explicitly on the wire.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Note: This just helps narrow down the list of keys to look at. It is possible
</span><span class="enscript-comment">// for two DNS keys to have the same ID i.e., key ID is not a unqiue tag
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 1st argument - the RDATA part of the DNSKEY RR
</span><span class="enscript-comment">// 2nd argument - the RDLENGTH
</span><span class="enscript-comment">//
</span>mDNSlocal mDNSu32 <span class="enscript-function-name">keytag</span>(mDNSu8 *key, mDNSu32 keysize)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ac;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// DST_ALG_RSAMD5 will be rejected automatically as the keytag
</span>    <span class="enscript-comment">// is calculated wrongly
</span>
    <span class="enscript-keyword">for</span> (ac = 0, i = 0; i &lt; keysize; ++i)
        ac += (i &amp; 1) ? key[i] : key[i] &lt;&lt; 8;
    ac += (ac &gt;&gt; 16) &amp; 0xFFFF;
    <span class="enscript-keyword">return</span> ac &amp; 0xFFFF;
}

mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">DNSMemCmp</span>(<span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> m1, <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-type">const</span> m2, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> res;

    res = mDNSPlatformMemCmp(m1, m2, len);
    <span class="enscript-keyword">if</span> (res != 0)
        <span class="enscript-keyword">return</span> (res &lt; 0 ? -1 : 1);
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// RFC 4034:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Section 6.1:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For the purposes of DNS security, owner names are ordered by treating
</span><span class="enscript-comment">// individual labels as unsigned left-justified octet strings.  The
</span><span class="enscript-comment">// absence of a octet sorts before a zero value octet, and uppercase
</span><span class="enscript-comment">// US-ASCII letters are treated as if they were lowercase US-ASCII
</span><span class="enscript-comment">// letters.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// To compute the canonical ordering of a set of DNS names, start by
</span><span class="enscript-comment">// sorting the names according to their most significant (rightmost)
</span><span class="enscript-comment">// labels.  For names in which the most significant label is identical,
</span><span class="enscript-comment">// continue sorting according to their next most significant label, and
</span><span class="enscript-comment">// so forth.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Returns 0 if the names are same
</span><span class="enscript-comment">// Returns -1 if d1 &lt; d2
</span><span class="enscript-comment">// Returns  1 if d1 &gt; d2
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// subdomain is set if there is at least one label match (starting from the end)
</span><span class="enscript-comment">// and d1 has more labels than d2 e.g., a.b.com is a subdomain of b.com
</span><span class="enscript-comment">//
</span>mDNSexport <span class="enscript-type">int</span> <span class="enscript-function-name">DNSSECCanonicalOrder</span>(<span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d1, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> d2, <span class="enscript-type">int</span> *subdomain)
{
    <span class="enscript-type">int</span> count, c1, c2;
    <span class="enscript-type">int</span> i, skip1, skip2;

    c1 = CountLabels(d1);
    skip1 = c1 - 1;
    c2 = CountLabels(d2);
    skip2 = c2 - 1;

    <span class="enscript-keyword">if</span> (subdomain) *subdomain = 0;

    <span class="enscript-comment">// Compare as many labels as possible starting from the rightmost
</span>    count = c1 &lt; c2 ? c1 : c2;
    <span class="enscript-keyword">for</span> (i = count; i &gt; 0; i--)
    {
        mDNSu8 *a, *b;
        <span class="enscript-type">int</span> j, len, lena, lenb;

        a = (mDNSu8 *)SkipLeadingLabels(d1, skip1);
        b = (mDNSu8 *)SkipLeadingLabels(d2, skip2);
        lena = *a;
        lenb = *b;
        <span class="enscript-comment">// Compare label by label. Note that &quot;z&quot; &gt; &quot;yak&quot; because z &gt; y, but z &lt; za
</span>        <span class="enscript-comment">// (lena - lenb check below) because 'za' has two characters. Hence compare the
</span>        <span class="enscript-comment">// letters first and then compare the length of the label at the end.
</span>        len = lena &lt; lenb ? lena : lenb;
        a++; b++;
        <span class="enscript-keyword">for</span> (j = 0; j &lt; len; j++)
        {
            mDNSu8 ac = *a++;
            mDNSu8 bc = *b++;
            <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
            <span class="enscript-keyword">if</span> (mDNSIsUpperCase(bc)) bc += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
            <span class="enscript-keyword">if</span> (ac != bc)
            {
                verbosedebugf(<span class="enscript-string">&quot;DNSSECCanonicalOrder: returning ac %c, bc %c&quot;</span>, ac, bc);
                <span class="enscript-keyword">return</span> ((ac &lt; bc) ? -1 : 1);
            }
        }
        <span class="enscript-keyword">if</span> ((lena - lenb) != 0)
        {
            verbosedebugf(<span class="enscript-string">&quot;DNSSECCanonicalOrder: returning lena %d lenb %d&quot;</span>, lena, lenb);
            <span class="enscript-keyword">return</span> ((lena &lt; lenb) ? -1 : 1);
        }

        <span class="enscript-comment">// Continue with the next label
</span>        skip1--;
        skip2--;
    }
    <span class="enscript-comment">// We have compared label by label. Both of them are same if we are here.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Two possibilities.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) Both names have same number of labels. In that case, return zero.
</span>    <span class="enscript-comment">// 2) The number of labels is not same. As zero label sorts before, names
</span>    <span class="enscript-comment">//    with more number of labels is greater.
</span>
    <span class="enscript-comment">// a.b.com is a subdomain of b.com
</span>    <span class="enscript-keyword">if</span> ((c1 &gt; c2) &amp;&amp; subdomain)
        *subdomain = 1;

    verbosedebugf(<span class="enscript-string">&quot;DNSSECCanonicalOrder: returning c1 %d c2 %d\n&quot;</span>, c1, c2);
    <span class="enscript-keyword">if</span> (c1 != c2)
        <span class="enscript-keyword">return</span> ((c1 &lt; c2) ? -1 : 1);
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// Initialize the question enough so that it can be answered from the cache using SameNameCacheRecordAnswersQuestion or
</span><span class="enscript-comment">// ResourceRecordAnswersQuestion.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">InitializeQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *qname,
                                   mDNSu16 qtype, mDNSQuestionCallback *callback, <span class="enscript-type">void</span> *context)
{
    debugf(<span class="enscript-string">&quot;InitializeQuestion: Called for %##s (%s)&quot;</span>, qname-&gt;c, DNSTypeName(qtype));

    <span class="enscript-keyword">if</span> (question-&gt;ThisQInterval != -1) mDNS_StopQuery(m, question);

    mDNS_SetupQuestion(question, InterfaceID, qname, qtype, callback, context);
    question-&gt;qnamehash  = DomainNameHashValue(qname);
    question-&gt;ValidatingResponse = mDNStrue;

    <span class="enscript-comment">// Need to hold the lock, as GetServerForQuestion (its callers) references m-&gt;timenow.
</span>    mDNS_Lock(m);
    <span class="enscript-comment">// We need to set the DNS server appropriately to match the question against the cache record.
</span>    <span class="enscript-comment">// Though not all callers of this function need it, we always do it to keep it simple.
</span>    SetValidDNSServers(m, question);
    question-&gt;qDNSServer = GetServerForQuestion(m, question);
    mDNS_Unlock(m);

    <span class="enscript-comment">// Make it look like unicast
</span>    question-&gt;TargetQID = onesID;
    question-&gt;TimeoutQuestion = 1;
    question-&gt;ReturnIntermed = 1;
    <span class="enscript-comment">// SetupQuestion sets LongLived if qtype == PTR
</span>    question-&gt;LongLived = 0;
}

mDNSexport DNSSECVerifier *<span class="enscript-function-name">AllocateDNSSECVerifier</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *name, mDNSu16 rrtype, mDNSInterfaceID InterfaceID,
    mDNSu8 ValidationRequired, DNSSECVerifierCallback dvcallback, mDNSQuestionCallback qcallback)
{
    DNSSECVerifier *dv;

    dv = (DNSSECVerifier *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*dv));
    <span class="enscript-keyword">if</span> (!dv) { LogMsg(<span class="enscript-string">&quot;AllocateDNSSECVerifier: ERROR!! memory alloc failed&quot;</span>); <span class="enscript-keyword">return</span> mDNSNULL; }

    LogDNSSEC(<span class="enscript-string">&quot;AllocateDNSSECVerifier called %p&quot;</span>, dv);

    <span class="enscript-comment">// Remember the question's name and type so that when we are done processing all
</span>    <span class="enscript-comment">// the verifications, we can trace the original question back
</span>    AssignDomainName(&amp;dv-&gt;origName, name);
    dv-&gt;origType = rrtype;
    dv-&gt;InterfaceID = InterfaceID;
    dv-&gt;DVCallback = dvcallback;
    dv-&gt;q.ThisQInterval = -1;
    ResetAuthChain(dv);
    <span class="enscript-comment">// These two are used for Insecure proof if we end up doing it.
</span>    <span class="enscript-comment">// -Value of ValidationRequired so that we know whether this is a secure or insecure validation
</span>    <span class="enscript-comment">// -InsecureProofDone tells us whether the proof has been done or not
</span>    dv-&gt;ValidationRequired = ValidationRequired;
    dv-&gt;InsecureProofDone = 0;
    dv-&gt;NumPackets = 0;
    mDNS_Lock(m);
    dv-&gt;StartTime = m-&gt;timenow;
    mDNS_Unlock(m);
    <span class="enscript-comment">// The verifier's question has to be initialized as some of the callers assume it
</span>    InitializeQuestion(m, &amp;dv-&gt;q, InterfaceID, name, rrtype, qcallback, dv);
    <span class="enscript-keyword">return</span> dv;
}

mDNSlocal AuthChain *<span class="enscript-function-name">AuthChainCopy</span>(AuthChain *ae)
{
    RRVerifier *rvfrom, **rvto;
    AuthChain **prev = mDNSNULL;
    AuthChain *retac = mDNSNULL;
    AuthChain *ac;


    <span class="enscript-keyword">while</span> (ae)
    {
        ac = (AuthChain *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*ac));
        <span class="enscript-keyword">if</span> (!ac)
        {
            LogMsg(<span class="enscript-string">&quot;AuthChainCopy: AuthChain alloc failure&quot;</span>);
            <span class="enscript-keyword">if</span> (retac)
                FreeDNSSECAuthChainInfo(retac);
            <span class="enscript-keyword">return</span> mDNSNULL;
        }

        ac-&gt;next  = mDNSNULL;

        <span class="enscript-keyword">if</span> (!retac)
            retac = ac;

        rvfrom = ae-&gt;rrset;
        rvto = &amp;ac-&gt;rrset;
        <span class="enscript-keyword">while</span> (rvfrom &amp;&amp; rvto)
        {
            *rvto = CopyRRVerifier(rvfrom);
            rvfrom = rvfrom-&gt;next;
            rvto = &amp;((*rvto)-&gt;next);
        }

        rvfrom = ae-&gt;rrsig;
        rvto = &amp;ac-&gt;rrsig;
        <span class="enscript-keyword">while</span> (rvfrom &amp;&amp; rvto)
        {
            *rvto = CopyRRVerifier(rvfrom);
            rvfrom = rvfrom-&gt;next;
            rvto = &amp;((*rvto)-&gt;next);
        }

        rvfrom = ae-&gt;key;
        rvto = &amp;ac-&gt;key;
        <span class="enscript-keyword">while</span> (rvfrom &amp;&amp; rvto)
        {
            *rvto = CopyRRVerifier(rvfrom);
            rvfrom = rvfrom-&gt;next;
            rvto = &amp;((*rvto)-&gt;next);
        }

        <span class="enscript-keyword">if</span> (prev)
        {
            *prev = ac;
        }
        prev = &amp;(ac-&gt;next);
        ae = ae-&gt;next;
    }
    <span class="enscript-keyword">return</span> retac;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeDNSSECAuthChainInfo</span>(AuthChain *ac)
{
    RRVerifier *rrset;
    RRVerifier *next;
    AuthChain *acnext;

    LogDNSSEC(<span class="enscript-string">&quot;FreeDNSSECAuthChainInfo: called&quot;</span>);

    <span class="enscript-keyword">while</span> (ac)
    {
        acnext = ac-&gt;next;
        rrset = ac-&gt;rrset;
        <span class="enscript-keyword">while</span> (rrset)
        {
            next = rrset-&gt;next;
            mDNSPlatformMemFree(rrset);
            rrset = next;
        }
        ac-&gt;rrset = mDNSNULL;

        rrset = ac-&gt;rrsig;
        <span class="enscript-keyword">while</span> (rrset)
        {
            next = rrset-&gt;next;
            mDNSPlatformMemFree(rrset);
            rrset = next;
        }
        ac-&gt;rrsig = mDNSNULL;

        rrset = ac-&gt;key;
        <span class="enscript-keyword">while</span> (rrset)
        {
            next = rrset-&gt;next;
            mDNSPlatformMemFree(rrset);
            rrset = next;
        }
        ac-&gt;key = mDNSNULL;

        mDNSPlatformMemFree(ac);
        ac = acnext;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeDNSSECAuthChain</span>(DNSSECVerifier *dv)
{
    <span class="enscript-keyword">if</span> (dv-&gt;ac)
    {
        FreeDNSSECAuthChainInfo(dv-&gt;ac);
        <span class="enscript-comment">// if someone reuses the &quot;dv&quot;, it will be initialized properly
</span>        ResetAuthChain(dv);
    }
    <span class="enscript-keyword">if</span> (dv-&gt;saveac)
    {
        FreeDNSSECAuthChainInfo(dv-&gt;saveac);
        dv-&gt;saveac = mDNSNULL;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeAuthChain</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context)
{
    AuthChain *ac = (AuthChain *)context;
    (<span class="enscript-type">void</span>) m; <span class="enscript-comment">// unused
</span>
    FreeDNSSECAuthChainInfo(ac);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FreeDNSSECVerifierRRSets</span>(DNSSECVerifier *dv)
{
    RRVerifier *rrset;
    RRVerifier *next;

    <span class="enscript-comment">//debugdnssec(&quot;FreeDNSSECVerifierRRSets called %p&quot;, dv);
</span>    rrset = dv-&gt;rrset;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;rrset = mDNSNULL;

    rrset = dv-&gt;rrsig;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;rrsig = mDNSNULL;

    rrset = dv-&gt;key;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;key = mDNSNULL;

    rrset = dv-&gt;rrsigKey;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;rrsigKey = mDNSNULL;

    rrset = dv-&gt;ds;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;ds = mDNSNULL;
    rrset = dv-&gt;pendingNSEC;
    <span class="enscript-keyword">while</span> (rrset)
    {
        next = rrset-&gt;next;
        mDNSPlatformMemFree(rrset);
        rrset = next;
    }
    dv-&gt;pendingNSEC = mDNSNULL;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">FreeDNSSECVerifier</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    LogDNSSEC(<span class="enscript-string">&quot;FreeDNSSECVerifier called %p&quot;</span>, dv);
    <span class="enscript-keyword">if</span> (dv-&gt;q.ThisQInterval != -1)
        mDNS_StopQuery(m, &amp;dv-&gt;q);
    FreeDNSSECVerifierRRSets(dv);
    <span class="enscript-keyword">if</span> (dv-&gt;ctx)
        AlgDestroy(dv-&gt;ctx);
    <span class="enscript-keyword">if</span> (dv-&gt;ac || dv-&gt;saveac)
        FreeDNSSECAuthChain(dv);
    <span class="enscript-keyword">if</span> (dv-&gt;parent)
    {
        LogDNSSEC(<span class="enscript-string">&quot;FreeDNSSECVerifier freeing parent %p&quot;</span>, dv-&gt;parent);
        FreeDNSSECVerifier(m, dv-&gt;parent);
    }
    mDNSPlatformMemFree(dv);
}

mDNSlocal RRVerifier* <span class="enscript-function-name">CopyRRVerifier</span>(RRVerifier *from)
{
    RRVerifier *r;

    r = (RRVerifier *) mDNSPlatformMemAllocate(<span class="enscript-keyword">sizeof</span>(*r) + from-&gt;rdlength);
    <span class="enscript-keyword">if</span> (!r)
    {
        LogMsg(<span class="enscript-string">&quot;CopyRRVerifier: memory failure&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    mDNSPlatformMemCopy(r, from, <span class="enscript-keyword">sizeof</span>(RRVerifier));
    r-&gt;next = mDNSNULL;
    r-&gt;rdata = (mDNSu8*) ((mDNSu8 *)r + <span class="enscript-keyword">sizeof</span>(RRVerifier));
    mDNSPlatformMemCopy(r-&gt;rdata, from-&gt;rdata, r-&gt;rdlength);
    <span class="enscript-keyword">return</span> r;
}

mDNSexport RRVerifier* <span class="enscript-function-name">AllocateRRVerifier</span>(<span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, mStatus *status)
{
    RRVerifier *r;

    r = (RRVerifier *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*r) + rr-&gt;rdlength);
    <span class="enscript-keyword">if</span> (!r)
    {
        LogMsg(<span class="enscript-string">&quot;AllocateRRVerifier: memory failure&quot;</span>);
        *status = mStatus_NoMemoryErr;
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    r-&gt;next = mDNSNULL;
    r-&gt;rrtype = rr-&gt;rrtype;
    r-&gt;rrclass = rr-&gt;rrclass;
    r-&gt;rroriginalttl = rr-&gt;rroriginalttl;
    r-&gt;rdlength = rr-&gt;rdlength;
    r-&gt;namehash = rr-&gt;namehash;
    r-&gt;rdatahash = rr-&gt;rdatahash;
    AssignDomainName(&amp;r-&gt;name, rr-&gt;name);
    r-&gt;rdata = (mDNSu8*) ((mDNSu8 *)r + <span class="enscript-keyword">sizeof</span>(RRVerifier));

    <span class="enscript-comment">// When we parsed the DNS response in GeLargeResourceRecord, for some records, we parse them into
</span>    <span class="enscript-comment">// host order so that the rest of the code does not have to bother with converting from network order
</span>    <span class="enscript-comment">// to host order. For signature verification, we need them back in network order. For DNSSEC records
</span>    <span class="enscript-comment">// like DNSKEY and DS, we just copy over the data both in GetLargeResourceRecord and putRData.
</span>
    <span class="enscript-keyword">if</span> (!putRData(mDNSNULL, r-&gt;rdata, r-&gt;rdata + rr-&gt;rdlength, rr))
    {
        LogMsg(<span class="enscript-string">&quot;AllocateRRVerifier: putRData failed&quot;</span>);
        *status = mStatus_BadParamErr;
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    *status = mStatus_NoError;
    <span class="enscript-keyword">return</span> r;
}

mDNSexport mStatus <span class="enscript-function-name">AddRRSetToVerifier</span>(DNSSECVerifier *dv, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr, RRVerifier *rv, RRVerifierSet set)
{
    RRVerifier *r;
    RRVerifier **v;
    mStatus status;

    <span class="enscript-keyword">if</span> (!rv)
    {
        r = AllocateRRVerifier(rr, &amp;status);
        <span class="enscript-keyword">if</span> (!r) <span class="enscript-keyword">return</span> status;
    }
    <span class="enscript-keyword">else</span>
        r = rv;

    <span class="enscript-keyword">switch</span> (set)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rr</span>:
        v = &amp;dv-&gt;rrset;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig</span>:
        v = &amp;dv-&gt;rrsig;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_key</span>:
        v = &amp;dv-&gt;key;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig_key</span>:
        v = &amp;dv-&gt;rrsigKey;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_ds</span>:
        v = &amp;dv-&gt;ds;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;AddRRSetToVerifier: ERROR!! default case %d&quot;</span>, set);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">while</span> (*v)
        v = &amp;(*v)-&gt;next;
    *v = r;
    <span class="enscript-keyword">return</span> mStatus_NoError;
}

<span class="enscript-comment">// Validate the RRSIG. &quot;type&quot; tells which RRSIG that we are supposed to validate. We fetch RRSIG for
</span><span class="enscript-comment">// the rrset (type is RRVS_rrsig) and RRSIG for the key (type is RRVS_rrsig_key).
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ValidateRRSIG</span>(DNSSECVerifier *dv, RRVerifierSet type, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    RRVerifier *rv;
    mDNSu32 currentTime;
    rdataRRSig *rrsigRData = (rdataRRSig *)((mDNSu8 *)rr-&gt;rdata + sizeofRDataHeader);

    <span class="enscript-keyword">if</span> (type == RRVS_rrsig)
    {
        rv = dv-&gt;rrset;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type == RRVS_rrsig_key)
    {
        rv = dv-&gt;key;
    }
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;ValidateRRSIG: ERROR!! type not valid %d&quot;</span>, type);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// RFC 4035:
</span>    <span class="enscript-comment">// For each authoritative RRset in a signed zone, there MUST be at least
</span>    <span class="enscript-comment">// one RRSIG record that meets the following requirements:
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// RRSet is defined by same name, class and type
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. The RRSIG RR and the RRset MUST have the same owner name and the same class.
</span>    <span class="enscript-keyword">if</span> (!SameDomainName(&amp;rv-&gt;name, rr-&gt;name) || (rr-&gt;rrclass != rv-&gt;rrclass))
    {
        debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: name mismatch or class mismatch&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// 2. The RRSIG RR's Type Covered field MUST equal the RRset's type.
</span>    <span class="enscript-keyword">if</span> ((swap16(rrsigRData-&gt;typeCovered)) != rv-&gt;rrtype)
    {
        debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: typeCovered mismatch rrsig %d, rr type %d&quot;</span>, swap16(rrsigRData-&gt;typeCovered), rv-&gt;rrtype);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// 3. The number of labels in the RRset owner name MUST be greater than or equal
</span>    <span class="enscript-comment">//    to the value in the RRSIG RR's Labels field.
</span>    <span class="enscript-keyword">if</span> (rrsigRData-&gt;labels &gt; CountLabels(&amp;rv-&gt;name))
    {
        debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: labels count problem rrsig %d, rr %d&quot;</span>, rrsigRData-&gt;labels, CountLabels(&amp;rv-&gt;name));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// 4. The RRSIG RR's Signer's Name field MUST be the name of the zone that contains
</span>    <span class="enscript-comment">//    the RRset. For a stub resolver, this can't be done in a secure way. Hence we
</span>    <span class="enscript-comment">//    do it this way (discussed in dnsext mailing list)
</span>    <span class="enscript-keyword">switch</span> (rv-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNSKEY</span>:
        <span class="enscript-comment">//Signed by the owner
</span>        <span class="enscript-keyword">if</span> (!SameDomainName(&amp;rv-&gt;name, (domainname *)&amp;rrsigRData-&gt;signerName))
        {
            debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: Signer Name does not match the record name for %s&quot;</span>, DNSTypeName(rv-&gt;rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DS</span>:
        <span class="enscript-comment">// Should be signed by the parent
</span>        <span class="enscript-keyword">if</span> (SameDomainName(&amp;rv-&gt;name, (domainname *)&amp;rrsigRData-&gt;signerName))
        {
            debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: Signer Name matches the record name for %s&quot;</span>, DNSTypeName(rv-&gt;rrtype));
            <span class="enscript-keyword">return</span>;
        }
    <span class="enscript-comment">// FALLTHROUGH
</span>    <span class="enscript-reference">default</span>:
    {
        <span class="enscript-type">int</span> c1 = CountLabels(&amp;rv-&gt;name);
        <span class="enscript-type">int</span> c2 = CountLabels((domainname *)&amp;rrsigRData-&gt;signerName);
        <span class="enscript-keyword">if</span> (c1 &lt; c2)
        {
            debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: Signer Name not a subdomain label count %d &lt; %d &quot;</span>, c1, c2);
            <span class="enscript-keyword">return</span>;
        }
        domainname *d = (domainname *)SkipLeadingLabels(&amp;rv-&gt;name, c1 - c2);
        <span class="enscript-keyword">if</span> (!SameDomainName(d, (domainname *)&amp;rrsigRData-&gt;signerName))
        {
            debugdnssec(<span class="enscript-string">&quot;ValidateRRSIG: Signer Name not a subdomain&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    }
    }

    <span class="enscript-comment">// 5. The validator's notion of the current time MUST be less than or equal to the
</span>    <span class="enscript-comment">//    time listed in the RRSIG RR's Expiration field.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 6. The validator's notion of the current time MUST be greater than or equal to the
</span>    <span class="enscript-comment">//    time listed in the RRSIG RR's Inception field.
</span>    currentTime = mDNSPlatformUTC();

    <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(swap32(rrsigRData-&gt;sigExpireTime), currentTime))
    {
        LogDNSSEC(<span class="enscript-string">&quot;ValidateRRSIG: Expired: currentTime %d, ExpireTime %d&quot;</span>, (<span class="enscript-type">int</span>)currentTime,
                  swap32((<span class="enscript-type">int</span>)rrsigRData-&gt;sigExpireTime));
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(currentTime, swap32(rrsigRData-&gt;sigInceptTime)))
    {
        LogDNSSEC(<span class="enscript-string">&quot;ValidateRRSIG: Future: currentTime %d, InceptTime %d&quot;</span>, (<span class="enscript-type">int</span>)currentTime,
                  swap32((<span class="enscript-type">int</span>)rrsigRData-&gt;sigInceptTime));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (AddRRSetToVerifier(dv, rr, mDNSNULL, type) != mStatus_NoError)
    {
        LogMsg(<span class="enscript-string">&quot;ValidateRRSIG: ERROR!! cannot allocate RRSet&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">CheckRRSIGForRRSet</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord **negcr)
{
    CacheGroup *cg;
    CacheRecord *cr;
    RRVerifier *rv;
    mDNSBool expectRRSIG = mDNSfalse;

    *negcr = mDNSNULL;
    <span class="enscript-keyword">if</span> (!dv-&gt;rrset)
    {
        LogMsg(<span class="enscript-string">&quot;CheckRRSIGForRRSet: ERROR!! rrset NULL for origName %##s (%s)&quot;</span>, dv-&gt;origName.c,
               DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    rv = dv-&gt;rrset;
    cg = CacheGroupForName(m, rv-&gt;namehash, &amp;rv-&gt;name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        debugdnssec(<span class="enscript-string">&quot;CheckRRSIGForRRSet: cg null&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
    }

    <span class="enscript-keyword">for</span> (cr=cg-&gt;members; cr; cr=cr-&gt;next)
    {
        debugdnssec(<span class="enscript-string">&quot;CheckRRSIGForRRSet: checking the validity of rrsig&quot;</span>);
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_RRSIG)
        {
            <span class="enscript-comment">// Check to see if we should expect RRSIGs for the type that we are looking for.
</span>            <span class="enscript-comment">// We would expect RRSIGs, if we had previously issued the question with the
</span>            <span class="enscript-comment">// EDNS0/DOK bit set.
</span>            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype == dv-&gt;rrset-&gt;rrtype)
            {
                expectRRSIG = cr-&gt;CRDNSSECQuestion;
                LogDNSSEC(<span class="enscript-string">&quot;CheckRRSIGForRRSet: %s RRSIG for %s&quot;</span>, (expectRRSIG ? <span class="enscript-string">&quot;Expecting&quot;</span> : <span class="enscript-string">&quot;Not Expecting&quot;</span>), CRDisplayString(m, cr));
            }
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            <span class="enscript-keyword">if</span> (!(*negcr))
            {
                LogDNSSEC(<span class="enscript-string">&quot;CheckRRSIGForRRSet: Negative cache record %s encountered for %##s (%s)&quot;</span>, CRDisplayString(m, cr),
                          rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                *negcr = cr;
            }
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;CheckRRSIGForRRSet: ERROR!! Negative cache record %s already set for %##s (%s)&quot;</span>, CRDisplayString(m, cr),
                       rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
            }
            <span class="enscript-keyword">continue</span>;
        }
        ValidateRRSIG(dv, RRVS_rrsig, &amp;cr-&gt;resrec);
    }
    <span class="enscript-keyword">if</span> (*negcr &amp;&amp; dv-&gt;rrsig)
    {
        <span class="enscript-comment">// Encountered both RRSIG and negative CR
</span>        LogMsg(<span class="enscript-string">&quot;CheckRRSIGForRRSet: ERROR!! Encountered negative cache record %s and RRSIG for %##s (%s)&quot;</span>,
               CRDisplayString(m, *negcr), rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-comment">// If we can't find RRSIGs, but we find a negative response then we need to validate that
</span>    <span class="enscript-comment">// which the caller will do it. Otherwise, if we should be expecting RRSIGs to be in the
</span>    <span class="enscript-comment">// cache already, then return error.
</span>    <span class="enscript-keyword">if</span> (dv-&gt;rrsig || *negcr)
        <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (expectRRSIG)
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckOneKeyForRRSIG</span>(DNSSECVerifier *dv, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    rdataRRSig *rrsig;

    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckOneKeyForRRSIG: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    <span class="enscript-keyword">if</span> (!SameDomainName((domainname *)&amp;rrsig-&gt;signerName, rr-&gt;name))
    {
        debugdnssec(<span class="enscript-string">&quot;CheckOneKeyForRRSIG: name mismatch&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// We store all the keys including the ZSK and KSK and use them appropriately
</span>    <span class="enscript-comment">// later
</span>    <span class="enscript-keyword">if</span> (AddRRSetToVerifier(dv, rr, mDNSNULL, RRVS_key) != mStatus_NoError)
    {
        LogMsg(<span class="enscript-string">&quot;CheckOneKeyForRRSIG: ERROR!! cannot allocate RRSet&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
}

mDNSlocal mStatus <span class="enscript-function-name">CheckKeyForRRSIG</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord **negcr)
{
    mDNSu32 namehash;
    CacheGroup *cg;
    CacheRecord *cr;
    rdataRRSig *rrsig;
    domainname *name;

    *negcr = mDNSNULL;
    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckKeyForRRSIG: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }

    <span class="enscript-comment">// Signer name should be the same on all rrsig ??
</span>    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    name = (domainname *)&amp;rrsig-&gt;signerName;

    namehash = DomainNameHashValue(name);
    cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        debugdnssec(<span class="enscript-string">&quot;CheckKeyForRRSIG: cg null for %##s&quot;</span>, name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
    }

    <span class="enscript-keyword">for</span> (cr=cg-&gt;members; cr; cr=cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_DNSKEY) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            <span class="enscript-keyword">if</span> (!(*negcr))
            {
                LogDNSSEC(<span class="enscript-string">&quot;CheckKeyForRRSIG: Negative cache record %s encountered for %##s (DNSKEY)&quot;</span>, CRDisplayString(m, cr),
                          name-&gt;c);
                *negcr = cr;
            }
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;CheckKeyForRRSIG: ERROR!! Negative cache record %s already set for %##s (DNSKEY)&quot;</span>, CRDisplayString(m, cr),
                       name-&gt;c);
            }
            <span class="enscript-keyword">continue</span>;
        }
        debugdnssec(<span class="enscript-string">&quot;CheckKeyForRRSIG: checking the validity of key record&quot;</span>);
        CheckOneKeyForRRSIG(dv, &amp;cr-&gt;resrec);
    }
    <span class="enscript-keyword">if</span> (*negcr &amp;&amp; dv-&gt;key)
    {
        <span class="enscript-comment">// Encountered both RRSIG and negative CR
</span>        LogMsg(<span class="enscript-string">&quot;CheckKeyForRRSIG: ERROR!! Encountered negative cache record %s and DNSKEY for %##s&quot;</span>,
               CRDisplayString(m, *negcr), name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (dv-&gt;key || *negcr)
        <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckOneRRSIGForKey</span>(DNSSECVerifier *dv, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    rdataRRSig *rrsig;
    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckOneRRSIGForKey: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    <span class="enscript-keyword">if</span> (!SameDomainName((domainname *)&amp;rrsig-&gt;signerName, rr-&gt;name))
    {
        debugdnssec(<span class="enscript-string">&quot;CheckOneRRSIGForKey: name mismatch&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    ValidateRRSIG(dv, RRVS_rrsig_key, rr);
}

mDNSlocal mStatus <span class="enscript-function-name">CheckRRSIGForKey</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord **negcr)
{
    mDNSu32 namehash;
    CacheGroup *cg;
    CacheRecord *cr;
    rdataRRSig *rrsig;
    domainname *name;
    mDNSBool expectRRSIG = mDNSfalse;

    *negcr = mDNSNULL;
    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckRRSIGForKey: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (!dv-&gt;key)
    {
        LogMsg(<span class="enscript-string">&quot;CheckRRSIGForKey:  ERROR!! key NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    name = (domainname *)&amp;rrsig-&gt;signerName;

    namehash = DomainNameHashValue(name);
    cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        debugdnssec(<span class="enscript-string">&quot;CheckRRSIGForKey: cg null %##s&quot;</span>, name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
    }
    <span class="enscript-keyword">for</span> (cr=cg-&gt;members; cr; cr=cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_RRSIG)
        {
            <span class="enscript-comment">// Check to see if we should expect RRSIGs for the DNSKEY record that we are
</span>            <span class="enscript-comment">// looking for. We would expect RRSIGs, if we had previously issued the question
</span>            <span class="enscript-comment">// with the EDNS0/DOK bit set.
</span>            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype == kDNSType_DNSKEY)
            {
                expectRRSIG = cr-&gt;CRDNSSECQuestion;
                LogDNSSEC(<span class="enscript-string">&quot;CheckRRSIGForKey: %s RRSIG for %s&quot;</span>, (expectRRSIG ? <span class="enscript-string">&quot;Expecting&quot;</span> : <span class="enscript-string">&quot;Not Expecting&quot;</span>), CRDisplayString(m, cr));
            }
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            <span class="enscript-keyword">if</span> (!(*negcr))
            {
                LogDNSSEC(<span class="enscript-string">&quot;CheckRRSIGForKey: Negative cache record %s encountered for %##s (RRSIG)&quot;</span>, CRDisplayString(m, cr),
                          name-&gt;c);
                *negcr = cr;
            }
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;CheckRRSIGForKey: ERROR!! Negative cache record %s already set for %##s (RRSIG)&quot;</span>, CRDisplayString(m, cr),
                       name-&gt;c);
            }
            <span class="enscript-keyword">continue</span>;
        }
        debugdnssec(<span class="enscript-string">&quot;CheckRRSIGForKey: checking the validity of rrsig&quot;</span>);
        CheckOneRRSIGForKey(dv, &amp;cr-&gt;resrec);
    }
    <span class="enscript-keyword">if</span> (*negcr &amp;&amp; dv-&gt;rrsigKey)
    {
        <span class="enscript-comment">// Encountered both RRSIG and negative CR
</span>        LogMsg(<span class="enscript-string">&quot;CheckRRSIGForKey: ERROR!! Encountered negative cache record %s and DNSKEY for %##s&quot;</span>,
               CRDisplayString(m, *negcr), name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-comment">// If we can't find RRSIGs, but we find a negative response then we need to validate that
</span>    <span class="enscript-comment">// which the caller will do it. Finally, make sure that we are not expecting RRSIGS.
</span>    <span class="enscript-keyword">if</span> (dv-&gt;rrsigKey || *negcr)
        <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (expectRRSIG)
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">CheckOneDSForKey</span>(DNSSECVerifier *dv, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    mDNSu16 tag;
    rdataDS *DS;
    RRVerifier *keyv;
    rdataDNSKey *key;
    rdataRRSig *rrsig;

    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckOneDSForKey: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    DS = (rdataDS *)((mDNSu8 *)rr-&gt;rdata + sizeofRDataHeader);

    <span class="enscript-keyword">if</span> (!SameDomainName((domainname *)&amp;rrsig-&gt;signerName, rr-&gt;name))
    {
        debugdnssec(<span class="enscript-string">&quot;CheckOneDSForKey: name mismatch&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">for</span> (keyv = dv-&gt;key; keyv; keyv = keyv-&gt;next)
    {
        key = (rdataDNSKey *)keyv-&gt;rdata;
        tag = (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength);
        <span class="enscript-keyword">if</span> (tag != swap16(DS-&gt;keyTag))
        {
            debugdnssec(<span class="enscript-string">&quot;CheckOneDSForKey: keyTag mismatch keyTag %d, DStag %d&quot;</span>, tag, swap16(DS-&gt;keyTag));
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (key-&gt;alg != DS-&gt;alg)
        {
            debugdnssec(<span class="enscript-string">&quot;CheckOneDSForKey: alg mismatch key alg%d, DS alg %d&quot;</span>, key-&gt;alg, swap16(DS-&gt;alg));
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (AddRRSetToVerifier(dv, rr, mDNSNULL, RRVS_ds) != mStatus_NoError)
        {
            debugdnssec(<span class="enscript-string">&quot;CheckOneDSForKey: cannot allocate RRSet&quot;</span>);
        }
    }
}

mDNSlocal mStatus <span class="enscript-function-name">CheckDSForKey</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord **negcr)
{
    mDNSu32 namehash;
    CacheGroup *cg;
    CacheRecord *cr;
    rdataRRSig *rrsig;
    domainname *name;

    *negcr = mDNSNULL;
    <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
    {
        LogMsg(<span class="enscript-string">&quot;CheckDSForKey: ERROR!! rrsig NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (!dv-&gt;key)
    {
        LogMsg(<span class="enscript-string">&quot;CheckDSForKey: ERROR!! key NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
    name = (domainname *)&amp;rrsig-&gt;signerName;
    namehash = DomainNameHashValue(name);
    cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        debugdnssec(<span class="enscript-string">&quot;CheckDSForKey: cg null for %s&quot;</span>, name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
    }
    <span class="enscript-keyword">for</span> (cr=cg-&gt;members; cr; cr=cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_DS) <span class="enscript-keyword">continue</span>;
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
        {
            <span class="enscript-keyword">if</span> (!(*negcr))
            {
                LogDNSSEC(<span class="enscript-string">&quot;CheckDSForKey: Negative cache record %s encountered for %##s (DS)&quot;</span>, CRDisplayString(m, cr),
                          name-&gt;c);
                *negcr = cr;
            }
            <span class="enscript-keyword">else</span>
            {
                LogMsg(<span class="enscript-string">&quot;CheckDSForKey: ERROR!! Negative cache record %s already set for %##s (DS)&quot;</span>, CRDisplayString(m, cr),
                       name-&gt;c);
            }
            <span class="enscript-keyword">continue</span>;
        }
        CheckOneDSForKey(dv, &amp;cr-&gt;resrec);
    }
    <span class="enscript-keyword">if</span> (*negcr &amp;&amp; dv-&gt;ds)
    {
        <span class="enscript-comment">// Encountered both RRSIG and negative CR
</span>        LogMsg(<span class="enscript-string">&quot;CheckDSForKey: ERROR!! Encountered negative cache record %s and DS for %##s&quot;</span>,
               CRDisplayString(m, *negcr), name-&gt;c);
        <span class="enscript-keyword">return</span> mStatus_BadParamErr;
    }
    <span class="enscript-keyword">if</span> (dv-&gt;ds || *negcr)
        <span class="enscript-keyword">return</span> mStatus_NoError;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

<span class="enscript-comment">// It returns mDNStrue if we have all the rrsets for verification and mDNSfalse otherwise.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">GetAllRRSetsForVerification</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    mStatus err;
    CacheRecord *negcr;
    rdataRRSig *rrsig;

    <span class="enscript-keyword">if</span> (!dv-&gt;rrset)
    {
        LogMsg(<span class="enscript-string">&quot;GetAllRRSetsForVerification: ERROR!! rrset NULL&quot;</span>);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (dv-&gt;next == RRVS_done) <span class="enscript-keyword">return</span> mDNStrue;

    debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: next %d&quot;</span>, dv-&gt;next);
    <span class="enscript-keyword">switch</span> (dv-&gt;next)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig</span>:
        <span class="enscript-comment">// If we can't find the RRSIG for the rrset, re-issue the query.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// NOTE: It is possible that the cache might answer partially e.g., RRSIGs match qtype but the
</span>        <span class="enscript-comment">// whole set is not there. In that case the validation will fail. Ideally we should flush the
</span>        <span class="enscript-comment">// cache and reissue the query (TBD).
</span>        err = CheckRRSIGForRRSet(m, dv, &amp;negcr);
        <span class="enscript-keyword">if</span> (err != mStatus_NoSuchRecord &amp;&amp; err != mStatus_NoError)
        {
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-comment">// Need to initialize the question as if we end up in ValidateWithNSECS below, the nsec proofs
</span>        <span class="enscript-comment">// looks in &quot;dv-&gt;q&quot; for the proof. Note that we have to use currQtype as the response could be
</span>        <span class="enscript-comment">// a CNAME and dv-&gt;rrset-&gt;rrtype would be set to CNAME and not the original question type that
</span>        <span class="enscript-comment">// resulted in CNAME.
</span>        InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, &amp;dv-&gt;rrset-&gt;name, dv-&gt;currQtype, VerifySigCallback, dv);
        <span class="enscript-comment">// We may not have the NSECS if the previous query was a non-DNSSEC query
</span>        <span class="enscript-keyword">if</span> (negcr &amp;&amp; negcr-&gt;nsec)
        {
            ValidateWithNSECS(m, dv, negcr);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }

        dv-&gt;next = RRVS_key;
        <span class="enscript-keyword">if</span> (!dv-&gt;rrsig)
        {
            <span class="enscript-comment">// We already found the rrset to verify. Ideally we should just issue the query for the RRSIG. Unfortunately,
</span>            <span class="enscript-comment">// that does not work well as the response may not contain the RRSIG whose typeCovered matches the
</span>            <span class="enscript-comment">// rrset-&gt;rrtype (recursive server returns what is in its cache). Hence, we send the original query with the
</span>            <span class="enscript-comment">// DO bit set again to get the RRSIG. Normally this would happen if there was question which did not require
</span>            <span class="enscript-comment">// DNSSEC validation (ValidationRequied = 0) populated the cache and later when the ValidationRequired question
</span>            <span class="enscript-comment">// comes along, we need to get the RRSIGs. If we started off with ValidationRequired question we would have
</span>            <span class="enscript-comment">// already set the DO bit and not able to get RRSIGs e.g., bad CPE device, we would reissue the query here
</span>            <span class="enscript-comment">// again once more.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Also, if it is a wildcard expanded answer, we need to issue the query with the original type for it to
</span>            <span class="enscript-comment">// elicit the right NSEC records. Just querying for RRSIG alone is not sufficient.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Note: For this to work, the core needs to deliver RRSIGs when they are added to the cache even if the
</span>            <span class="enscript-comment">// &quot;qtype&quot; is not RRSIG.
</span>            debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Fetching RRSIGS for RRSET&quot;</span>);
            dv-&gt;NumPackets++;
            mDNS_StartQuery(m, &amp;dv-&gt;q);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-comment">// if we found the RRSIG, then fall through to find the DNSKEY
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_key</span>:
        err = CheckKeyForRRSIG(m, dv, &amp;negcr);
        <span class="enscript-keyword">if</span> (err != mStatus_NoSuchRecord &amp;&amp; err != mStatus_NoError)
        {
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-comment">// Need to initialize the question as if we end up in ValidateWithNSECS below, the nsec proofs
</span>        <span class="enscript-comment">// looks in &quot;dv-&gt;q&quot; for the proof.
</span>        rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
        InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, (domainname *)&amp;rrsig-&gt;signerName, kDNSType_DNSKEY, VerifySigCallback, dv);
        <span class="enscript-comment">// We may not have the NSECS if the previous query was a non-DNSSEC query
</span>        <span class="enscript-keyword">if</span> (negcr &amp;&amp; negcr-&gt;nsec)
        {
            ValidateWithNSECS(m, dv, negcr);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }

        dv-&gt;next = RRVS_rrsig_key;
        <span class="enscript-keyword">if</span> (!dv-&gt;key)
        {
            debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Fetching DNSKEY for RRSET&quot;</span>);
            dv-&gt;NumPackets++;
            mDNS_StartQuery(m, &amp;dv-&gt;q);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
    <span class="enscript-comment">// if we found the DNSKEY, then fall through to find the RRSIG for the DNSKEY
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig_key</span>:
        err = CheckRRSIGForKey(m, dv, &amp;negcr);
        <span class="enscript-comment">// if we are falling through, then it is okay if we don't find the record
</span>        <span class="enscript-keyword">if</span> (err != mStatus_NoSuchRecord &amp;&amp; err != mStatus_NoError)
        {
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-comment">// Need to initialize the question as if we end up in ValidateWithNSECS below, the nsec proofs
</span>        <span class="enscript-comment">// looks in &quot;dv-&gt;q&quot; for the proof.
</span>        rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
        InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, (domainname *)&amp;rrsig-&gt;signerName, kDNSType_DNSKEY, VerifySigCallback, dv);
        <span class="enscript-comment">// We may not have the NSECS if the previous query was a non-DNSSEC query
</span>        <span class="enscript-keyword">if</span> (negcr &amp;&amp; negcr-&gt;nsec)
        {
            ValidateWithNSECS(m, dv, negcr);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        dv-&gt;next = RRVS_ds;
        debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: RRVS_rrsig_key %p&quot;</span>, dv-&gt;rrsigKey);
        <span class="enscript-keyword">if</span> (!dv-&gt;rrsigKey)
        {
            debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Fetching RRSIGS for DNSKEY&quot;</span>);
            dv-&gt;NumPackets++;
            mDNS_StartQuery(m, &amp;dv-&gt;q);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
    <span class="enscript-comment">// if we found RRSIG for the DNSKEY, then fall through to find the DS
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_ds</span>:
    {
        domainname *qname;
        rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;
        qname = (domainname *)&amp;rrsig-&gt;signerName;

        err = CheckDSForKey(m, dv, &amp;negcr);
        <span class="enscript-keyword">if</span> (err != mStatus_NoSuchRecord &amp;&amp; err != mStatus_NoError)
        {
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-comment">// Need to initialize the question as if we end up in ValidateWithNSECS below, the nsec proofs
</span>        <span class="enscript-comment">// looks in &quot;dv-&gt;q&quot; for the proof.
</span>        InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, qname, kDNSType_DS, VerifySigCallback, dv);
        <span class="enscript-comment">// We may not have the NSECS if the previous query was a non-DNSSEC query
</span>        <span class="enscript-keyword">if</span> (negcr &amp;&amp; negcr-&gt;nsec)
        {
            ValidateWithNSECS(m, dv, negcr);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        dv-&gt;next = RRVS_done;
        <span class="enscript-comment">// If we have a trust anchor, then don't bother looking up the DS record
</span>        <span class="enscript-keyword">if</span> (!dv-&gt;ds &amp;&amp; !TrustedKeyPresent(m, dv))
        {
            <span class="enscript-comment">// There is no DS for the root. Hence, if we don't have the trust
</span>            <span class="enscript-comment">// anchor for root, just fail.
</span>            <span class="enscript-keyword">if</span> (SameDomainName(qname, (<span class="enscript-type">const</span> domainname *)<span class="enscript-string">&quot;\000&quot;</span>))
            {
                LogDNSSEC(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Reached root&quot;</span>);
                dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
            debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Fetching DS&quot;</span>);
            dv-&gt;NumPackets++;
            mDNS_StartQuery(m, &amp;dv-&gt;q);
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        <span class="enscript-keyword">else</span>
        {
            debugdnssec(<span class="enscript-string">&quot;GetAllRRSetsForVerification: Skipped fetching the DS&quot;</span>);
            <span class="enscript-keyword">return</span> mDNStrue;
        }
    }
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;GetAllRRSetsForVerification: ERROR!! unknown next %d&quot;</span>, dv-&gt;next);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DNSSEC_DEBUG</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintFixedSignInfo</span>(rdataRRSig *rrsig, domainname *signerName, <span class="enscript-type">int</span> sigNameLen, mDNSu8 *fixedPart, <span class="enscript-type">int</span> fixedPartLen)
{
    <span class="enscript-type">int</span> j;
    <span class="enscript-type">char</span> buf[RRSIG_FIXED_SIZE *3 + 1]; <span class="enscript-comment">// 3 bytes count for %2x + 1 and the one byte for null at the end
</span>    <span class="enscript-type">char</span> sig[sigNameLen * 3 + 1];
    <span class="enscript-type">char</span> fp[fixedPartLen * 3 + 1];
    <span class="enscript-type">int</span> length;

    length = 0;
    <span class="enscript-keyword">for</span> (j = 0; j &lt; RRSIG_FIXED_SIZE; j++)
        length += mDNS_snprintf(buf+length, <span class="enscript-keyword">sizeof</span>(buf) - length - 1, <span class="enscript-string">&quot;%2x &quot;</span>, ((mDNSu8 *)rrsig)[j]);
    LogMsg(<span class="enscript-string">&quot;RRSIG(%d) %s&quot;</span>, RRSIG_FIXED_SIZE, buf);


    length = 0;
    <span class="enscript-keyword">for</span> (j = 0; j &lt; sigNameLen; j++)
        length += mDNS_snprintf(sig+length, <span class="enscript-keyword">sizeof</span>(sig) - length - 1, <span class="enscript-string">&quot;%2x &quot;</span>, signerName-&gt;c[j]);
    LogMsg(<span class="enscript-string">&quot;SIGNAME(%d) %s&quot;</span>, sigNameLen, sig);

    length = 0;
    <span class="enscript-keyword">for</span> (j = 0; j &lt; fixedPartLen; j++)
        length += mDNS_snprintf(fp+length, <span class="enscript-keyword">sizeof</span>(fp) - length - 1, <span class="enscript-string">&quot;%2x &quot;</span>, fixedPart[j]);
    LogMsg(<span class="enscript-string">&quot;fixedPart(%d) %s&quot;</span>, fixedPartLen, fp);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintVarSignInfo</span>(mDNSu16 rdlen, mDNSu8 *rdata)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> j;
    mDNSu8 *r;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> blen = swap16(rdlen);
    <span class="enscript-type">char</span> buf[blen * 3 + 1]; <span class="enscript-comment">// 3 bytes count for %2x + 1 and the one byte for null at the end
</span>    <span class="enscript-type">int</span> length;

    length = 0;

    r = (mDNSu8 *)&amp;rdlen;
    <span class="enscript-keyword">for</span> (j = 0; j &lt; <span class="enscript-keyword">sizeof</span>(mDNSu16); j++)
        length += mDNS_snprintf(buf+length, <span class="enscript-keyword">sizeof</span>(buf) - length - 1, <span class="enscript-string">&quot;%2x &quot;</span>, r[j]);
    LogMsg(<span class="enscript-string">&quot;RDLENGTH(%d) %s&quot;</span>, <span class="enscript-keyword">sizeof</span>(mDNSu16), buf);

    length = 0;
    <span class="enscript-keyword">for</span> (j = 0; j &lt; blen; j++)
        length += mDNS_snprintf(buf+length, <span class="enscript-keyword">sizeof</span>(buf) - length - 1, <span class="enscript-string">&quot;%2x &quot;</span>, rdata[j]);
    LogMsg(<span class="enscript-string">&quot;RDATA(%d) %s&quot;</span>, blen, buf);
}
#<span class="enscript-reference">else</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintVarSignInfo</span>(mDNSu16 rdlen, mDNSu8 *rdata)
{
    (<span class="enscript-type">void</span>)rdlen;
    (<span class="enscript-type">void</span>)rdata;
}
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintFixedSignInfo</span>(rdataRRSig *rrsig, domainname *signerName, <span class="enscript-type">int</span> sigNameLen, mDNSu8 *fixedPart, <span class="enscript-type">int</span> fixedPartLen)
{
    (<span class="enscript-type">void</span>)rrsig;
    (<span class="enscript-type">void</span>)signerName;
    (<span class="enscript-type">void</span>)sigNameLen;
    (<span class="enscript-type">void</span>)fixedPart;
    (<span class="enscript-type">void</span>)fixedPartLen;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Used for RDATA comparison
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>
{
    mDNSu16 rdlength;
    mDNSu16 rrtype;
    mDNSu8 *rdata;
} rdataComp;

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">rdata_compare</span>(mDNSu8 *<span class="enscript-type">const</span> rdata1, mDNSu8 *<span class="enscript-type">const</span> rdata2, <span class="enscript-type">int</span> rdlen1, <span class="enscript-type">int</span> rdlen2)
{
    <span class="enscript-type">int</span> len;
    <span class="enscript-type">int</span> ret;

    len = (rdlen1 &lt; rdlen2) ? rdlen1 : rdlen2;

    ret = DNSMemCmp(rdata1, rdata2, len);
    <span class="enscript-keyword">if</span> (ret != 0) <span class="enscript-keyword">return</span> ret;

    <span class="enscript-comment">// RDATA is same at this stage. Consider them equal if they are of same length. Otherwise
</span>    <span class="enscript-comment">// decide based on their lengths.
</span>    <span class="enscript-keyword">return</span> ((rdlen1 == rdlen2) ? 0 : (rdlen1 &lt; rdlen2) ? -1 : 1);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">name_compare</span>(mDNSu8 *<span class="enscript-type">const</span> rdata1, mDNSu8 *<span class="enscript-type">const</span> rdata2, <span class="enscript-type">int</span> rdlen1, <span class="enscript-type">int</span> rdlen2)
{
    domainname *n1 = (domainname *)rdata1;
    domainname *n2 = (domainname *)rdata2;
    mDNSu8 *a = n1-&gt;c;
    mDNSu8 *b = n2-&gt;c;
    <span class="enscript-type">int</span> count, c1, c2;
    <span class="enscript-type">int</span> i, j, len;

    c1 = CountLabels(n1);
    c2 = CountLabels(n2);

    count = c1 &lt; c2 ? c1 : c2;

    <span class="enscript-comment">// We can't use SameDomainName as we need to know exactly which is greater/smaller
</span>    <span class="enscript-comment">// for sorting purposes. Hence, we need to compare label by label
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++)
    {
        <span class="enscript-comment">// Are the lengths same ?
</span>        <span class="enscript-keyword">if</span> (*a != *b)
        {
            debugdnssec(<span class="enscript-string">&quot;compare_name: returning c1 %d, c2 %d&quot;</span>, *a, *b);
            <span class="enscript-keyword">return</span> ((*a &lt; *b) ? -1 : 1);
        }
        len = *a;
        rdlen1 -= (len + 1);
        rdlen2 -= (len + 1);
        <span class="enscript-keyword">if</span> (rdlen1 &lt; 0 || rdlen2 &lt; 0)
        {
            LogMsg(<span class="enscript-string">&quot;name_compare: ERROR!! not enough data rdlen1 %d, rdlen2 %d&quot;</span>, rdlen1, rdlen2);
            <span class="enscript-keyword">return</span> -1;
        }
        a++; b++;
        <span class="enscript-keyword">for</span> (j = 0; j &lt; len; j++)
        {
            mDNSu8 ac = *a++;
            mDNSu8 bc = *b++;
            <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
            <span class="enscript-keyword">if</span> (mDNSIsUpperCase(bc)) bc += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
            <span class="enscript-keyword">if</span> (ac != bc)
            {
                debugdnssec(<span class="enscript-string">&quot;compare_name: returning ac %c, bc %c&quot;</span>, ac, bc);
                <span class="enscript-keyword">return</span> ((ac &lt; bc) ? -1 : 1);
            }
        }
    }

    <span class="enscript-keyword">return</span> 0;
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">srv_compare</span>(rdataComp *<span class="enscript-type">const</span> r1, rdataComp *<span class="enscript-type">const</span> r2)
{
    <span class="enscript-type">int</span> res;
    <span class="enscript-type">int</span> length1, length2;

    length1 = r1-&gt;rdlength;
    length2 = r2-&gt;rdlength;
    <span class="enscript-comment">// We should have at least priority, weight, port plus 1 byte
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 7 || length2 &lt; 7)
    {
        LogMsg(<span class="enscript-string">&quot;srv_compare: ERROR!! Length smaller than 7 bytes&quot;</span>);
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-comment">// Compare priority, weight and port
</span>    res = DNSMemCmp(r1-&gt;rdata, r2-&gt;rdata, 6);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    length1 -= 6;
    length2 -= 6;
    <span class="enscript-keyword">return</span> (name_compare(r1-&gt;rdata + 6, r2-&gt;rdata + 6, length1, length2));
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">tsig_compare</span>(rdataComp *<span class="enscript-type">const</span> r1, rdataComp *<span class="enscript-type">const</span> r2)
{
    <span class="enscript-type">int</span> offset1, offset2;
    <span class="enscript-type">int</span> length1, length2;
    <span class="enscript-type">int</span> res, dlen;

    offset1 = offset2 = 0;
    length1 = r1-&gt;rdlength;
    length2 = r2-&gt;rdlength;

    <span class="enscript-comment">// we should have at least one byte to start with
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 1 || length2 &lt; 1)
    {
        LogMsg(<span class="enscript-string">&quot;sig_compare: Length smaller than 18 bytes&quot;</span>);
        <span class="enscript-keyword">return</span> -1;
    }

    res = name_compare(r1-&gt;rdata, r2-&gt;rdata, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;

    dlen = DomainNameLength((domainname *)r1-&gt;rdata);
    offset1 += dlen;
    offset2 += dlen;
    length1 -= dlen;
    length2 -= dlen;

    <span class="enscript-keyword">if</span> (length1 &lt;= 1 || length2 &lt;= 1)
    {
        LogMsg(<span class="enscript-string">&quot;tsig_compare: data too small to compare length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">return</span> (rdata_compare(r1-&gt;rdata + offset1, r2-&gt;rdata + offset2, length1, length2));
}

<span class="enscript-comment">// Compares types that conform to : &lt;length&gt;&lt;Value&gt;
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">lenval_compare</span>(mDNSu8 *d1, mDNSu8 *d2, <span class="enscript-type">int</span> *len1, <span class="enscript-type">int</span> *len2, <span class="enscript-type">int</span> rem1, <span class="enscript-type">int</span> rem2)
{
    <span class="enscript-type">int</span> len;
    <span class="enscript-type">int</span> res;

    <span class="enscript-keyword">if</span> (rem1 &lt;= 1 || rem2 &lt;= 1)
    {
        LogMsg(<span class="enscript-string">&quot;lenval_compare: data too small to compare length1 %d, length2 %d&quot;</span>, rem1, rem2);
        <span class="enscript-keyword">return</span> -1;
    }
    *len1 = (<span class="enscript-type">int</span>)d1[0];
    *len2 = (<span class="enscript-type">int</span>)d2[0];
    len = (*len1 &lt; *len2 ? *len1 : *len2);
    res = DNSMemCmp(d1, d2, len + 1);
    <span class="enscript-keyword">return</span> res;
}

<span class="enscript-comment">// RFC 2915: Order (2) Preference(2) and variable length: Flags Service Regexp Replacement
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">naptr_compare</span>(rdataComp *<span class="enscript-type">const</span> r1, rdataComp *<span class="enscript-type">const</span> r2)
{
    mDNSu8 *d1 = r1-&gt;rdata;
    mDNSu8 *d2 = r2-&gt;rdata;
    <span class="enscript-type">int</span> len1, len2, res;
    <span class="enscript-type">int</span> length1, length2;

    length1 = r1-&gt;rdlength;
    length2 = r2-&gt;rdlength;

    <span class="enscript-comment">// Order, Preference plus at least 1 byte
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 5 || length2 &lt; 5)
    {
        LogMsg(<span class="enscript-string">&quot;naptr_compare: Length smaller than 18 bytes&quot;</span>);
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-comment">// Compare order and preference
</span>    res = DNSMemCmp(d1, d2, 4);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;

    d1 += 4;
    d2 += 4;
    length1 -= 4;
    length2 -= 4;

    <span class="enscript-comment">// Compare Flags (including the length byte)
</span>    res = lenval_compare(d1, d2, &amp;len1, &amp;len2, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    d1 += (len1 + 1);
    d2 += (len2 + 1);
    length1 -= (len1 + 1);
    length2 -= (len2 + 1);

    <span class="enscript-comment">// Compare Service (including the length byte)
</span>    res = lenval_compare(d1, d2, &amp;len1, &amp;len2, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    d1 += (len1 + 1);
    d2 += (len2 + 1);
    length1 -= (len1 + 1);
    length2 -= (len2 + 1);

    <span class="enscript-comment">// Compare regexp (including the length byte)
</span>    res = lenval_compare(d1, d2, &amp;len1, &amp;len2, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    d1 += (len1 + 1);
    d2 += (len2 + 1);
    length1 -= (len1 + 1);
    length2 -= (len2 + 1);

    <span class="enscript-comment">// Compare Replacement
</span>    <span class="enscript-keyword">return</span> name_compare(d1, d2, length1, length2);
}

<span class="enscript-comment">// RFC 1035: MINFO: Two domain names
</span><span class="enscript-comment">// RFC 1183: RP: Two domain names
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">dom2_compare</span>(mDNSu8 *d1, mDNSu8 *d2, <span class="enscript-type">int</span> length1, <span class="enscript-type">int</span> length2)
{
    <span class="enscript-type">int</span> res, dlen;

    <span class="enscript-comment">// We need at least one byte to start with
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 1 || length2 &lt; 1)
    {
        LogMsg(<span class="enscript-string">&quot;dom2_compare:1: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }
    res = name_compare(d1, d2, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    dlen = DomainNameLength((domainname *)d1);

    length1 -= dlen;
    length2 -= dlen;
    <span class="enscript-comment">// We need at least one byte to start with
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 1 || length2 &lt; 1)
    {
        LogMsg(<span class="enscript-string">&quot;dom2_compare:2: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }

    d1 += dlen;
    d2 += dlen;

    <span class="enscript-keyword">return</span> name_compare(d1, d2, length1, length2);
}

<span class="enscript-comment">// MX : preference (2 bytes), domainname
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">mx_compare</span>(rdataComp *<span class="enscript-type">const</span> r1, rdataComp *<span class="enscript-type">const</span> r2)
{
    <span class="enscript-type">int</span> res;
    <span class="enscript-type">int</span> length1, length2;

    length1 = r1-&gt;rdlength;
    length2 = r2-&gt;rdlength;

    <span class="enscript-comment">// We need at least two bytes + 1 extra byte for the domainname to start with
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 3 || length2 &lt; 3)
    {
        LogMsg(<span class="enscript-string">&quot;mx_compare: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }

    res = DNSMemCmp(r1-&gt;rdata, r2-&gt;rdata, 2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;
    length1 -= 2;
    length2 -= 2;
    <span class="enscript-keyword">return</span> name_compare(r1-&gt;rdata + 2, r2-&gt;rdata + 2, length1, length2);
}

<span class="enscript-comment">// RFC 2163 (PX) : preference (2 bytes), map822. mapx400 (domainnames)
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">px_compare</span>(rdataComp *<span class="enscript-type">const</span> r1, rdataComp *<span class="enscript-type">const</span> r2)
{
    <span class="enscript-type">int</span> res;

    <span class="enscript-comment">// We need at least two bytes + 1 extra byte for the domainname to start with
</span>    <span class="enscript-keyword">if</span> (r1-&gt;rdlength &lt; 3 || r2-&gt;rdlength &lt; 3)
    {
        LogMsg(<span class="enscript-string">&quot;px_compare: data too small length1 %d, length2 %d&quot;</span>, r1-&gt;rdlength, r2-&gt;rdlength);
        <span class="enscript-keyword">return</span> -1;
    }

    res = DNSMemCmp(r1-&gt;rdata, r2-&gt;rdata, 2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;

    <span class="enscript-keyword">return</span> dom2_compare(r1-&gt;rdata + 2, r2-&gt;rdata + 2, r1-&gt;rdlength - 2, r2-&gt;rdlength - 2);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">soa_compare</span>(rdataComp *r1, rdataComp *r2)
{
    <span class="enscript-type">int</span> res, dlen;
    <span class="enscript-type">int</span> offset1, offset2;
    <span class="enscript-type">int</span> length1, length2;

    length1 = r1-&gt;rdlength;
    length2 = r2-&gt;rdlength;
    offset1 = offset2 = 0;

    <span class="enscript-comment">// We need at least 20 bytes plus 1 byte for each domainname
</span>    <span class="enscript-keyword">if</span> (length1 &lt; 22 || length2 &lt; 22)
    {
        LogMsg(<span class="enscript-string">&quot;soa_compare:1: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-comment">// There are two domainnames followed by 20 bytes of serial, refresh, retry, expire and min
</span>    <span class="enscript-comment">// Compare the names and then the rest of the bytes
</span>
    res = name_compare(r1-&gt;rdata, r2-&gt;rdata, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;

    dlen = DomainNameLength((domainname *)r1-&gt;rdata);

    length1 -= dlen;
    length2 -= dlen;
    <span class="enscript-keyword">if</span> (length1 &lt; 1 || length2 &lt; 1)
    {
        LogMsg(<span class="enscript-string">&quot;soa_compare:2: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }
    offset1 += dlen;
    offset2 += dlen;

    res = name_compare(r1-&gt;rdata + offset1, r2-&gt;rdata + offset2, length1, length2);
    <span class="enscript-keyword">if</span> (res != 0) <span class="enscript-keyword">return</span> res;

    dlen = DomainNameLength((domainname *)r1-&gt;rdata);
    length1 -= dlen;
    length2 -= dlen;
    <span class="enscript-keyword">if</span> (length1 &lt; 20 || length2 &lt; 20)
    {
        LogMsg(<span class="enscript-string">&quot;soa_compare:3: data too small length1 %d, length2 %d&quot;</span>, length1, length2);
        <span class="enscript-keyword">return</span> -1;
    }
    offset1 += dlen;
    offset2 += dlen;

    <span class="enscript-keyword">return</span> (rdata_compare(r1-&gt;rdata + offset1, r2-&gt;rdata + offset2, length1, length2));
}

<span class="enscript-comment">// RFC 4034 Section 6.0 states that:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A canonical RR form and ordering within an RRset are required in order to
</span><span class="enscript-comment">// construct and verify RRSIG RRs.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This function is called to order within an RRset. We can't just do a memcmp as
</span><span class="enscript-comment">// as stated in 6.3. This function is responsible for the third bullet in 6.2, where
</span><span class="enscript-comment">// the RDATA has to be converted to lower case if it has domain names.
</span>mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">RDATACompare</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *rdata1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *rdata2)
{
    rdataComp *r1 = (rdataComp *)rdata1;
    rdataComp *r2 = (rdataComp *)rdata2;

    <span class="enscript-keyword">if</span> (r1-&gt;rrtype != r2-&gt;rrtype)
    {
        LogMsg(<span class="enscript-string">&quot;RDATACompare: ERROR!! comparing rdata of wrong types type1: %d, type2: %d&quot;</span>, r1-&gt;rrtype, r2-&gt;rrtype);
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">switch</span> (r1-&gt;rrtype)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A</span>:                <span class="enscript-comment">// 1. Address Record
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NULL</span>:             <span class="enscript-comment">// 10 NULL RR
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_WKS</span>:              <span class="enscript-comment">// 11 Well-known-service
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HINFO</span>:            <span class="enscript-comment">// 13 Host information
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TXT</span>:              <span class="enscript-comment">// 16 Arbitrary text string
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_X25</span>:              <span class="enscript-comment">// 19 X_25 calling address
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_ISDN</span>:             <span class="enscript-comment">// 20 ISDN calling address
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSAP</span>:             <span class="enscript-comment">// 22 NSAP address
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KEY</span>:              <span class="enscript-comment">// 25 Security key
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_GPOS</span>:             <span class="enscript-comment">// 27 Geographical position (withdrawn)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AAAA</span>:             <span class="enscript-comment">// 28 IPv6 Address
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_LOC</span>:              <span class="enscript-comment">// 29 Location Information
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_EID</span>:              <span class="enscript-comment">// 31 Endpoint identifier
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NIMLOC</span>:           <span class="enscript-comment">// 32 Nimrod Locator
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_ATMA</span>:             <span class="enscript-comment">// 34 ATM Address
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CERT</span>:             <span class="enscript-comment">// 37 Certification record
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A6</span>:               <span class="enscript-comment">// 38 IPv6 Address (deprecated)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SINK</span>:             <span class="enscript-comment">// 40 Kitchen sink (experimental)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_OPT</span>:              <span class="enscript-comment">// 41 EDNS0 option (meta-RR)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_APL</span>:              <span class="enscript-comment">// 42 Address Prefix List
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DS</span>:               <span class="enscript-comment">// 43 Delegation Signer
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SSHFP</span>:            <span class="enscript-comment">// 44 SSH Key Fingerprint
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_IPSECKEY</span>:         <span class="enscript-comment">// 45 IPSECKEY
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RRSIG</span>:            <span class="enscript-comment">// 46 RRSIG
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC</span>:             <span class="enscript-comment">// 47 Denial of Existence
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNSKEY</span>:           <span class="enscript-comment">// 48 DNSKEY
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DHCID</span>:            <span class="enscript-comment">// 49 DHCP Client Identifier
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3</span>:            <span class="enscript-comment">// 50 Hashed Authenticated Denial of Existence
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSEC3PARAM</span>:       <span class="enscript-comment">// 51 Hashed Authenticated Denial of Existence
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_HIP</span>:              <span class="enscript-comment">// 55 Host Identity Protocol
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SPF</span>:              <span class="enscript-comment">// 99 Sender Policy Framework for E-Mail
</span>    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> rdata_compare(r1-&gt;rdata, r2-&gt;rdata, r1-&gt;rdlength, r2-&gt;rdlength);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:               <span class="enscript-comment">//  2 Name Server
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:               <span class="enscript-comment">//  3 Mail Destination
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:               <span class="enscript-comment">//  4 Mail Forwarder
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:            <span class="enscript-comment">//  5 Canonical Name
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:               <span class="enscript-comment">//  7 Mailbox
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:               <span class="enscript-comment">//  8 Mail Group
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:               <span class="enscript-comment">//  9 Mail Rename
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:              <span class="enscript-comment">// 12 Domain name pointer
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NSAP_PTR</span>:         <span class="enscript-comment">// 23 Reverse NSAP lookup (deprecated)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>:            <span class="enscript-comment">// 39 Non-terminal DNAME (for IPv6)
</span>        <span class="enscript-keyword">return</span> name_compare(r1-&gt;rdata, r2-&gt;rdata, r1-&gt;rdlength, r2-&gt;rdlength);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:              <span class="enscript-comment">// 33 Service record
</span>        <span class="enscript-keyword">return</span> srv_compare(r1, r2);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:              <span class="enscript-comment">//  6 Start of Authority
</span>        <span class="enscript-keyword">return</span> soa_compare(r1, r2);

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:               <span class="enscript-comment">// 17 Responsible person
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:            <span class="enscript-comment">// 14 Mailbox information
</span>        <span class="enscript-keyword">return</span> dom2_compare(r1-&gt;rdata, r2-&gt;rdata, r1-&gt;rdlength, r2-&gt;rdlength);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:               <span class="enscript-comment">// 15 Mail Exchanger
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:            <span class="enscript-comment">// 18 AFS cell database
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:               <span class="enscript-comment">// 21 Router
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:               <span class="enscript-comment">// 36 Key Exchange
</span>        <span class="enscript-keyword">return</span> mx_compare(r1, r2);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:               <span class="enscript-comment">// 26 X.400 mail mapping
</span>        <span class="enscript-keyword">return</span> px_compare(r1, r2);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NAPTR</span>:            <span class="enscript-comment">// 35 Naming Authority PoinTeR
</span>        <span class="enscript-keyword">return</span> naptr_compare(r1, r2);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TKEY</span>:             <span class="enscript-comment">// 249 Transaction key
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>:             <span class="enscript-comment">// 250 Transaction signature
</span>        <span class="enscript-comment">// TSIG and TKEY have a domainname followed by data
</span>        <span class="enscript-keyword">return</span> tsig_compare(r1, r2);
    <span class="enscript-comment">// TBD: We are comparing them as opaque types, perhaps not right
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SIG</span>:              <span class="enscript-comment">// 24 Security signature
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NXT</span>:              <span class="enscript-comment">// 30 Next domain (security)
</span>        LogMsg(<span class="enscript-string">&quot;RDATACompare: WARNING!! explicit support has not been added, using default&quot;</span>);
        <span class="enscript-keyword">return</span> rdata_compare(r1-&gt;rdata, r2-&gt;rdata, r1-&gt;rdlength, r2-&gt;rdlength);
    }
}



<span class="enscript-comment">// RFC 4034 section 6.2 requirement for verifying signature.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 3. if the type of the RR is NS, MD, MF, CNAME, SOA, MB, MG, MR, PTR,
</span><span class="enscript-comment">// HINFO, MINFO, MX, HINFO, RP, AFSDB, RT, SIG, PX, NXT, NAPTR, KX,
</span><span class="enscript-comment">// SRV, DNAME, A6, RRSIG, or NSEC, all uppercase US-ASCII letters in
</span><span class="enscript-comment">// the DNS names contained within the RDATA are replaced by the
</span><span class="enscript-comment">// corresponding lowercase US-ASCII letters;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// NSEC and HINFO is not needed as per dnssec-bis update. RRSIG is done elsewhere
</span><span class="enscript-comment">// as part of signature verification
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ConvertRDATAToCanonical</span>(mDNSu16 rrtype, mDNSu16 rdlength, mDNSu8 *rdata)
{
    domainname name;
    <span class="enscript-type">int</span> len;
    mDNSu8 *origRdata = rdata;

    <span class="enscript-comment">// Ensure that we have at least one byte of data to examine and modify.
</span>
    <span class="enscript-keyword">if</span> (!rdlength) { LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: rdlength zero for rrtype %s&quot;</span>, DNSTypeName(rrtype)); <span class="enscript-keyword">return</span>; }

    <span class="enscript-keyword">switch</span> (rrtype)
    {
    <span class="enscript-comment">// Not adding suppot for A6 as it is deprecated
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_A6</span>:               <span class="enscript-comment">// 38 IPv6 Address (deprecated)
</span>    <span class="enscript-reference">default</span>:
        debugdnssec(<span class="enscript-string">&quot;ConvertRDATAToCanonical: returning from default %s&quot;</span>, DNSTypeName(rrtype));
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NS</span>:               <span class="enscript-comment">//  2 Name Server
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MD</span>:               <span class="enscript-comment">//  3 Mail Destination
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MF</span>:               <span class="enscript-comment">//  4 Mail Forwarder
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_CNAME</span>:            <span class="enscript-comment">//  5 Canonical Name
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MB</span>:               <span class="enscript-comment">//  7 Mailbox
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MG</span>:               <span class="enscript-comment">//  8 Mail Group
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MR</span>:               <span class="enscript-comment">//  9 Mail Rename
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PTR</span>:              <span class="enscript-comment">// 12 Domain name pointer
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_DNAME</span>:            <span class="enscript-comment">// 39 Non-terminal DNAME (for IPv6)
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NXT</span>:              <span class="enscript-comment">// 30 Next domain (security)
</span>
    <span class="enscript-comment">// TSIG and TKEY are not mentioned in RFC 4034, but we just leave it here
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TSIG</span>:             <span class="enscript-comment">// 250 Transaction signature
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_TKEY</span>:             <span class="enscript-comment">// 249 Transaction key
</span>
        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)rdata, &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)rdata, &amp;name);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MX</span>:               <span class="enscript-comment">// 15 Mail Exchanger
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_AFSDB</span>:            <span class="enscript-comment">// 18 AFS cell database
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RT</span>:               <span class="enscript-comment">// 21 Router
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_KX</span>:               <span class="enscript-comment">// 36 Key Exchange
</span>
        <span class="enscript-comment">// format: preference - 2 bytes, followed by name
</span>        <span class="enscript-comment">// Ensure that we have at least 3 bytes (preference + 1 byte for the domain name)
</span>        <span class="enscript-keyword">if</span> (rdlength &lt;= 3)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:MX: rdlength %d for rrtype %s too small&quot;</span>, rdlength, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)(rdata + 2), &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: MX: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)(rdata + 2), &amp;name);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SRV</span>:              <span class="enscript-comment">// 33 Service record
</span>        <span class="enscript-comment">// format : priority, weight and port - 6 bytes, followed by name
</span>        <span class="enscript-keyword">if</span> (rdlength &lt;= 7)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:SRV: rdlength %d for rrtype %s too small&quot;</span>, rdlength, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)(rdata + 6), &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: SRV: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)(rdata + 6), &amp;name);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_PX</span>:               <span class="enscript-comment">// 26 X.400 mail mapping
</span>        <span class="enscript-keyword">if</span> (rdlength &lt;= 3)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:PX: rdlength %d for rrtype %s too small&quot;</span>, rdlength, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// Preference followed by two domain names
</span>        rdata += 2;
    <span class="enscript-comment">/* FALLTHROUGH */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_RP</span>:               <span class="enscript-comment">// 17 Responsible person
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SOA</span>:              <span class="enscript-comment">//  6 Start of Authority
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_MINFO</span>:            <span class="enscript-comment">// 14 Mailbox information
</span>        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)rdata, &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: SOA1: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }

        AssignDomainName((domainname *)rdata, &amp;name);
        len = DomainNameLength((domainname *)rdata);
        <span class="enscript-keyword">if</span> (rdlength &lt;= len + 1)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:RP: rdlength %d for rrtype %s too small&quot;</span>, rdlength, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        rdata += len;

        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)rdata, &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: SOA2: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)rdata, &amp;name);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_NAPTR</span>:            <span class="enscript-comment">// 35 Naming Authority Pointer
</span>        <span class="enscript-comment">// order and preference
</span>        rdata += 4;
        <span class="enscript-comment">// Flags (including the length byte)
</span>        rdata += (((<span class="enscript-type">int</span>) rdata[0]) + 1);
        <span class="enscript-comment">// Service (including the length byte)
</span>        rdata += (((<span class="enscript-type">int</span>) rdata[0]) + 1);
        <span class="enscript-comment">// regexp (including the length byte)
</span>        rdata += (((<span class="enscript-type">int</span>) rdata[0]) + 1);

        <span class="enscript-comment">// Replacement field is a domainname. If we have at least one more byte, then we are okay.
</span>        <span class="enscript-keyword">if</span> ((origRdata + rdlength) &lt; rdata + 1)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:NAPTR: origRdata %p, rdlength %d, rdata %p for rrtype %s too small&quot;</span>, origRdata, rdlength, rdata, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)rdata, &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: NAPTR2: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)rdata, &amp;name);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDNSType_SIG</span>:              <span class="enscript-comment">// 24 Security signature
</span>        <span class="enscript-comment">// format: &lt;18 bytes&gt; &lt;domainname&gt; &lt;data&gt;
</span>        <span class="enscript-keyword">if</span> (rdlength &lt;= 19)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical:SIG: rdlength %d for rrtype %s too small&quot;</span>, rdlength, DNSTypeName(rrtype));
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// Preference followed by two domain names
</span>        rdata += 18;
        <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)rdata, &amp;name) != mStatus_NoError)
        {
            LogMsg(<span class="enscript-string">&quot;ConvertRDATAToCanonical: SIG: ERROR!! DNSNameToLowerCase failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        AssignDomainName((domainname *)rdata, &amp;name);
        <span class="enscript-keyword">return</span>;
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">ValidateSignatureWithKey</span>(DNSSECVerifier *dv, RRVerifier *rrset, RRVerifier *keyv, RRVerifier *sig)
{
    domainname name;
    domainname signerName;
    <span class="enscript-type">int</span> labels;
    mDNSu8 fixedPart[MAX_DOMAIN_NAME + 8];  <span class="enscript-comment">// domainname + type + class + ttl
</span>    <span class="enscript-type">int</span> fixedPartLen;
    RRVerifier *tmp;
    <span class="enscript-type">int</span> nrrsets;
    rdataComp *ptr, *start, *p;
    rdataRRSig *rrsig;
    rdataDNSKey *key;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> sigNameLen;
    mDNSu16 temp;
    mStatus algRet;


    key = (rdataDNSKey *)keyv-&gt;rdata;
    rrsig = (rdataRRSig *)sig-&gt;rdata;

    LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKey: Validating signature with key with tag %d&quot;</span>, (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength));

    <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)&amp;rrsig-&gt;signerName, &amp;signerName) != mStatus_NoError)
    {
        LogMsg(<span class="enscript-string">&quot;ValidateSignatureWithKey: ERROR!! cannot convert signer name to lower case&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)&amp;rrset-&gt;name, &amp;name) != mStatus_NoError)
    {
        LogMsg(<span class="enscript-string">&quot;ValidateSignatureWithKey: ERROR!! cannot convert rrset name to lower case&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    sigNameLen = DomainNameLength(&amp;signerName);
    labels = CountLabels(&amp;name);
    <span class="enscript-comment">// RFC 4034: RRSIG validation
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// signature = sign(RRSIG_RDATA | RR(1) | RR(2)... )
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// where RRSIG_RDATA excludes the signature and signer name in canonical form
</span>
    <span class="enscript-keyword">if</span> (dv-&gt;ctx) AlgDestroy(dv-&gt;ctx);
    dv-&gt;ctx = AlgCreate(CRYPTO_ALG, rrsig-&gt;alg);
    <span class="enscript-keyword">if</span> (!dv-&gt;ctx)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKey: ERROR!! No algorithm support for %d&quot;</span>, rrsig-&gt;alg);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)rrsig, RRSIG_FIXED_SIZE);
    AlgAdd(dv-&gt;ctx, signerName.c, sigNameLen);

    <span class="enscript-keyword">if</span> (labels - rrsig-&gt;labels &gt; 0)
    {
        domainname *d;
        LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKey: ====splitting labels %d, rrsig-&gt;labels %d====&quot;</span>, labels,rrsig-&gt;labels);
        d = (domainname *)SkipLeadingLabels(&amp;name, labels - rrsig-&gt;labels);
        fixedPart[0] = 1;
        fixedPart[1] = <span class="enscript-string">'*'</span>;
        AssignDomainName((domainname *)(fixedPart + 2), d);
        fixedPartLen = DomainNameLength(d) + 2;
        <span class="enscript-comment">// See RFC 4034 section 3.1.3. If you are looking up *.example.com,
</span>        <span class="enscript-comment">// the labels count in the RRSIG is 2, but this is not considered as
</span>        <span class="enscript-comment">// a wildcard answer
</span>        <span class="enscript-keyword">if</span> (name.c[0] != 1 || name.c[1] != <span class="enscript-string">'*'</span>)
        {
            LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKey: Wildcard exapnded answer for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
            dv-&gt;flags |= WILDCARD_PROVES_ANSWER_EXPANDED;
            dv-&gt;wildcardName = (domainname *)SkipLeadingLabels(&amp;dv-&gt;origName, labels - rrsig-&gt;labels);
            <span class="enscript-keyword">if</span> (!dv-&gt;wildcardName) <span class="enscript-keyword">return</span> mDNSfalse;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        debugdnssec(<span class="enscript-string">&quot;ValidateSignatureWithKey: assigning domainname&quot;</span>);
        AssignDomainName((domainname *)fixedPart, &amp;name);
        fixedPartLen = DomainNameLength(&amp;name);
    }
    temp = swap16(rrset-&gt;rrtype);
    mDNSPlatformMemCopy(fixedPart + fixedPartLen, (mDNSu8 *)&amp;temp, <span class="enscript-keyword">sizeof</span>(rrset-&gt;rrtype));
    fixedPartLen += <span class="enscript-keyword">sizeof</span>(rrset-&gt;rrtype);
    temp = swap16(rrset-&gt;rrclass);
    mDNSPlatformMemCopy(fixedPart + fixedPartLen, (mDNSu8 *)&amp;temp, <span class="enscript-keyword">sizeof</span>(rrset-&gt;rrclass));
    fixedPartLen += <span class="enscript-keyword">sizeof</span>(rrset-&gt;rrclass);
    mDNSPlatformMemCopy(fixedPart + fixedPartLen, (mDNSu8 *)&amp;rrsig-&gt;origTTL, <span class="enscript-keyword">sizeof</span>(rrsig-&gt;origTTL));
    fixedPartLen += <span class="enscript-keyword">sizeof</span>(rrsig-&gt;origTTL);


    <span class="enscript-keyword">for</span> (tmp = rrset, nrrsets = 0; tmp; tmp = tmp-&gt;next)
        nrrsets++;

    tmp = rrset;
    start = ptr = (rdataComp *) mDNSPlatformMemAllocateClear(nrrsets * <span class="enscript-keyword">sizeof</span>(rdataComp));
    debugdnssec(<span class="enscript-string">&quot;ValidateSignatureWithKey: start %p, nrrsets %d&quot;</span>, start, nrrsets);
    <span class="enscript-keyword">if</span> (ptr)
    {
        <span class="enscript-keyword">while</span> (tmp)
        {
            ptr-&gt;rdlength = tmp-&gt;rdlength;
            ptr-&gt;rrtype = tmp-&gt;rrtype;
            <span class="enscript-keyword">if</span> (ptr-&gt;rdlength)
            {
                ptr-&gt;rdata = (mDNSu8 *) mDNSPlatformMemAllocate(ptr-&gt;rdlength);
                <span class="enscript-keyword">if</span> (ptr-&gt;rdata)
                {
                    mDNSPlatformMemCopy(ptr-&gt;rdata, tmp-&gt;rdata, tmp-&gt;rdlength);
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-keyword">for</span> (i = 0; i &lt; nrrsets; i++)
                        <span class="enscript-keyword">if</span> (start[i].rdata) mDNSPlatformMemFree(start[i].rdata);
                    mDNSPlatformMemFree(start);
                    LogMsg(<span class="enscript-string">&quot;ValidateSignatureWithKey:1: ERROR!! RDATA memory alloation failure&quot;</span>);
                    <span class="enscript-keyword">return</span> mDNSfalse;
                }
            }
            ptr++;
            tmp = tmp-&gt;next;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        LogMsg(<span class="enscript-string">&quot;ValidateSignatureWithKey:2: ERROR!! RDATA memory alloation failure&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    PrintFixedSignInfo(rrsig, &amp;signerName, sigNameLen, fixedPart, fixedPartLen);

    mDNSPlatformQsort(start, nrrsets, <span class="enscript-keyword">sizeof</span>(rdataComp), RDATACompare);
    <span class="enscript-keyword">for</span> (p = start, i = 0; i &lt; nrrsets; p++, i++)
    {
        <span class="enscript-type">int</span> rdlen;

        <span class="enscript-comment">// The array is sorted and hence checking adjacent entries for duplicate is sufficient
</span>        <span class="enscript-keyword">if</span> (i &gt; 0)
        {
            rdataComp *q = p - 1;
            <span class="enscript-keyword">if</span> (!RDATACompare((<span class="enscript-type">void</span> *)p, (<span class="enscript-type">void</span> *)q)) <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// Add the fixed part
</span>        AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)fixedPart, fixedPartLen);

        <span class="enscript-comment">// Add the rdlength
</span>        rdlen = swap16(p-&gt;rdlength);
        AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)&amp;rdlen, <span class="enscript-keyword">sizeof</span>(mDNSu16));

        ConvertRDATAToCanonical(p-&gt;rrtype, p-&gt;rdlength, p-&gt;rdata);

        PrintVarSignInfo(rdlen, p-&gt;rdata);
        AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)p-&gt;rdata, p-&gt;rdlength);
    }
    <span class="enscript-comment">// free the memory as we don't need it anymore
</span>    <span class="enscript-keyword">for</span> (i = 0; i &lt; nrrsets; i++)
        <span class="enscript-keyword">if</span> (start[i].rdata) mDNSPlatformMemFree(start[i].rdata);
    mDNSPlatformMemFree(start);

    algRet = AlgVerify(dv-&gt;ctx, (mDNSu8 *)&amp;key-&gt;data, keyv-&gt;rdlength - DNSKEY_FIXED_SIZE, (mDNSu8 *)(sig-&gt;rdata + sigNameLen + RRSIG_FIXED_SIZE), sig-&gt;rdlength - RRSIG_FIXED_SIZE - sigNameLen);
    AlgDestroy(dv-&gt;ctx);
    dv-&gt;ctx = mDNSNULL;
    <span class="enscript-keyword">if</span> (algRet != mStatus_NoError)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKey: AlgVerify failed for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-comment">// Reset the state if we set any above.
</span>        <span class="enscript-keyword">if</span> (dv-&gt;flags &amp; WILDCARD_PROVES_ANSWER_EXPANDED)
        {
            dv-&gt;flags &amp;= ~WILDCARD_PROVES_ANSWER_EXPANDED;
            dv-&gt;wildcardName = mDNSNULL;
        }
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// Walk all the keys and for each key walk all the RRSIGS that signs the original rrset
</span>mDNSlocal mStatus <span class="enscript-function-name">ValidateSignature</span>(DNSSECVerifier *dv, RRVerifier **resultKey, RRVerifier **resultRRSIG)
{
    RRVerifier *rrset;
    RRVerifier *keyv;
    RRVerifier *rrsigv;
    RRVerifier *sig;
    rdataDNSKey *key;
    rdataRRSig *rrsig;
    mDNSu16 tag;

    rrset = dv-&gt;rrset;
    sig = dv-&gt;rrsig;

    <span class="enscript-keyword">for</span> (keyv = dv-&gt;key; keyv; keyv = keyv-&gt;next)
    {
        key = (rdataDNSKey *)keyv-&gt;rdata;
        tag = (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength);
        <span class="enscript-keyword">for</span> (rrsigv = sig; rrsigv; rrsigv = rrsigv-&gt;next)
        {
            rrsig = (rdataRRSig *)rrsigv-&gt;rdata;
            <span class="enscript-comment">// 7. The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST match the owner
</span>            <span class="enscript-comment">//    name, algorithm, and key tag for some DNSKEY RR in the zone's apex DNSKEY RRset.
</span>            <span class="enscript-keyword">if</span> (!SameDomainName((domainname *)&amp;rrsig-&gt;signerName, &amp;keyv-&gt;name))
            {
                debugdnssec(<span class="enscript-string">&quot;ValidateSignature: name mismatch&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (key-&gt;alg != rrsig-&gt;alg)
            {
                debugdnssec(<span class="enscript-string">&quot;ValidateSignature: alg mismatch&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (tag != swap16(rrsig-&gt;keyTag))
            {
                debugdnssec(<span class="enscript-string">&quot;ValidateSignature: keyTag mismatch rrsig tag %d(0x%x), keyTag %d(0x%x)&quot;</span>, swap16(rrsig-&gt;keyTag),
                            swap16(rrsig-&gt;keyTag), tag, tag);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-comment">// 8. The matching DNSKEY RR MUST be present in the zone's apex DNSKEY RRset, and MUST
</span>            <span class="enscript-comment">//    have the Zone Flag bit (DNSKEY RDATA Flag bit 7) set.
</span>            <span class="enscript-keyword">if</span> (!((swap16(key-&gt;flags)) &amp; DNSKEY_ZONE_SIGN_KEY))
            {
                debugdnssec(<span class="enscript-string">&quot;ValidateSignature: ZONE flag bit not set&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }
            debugdnssec(<span class="enscript-string">&quot;ValidateSignature:Found a key and RRSIG tag: %d&quot;</span>, tag);
            <span class="enscript-keyword">if</span> (ValidateSignatureWithKey(dv, rrset, keyv, rrsigv))
            {
                LogDNSSEC(<span class="enscript-string">&quot;ValidateSignature: Validated successfully with key tag %d&quot;</span>, tag);
                *resultKey = keyv;
                *resultRRSIG = rrsigv;
                <span class="enscript-keyword">return</span> mStatus_NoError;
            }
        }
    }
    *resultKey = mDNSNULL;
    *resultRRSIG = mDNSNULL;
    <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal mDNSBool <span class="enscript-function-name">ValidateSignatureWithKeyForAllRRSigs</span>(DNSSECVerifier *dv, RRVerifier *rrset, RRVerifier *keyv, RRVerifier *sig)
{
    rdataRRSig *rrsig;
    mDNSu16 tag;

    <span class="enscript-keyword">while</span> (sig)
    {
        rrsig = (rdataRRSig *)sig-&gt;rdata;
        tag = (mDNSu16)keytag(keyv-&gt;rdata, keyv-&gt;rdlength);
        <span class="enscript-keyword">if</span> (tag == swap16(rrsig-&gt;keyTag))
        {
            <span class="enscript-keyword">if</span> (ValidateSignatureWithKey(dv, rrset, keyv, sig))
            {
                LogDNSSEC(<span class="enscript-string">&quot;ValidateSignatureWithKeyForAllRRSigs: Validated&quot;</span>);
                <span class="enscript-keyword">return</span> mDNStrue;
            }
        }
        sig = sig-&gt;next;
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal mStatus <span class="enscript-function-name">ValidateDS</span>(DNSSECVerifier *dv)
{
    mDNSu8 *digest;
    <span class="enscript-type">int</span> digestLen;
    domainname name;
    rdataRRSig *rrsig;
    rdataDS *ds;
    rdataDNSKey *key;
    RRVerifier *keyv;
    RRVerifier *dsv;
    mStatus algRet;

    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;

    <span class="enscript-comment">// Walk all the DS Records to see if we have a matching DNS KEY record that verifies
</span>    <span class="enscript-comment">// the hash. If we find one, verify that this key was used to sign the KEY rrsets in
</span>    <span class="enscript-comment">// this zone. Loop till we find one.
</span>    <span class="enscript-keyword">for</span> (dsv = dv-&gt;ds; dsv; dsv = dsv-&gt;next)
    {
        ds = (rdataDS *)dsv-&gt;rdata;
        <span class="enscript-keyword">if</span> ((ds-&gt;digestType != SHA1_DIGEST_TYPE) &amp;&amp; (ds-&gt;digestType != SHA256_DIGEST_TYPE))
        {
            LogDNSSEC(<span class="enscript-string">&quot;ValidateDS: Unsupported digest %d&quot;</span>, ds-&gt;digestType);
            <span class="enscript-keyword">return</span> mStatus_BadParamErr;
        }
        <span class="enscript-keyword">else</span> debugdnssec(<span class="enscript-string">&quot;ValidateDS: digest type %d&quot;</span>, ds-&gt;digestType);
        <span class="enscript-keyword">for</span> (keyv = dv-&gt;key; keyv; keyv = keyv-&gt;next)
        {
            key = (rdataDNSKey *)keyv-&gt;rdata;
            mDNSu16 tag = (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength);
            <span class="enscript-keyword">if</span> (tag != swap16(ds-&gt;keyTag))
            {
                debugdnssec(<span class="enscript-string">&quot;ValidateDS:Not a valid keytag %d&quot;</span>, tag);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)&amp;rrsig-&gt;signerName, &amp;name) != mStatus_NoError)
            {
                LogMsg(<span class="enscript-string">&quot;ValidateDS: ERROR!! cannot convert to lower case&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (dv-&gt;ctx) AlgDestroy(dv-&gt;ctx);
            dv-&gt;ctx = AlgCreate(DIGEST_ALG, ds-&gt;digestType);
            <span class="enscript-keyword">if</span> (!dv-&gt;ctx)
            {
                LogMsg(<span class="enscript-string">&quot;ValidateDS: ERROR!! Cannot allocate context&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }
            digest = (mDNSu8 *)&amp;ds-&gt;digest;
            digestLen = dsv-&gt;rdlength - DS_FIXED_SIZE;

            AlgAdd(dv-&gt;ctx, name.c, DomainNameLength(&amp;name));
            AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)key, keyv-&gt;rdlength);

            algRet = AlgVerify(dv-&gt;ctx, mDNSNULL, 0, digest, digestLen);
            AlgDestroy(dv-&gt;ctx);
            dv-&gt;ctx = mDNSNULL;
            <span class="enscript-keyword">if</span> (algRet == mStatus_NoError)
            {
                LogDNSSEC(<span class="enscript-string">&quot;ValidateDS: DS Validated Successfully, need to verify the key %d&quot;</span>, tag);
                <span class="enscript-comment">// We found the DNS KEY that is authenticated by the DS in our parent zone. Check to see if this key
</span>                <span class="enscript-comment">// was used to sign the DNS KEY RRSET. If so, then the keys in our DNS KEY RRSET are valid
</span>                <span class="enscript-keyword">if</span> (ValidateSignatureWithKeyForAllRRSigs(dv, dv-&gt;key, keyv, dv-&gt;rrsigKey))
                {
                    LogDNSSEC(<span class="enscript-string">&quot;ValidateDS: DS Validated Successfully %d&quot;</span>, tag);
                    <span class="enscript-keyword">return</span> mStatus_NoError;
                }
            }
        }
    }
    <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal mDNSBool <span class="enscript-function-name">UnlinkRRVerifier</span>(DNSSECVerifier *dv, RRVerifier *elem, RRVerifierSet set)
{
    RRVerifier **v;

    <span class="enscript-keyword">switch</span> (set)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rr</span>:
        v = &amp;dv-&gt;rrset;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig</span>:
        v = &amp;dv-&gt;rrsig;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_key</span>:
        v = &amp;dv-&gt;key;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig_key</span>:
        v = &amp;dv-&gt;rrsigKey;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_ds</span>:
        v = &amp;dv-&gt;ds;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;UnlinkRRVerifier: ERROR!! default case %d&quot;</span>, set);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">while</span> (*v &amp;&amp; *v != elem)
        v = &amp;(*v)-&gt;next;
    <span class="enscript-keyword">if</span> (!(*v))
    {
        LogMsg(<span class="enscript-string">&quot;UnlinkRRVerifier: ERROR!! cannot find element in set %d&quot;</span>, set);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    *v = elem-&gt;next;                  <span class="enscript-comment">// Cut this record from the list
</span>    elem-&gt;next = mDNSNULL;
    <span class="enscript-keyword">return</span> mDNStrue;
}

<span class="enscript-comment">// This can link a single AuthChain element or a list of AuthChain elements to
</span><span class="enscript-comment">// DNSSECVerifier. The latter happens when we have multiple NSEC proofs and
</span><span class="enscript-comment">// we gather up all the proofs in one place.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">AuthChainLink</span>(DNSSECVerifier *dv, AuthChain *ae)
{
    AuthChain *head;

    LogDNSSEC(<span class="enscript-string">&quot;AuthChainLink: called&quot;</span>);

    head = ae;
    <span class="enscript-comment">// Get to the last element
</span>    <span class="enscript-keyword">while</span> (ae-&gt;next)
        ae = ae-&gt;next;
    *(dv-&gt;actail) = head;                <span class="enscript-comment">// Append this record to tail of auth chain
</span>    dv-&gt;actail = &amp;(ae-&gt;next);          <span class="enscript-comment">// Advance tail pointer
</span>}

mDNSlocal mDNSBool <span class="enscript-function-name">AuthChainAdd</span>(DNSSECVerifier *dv, RRVerifier *resultKey, RRVerifier *resultRRSig)
{
    AuthChain *ae;
    rdataDNSKey *key;
    mDNSu16 tag;

    <span class="enscript-keyword">if</span> (!dv-&gt;rrset || !resultKey || !resultRRSig)
    {
        LogMsg(<span class="enscript-string">&quot;AuthChainAdd: ERROR!! input argument NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// Unlink resultKey and resultRRSig and store as part of AuthChain
</span>    <span class="enscript-keyword">if</span> (!UnlinkRRVerifier(dv, resultKey, RRVS_key))
    {
        LogMsg(<span class="enscript-string">&quot;AuthChainAdd: ERROR!! cannot unlink key&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (!UnlinkRRVerifier(dv, resultRRSig, RRVS_rrsig))
    {
        LogMsg(<span class="enscript-string">&quot;AuthChainAdd: ERROR!! cannot unlink rrsig&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    ae = (AuthChain *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*ae));
    <span class="enscript-keyword">if</span> (!ae)
    {
        LogMsg(<span class="enscript-string">&quot;AuthChainAdd: AuthChain alloc failure&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    ae-&gt;next  = mDNSNULL;
    ae-&gt;rrset = dv-&gt;rrset;
    dv-&gt;rrset = mDNSNULL;

    ae-&gt;rrsig = resultRRSig;
    ae-&gt;key   = resultKey;

    key = (rdataDNSKey *)resultKey-&gt;rdata;
    tag = (mDNSu16)keytag((mDNSu8 *)key, resultKey-&gt;rdlength);
    LogDNSSEC(<span class="enscript-string">&quot;AuthChainAdd: inserting AuthChain element with rrset %##s (%s), DNSKEY tag %d&quot;</span>, ae-&gt;rrset-&gt;name.c, DNSTypeName(ae-&gt;rrset-&gt;rrtype), tag);

    AuthChainLink(dv, ae);
    <span class="enscript-keyword">return</span> mDNStrue;
}
	
<span class="enscript-comment">// RFC 4035: Section 5.3.3
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If the resolver accepts the RRset as authentic, the validator MUST set the TTL of
</span><span class="enscript-comment">// the RRSIG RR and each RR in the authenticated RRset to a value no greater than the
</span><span class="enscript-comment">// minimum of:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   o  the RRset's TTL as received in the response;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   o  the RRSIG RR's TTL as received in the response;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   o  the value in the RRSIG RR's Original TTL field; and
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//   o  the difference of the RRSIG RR's Signature Expiration time and the
</span><span class="enscript-comment">//      current time.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">SetTTLRRSet</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, DNSSECStatus status)
{
    DNSQuestion question;
    CacheRecord *rr;
    RRVerifier *rrsigv;
    rdataRRSig *rrsig;
    CacheGroup *cg;
    mDNSu32 rrTTL, rrsigTTL, rrsigOrigTTL, rrsigTimeTTL;
    domainname *qname;
    mDNSu16 qtype;
    CacheRecord *rrsigRR;
    mDNSs32 now;

    debugdnssec(<span class="enscript-string">&quot;SetTTLRRSet called&quot;</span>);

    <span class="enscript-keyword">if</span> (status == DNSSEC_Insecure || status == DNSSEC_Indeterminate)
    {
        LogDNSSEC(<span class="enscript-string">&quot;SetTTLRRSET: not setting ttl for status %s&quot;</span>, DNSSECStatusName(status));
        <span class="enscript-keyword">return</span>;
    }

    mDNS_Lock(m);
    now = m-&gt;timenow;
    mDNS_Unlock(m);

    mDNSPlatformMemZero(&amp;question, <span class="enscript-keyword">sizeof</span>(DNSQuestion));
    rrTTL = rrsigTTL = rrsigOrigTTL = rrsigTimeTTL = 0;

    <span class="enscript-comment">// 1. Locate the rrset name and get its TTL (take the first one as a representative
</span>    <span class="enscript-comment">// of the rrset). Ideally, we should set the TTL on the first validation. Instead,
</span>    <span class="enscript-comment">// we do it whenever we validate which happens whenever a ValidationRequired question
</span>    <span class="enscript-comment">// finishes validation. 
</span>    qname = &amp;dv-&gt;origName;
    qtype = dv-&gt;origType;

    question.ThisQInterval = -1;
    InitializeQuestion(m, &amp;question, dv-&gt;InterfaceID, qname, qtype, mDNSNULL, mDNSNULL);
    cg = CacheGroupForName(m, question.qnamehash, &amp;question.qname);

    <span class="enscript-keyword">if</span> (!cg)
    {
        LogMsg(<span class="enscript-string">&quot;SetTTLRRSet cg NULL for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">for</span> (rr = cg-&gt;members; rr; rr = rr-&gt;next)
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(rr, &amp;question))
        {
            <span class="enscript-comment">// originalttl is never touched. The actual TTL is derived based on when it was
</span>            <span class="enscript-comment">// received.
</span>            rrTTL = rr-&gt;resrec.rroriginalttl - (now - rr-&gt;TimeRcvd)/mDNSPlatformOneSecond;
            <span class="enscript-keyword">break</span>;
        }

    <span class="enscript-comment">// Should we check to see if it matches the record in dv-&gt;ac-&gt;rrset ?
</span>    <span class="enscript-keyword">if</span> (!rr)
    {
        LogMsg(<span class="enscript-string">&quot;SetTTLRRSet: ERROR!! cannot locate main rrset for %##s (%s)&quot;</span>, qname-&gt;c, DNSTypeName(qtype));
        <span class="enscript-keyword">return</span>;
    }


    <span class="enscript-comment">// 2. Get the RRSIG ttl. For NSEC records we need to get the NSEC record's TTL as
</span>    <span class="enscript-comment">// the negative cache record that we created may not be right.
</span>
    <span class="enscript-keyword">if</span> (dv-&gt;ac &amp;&amp; dv-&gt;ac-&gt;rrsig)
    {
        rrsigv = dv-&gt;ac-&gt;rrsig;
        rrsig = (rdataRRSig *)rrsigv-&gt;rdata;
    }
    <span class="enscript-keyword">else</span>
    {
        rrsigv = mDNSNULL;
        rrsig = mDNSNULL;
    }

    rrsigRR = mDNSNULL;
    <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative &amp;&amp; status == DNSSEC_Secure)
    {
        CacheRecord *ncr;
        rrTTL = 0;
        <span class="enscript-keyword">for</span> (ncr = rr-&gt;nsec; ncr; ncr = ncr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (ncr-&gt;resrec.rrtype == kDNSType_NSEC || ncr-&gt;resrec.rrtype == kDNSType_NSEC3)
            {
                rrTTL = ncr-&gt;resrec.rroriginalttl - (now - ncr-&gt;TimeRcvd)/mDNSPlatformOneSecond;
                debugdnssec(<span class="enscript-string">&quot;SetTTLRRSet: NSEC TTL %u&quot;</span>, rrTTL);
            }
            <span class="enscript-comment">// Note: we can't use dv-&gt;origName here as the NSEC record's RRSIG may not match
</span>            <span class="enscript-comment">// the original name
</span>            <span class="enscript-keyword">if</span> (rrsigv &amp;&amp; ncr-&gt;resrec.rrtype == kDNSType_RRSIG &amp;&amp; SameDomainName(ncr-&gt;resrec.name, &amp;rrsigv-&gt;name))
            {
                RDataBody2 *rdb = (RDataBody2 *)ncr-&gt;resrec.rdata-&gt;u.data;
                rdataRRSig *sig = (rdataRRSig *)rdb-&gt;data;
                <span class="enscript-keyword">if</span> (rrsigv-&gt;rdlength != ncr-&gt;resrec.rdlength)
                {
                    debugdnssec(<span class="enscript-string">&quot;SetTTLRRSet length mismatch&quot;</span>);
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-keyword">if</span> (mDNSPlatformMemSame(sig, rrsig, rrsigv-&gt;rdlength))
                {
                    mDNSu32 remain = (now - ncr-&gt;TimeRcvd)/mDNSPlatformOneSecond;
                    rrsigTTL = ncr-&gt;resrec.rroriginalttl - remain;
                    rrsigOrigTTL = swap32(rrsig-&gt;origTTL) - remain;
                    rrsigTimeTTL = swap32(rrsig-&gt;sigExpireTime) - swap32(rrsig-&gt;sigInceptTime);
                }
            }
            <span class="enscript-keyword">if</span> (rrTTL &amp;&amp; (!rrsigv || rrsigTTL)) <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rrsigv)
    {
        <span class="enscript-comment">// Look for the matching RRSIG so that we can get its TTL
</span>        <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_RRSIG &amp;&amp; SameDomainName(rr-&gt;resrec.name, &amp;rrsigv-&gt;name))
            {
                RDataBody2 *rdb = (RDataBody2 *)rr-&gt;resrec.rdata-&gt;u.data;
                rdataRRSig *sig = (rdataRRSig *)rdb-&gt;data;
                <span class="enscript-keyword">if</span> (rrsigv-&gt;rdlength != rr-&gt;resrec.rdlength)
                {
                    debugdnssec(<span class="enscript-string">&quot;SetTTLRRSet length mismatch&quot;</span>);
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-keyword">if</span> (mDNSPlatformMemSame(sig, rrsig, rrsigv-&gt;rdlength))
                {
                    mDNSu32 remain = (now - rr-&gt;TimeRcvd)/mDNSPlatformOneSecond;
                    rrsigTTL = rr-&gt;resrec.rroriginalttl - remain;
                    rrsigOrigTTL = swap32(rrsig-&gt;origTTL) - remain;
                    rrsigTimeTTL = swap32(rrsig-&gt;sigExpireTime) - swap32(rrsig-&gt;sigInceptTime);
                    rrsigRR = rr;
                    <span class="enscript-keyword">break</span>;
                }
            }
    }

    <span class="enscript-comment">// It is possible that there are no RRSIGs and in that case it is not an error
</span>    <span class="enscript-comment">// to find the rrsigTTL.
</span>    <span class="enscript-keyword">if</span> (!rrTTL || (rrsigv &amp;&amp; (!rrsigTTL || !rrsigOrigTTL || !rrsigTimeTTL)))
    {
        LogDNSSEC(<span class="enscript-string">&quot;SetTTLRRSet: ERROR!! Bad TTL rrtl %u, rrsigTTL %u, rrsigOrigTTL %u, rrsigTimeTTL %u for %##s (%s)&quot;</span>,
               rrTTL, rrsigTTL, rrsigOrigTTL, rrsigTimeTTL, qname-&gt;c, DNSTypeName(qtype));
        <span class="enscript-keyword">return</span>;
    }
    LogDNSSEC(<span class="enscript-string">&quot;SetTTLRRSet: TTL rrtl %u, rrsigTTL %u, rrsigOrigTTL %u, rrsigTimeTTL %u for %##s (%s)&quot;</span>,
        rrTTL, rrsigTTL, rrsigOrigTTL, rrsigTimeTTL, qname-&gt;c, DNSTypeName(qtype));

    <span class="enscript-keyword">if</span> (status == DNSSEC_Bogus)
    {
        rrTTL = RR_BOGUS_TTL;
        LogDNSSEC(<span class="enscript-string">&quot;SetTTLRRSet: setting to bogus TTL %d&quot;</span>, rrTTL);
    }

    <span class="enscript-keyword">if</span> (rrsigv)
    {
        <span class="enscript-keyword">if</span> (rrsigTTL &lt; rrTTL)
            rrTTL = rrsigTTL;
        <span class="enscript-keyword">if</span> (rrsigOrigTTL &lt; rrTTL)
            rrTTL = rrsigOrigTTL;
        <span class="enscript-keyword">if</span> (rrsigTimeTTL &lt; rrTTL)
            rrTTL = rrsigTimeTTL;
    }

    <span class="enscript-comment">// Set the rrsig's TTL. For NSEC records, rrsigRR is NULL which means it expires when
</span>    <span class="enscript-comment">// the negative cache record expires.
</span>    <span class="enscript-keyword">if</span> (rrsigRR)
    {
        rrsigRR-&gt;resrec.rroriginalttl = rrTTL;
        rrsigRR-&gt;TimeRcvd = now;
        rrsigRR-&gt;UnansweredQueries = 0;
    }

    <span class="enscript-comment">// Find the RRset and set its TTL
</span>    <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(rr, &amp;question))
        {
            LogDNSSEC(<span class="enscript-string">&quot;SetTTLRRSet: Setting the TTL %d for %s, question %##s (%s)&quot;</span>, rrTTL, CRDisplayString(m, rr),
                      question.qname.c, DNSTypeName(rr-&gt;resrec.rrtype));
            rr-&gt;resrec.rroriginalttl = rrTTL;
            rr-&gt;TimeRcvd = now;
            rr-&gt;UnansweredQueries = 0;
            SetNextCacheCheckTimeForRecord(m, rr);
        }
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">FinishDNSSECVerification</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    RRVerifier *resultKey;
    RRVerifier *resultRRSig;

    LogDNSSEC(<span class="enscript-string">&quot;FinishDNSSECVerification: all rdata sets available for sig verification for %##s (%s)&quot;</span>,
              dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));

    <span class="enscript-comment">// Stop outstanding query if one exists
</span>    <span class="enscript-keyword">if</span> (dv-&gt;q.ThisQInterval != -1)
        mDNS_StopQuery(m, &amp;dv-&gt;q);
    <span class="enscript-keyword">if</span> (ValidateSignature(dv, &amp;resultKey, &amp;resultRRSig) == mStatus_NoError)
    {
        rdataDNSKey *key;
        mDNSu16 tag;
        key = (rdataDNSKey *)resultKey-&gt;rdata;
        tag = (mDNSu16)keytag((mDNSu8 *)key, resultKey-&gt;rdlength);

        LogDNSSEC(<span class="enscript-string">&quot;FinishDNSSECVerification: RRSIG validated by DNSKEY tag %d, %##s (%s)&quot;</span>, tag, dv-&gt;rrset-&gt;name.c,
                  DNSTypeName(dv-&gt;rrset-&gt;rrtype));

        <span class="enscript-keyword">if</span> (TrustedKey(m, dv) == mStatus_NoError)
        {
            <span class="enscript-comment">// Need to call this after we called TrustedKey, as AuthChainAdd
</span>            <span class="enscript-comment">// unlinks the resultKey and resultRRSig
</span>            <span class="enscript-keyword">if</span> (!AuthChainAdd(dv, resultKey, resultRRSig))
            {
                dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-comment">// The callback will be called when NSEC verification is done.
</span>            <span class="enscript-keyword">if</span> ((dv-&gt;flags &amp; WILDCARD_PROVES_ANSWER_EXPANDED))
            {
                WildcardAnswerProof(m, dv);
                <span class="enscript-keyword">return</span>;
            }
            <span class="enscript-keyword">else</span>
            {
                dv-&gt;DVCallback(m, dv, DNSSEC_Secure);
                <span class="enscript-keyword">return</span>;
            }
        }
        <span class="enscript-keyword">if</span> (!ValidateDS(dv))
        {
            <span class="enscript-comment">// Need to call this after we called ValidateDS, as AuthChainAdd
</span>            <span class="enscript-comment">// unlinks the resultKey and resultRRSig
</span>            <span class="enscript-keyword">if</span> (!AuthChainAdd(dv, resultKey, resultRRSig))
            {
                dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                <span class="enscript-keyword">return</span>;
            }
            FreeDNSSECVerifierRRSets(dv);
            dv-&gt;recursed++;
            <span class="enscript-keyword">if</span> (dv-&gt;recursed &lt; MAX_RECURSE_COUNT)
            {
                LogDNSSEC(<span class="enscript-string">&quot;FinishDNSSECVerification: Recursion level %d for %##s (%s)&quot;</span>, dv-&gt;recursed, dv-&gt;origName.c,
                          DNSTypeName(dv-&gt;origType));
                VerifySignature(m, dv, &amp;dv-&gt;q);
                <span class="enscript-keyword">return</span>;
            }
        }
        <span class="enscript-keyword">else</span>
        {
            LogDNSSEC(<span class="enscript-string">&quot;FinishDNSSECVerification: ValidateDS failed %##s (%s)&quot;</span>, dv-&gt;rrset-&gt;name.c, DNSTypeName(dv-&gt;rrset-&gt;rrtype));
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }
    }
    <span class="enscript-keyword">else</span>
    {
        LogDNSSEC(<span class="enscript-string">&quot;FinishDNSSECVerification: Could not validate the rrset %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">StartDNSSECVerification</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context)
{
    mDNSBool done;
    DNSSECVerifier *dv = (DNSSECVerifier *)context;

    done = GetAllRRSetsForVerification(m, dv);
    <span class="enscript-keyword">if</span> (done)
    {
        <span class="enscript-keyword">if</span> (dv-&gt;next != RRVS_done)
            LogMsg(<span class="enscript-string">&quot;StartDNSSECVerification: ERROR!! dv-&gt;next is not done&quot;</span>);
        <span class="enscript-keyword">else</span>
            LogDNSSEC(<span class="enscript-string">&quot;StartDNSSECVerification: all rdata sets available for sig verification&quot;</span>);
        FinishDNSSECVerification(m, dv);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">else</span> debugdnssec(<span class="enscript-string">&quot;StartDNSSECVerification: all rdata sets not available for sig verification next %d&quot;</span>, dv-&gt;next);
}

mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSSECStatusName</span>(DNSSECStatus status)
{
    <span class="enscript-keyword">switch</span> (status)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Secure</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Secure&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Insecure</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Insecure&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Indeterminate</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Indeterminate&quot;</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Bogus</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Bogus&quot;</span>;
    <span class="enscript-reference">default</span>: <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Invalid&quot;</span>;
    }
}

<span class="enscript-comment">// We could not use GenerateNegativeResponse as it assumes m-&gt;CurrentQuestion to be set. Even if
</span><span class="enscript-comment">// we change that, we needs to fix its callers and so on. It is much simpler to call the callback.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeliverDNSSECStatus</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, ResourceRecord *answer, DNSSECStatus status)
{

    <span class="enscript-comment">// Can't use m-&gt;CurrentQuestion as it may already be in use
</span>    <span class="enscript-keyword">if</span> (m-&gt;ValidationQuestion)
        LogMsg(<span class="enscript-string">&quot;DeliverDNSSECStatus: ERROR!! m-&gt;ValidationQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;ValidationQuestion-&gt;qname.c, DNSTypeName(m-&gt;ValidationQuestion-&gt;qtype));

    BumpDNSSECStats(m, kStatsActionSet, kStatsTypeStatus, status);
    BumpDNSSECStats(m, kStatsActionSet, kStatsTypeExtraPackets, dv-&gt;NumPackets);
    mDNS_Lock(m);
    BumpDNSSECStats(m, kStatsActionSet, kStatsTypeLatency, m-&gt;timenow - dv-&gt;StartTime);
    mDNS_Unlock(m);

    m-&gt;ValidationQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;ValidationQuestion &amp;&amp; m-&gt;ValidationQuestion != m-&gt;NewQuestions)
    {
        DNSQuestion *q = m-&gt;ValidationQuestion;

        <span class="enscript-keyword">if</span> (q-&gt;ValidatingResponse || !q-&gt;ValidationRequired ||
           (q-&gt;ValidationState != DNSSECValInProgress) || !ResourceRecordAnswersQuestion(answer, q))
        {
            m-&gt;ValidationQuestion = q-&gt;next;
            <span class="enscript-keyword">continue</span>;
        }

        q-&gt;ValidationState = DNSSECValDone;
        q-&gt;ValidationStatus = status;

        MakeNegativeCacheRecord(m, &amp;largerec.r, &amp;q-&gt;qname, q-&gt;qnamehash, q-&gt;qtype, q-&gt;qclass, 60, mDNSInterface_Any, mDNSNULL);
        <span class="enscript-keyword">if</span> (q-&gt;qtype == answer-&gt;rrtype || status != DNSSEC_Secure)
        {
            LogDNSSEC(<span class="enscript-string">&quot;DeliverDNSSECStatus: Generating dnssec status %s for %##s (%s)&quot;</span>, DNSSECStatusName(status),
                q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            <span class="enscript-keyword">if</span> (q-&gt;QuestionCallback)
            {
                <span class="enscript-keyword">if</span> (q-&gt;DNSSECAuthInfo)
                    FreeDNSSECAuthChainInfo((AuthChain *)q-&gt;DNSSECAuthInfo);
                q-&gt;DNSSECAuthInfo = AuthChainCopy(dv-&gt;ac);
                q-&gt;DAIFreeCallback = FreeAuthChain;
                q-&gt;QuestionCallback(m, q, &amp;largerec.r.resrec, QC_dnssec);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (FollowCNAME(q, answer, QC_add))
        {
            LogDNSSEC(<span class="enscript-string">&quot;DeliverDNSSECStatus: Following CNAME dnssec status %s for %##s (%s)&quot;</span>, DNSSECStatusName(status),
                q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
            mDNS_Lock(m); 
            AnswerQuestionByFollowingCNAME(m, q, answer);
            mDNS_Unlock(m);
        }

        <span class="enscript-keyword">if</span> (m-&gt;ValidationQuestion == q)    <span class="enscript-comment">// If m-&gt;ValidationQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;ValidationQuestion = q-&gt;next;
    }
    m-&gt;ValidationQuestion = mDNSNULL;
}

<span class="enscript-comment">// There is no work to be done if we could not validate DNSSEC (as the actual response for
</span><span class="enscript-comment">// the query has already been delivered) except in the case of CNAMEs where we did not follow
</span><span class="enscript-comment">// CNAMEs until we finished the DNSSEC processing.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECNoResponse</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    CacheGroup *cg;
    CacheRecord *cr;
    mDNSu32 namehash;
    ResourceRecord *answer = mDNSNULL;

    LogDNSSEC(<span class="enscript-string">&quot;DNSSECNoResponse: called&quot;</span>);

    <span class="enscript-keyword">if</span> (dv-&gt;ValidationRequired != DNSSEC_VALIDATION_SECURE_OPTIONAL)
    {
        LogMsg(<span class="enscript-string">&quot;DNSSECNoResponse: ERROR!! ValidationRequired incorrect %d&quot;</span>, dv-&gt;ValidationRequired);
        <span class="enscript-keyword">return</span>;
    }

    BumpDNSSECStats(m, kStatsActionSet, kStatsTypeStatus, DNSSEC_NoResponse);

    namehash = DomainNameHashValue(&amp;dv-&gt;origName);

    cg = CacheGroupForName(m, namehash, &amp;dv-&gt;origName);
    <span class="enscript-keyword">if</span> (!cg)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECNoResponse: cg NULL for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, &amp;dv-&gt;origName, dv-&gt;origType, mDNSNULL, mDNSNULL);

    <span class="enscript-comment">// We don't have to reset ValidatingResponse (unlike in DeliverDNSSECStatus) as there are no
</span>    <span class="enscript-comment">// RRSIGs that can match the original question
</span>    <span class="enscript-keyword">for</span> (cr = cg-&gt;members; cr; cr = cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, &amp;dv-&gt;q))
        {
            answer = &amp;cr-&gt;resrec;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-comment">// It is not an error for things to disappear underneath
</span>    <span class="enscript-keyword">if</span> (!answer)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECNoResponse: answer NULL for %##s, %s&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> (answer-&gt;rrtype == kDNSType_RRSIG)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECNoResponse: RRSIG present for %##s, %s&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-comment">// Can't use m-&gt;CurrentQuestion as it may already be in use
</span>    <span class="enscript-keyword">if</span> (m-&gt;ValidationQuestion)
        LogMsg(<span class="enscript-string">&quot;DNSSECNoResponse: ERROR!! m-&gt;ValidationQuestion already set: %##s (%s)&quot;</span>,
               m-&gt;ValidationQuestion-&gt;qname.c, DNSTypeName(m-&gt;ValidationQuestion-&gt;qtype));

    m-&gt;ValidationQuestion = m-&gt;Questions;
    <span class="enscript-keyword">while</span> (m-&gt;ValidationQuestion &amp;&amp; m-&gt;ValidationQuestion != m-&gt;NewQuestions)
    {
        DNSQuestion *q = m-&gt;ValidationQuestion;

        <span class="enscript-keyword">if</span> (q-&gt;ValidatingResponse || !q-&gt;ValidationRequired ||
           (q-&gt;ValidationState != DNSSECValInProgress) || !ResourceRecordAnswersQuestion(answer, q))
        {
            m-&gt;ValidationQuestion = q-&gt;next;
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-comment">// If we could not validate e.g., zone was not signed or bad delegation etc., 
</span>        <span class="enscript-comment">// disable validation. Ideally, for long outstanding questions, we should try again when
</span>        <span class="enscript-comment">// we switch networks. But for now, keep it simple.
</span>        <span class="enscript-comment">// 
</span>        <span class="enscript-comment">// Note: If we followed a CNAME with no dnssec protection, it is even more important that
</span>        <span class="enscript-comment">// we disable validation as we don't want to deliver a &quot;secure&quot; dnssec response later e.g.,
</span>        <span class="enscript-comment">// it is possible that the CNAME is not secure but the address records are secure. In this
</span>        <span class="enscript-comment">// case, we don't want to deliver the secure response later as we followed a CNAME that was
</span>        <span class="enscript-comment">// not protected with DNSSEC.
</span>
        q-&gt;ValidationRequired = 0;
        q-&gt;ValidationState = DNSSECValNotRequired;
        
        <span class="enscript-keyword">if</span> (FollowCNAME(q, answer, QC_add))
        {
            LogDNSSEC(<span class="enscript-string">&quot;DNSSECNoResponse: Following CNAME for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));

            mDNS_Lock(m); 
            AnswerQuestionByFollowingCNAME(m, q, answer);
            mDNS_Unlock(m);
        }

        <span class="enscript-keyword">if</span> (m-&gt;ValidationQuestion == q)    <span class="enscript-comment">// If m-&gt;ValidationQuestion was not auto-advanced, do it ourselves now
</span>            m-&gt;ValidationQuestion = q-&gt;next;
    }
    m-&gt;ValidationQuestion = mDNSNULL;

<span class="enscript-reference">done</span>:
    FreeDNSSECVerifier(m, dv);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECPositiveValidationCB</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheGroup *cg, ResourceRecord *answer, DNSSECStatus status)
{
    RRVerifier *rrset;
    RRVerifier *rv;
    CacheRecord *cr;
    mDNSu16 rrtype, rrclass;
    CacheRecord *<span class="enscript-type">const</span> lrr = &amp;largerec.r;

    LogDNSSEC(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: called %s for %##s (%s)&quot;</span>, DNSSECStatusName(status), dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. Check to see if the rrset that was validated is the same as in cache. If they are not same,
</span>    <span class="enscript-comment">//    this validation result is not valid. When the rrset changed while the validation was in
</span>    <span class="enscript-comment">//    progress, the act of delivering the changed rrset again should have kicked off another
</span>    <span class="enscript-comment">//    verification.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. Walk the question list to find the matching question. The original question that started
</span>    <span class="enscript-comment">//    the DNSSEC verification may or may not be there. As long as there is a matching question
</span>    <span class="enscript-comment">//    and waiting for the response, deliver the response.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 3. If we are answering with CNAME, it is time to follow the CNAME if the response is secure
</span>
    <span class="enscript-keyword">if</span> (!dv-&gt;ac || status == DNSSEC_Insecure)
    {
        <span class="enscript-comment">// For Insecure status, the auth chain contains information about the trust
</span>        <span class="enscript-comment">// chain starting from the known trust anchor. The rrsets are not related to
</span>        <span class="enscript-comment">// the origName like in Bogus or Secure.
</span>        <span class="enscript-keyword">if</span> (!answer)
            LogMsg(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: ERROR: answer NULL&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (!dv-&gt;ac-&gt;rrset)
        {
            LogMsg(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: ERROR!! Validated RRSET NULL&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }

        rrset = dv-&gt;ac-&gt;rrset;
        rrtype = rrset-&gt;rrtype;
        rrclass = rrset-&gt;rrclass;
    
        lrr-&gt;resrec.name = &amp;largerec.namestorage;

        <span class="enscript-keyword">for</span> (rv = dv-&gt;ac-&gt;rrset; rv; rv = rv-&gt;next)
            rv-&gt;found = 0;

        <span class="enscript-comment">// Check to see if we can find all the elements in the rrset
</span>        <span class="enscript-keyword">for</span> (cr = cg ? cg-&gt;members : mDNSNULL; cr; cr = cr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype == rrtype &amp;&amp; cr-&gt;resrec.rrclass == rrclass)
            {
                <span class="enscript-keyword">for</span> (rv = dv-&gt;ac-&gt;rrset; rv; rv = rv-&gt;next)
                {
                    <span class="enscript-keyword">if</span> (rv-&gt;rdlength == cr-&gt;resrec.rdlength &amp;&amp; rv-&gt;rdatahash == cr-&gt;resrec.rdatahash)
                    {
                        lrr-&gt;resrec.namehash = rv-&gt;namehash;
                        lrr-&gt;resrec.rrtype = rv-&gt;rrtype;
                        lrr-&gt;resrec.rrclass = rv-&gt;rrclass;
                        lrr-&gt;resrec.rdata = (RData*)&amp;lrr-&gt;smallrdatastorage;
                        lrr-&gt;resrec.rdata-&gt;MaxRDLength = MaximumRDSize;

                        <span class="enscript-comment">// Convert the &quot;rdata&quot; to a suitable form before we can call SameRDataBody which expects
</span>                        <span class="enscript-comment">// some of the resource records in host order and also domainnames fully expanded. We
</span>                        <span class="enscript-comment">// converted the resource records into network order for verification purpose and hence
</span>                        <span class="enscript-comment">// need to convert them back again before comparing them.
</span>                        <span class="enscript-keyword">if</span> (!SetRData(mDNSNULL, rv-&gt;rdata, rv-&gt;rdata + rv-&gt;rdlength, &amp;largerec, rv-&gt;rdlength))
                        {
                            LogMsg(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: SetRData failed for %##s (%s)&quot;</span>, rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                        }
                        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SameRDataBody(&amp;cr-&gt;resrec, &amp;lrr-&gt;resrec.rdata-&gt;u, SameDomainName))
                        {
                            answer = &amp;cr-&gt;resrec;
                            rv-&gt;found = 1;
                            <span class="enscript-keyword">break</span>;
                        }
                    }
                }
                <span class="enscript-keyword">if</span> (!rv)
                {
                    <span class="enscript-comment">// The validated rrset does not have the element in the cache, re-validate
</span>                    LogDNSSEC(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: CacheRecord %s, not found in the validated set&quot;</span>, CRDisplayString(m, cr));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                }
            }
        }
        <span class="enscript-comment">// Check to see if we have elements that were not in the cache
</span>        <span class="enscript-keyword">for</span> (rv = dv-&gt;ac-&gt;rrset; rv; rv = rv-&gt;next)
        {
            <span class="enscript-keyword">if</span> (!rv-&gt;found)
            {
                <span class="enscript-comment">// We had more elements in the validated set, re-validate
</span>                LogDNSSEC(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: Record %##s (%s) not found in the cache&quot;</span>, rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
            }
        }
    }

    <span class="enscript-comment">// It is not an error for things to disappear underneath
</span>    <span class="enscript-keyword">if</span> (!answer)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECPositiveValidationCB: answer NULL for %##s, %s&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    DeliverDNSSECStatus(m, dv, answer, status);
    SetTTLRRSet(m, dv, status);

<span class="enscript-reference">done</span>:
    FreeDNSSECVerifier(m, dv);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECNegativeValidationCB</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheGroup *cg, ResourceRecord *answer, DNSSECStatus status)
{
    RRVerifier *rv;
    CacheRecord *cr;
    mDNSu16 rrtype, rrclass;
    AuthChain *ac;

    LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: called %s for %##s (%s)&quot;</span>, DNSSECStatusName(status), dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));

    <span class="enscript-keyword">if</span> (dv-&gt;parent)
    {
        <span class="enscript-comment">// When NSEC/NSEC3s validation is completed, it calls the parent's DVCallback with the
</span>        <span class="enscript-comment">// parent DNSSECVerifier which is the original one that started the verification. It itself
</span>        <span class="enscript-comment">// should not have a parent. If the NSEC/NSEC3 validation results in another NSEC/NSEC3
</span>        <span class="enscript-comment">// validation, it should chain up via the dv-&gt;parent all the way to the top.
</span>        LogMsg(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: ERROR!! dv-&gt;parent is set for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-comment">// 1. Locate the negative cache record and check the cached NSEC/NSEC3 records to see if it matches the
</span>    <span class="enscript-comment">//    NSEC/NSEC3s that were valiated. If the cached NSEC/NSEC3s changed while the validation was in progress,
</span>    <span class="enscript-comment">//    we ignore the validation results.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. Walk the question list to find the matching question. The original question that started
</span>    <span class="enscript-comment">//    the DNSSEC verification may or may not be there. As long as there is a matching question
</span>    <span class="enscript-comment">//    and waiting for the response, deliver the response.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> (!dv-&gt;ac || status == DNSSEC_Insecure)
    {
        <span class="enscript-comment">// For Insecure status, the auth chain contains information about the trust
</span>        <span class="enscript-comment">// chain starting from the known trust anchor. The rrsets are not related to
</span>        <span class="enscript-comment">// the origName like in Bogus or Secure.
</span>        <span class="enscript-keyword">if</span> (!answer)
            LogMsg(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: ERROR: answer NULL&quot;</span>);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (!dv-&gt;ac-&gt;rrset)
        {
            LogMsg(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: ERROR!! Validated RRSET NULL&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }

        rrtype = dv-&gt;origType;
        rrclass = dv-&gt;ac-&gt;rrset-&gt;rrclass;

        <span class="enscript-keyword">for</span> (ac = dv-&gt;ac; ac; ac = ac-&gt;next)
        {
            <span class="enscript-keyword">for</span> (rv = ac-&gt;rrset; rv; rv = rv-&gt;next)
            {
                <span class="enscript-keyword">if</span> (rv-&gt;rrtype == kDNSType_NSEC || rv-&gt;rrtype == kDNSType_NSEC3)
                {
                    LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: Record %p %##s (%s) marking zero&quot;</span>, rv, rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                    rv-&gt;found = 0;
                }
            }
        }

        <span class="enscript-comment">// Check to see if we can find all the elements in the rrset
</span>        <span class="enscript-keyword">for</span> (cr = cg-&gt;members; cr; cr = cr-&gt;next)
        {
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative &amp;&amp; 
                cr-&gt;resrec.rrtype == rrtype &amp;&amp; cr-&gt;resrec.rrclass == rrclass)
            {
                CacheRecord *ncr;
                <span class="enscript-keyword">for</span> (ncr = cr-&gt;nsec; ncr; ncr = ncr-&gt;next)
                {
                    <span class="enscript-comment">// We have RRSIGs for the NSECs cached there too
</span>                    <span class="enscript-keyword">if</span> (ncr-&gt;resrec.rrtype != kDNSType_NSEC &amp;&amp; ncr-&gt;resrec.rrtype != kDNSType_NSEC3)
                        <span class="enscript-keyword">continue</span>;
                    <span class="enscript-keyword">for</span> (ac = dv-&gt;ac; ac; ac = ac-&gt;next)
                    {
                        <span class="enscript-keyword">for</span> (rv = ac-&gt;rrset; rv; rv = rv-&gt;next)
                        {
                            <span class="enscript-keyword">if</span> ((rv-&gt;rrtype == kDNSType_NSEC || rv-&gt;rrtype == kDNSType_NSEC3) &amp;&amp; rv-&gt;rdlength == ncr-&gt;resrec.rdlength &amp;&amp;
                                rv-&gt;rdatahash == ncr-&gt;resrec.rdatahash)
                            {
                                <span class="enscript-keyword">if</span> (SameDomainName(ncr-&gt;resrec.name, &amp;rv-&gt;name) &amp;&amp;
                                    SameRDataBody(&amp;ncr-&gt;resrec, (<span class="enscript-type">const</span> RDataBody *)rv-&gt;rdata, SameDomainName))
                                {
                                    LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: Record %p %##s (%s) marking one&quot;</span>, rv, rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                                    answer = &amp;cr-&gt;resrec;
                                    rv-&gt;found = 1;
                                    <span class="enscript-keyword">break</span>;
                                }
                            }
                        }
                        <span class="enscript-keyword">if</span> (rv)
                            <span class="enscript-keyword">break</span>;
                    }
                }
                <span class="enscript-keyword">if</span> (!rv)
                {
                    <span class="enscript-comment">// The validated rrset does not have the element in the cache, re-validate
</span>                    LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: CacheRecord %s, not found in the validated set&quot;</span>, CRDisplayString(m, cr));
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                }
            }
        }
        <span class="enscript-comment">// Check to see if we have elements that were not in the cache
</span>        <span class="enscript-keyword">for</span> (ac = dv-&gt;ac; ac; ac = ac-&gt;next)
        {
            <span class="enscript-keyword">for</span> (rv = ac-&gt;rrset; rv; rv = rv-&gt;next)
            {
                <span class="enscript-keyword">if</span> (rv-&gt;rrtype == kDNSType_NSEC || rv-&gt;rrtype == kDNSType_NSEC3)
                {
                    <span class="enscript-keyword">if</span> (!rv-&gt;found)
                    {
                        <span class="enscript-comment">// We had more elements in the validated set, re-validate
</span>                        LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: Record %p %##s (%s) not found in the cache&quot;</span>, rv, rv-&gt;name.c, DNSTypeName(rv-&gt;rrtype));
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                    }
                    rv-&gt;found = 0;
                }
            }
        }
    }

    <span class="enscript-comment">// It is not an error for things to disappear underneath
</span>    <span class="enscript-keyword">if</span> (!answer)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECNegativeValidationCB: answer NULL for %##s, %s&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    DeliverDNSSECStatus(m, dv, answer, status); 
    SetTTLRRSet(m, dv, status);

<span class="enscript-reference">done</span>:
    FreeDNSSECVerifier(m, dv);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DNSSECValidationCB</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, DNSSECStatus status)
{
    mDNSu32 namehash;
    CacheGroup *cg;
    CacheRecord *cr;

    LogDNSSEC(<span class="enscript-string">&quot;DNSSECValidationCB: called %s for %##s (%s)&quot;</span>, DNSSECStatusName(status), dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));

    <span class="enscript-comment">// Currently, if we receive anything other than secure, we abort DNSSEC validation for
</span>    <span class="enscript-comment">// the optional case.
</span>    <span class="enscript-keyword">if</span> (dv-&gt;ValidationRequired == DNSSEC_VALIDATION_SECURE_OPTIONAL &amp;&amp; status != DNSSEC_Secure)
    {
        DNSSECNoResponse(m, dv);
        <span class="enscript-keyword">return</span>; 
    }

    <span class="enscript-keyword">if</span> (dv-&gt;ValidationRequired == DNSSEC_VALIDATION_SECURE &amp;&amp; !dv-&gt;InsecureProofDone &amp;&amp; status == DNSSEC_Bogus)
    {
        dv-&gt;InsecureProofDone = 1;
        ProveInsecure(m, dv, mDNSNULL, mDNSNULL);
        <span class="enscript-keyword">return</span>;
    }
    namehash = DomainNameHashValue(&amp;dv-&gt;origName);

    cg = CacheGroupForName(m, namehash, &amp;dv-&gt;origName);
    <span class="enscript-keyword">if</span> (!cg)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DNSSECValidationCB: cg NULL for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        FreeDNSSECVerifier(m, dv);
        <span class="enscript-keyword">return</span>;
    }
    InitializeQuestion(m, &amp;dv-&gt;q, dv-&gt;InterfaceID, &amp;dv-&gt;origName, dv-&gt;origType, mDNSNULL, mDNSNULL);
    <span class="enscript-comment">// Need to be reset ValidatingResponse as we are looking for the cache record that would answer
</span>    <span class="enscript-comment">// the original question
</span>    dv-&gt;q.ValidatingResponse = mDNSfalse;
    <span class="enscript-keyword">for</span> (cr = cg-&gt;members; cr; cr = cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(cr, &amp;dv-&gt;q))
        {
            <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative)
                DNSSECNegativeValidationCB(m, dv, cg, &amp;cr-&gt;resrec, status);
            <span class="enscript-keyword">else</span>
                DNSSECPositiveValidationCB(m, dv, cg, &amp;cr-&gt;resrec, status);
            <span class="enscript-keyword">return</span>;
        }
    }
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">VerifySignature</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, DNSQuestion *q)
{
    CacheGroup *<span class="enscript-type">const</span> cg = CacheGroupForName(m, q-&gt;qnamehash, &amp;q-&gt;qname);
    CacheRecord *rr;
    mDNSBool first = mDNSfalse;
    <span class="enscript-type">static</span> mDNSBool TrustAnchorsUpdated = mDNSfalse;

    LogDNSSEC(<span class="enscript-string">&quot;VerifySignature called for %##s (%s)&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype));
    <span class="enscript-keyword">if</span> (!TrustAnchorsUpdated)
    {
        TrustAnchorsUpdated = mDNStrue;
        UpdateTrustAnchors(m);
    }
    <span class="enscript-keyword">if</span> (!dv)
    {
        first = mDNStrue;
        <span class="enscript-keyword">if</span> (!q-&gt;qDNSServer || q-&gt;qDNSServer-&gt;isCell)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySignature: Disabled&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// We assume that the verifier's question has been initialized here so that ValidateWithNSECS below
</span>        <span class="enscript-comment">// knows what it has prove the non-existence of.
</span>        dv = AllocateDNSSECVerifier(m, &amp;q-&gt;qname, q-&gt;qtype, q-&gt;InterfaceID, q-&gt;ValidationRequired, DNSSECValidationCB, VerifySigCallback);
        <span class="enscript-keyword">if</span> (!dv)
        {
            LogMsg(<span class="enscript-string">&quot;VerifySignature: ERROR!! memory alloc failed&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
    }

    <span class="enscript-comment">// If we find a CNAME response to the question, remember what qtype
</span>    <span class="enscript-comment">// caused the CNAME response. origType is not sufficient as we
</span>    <span class="enscript-comment">// recursively validate the response and origType is initialized above
</span>    <span class="enscript-comment">// the first time this function is called.
</span>    dv-&gt;currQtype = q-&gt;qtype;

    <span class="enscript-comment">// Walk the cache and get all the rrsets for verification.
</span>    <span class="enscript-keyword">for</span> (rr = cg ? cg-&gt;members : mDNSNULL; rr; rr=rr-&gt;next)
        <span class="enscript-keyword">if</span> (SameNameCacheRecordAnswersQuestion(rr, q))
        {
            <span class="enscript-comment">// We also get called for RRSIGs which matches qtype. We don't need that here as we are
</span>            <span class="enscript-comment">// building rrset for matching q-&gt;qname. Checking for RRSIG type is important as otherwise
</span>            <span class="enscript-comment">// we would miss the CNAME answering any qtype.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_RRSIG &amp;&amp; rr-&gt;resrec.rrtype != q-&gt;qtype)
            {
                LogDNSSEC(<span class="enscript-string">&quot;VerifySignature: Question %##s (%s) answered with RRSIG record %s, not using it&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), CRDisplayString(m, rr));
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// See DNSSECRecordAnswersQuestion: This should never happen. NSEC records are
</span>            <span class="enscript-comment">// answered directly only when the qtype is NSEC. Otherwise, NSEC records are
</span>            <span class="enscript-comment">// used only for denial of existence and hence should go through negative cache
</span>            <span class="enscript-comment">// entry.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.rrtype == kDNSType_NSEC &amp;&amp; q-&gt;qtype != kDNSType_NSEC)
            {
                LogMsg(<span class="enscript-string">&quot;VerifySignature: ERROR!! Question %##s (%s) answered using NSEC record %s&quot;</span>, q-&gt;qname.c, DNSTypeName(q-&gt;qtype), CRDisplayString(m, rr));
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// We might get a NSEC response when we first send the query out from the &quot;core&quot; for ValidationRequired
</span>            <span class="enscript-comment">// questions. Later as part of validating the response, we might get a NSEC response.
</span>            <span class="enscript-keyword">if</span> (rr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative &amp;&amp; DNSSECQuestion(q))
            {
                <span class="enscript-comment">// If we can't find the NSEC, we can't validate. This can happens if we are
</span>                <span class="enscript-comment">// behind a non-DNSSEC aware CPE/server.
</span>                <span class="enscript-keyword">if</span> (!rr-&gt;nsec)
                {
                    LogDNSSEC(<span class="enscript-string">&quot;VerifySignature: No nsecs found for %s&quot;</span>, CRDisplayString(m, rr));
                    dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                    <span class="enscript-keyword">return</span>;
                }
                ValidateWithNSECS(m, dv, rr);
                <span class="enscript-keyword">return</span>;
            }

            <span class="enscript-keyword">if</span> (AddRRSetToVerifier(dv, &amp;rr-&gt;resrec, mDNSNULL, RRVS_rr) != mStatus_NoError)
            {
                dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                <span class="enscript-keyword">return</span>;
            }
        }
    <span class="enscript-keyword">if</span> (!dv-&gt;rrset)
    {
        LogMsg(<span class="enscript-string">&quot;VerifySignature: rrset mDNSNULL for %##s (%s)&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType));
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }
    dv-&gt;next = RRVS_rrsig;
    <span class="enscript-comment">// Delay this so that the mDNS &quot;core&quot; can deliver all the results before
</span>    <span class="enscript-comment">// we can deliver the dnssec result
</span>    <span class="enscript-keyword">if</span> (first)
    {
        mDNSPlatformDispatchAsync(m, dv, StartDNSSECVerification);
    }
    <span class="enscript-keyword">else</span>
    {
        StartDNSSECVerification(m, dv);
    }
}

mDNSlocal mDNSBool <span class="enscript-function-name">TrustedKeyPresent</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    rdataDS *ds;
    rdataDNSKey *key;
    TrustAnchor *ta;
    RRVerifier *keyv;

    <span class="enscript-comment">// Walk all our trusted DS Records to see if we have a matching DNS KEY record that verifies
</span>    <span class="enscript-comment">// the hash. If we find one, verify that this key was used to sign the KEY rrsets in
</span>    <span class="enscript-comment">// this zone. Loop till we find one.
</span>    <span class="enscript-keyword">for</span> (ta = m-&gt;TrustAnchors; ta; ta = ta-&gt;next)
    {
        ds = (rdataDS *)&amp;ta-&gt;rds;
        <span class="enscript-keyword">if</span> ((ds-&gt;digestType != SHA1_DIGEST_TYPE) &amp;&amp; (ds-&gt;digestType != SHA256_DIGEST_TYPE))
        {
            LogMsg(<span class="enscript-string">&quot;TrustedKeyPresent: Unsupported digest %d&quot;</span>, ds-&gt;digestType);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">else</span>
        {
            debugdnssec(<span class="enscript-string">&quot;TrustedKeyPresent: digest type %d&quot;</span>, ds-&gt;digestType);
        }
        <span class="enscript-keyword">for</span> (keyv = dv-&gt;key; keyv; keyv = keyv-&gt;next)
        {
            key = (rdataDNSKey *)keyv-&gt;rdata;
            mDNSu16 tag = (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength);
            <span class="enscript-keyword">if</span> (tag != ds-&gt;keyTag)
            {
                debugdnssec(<span class="enscript-string">&quot;TrustedKeyPresent:Not a valid keytag %d&quot;</span>, tag);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (!SameDomainName(&amp;keyv-&gt;name, &amp;ta-&gt;zone))
            {
                debugdnssec(<span class="enscript-string">&quot;TrustedKeyPresent: domainame mismatch key %##s, ta %##s&quot;</span>, keyv-&gt;name.c, ta-&gt;zone.c);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">return</span> mDNStrue;
        }
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal mStatus <span class="enscript-function-name">TrustedKey</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv)
{
    mDNSu8 *digest;
    <span class="enscript-type">int</span> digestLen;
    domainname name;
    rdataRRSig *rrsig;
    rdataDS *ds;
    rdataDNSKey *key;
    TrustAnchor *ta;
    RRVerifier *keyv;
    mStatus algRet;
    mDNSu32 currTime = mDNSPlatformUTC();

    rrsig = (rdataRRSig *)dv-&gt;rrsig-&gt;rdata;

    <span class="enscript-comment">// Walk all our trusted DS Records to see if we have a matching DNS KEY record that verifies
</span>    <span class="enscript-comment">// the hash. If we find one, verify that this key was used to sign the KEY rrsets in
</span>    <span class="enscript-comment">// this zone. Loop till we find one.
</span>    <span class="enscript-keyword">for</span> (ta = m-&gt;TrustAnchors; ta; ta = ta-&gt;next)
    {
        ds = (rdataDS *)&amp;ta-&gt;rds;
        <span class="enscript-keyword">if</span> ((ds-&gt;digestType != SHA1_DIGEST_TYPE) &amp;&amp; (ds-&gt;digestType != SHA256_DIGEST_TYPE))
        {
            LogMsg(<span class="enscript-string">&quot;TrustedKey: Unsupported digest %d&quot;</span>, ds-&gt;digestType);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">else</span>
        {
            debugdnssec(<span class="enscript-string">&quot;TrustedKey: Zone %##s, digest type %d, tag %d&quot;</span>, ta-&gt;zone.c, ds-&gt;digestType, ds-&gt;keyTag);
        }
        <span class="enscript-keyword">for</span> (keyv = dv-&gt;key; keyv; keyv = keyv-&gt;next)
        {
            key = (rdataDNSKey *)keyv-&gt;rdata;
            mDNSu16 tag = (mDNSu16)keytag((mDNSu8 *)key, keyv-&gt;rdlength);
            <span class="enscript-keyword">if</span> (tag != ds-&gt;keyTag)
            {
                debugdnssec(<span class="enscript-string">&quot;TrustedKey:Not a valid keytag %d&quot;</span>, tag);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (!SameDomainName(&amp;keyv-&gt;name, &amp;ta-&gt;zone))
            {
                debugdnssec(<span class="enscript-string">&quot;TrustedKey: domainame mismatch key %##s, ta %##s&quot;</span>, keyv-&gt;name.c, ta-&gt;zone.c);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(ta-&gt;validUntil, currTime))
            {
                LogDNSSEC(<span class="enscript-string">&quot;TrustedKey: Expired: currentTime %d, ExpireTime %d&quot;</span>, (<span class="enscript-type">int</span>)currTime, ta-&gt;validUntil);
                <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(currTime, ta-&gt;validFrom))
            {
                LogDNSSEC(<span class="enscript-string">&quot;TrustedKey: Future: currentTime %d, InceptTime %d&quot;</span>, (<span class="enscript-type">int</span>)currTime, ta-&gt;validFrom);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)&amp;rrsig-&gt;signerName, &amp;name) != mStatus_NoError)
            {
                LogMsg(<span class="enscript-string">&quot;TrustedKey: ERROR!! cannot convert to lower case&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-keyword">if</span> (dv-&gt;ctx) AlgDestroy(dv-&gt;ctx);
            dv-&gt;ctx = AlgCreate(DIGEST_ALG, ds-&gt;digestType);
            <span class="enscript-keyword">if</span> (!dv-&gt;ctx)
            {
                LogMsg(<span class="enscript-string">&quot;TrustedKey: ERROR!! No digest support&quot;</span>);
                <span class="enscript-keyword">continue</span>;
            }
            digest = ds-&gt;digest;
            digestLen = ta-&gt;digestLen;

            AlgAdd(dv-&gt;ctx, name.c, DomainNameLength(&amp;name));
            AlgAdd(dv-&gt;ctx, (<span class="enscript-type">const</span> mDNSu8 *)key, keyv-&gt;rdlength);

            algRet = AlgVerify(dv-&gt;ctx, mDNSNULL, 0, digest, digestLen);
            AlgDestroy(dv-&gt;ctx);
            dv-&gt;ctx = mDNSNULL;
            <span class="enscript-keyword">if</span> (algRet == mStatus_NoError)
            {
                LogDNSSEC(<span class="enscript-string">&quot;TrustedKey: DS Validated Successfully, need to verify the key %d&quot;</span>, tag);
                <span class="enscript-comment">// We found the DNS KEY that is authenticated by the DS in our parent zone. Check to see if this key
</span>                <span class="enscript-comment">// was used to sign the DNS KEY RRSET. If so, then the keys in our DNS KEY RRSET are valid
</span>                <span class="enscript-keyword">if</span> (ValidateSignatureWithKeyForAllRRSigs(dv, dv-&gt;key, keyv, dv-&gt;rrsigKey))
                {
                    LogDNSSEC(<span class="enscript-string">&quot;TrustedKey: DS Validated Successfully %d&quot;</span>, tag);
                    <span class="enscript-keyword">return</span> mStatus_NoError;
                }
            }
        }
    }
    <span class="enscript-keyword">return</span> mStatus_NoSuchRecord;
}

mDNSlocal CacheRecord* <span class="enscript-function-name">NegativeCacheRecordForRR</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> rr)
{
    mDNSu32 namehash;
    CacheGroup *cg;
    CacheRecord *cr;

    namehash = DomainNameHashValue(rr-&gt;name);
    cg = CacheGroupForName(m, namehash, rr-&gt;name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        LogMsg(<span class="enscript-string">&quot;NegativeCacheRecordForRR: cg null %##s&quot;</span>, rr-&gt;name-&gt;c);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    <span class="enscript-keyword">for</span> (cr=cg-&gt;members; cr; cr=cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.RecordType == kDNSRecordTypePacketNegative &amp;&amp; (&amp;cr-&gt;resrec == rr))
            <span class="enscript-keyword">return</span> cr;
    }
    <span class="enscript-keyword">return</span> mDNSNULL;
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">VerifySigCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    DNSSECVerifier *dv = (DNSSECVerifier *)question-&gt;QuestionContext;
    mDNSu16 rrtype;
    CacheRecord *negcr;

    debugdnssec(<span class="enscript-string">&quot;VerifySigCallback: AddRecord %d, dv %p&quot;</span>, AddRecord, dv);

    <span class="enscript-keyword">if</span> (!AddRecord)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// After the first ADD event, we should ideally stop the question. If we don't stop
</span>    <span class="enscript-comment">// the question, we might get more callbacks and that can cause problems. For example,
</span>    <span class="enscript-comment">// in the first callback, we could start a insecure proof and while that is in progress,
</span>    <span class="enscript-comment">// if we get more callbacks, we will try to start another insecure proof. As we already
</span>    <span class="enscript-comment">// started an insecure proof, we won't start another but terminate the verification
</span>    <span class="enscript-comment">// process where we free the current DNSSECVerifier while the first insecure proof is
</span>    <span class="enscript-comment">// still referencing it.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// But there are cases below which might return if we have not received the right answer
</span>    <span class="enscript-comment">// yet e.g., no RRSIGs. In that case if the question is stopped, we will never get any
</span>    <span class="enscript-comment">// callbacks again and also we leak &quot;dv&quot;. Hence it is important that we either process
</span>    <span class="enscript-comment">// the result or wait for more results. Note that the question eventually times out
</span>    <span class="enscript-comment">// and cleans up the &quot;dv&quot; i.e., we don't wait forever.
</span>    
    <span class="enscript-keyword">if</span> (!answer)
    {
        LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Question %##s (%s) no dnssec response&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        mDNS_StopQuery(m, question);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }

    LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback(%p): Called with record %s for question %##s (%s)&quot;</span>, dv, RRDisplayString(m, answer), question-&gt;qname.c,
        DNSTypeName(question-&gt;qtype));
    mDNS_Lock(m);
    <span class="enscript-keyword">if</span> ((m-&gt;timenow - question-&gt;StopTime) &gt;= 0)
    {
        mDNS_Unlock(m);
        LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Question %##s (%s) timed out&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        mDNS_StopQuery(m, question);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }
    mDNS_Unlock(m);

    <span class="enscript-keyword">if</span> (answer-&gt;RecordType == kDNSRecordTypePacketNegative)
    {
        CacheRecord *cr;
        LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Received a negative answer with record %s, AddRecord %d&quot;</span>,
                  RRDisplayString(m, answer), AddRecord);
        mDNS_StopQuery(m, question);
        cr = NegativeCacheRecordForRR(m, answer);
        <span class="enscript-keyword">if</span> (cr &amp;&amp; cr-&gt;nsec)
        {
            ValidateWithNSECS(m, dv, cr);
        }
        <span class="enscript-keyword">else</span>
        {
            
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Missing record (%s) Negative Cache Record %p&quot;</span>, RRDisplayString(m, answer), cr);
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (!dv-&gt;rrset)
    {
        LogMsg(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! rrset NULL&quot;</span>);
        mDNS_StopQuery(m, question);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }

    rrtype = answer-&gt;rrtype;
    <span class="enscript-comment">// Check whether we got any answers for the question. If there are no answers, we
</span>    <span class="enscript-comment">// can't do the verification.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We need to look at the whole rrset for verifying the signatures. This callback gets
</span>    <span class="enscript-comment">// called back for each record in the rrset sequentially and we won't know when to start the
</span>    <span class="enscript-comment">// verification. Hence, we look for all the records in the rrset ourselves using the
</span>    <span class="enscript-comment">// CheckXXX function below. The caller has to ensure that all the records in the rrset are
</span>    <span class="enscript-comment">// added to the cache before calling this callback which happens naturally because all
</span>    <span class="enscript-comment">// unicast records are marked for DelayDelivery and hence added to the cache before the
</span>    <span class="enscript-comment">// callback is done.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We also need the RRSIGs for the rrset to do the validation. It is possible that the
</span>    <span class="enscript-comment">// cache contains RRSIG records but it may not be a valid record when we filter them
</span>    <span class="enscript-comment">// in CheckXXX function. For example, some application can query for RRSIG records which
</span>    <span class="enscript-comment">// might come back with a partial set of RRSIG records from the recursive server and
</span>    <span class="enscript-comment">// they may not be the right ones for the current validation. In this case, we still
</span>    <span class="enscript-comment">// need to send the query out to get the right RRSIGs but the &quot;core&quot; should not answer
</span>    <span class="enscript-comment">// this query with the same records that we checked and found them to be unusable.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We handle this in two ways:
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1) AnswerNewQuestion always sends the &quot;ValidatingResponse&quot; query out bypassing the cache.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2) DNSSECRecordAnswersQuestion does not answer a question with RRSIGs matching the
</span>    <span class="enscript-comment">//    same name as the query until the typeCovered also matches the query's type.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// NOTE: We use &quot;next - 1&quot; as next always points to what we are going to fetch next and not the one
</span>    <span class="enscript-comment">// we are fetching currently
</span>    <span class="enscript-keyword">switch</span>(dv-&gt;next - 1)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rr</span>:
        <span class="enscript-comment">// Verification always starts at RRVS_rrsig (which means dv-&gt;next points at RRVS_key) as verification does
</span>        <span class="enscript-comment">// not begin until we have the main rrset.
</span>        LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! rrset %##s dv-&gt;next is RRVS_rr&quot;</span>, dv-&gt;rrset-&gt;name.c);
        <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig</span>:
        <span class="enscript-comment">// We can get called back with rrtype matching qtype as new records are added to the cache
</span>        <span class="enscript-comment">// triggered by other questions. This could potentially mean that the rrset that is being
</span>        <span class="enscript-comment">// validated by this &quot;dv&quot; whose rrsets were initialized at the beginning of the verification
</span>        <span class="enscript-comment">// may not be the right one. If this case happens, we will detect this at the end of validation
</span>        <span class="enscript-comment">// and throw away the validation results. This should not be a common case.
</span>        <span class="enscript-keyword">if</span> (rrtype != kDNSType_RRSIG)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_rrsig called with %s&quot;</span>, RRDisplayString(m, answer));
            <span class="enscript-keyword">return</span>;
        }
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (CheckRRSIGForRRSet(m, dv, &amp;negcr) != mStatus_NoError)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Unable to find RRSIG for %##s (%s), question %##s&quot;</span>, dv-&gt;rrset-&gt;name.c,
                      DNSTypeName(dv-&gt;rrset-&gt;rrtype), question-&gt;qname.c);
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_key</span>:
        <span class="enscript-comment">// We are waiting for the DNSKEY record and hence dv-&gt;key should be NULL. If RRSIGs are being
</span>        <span class="enscript-comment">// returned first, ignore them for now.
</span>        <span class="enscript-keyword">if</span> (dv-&gt;key)
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! RRVS_key dv-&gt;key non-NULL for %##s&quot;</span>, question-&gt;qname.c);
        <span class="enscript-keyword">if</span> (rrtype == kDNSType_RRSIG)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_key rrset type %s, %##s received before DNSKEY&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (rrtype != question-&gt;qtype)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! RRVS_key rrset type %s, %##s not matching qtype %d&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c,
                question-&gt;qtype);
            <span class="enscript-keyword">return</span>;
        }
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (CheckKeyForRRSIG(m, dv, &amp;negcr) != mStatus_NoError)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Unable to find DNSKEY for %##s (%s), question %##s&quot;</span>, dv-&gt;rrset-&gt;name.c,
                      DNSTypeName(dv-&gt;rrset-&gt;rrtype), question-&gt;qname.c);
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_rrsig_key</span>:
        <span class="enscript-comment">// If we are in RRVS_rrsig_key, it means that we already found the relevant DNSKEYs (dv-&gt;key should be non-NULL).
</span>        <span class="enscript-comment">// If DNSKEY record is being returned i.e., it means it is being added to the cache, then it can't be in our
</span>        <span class="enscript-comment">// list.
</span>        <span class="enscript-keyword">if</span> (!dv-&gt;key)
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! RRVS_rrsig_key dv-&gt;key NULL for %##s&quot;</span>, question-&gt;qname.c);
        <span class="enscript-keyword">if</span> (rrtype == question-&gt;qtype)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_rrsig_key rrset type %s, %##s&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c);
            CheckOneKeyForRRSIG(dv, answer);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">if</span> (rrtype != kDNSType_RRSIG)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_rrsig_key rrset type %s, %##s not matching qtype %d&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c,
                question-&gt;qtype);
            <span class="enscript-keyword">return</span>;
        }
        mDNS_StopQuery(m, question);
        <span class="enscript-keyword">if</span> (CheckRRSIGForKey(m, dv, &amp;negcr) != mStatus_NoError)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Unable to find RRSIG for %##s (%s), question %##s&quot;</span>, dv-&gt;rrset-&gt;name.c,
                      DNSTypeName(dv-&gt;rrset-&gt;rrtype), question-&gt;qname.c);
            dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">RRVS_ds</span>:
        <span class="enscript-keyword">if</span> (rrtype == question-&gt;qtype)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_ds rrset type %s, %##s&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c);
        }
        <span class="enscript-keyword">else</span>
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: RRVS_ds rrset type %s, %##s received before DS&quot;</span>, DNSTypeName(rrtype), question-&gt;qname.c);
        }
        mDNS_StopQuery(m, question);
        <span class="enscript-comment">// It is not an error if we don't find the DS record as we could have
</span>        <span class="enscript-comment">// a trusted key. Or this is not a secure delegation which will be handled
</span>        <span class="enscript-comment">// below.
</span>        <span class="enscript-keyword">if</span> (CheckDSForKey(m, dv, &amp;negcr) != mStatus_NoError)
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: Unable find DS for %##s (%s), question %##s&quot;</span>, dv-&gt;rrset-&gt;name.c,
                      DNSTypeName(dv-&gt;rrset-&gt;rrtype), question-&gt;qname.c);
        }
        <span class="enscript-comment">// dv-&gt;next is already at RRVS_done, so if we &quot;break&quot; from here, we will end up
</span>        <span class="enscript-comment">// in FinishDNSSECVerification. We should not do that if we receive a negative
</span>        <span class="enscript-comment">// response. For all other cases above, GetAllRRSetsForVerification handles
</span>        <span class="enscript-comment">// negative cache record
</span>        <span class="enscript-keyword">if</span> (negcr)
        {
            <span class="enscript-keyword">if</span> (!negcr-&gt;nsec)
            {
                LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: No nsec records for %##s (DS)&quot;</span>, dv-&gt;ds-&gt;name.c);
                dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
                <span class="enscript-keyword">return</span>;
            }
            ValidateWithNSECS(m, dv, negcr);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: ERROR!! default case rrset %##s question %##s&quot;</span>, dv-&gt;rrset-&gt;name.c, question-&gt;qname.c);
        mDNS_StopQuery(m, question);
        dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (dv-&gt;next != RRVS_done)
    {
        mDNSBool done = GetAllRRSetsForVerification(m, dv);
        <span class="enscript-keyword">if</span> (done)
        {
            <span class="enscript-keyword">if</span> (dv-&gt;next != RRVS_done)
                LogMsg(<span class="enscript-string">&quot;VerifySigCallback ERROR!! dv-&gt;next is not done&quot;</span>);
            <span class="enscript-keyword">else</span>
                LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: all rdata sets available for sig verification&quot;</span>);
        }
        <span class="enscript-keyword">else</span>
        {
            LogDNSSEC(<span class="enscript-string">&quot;VerifySigCallback: all rdata sets not available for sig verification&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
    }
    FinishDNSSECVerification(m, dv);
}

mDNSlocal TrustAnchor *<span class="enscript-function-name">FindTrustAnchor</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">const</span> domainname *<span class="enscript-type">const</span> name)
{
    TrustAnchor *ta;
    TrustAnchor *matchTA = mDNSNULL;
    TrustAnchor *rootTA = mDNSNULL;
    <span class="enscript-type">int</span> currmatch = 0;
    <span class="enscript-type">int</span> match;
    mDNSu32 currTime = mDNSPlatformUTC();

    <span class="enscript-keyword">for</span> (ta = m-&gt;TrustAnchors; ta; ta = ta-&gt;next)
    {
        <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(ta-&gt;validUntil, currTime))
        {
            LogDNSSEC(<span class="enscript-string">&quot;FindTrustAnchor: Expired: currentTime %d, ExpireTime %d&quot;</span>, (<span class="enscript-type">int</span>)currTime, ta-&gt;validUntil);
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (DNS_SERIAL_LT(currTime, ta-&gt;validFrom))
        {
            LogDNSSEC(<span class="enscript-string">&quot;FindTrustAnchor: Future: currentTime %d, InceptTime %d&quot;</span>, (<span class="enscript-type">int</span>)currTime, ta-&gt;validFrom);
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (SameDomainName((<span class="enscript-type">const</span> domainname *)<span class="enscript-string">&quot;\000&quot;</span>, &amp;ta-&gt;zone))
            rootTA = ta;

        match = CountLabelsMatch(&amp;ta-&gt;zone, name);
        <span class="enscript-keyword">if</span> (match &gt; currmatch)
        {
            currmatch = match;
            matchTA = ta;
        }
    }
    <span class="enscript-keyword">if</span> (matchTA)
    {
        LogDNSSEC(<span class="enscript-string">&quot;FindTrustAnhcor: matched %##s&quot;</span>, matchTA-&gt;zone.c);
        <span class="enscript-keyword">return</span> matchTA;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rootTA)
    {
        LogDNSSEC(<span class="enscript-string">&quot;FindTrustAnhcor: matched rootTA %##s&quot;</span>, rootTA-&gt;zone.c);
        <span class="enscript-keyword">return</span> rootTA;
    }
    <span class="enscript-keyword">else</span>
    {
        LogDNSSEC(<span class="enscript-string">&quot;FindTrustAnhcor: No Trust Anchor&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeliverInsecureProofResultAsync</span>(mDNS *<span class="enscript-type">const</span> m, <span class="enscript-type">void</span> *context)
{
    InsecureContext *ic = (InsecureContext *)context;
    ic-&gt;dv-&gt;DVCallback(m, ic-&gt;dv, ic-&gt;status);
    <span class="enscript-keyword">if</span> (ic-&gt;q.ThisQInterval != -1)
    {
        LogMsg(<span class="enscript-string">&quot;DeliverInsecureProofResultAsync: ERROR!! Question %##s (%s) not stopped already&quot;</span>, ic-&gt;q.qname.c, DNSTypeName(ic-&gt;q.qtype));
        mDNS_StopQuery(m, &amp;ic-&gt;q);
    }
    mDNSPlatformMemFree(ic);
}

mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">DeliverInsecureProofResult</span>(mDNS *<span class="enscript-type">const</span> m, InsecureContext *ic, DNSSECStatus status)
{
    <span class="enscript-comment">// If the status is Bogus, restore the original auth chain before the insecure
</span>    <span class="enscript-comment">// proof.
</span>    <span class="enscript-keyword">if</span> (status == DNSSEC_Bogus)
    {
        LogDNSSEC(<span class="enscript-string">&quot;DeliverInsecureProofResult: Restoring the auth chain&quot;</span>);
        <span class="enscript-keyword">if</span> (ic-&gt;dv-&gt;ac)
        {
            FreeDNSSECAuthChainInfo(ic-&gt;dv-&gt;ac);
        }
        ResetAuthChain(ic-&gt;dv);
        ic-&gt;dv-&gt;ac = ic-&gt;dv-&gt;saveac;
        <span class="enscript-keyword">if</span> (ic-&gt;dv-&gt;ac)
        {
            AuthChain *tmp = ic-&gt;dv-&gt;ac;
            AuthChain **tail = &amp;tmp-&gt;next;
            <span class="enscript-keyword">while</span> (tmp-&gt;next)
            {
                tail = &amp;tmp-&gt;next;
                tmp = tmp-&gt;next;
            }
            ic-&gt;dv-&gt;actail = tail;
        }
        ic-&gt;dv-&gt;saveac = mDNSNULL;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ic-&gt;dv-&gt;saveac)
    {
        FreeDNSSECAuthChainInfo(ic-&gt;dv-&gt;saveac);
        ic-&gt;dv-&gt;saveac = mDNSNULL;
    }
    ic-&gt;status = status;
    <span class="enscript-comment">// Stop the question before we schedule the block so that we don't receive additional
</span>    <span class="enscript-comment">// callbacks again. Once the block runs, it will free the &quot;ic&quot; and you can't
</span>    <span class="enscript-comment">// have another block queued up. This can happen if we receive a callback after we
</span>    <span class="enscript-comment">// queue the block below.
</span>    <span class="enscript-keyword">if</span> (ic-&gt;q.ThisQInterval != -1)
        mDNS_StopQuery(m, &amp;ic-&gt;q);
    mDNSPlatformDispatchAsync(m, ic, DeliverInsecureProofResultAsync);
}

mDNSlocal mDNSBool <span class="enscript-function-name">AlgorithmSupported</span>(rdataDS *ds)
{
    <span class="enscript-keyword">switch</span>(ds-&gt;digestType)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA1_DIGEST_TYPE</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SHA256_DIGEST_TYPE</span>:
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogDNSSEC(<span class="enscript-string">&quot;AlgorithmSupported: Unsupported digest %d&quot;</span>, ds-&gt;digestType);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-keyword">switch</span>(ds-&gt;alg)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_NSEC3_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA1</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA256</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">CRYPTO_RSA_SHA512</span>:
        <span class="enscript-keyword">return</span> mDNStrue;
    <span class="enscript-reference">default</span>:
        LogDNSSEC(<span class="enscript-string">&quot;AlgorithmSupported: Unsupported algorithm %d&quot;</span>, ds-&gt;alg);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
}

<span class="enscript-comment">// Note: This function is called when DNSSEC results are delivered (from DeliverDNSSECStatus) and we can't deliver DNSSEC result
</span><span class="enscript-comment">// again within this function as &quot;m-&gt;ValidationQuestion&quot; is already in use. Hence we should dispatch off the delivery of insecure
</span><span class="enscript-comment">// results asynchronously.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Insecure proof callback can deliver either insecure or bogus, but never secure result.
</span>mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">ProveInsecureCallback</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, <span class="enscript-type">const</span> ResourceRecord *<span class="enscript-type">const</span> answer, QC_result AddRecord)
{
    InsecureContext *ic = (InsecureContext *)question-&gt;QuestionContext;
    DNSSECVerifier *pdv = ic-&gt;dv;
    AuthChain *ac;

    (<span class="enscript-type">void</span>) answer;

    <span class="enscript-keyword">if</span> (!AddRecord)
        <span class="enscript-keyword">return</span>;

    mDNS_Lock(m);
    <span class="enscript-keyword">if</span> ((m-&gt;timenow - question-&gt;StopTime) &gt;= 0)
    {
        mDNS_Unlock(m);
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Question %##s (%s) timed out&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }
    mDNS_Unlock(m);

    <span class="enscript-comment">// We only need to handle the actual DNSSEC results and the ones that are secure. Anything else results in
</span>    <span class="enscript-comment">// bogus.
</span>    <span class="enscript-keyword">if</span> (AddRecord != QC_dnssec)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Question %##s (%s), AddRecord %d, answer %s&quot;</span>, question-&gt;qname.c,
            DNSTypeName(question-&gt;qtype), AddRecord, RRDisplayString(m, answer));
        <span class="enscript-keyword">return</span>;
    }

    LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: ic %p Question %##s (%s), DNSSEC status %s&quot;</span>, ic, question-&gt;qname.c, DNSTypeName(question-&gt;qtype),
            DNSSECStatusName(question-&gt;ValidationStatus));

    <span class="enscript-comment">// Insecure is delivered for NSEC3 OptOut 
</span>    <span class="enscript-keyword">if</span> (question-&gt;ValidationStatus != DNSSEC_Secure &amp;&amp; question-&gt;ValidationStatus != DNSSEC_Insecure)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Question %##s (%s) returned DNSSEC status %s&quot;</span>, question-&gt;qname.c,
            DNSTypeName(question-&gt;qtype), DNSSECStatusName(question-&gt;ValidationStatus));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    ac = (AuthChain *)question-&gt;DNSSECAuthInfo;
    <span class="enscript-keyword">if</span> (!ac)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: ac NULL for question %##s, %s&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> (!ac-&gt;rrset)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: ac-&gt;rrset NULL for question %##s, %s&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> (ac-&gt;rrset-&gt;rrtype != kDNSType_DS &amp;&amp; ac-&gt;rrset-&gt;rrtype != kDNSType_NSEC &amp;&amp; ac-&gt;rrset-&gt;rrtype != kDNSType_NSEC3)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: ac-&gt;rrset-&gt;rrtype %##s (%s) not handled&quot;</span>, ac-&gt;rrset-&gt;name.c,
            DNSTypeName(ac-&gt;rrset-&gt;rrtype));
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    AuthChainLink(pdv, ac);
    question-&gt;DNSSECAuthInfo = mDNSNULL;
    <span class="enscript-keyword">if</span> (ac-&gt;rrset-&gt;rrtype == kDNSType_DS)
    {
        rdataDS *ds = (rdataDS *)ac-&gt;rrset-&gt;rdata;

        <span class="enscript-comment">// If the delegation is secure, but the underlying zone is signed with an unsupported
</span>        <span class="enscript-comment">// algorithm, then we can't verify it. Deliver insecure in that case.
</span>        <span class="enscript-keyword">if</span> (!AlgorithmSupported(ds))
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Unsupported algorithm %d or digest %d&quot;</span>, ds-&gt;alg, ds-&gt;digestType);
            DeliverInsecureProofResult(m, ic, DNSSEC_Insecure);
            <span class="enscript-keyword">return</span>;
        }

        <span class="enscript-comment">// If the delegation is secure and the name that we queried for is same as the original
</span>        <span class="enscript-comment">// name that started the insecure proof, then something is not right. We started the
</span>        <span class="enscript-comment">// insecure proof e.g., the zone is not signed, but we are able to validate a DS for
</span>        <span class="enscript-comment">// the same name which implies that the zone is signed (whose algorithm we support) and
</span>        <span class="enscript-comment">// we should not have started the insecurity proof in the first place.
</span>        <span class="enscript-keyword">if</span> (SameDomainName(&amp;question-&gt;qname, &amp;pdv-&gt;origName))
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Insecure proof reached original name %##s, error&quot;</span>, question-&gt;qname.c);
            DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }

        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Trying one more level down&quot;</span>);
        ProveInsecure(m, pdv, ic, mDNSNULL);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ac-&gt;rrset-&gt;rrtype == kDNSType_NSEC || ac-&gt;rrset-&gt;rrtype == kDNSType_NSEC3)
    {
        CacheRecord *cr;

        <span class="enscript-keyword">if</span> (ac-&gt;rrset-&gt;rrtype == kDNSType_NSEC)
            cr = NSECRecordIsDelegation(m, &amp;question-&gt;qname, question-&gt;qtype);
        <span class="enscript-keyword">else</span>
            cr = NSEC3RecordIsDelegation(m, &amp;question-&gt;qname, question-&gt;qtype);
		<span class="enscript-keyword">if</span> (cr)
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Non-existence proved and %s is a delegation for %##s (%s)&quot;</span>, CRDisplayString(m, cr),
				question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
            DeliverInsecureProofResult(m, ic, DNSSEC_Insecure);
			<span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// Could be a ENT. Go one more level down to see whether it is a secure delegation or not.
</span>        <span class="enscript-keyword">if</span> (!SameDomainName(&amp;question-&gt;qname, &amp;pdv-&gt;origName))
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Not a delegation %##s (%s), go one more level down&quot;</span>, question-&gt;qname.c, DNSTypeName(question-&gt;qtype));
            ProveInsecure(m, pdv, ic, mDNSNULL);
        }
        <span class="enscript-keyword">else</span>
        {
             <span class="enscript-comment">// Secure denial of existence and the name matches the original query. This means we should have
</span>             <span class="enscript-comment">// received an NSEC (if the type does not exist) or signed records (if the name and type exists)
</span>             <span class="enscript-comment">// and verified it successfully instead of starting the insecure proof. This could happen e.g.,
</span>             <span class="enscript-comment">// Wildcard expanded answer received without NSEC/NSEC3s etc. Also, is it possible that the
</span>             <span class="enscript-comment">// zone went from unsigned to signed in a short time ? For now, we return bogus.
</span>             LogDNSSEC(<span class="enscript-string">&quot;ProveInsecureCallback: Not a delegation %##s (%s), but reached original name&quot;</span>, question-&gt;qname.c,
                 DNSTypeName(question-&gt;qtype));
             DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
        }
    }
    <span class="enscript-keyword">return</span>;
<span class="enscript-reference">done</span>:
    DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
}

<span class="enscript-comment">// We return Insecure if we don't have a trust anchor or we have a trust anchor and
</span><span class="enscript-comment">// can prove that the delegation is not secure (and hence can't establish the trust
</span><span class="enscript-comment">// chain) or the delegation is possibly secure but we don't have the algorithm support
</span><span class="enscript-comment">// to prove that.
</span>mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">ProveInsecure</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, InsecureContext *ic, domainname *trigger)
{
    TrustAnchor *ta;
    domainname *sname;

    <span class="enscript-keyword">if</span> (ic == mDNSNULL)
    {
        ic = (InsecureContext *) mDNSPlatformMemAllocateClear(<span class="enscript-keyword">sizeof</span>(*ic));
        <span class="enscript-keyword">if</span> (!ic)
        {
            LogMsg(<span class="enscript-string">&quot;mDNSPlatformMemAllocateClear: ERROR!! memory alloc failed for ic&quot;</span>);
            <span class="enscript-keyword">return</span>;
        }
        
        <span class="enscript-comment">// Save the AuthInfo while we are proving insecure. We don't want to mix up
</span>        <span class="enscript-comment">// the auth chain for Bogus and Insecure. If we prove it to be insecure, we
</span>        <span class="enscript-comment">// will add the chain corresponding to the insecure proof. Otherwise, we will
</span>        <span class="enscript-comment">// restore this chain.
</span>        <span class="enscript-keyword">if</span> (dv-&gt;ac)
        {
            <span class="enscript-keyword">if</span> (!dv-&gt;saveac)
            {
                LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: saving authinfo&quot;</span>);
            }
            <span class="enscript-keyword">else</span>
            {
                LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: ERROR!! authinfo already set&quot;</span>);
                FreeDNSSECAuthChainInfo(dv-&gt;saveac);
            }
            dv-&gt;saveac = dv-&gt;ac;
            ResetAuthChain(dv);
        }
        ic-&gt;dv = dv;
        ic-&gt;q.ThisQInterval = -1;

        <span class="enscript-keyword">if</span> (trigger)
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: Setting Trigger %##s&quot;</span>, trigger-&gt;c);
            ic-&gt;triggerLabelCount = CountLabels(trigger);
        }
        <span class="enscript-keyword">else</span>
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: No Trigger&quot;</span>);
            ic-&gt;triggerLabelCount = CountLabels(&amp;dv-&gt;origName);
        }

        ta = FindTrustAnchor(m, &amp;dv-&gt;origName);
        <span class="enscript-keyword">if</span> (!ta)
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: TrustAnchor NULL&quot;</span>);
            DeliverInsecureProofResult(m, ic, DNSSEC_Insecure);
            <span class="enscript-keyword">return</span>;
        }
        <span class="enscript-comment">// We want to skip the labels that is already matched by the trust anchor so
</span>        <span class="enscript-comment">// that the first query starts just below the trust anchor
</span>        ic-&gt;skip = CountLabels(&amp;dv-&gt;origName) - CountLabels(&amp;ta-&gt;zone);
        <span class="enscript-keyword">if</span> (!ic-&gt;skip)
        {
            LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: origName %##s, skip is zero&quot;</span>, dv-&gt;origName.c);
            DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
            <span class="enscript-keyword">return</span>;
        }
    }
    <span class="enscript-comment">// Look for the DS record starting just below the trust anchor.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 1. If we find an NSEC record, then see if it is a delegation. If it is, then
</span>    <span class="enscript-comment">//    we are done. Otherwise, go down one more level.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. If we find a DS record and no algorithm support, return &quot;insecure&quot;. Otherwise, go
</span>    <span class="enscript-comment">//    down one more level.
</span>    <span class="enscript-comment">//
</span>    sname = (domainname *)SkipLeadingLabels(&amp;dv-&gt;origName, (ic-&gt;skip ? ic-&gt;skip - 1 : 0));
    <span class="enscript-keyword">if</span> (!sname)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: sname NULL, origName %##s, skip %d&quot;</span>, dv-&gt;origName.c, ic-&gt;skip);
        DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Insecurity proof is started during the normal bottom-up validation when we have a break in the trust
</span>    <span class="enscript-comment">// chain e.g., we get NSEC/NSEC3s when looking up a DS record. Insecurity proof is top-down looking
</span>    <span class="enscript-comment">// for a break in the trust chain. If we have already tried the validation (before the insecurity
</span>    <span class="enscript-comment">// proof started) for this &quot;sname&quot;, then don't bother with the proof. This happens sometimes, when 
</span>    <span class="enscript-comment">// we can't prove whether a zone is insecurely delegated or not. For example, if we are looking up
</span>    <span class="enscript-comment">// host1.secure-nods.secure.example and when we encounter secure-nods, there is no DS record in the
</span>    <span class="enscript-comment">// parent. We start the insecurity proof remembering that &quot;secure-nods.secure.example&quot; is the trigger
</span>    <span class="enscript-comment">// point. As part of the proof we reach &quot;secure-nods.secure.example&quot;. Even though secure.example
</span>    <span class="enscript-comment">// prove that the name &quot;secure-nods.secure.example/DS&quot; does not exist,  it can't prove that it is a
</span>    <span class="enscript-comment">// delegation. So, we continue one more level down to host1.secure-nods.secure.example and we
</span>    <span class="enscript-comment">// realize that we already tried the validation and hence abort here.
</span>
    <span class="enscript-keyword">if</span> (CountLabels(sname) &gt; ic-&gt;triggerLabelCount)
    {
        LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: Beyond the trigger current name %##s, origName %##s&quot;</span>, sname-&gt;c, dv-&gt;origName.c);
        DeliverInsecureProofResult(m, ic, DNSSEC_Bogus);
        <span class="enscript-keyword">return</span>;
    }

    LogDNSSEC(<span class="enscript-string">&quot;ProveInsecure: OrigName %##s (%s), Current %##s&quot;</span>, dv-&gt;origName.c, DNSTypeName(dv-&gt;origType), sname-&gt;c);
    ic-&gt;skip--;
    InitializeQuestion(m, &amp;ic-&gt;q, dv-&gt;InterfaceID, sname, kDNSType_DS, ProveInsecureCallback, ic);
    ic-&gt;q.ValidationRequired = DNSSEC_VALIDATION_INSECURE;
    ic-&gt;q.ValidatingResponse = 0;
    ic-&gt;q.DNSSECAuthInfo = mDNSNULL;
    mDNS_StartQuery(m, &amp;ic-&gt;q);
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">BumpDNSSECStats</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECStatsAction action, DNSSECStatsType type, mDNSu32 value)
{
    <span class="enscript-keyword">switch</span> (type)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeMemoryUsage</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionIncrement)
        {
            m-&gt;DNSSECStats.TotalMemUsed += value;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (action == kStatsActionDecrement)
        {
            m-&gt;DNSSECStats.TotalMemUsed -= value;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeLatency</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionSet)
        {
            <span class="enscript-keyword">if</span> (value &lt;= 4)
            {
                m-&gt;DNSSECStats.Latency0++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 9)
            {
                m-&gt;DNSSECStats.Latency5++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 19)
            {
                m-&gt;DNSSECStats.Latency10++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 49)
            {
                m-&gt;DNSSECStats.Latency20++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 99)
            {
                m-&gt;DNSSECStats.Latency50++;
            }
            <span class="enscript-keyword">else</span>
            {
                m-&gt;DNSSECStats.Latency100++;
            }
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeExtraPackets</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionSet)
        {
            <span class="enscript-keyword">if</span> (value &lt;= 2)
            {
                m-&gt;DNSSECStats.ExtraPackets0++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 6)
            {
                m-&gt;DNSSECStats.ExtraPackets3++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 9)
            {
                m-&gt;DNSSECStats.ExtraPackets7++;
            }
            <span class="enscript-keyword">else</span>
            {
                m-&gt;DNSSECStats.ExtraPackets10++;
            }
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeStatus</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionSet)
        {
            <span class="enscript-keyword">switch</span>(value)
            {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Secure</span>:
                m-&gt;DNSSECStats.SecureStatus++;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Insecure</span>:
                m-&gt;DNSSECStats.InsecureStatus++;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Indeterminate</span>:
                m-&gt;DNSSECStats.IndeterminateStatus++;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_Bogus</span>:
                m-&gt;DNSSECStats.BogusStatus++;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">DNSSEC_NoResponse</span>:
                m-&gt;DNSSECStats.NoResponseStatus++;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                LogMsg(<span class="enscript-string">&quot;BumpDNSSECStats: unknown status %d&quot;</span>, value);
            }
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeMsgSize</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionSet)
        {
            <span class="enscript-keyword">if</span> (value &lt;= 1024)
            {
                m-&gt;DNSSECStats.MsgSize0++;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &lt;= 2048)
            {
                m-&gt;DNSSECStats.MsgSize1++;
            }
            <span class="enscript-keyword">else</span>
            {
                m-&gt;DNSSECStats.MsgSize2++;
            }
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kStatsTypeProbe</span>:
        <span class="enscript-keyword">if</span> (action == kStatsActionIncrement)
        {
            m-&gt;DNSSECStats.NumProbesSent += value;
        }
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        LogMsg(<span class="enscript-string">&quot;BumpDNSSECStats: unknown type %d&quot;</span>, type);
    }
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">VerifySignature</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, DNSQuestion *q)
{
    (<span class="enscript-type">void</span>)m;
    (<span class="enscript-type">void</span>)dv;
    (<span class="enscript-type">void</span>)q;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">BumpDNSSECStats</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECStatsAction action, DNSSECStatsType type, mDNSu32 value)
{
    (<span class="enscript-type">void</span>)m;
    (<span class="enscript-type">void</span>)action;
    (<span class="enscript-type">void</span>)type;
    (<span class="enscript-type">void</span>)value;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">InitializeQuestion</span>(mDNS *<span class="enscript-type">const</span> m, DNSQuestion *question, mDNSInterfaceID InterfaceID, <span class="enscript-type">const</span> domainname *qname, mDNSu16 qtype, mDNSQuestionCallback *callback, <span class="enscript-type">void</span> *context)
{
    (<span class="enscript-type">void</span>) m;
    (<span class="enscript-type">void</span>) question;
    (<span class="enscript-type">void</span>) InterfaceID;
    (<span class="enscript-type">void</span>) qname;
    (<span class="enscript-type">void</span>) qtype;
    (<span class="enscript-type">void</span>) callback;
    (<span class="enscript-type">void</span>) context;
}

mDNSexport <span class="enscript-type">char</span> *<span class="enscript-function-name">DNSSECStatusName</span>(DNSSECStatus status)
{
    (<span class="enscript-type">void</span>) status;
    
    <span class="enscript-keyword">return</span> mDNSNULL;
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>
</pre>
<hr />
</body></html>