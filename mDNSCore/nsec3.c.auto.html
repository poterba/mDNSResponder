<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nsec3.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nsec3.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="nsec3.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* -*- Mode: C; tab-width: 4 -*-
 *
 * Copyright (c) 2011-2018 Apple Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</span>

<span class="enscript-comment">// ***************************************************************************
</span><span class="enscript-comment">// nsec3.c: This file contains support functions to validate NSEC3 records for
</span><span class="enscript-comment">// NODATA and NXDOMAIN error.
</span><span class="enscript-comment">// ***************************************************************************
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;mDNSEmbeddedAPI.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DNSCommon.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;CryptoAlg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nsec3.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nsec.h&quot;</span>

<span class="enscript-comment">// Base32 encoding takes 5 bytes of the input and encodes as 8 bytes of output.
</span><span class="enscript-comment">// For example, SHA-1 hash of 20 bytes will be encoded as 20/5 * 8 = 32 base32
</span><span class="enscript-comment">// bytes. For a max domain name size of 255 bytes of base32 encoding : (255/8)*5
</span><span class="enscript-comment">// is the max hash length possible.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC3_MAX_HASH_LEN</span>  155
<span class="enscript-comment">// In NSEC3, the names are hashed and stored in the first label and hence cannot exceed label
</span><span class="enscript-comment">// size.
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSEC3_MAX_B32_LEN</span>   MAX_DOMAIN_LABEL

<span class="enscript-comment">// Define DNSSEC_DISABLED to remove all the DNSSEC functionality
</span><span class="enscript-comment">// and use the stub functions implemented later in this file.
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">DNSSEC_DISABLED</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> 
{
    NSEC3ClosestEncloser,
    NSEC3Covers,
    NSEC3CEProof
} NSEC3FindValues;

<span class="enscript-comment">//#define NSEC3_DEBUG 1
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NSEC3_DEBUG</span>
mDNSlocal <span class="enscript-type">void</span> <span class="enscript-function-name">PrintHash</span>(mDNSu8 *digest, <span class="enscript-type">int</span> digestlen, <span class="enscript-type">char</span> *buffer, <span class="enscript-type">int</span> buflen)
{
    <span class="enscript-type">int</span> length = 0;
    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> j = 0; j &lt; digestlen; j++)
    {
        length += mDNS_snprintf(buffer+length, buflen-length-1, <span class="enscript-string">&quot;%x&quot;</span>, digest[j]);
    }
}
#<span class="enscript-reference">endif</span>

mDNSlocal mDNSBool <span class="enscript-function-name">NSEC3OptOut</span>(CacheRecord *cr)
{
    <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)cr-&gt;resrec.rdata-&gt;u.data;
    rdataNSEC3 *nsec3 = (rdataNSEC3 *)rdb-&gt;data;
    <span class="enscript-keyword">return</span> (nsec3-&gt;flags &amp; NSEC3_FLAGS_OPTOUT);
}

mDNSlocal <span class="enscript-type">int</span> <span class="enscript-function-name">NSEC3SameName</span>(<span class="enscript-type">const</span> mDNSu8 *name, <span class="enscript-type">int</span> namelen, <span class="enscript-type">const</span> mDNSu8 *nsecName, <span class="enscript-type">int</span> nsecLen)
{
    <span class="enscript-type">int</span> i;

    <span class="enscript-comment">// Note: With NSEC3, the lengths should always be same. 
</span>    <span class="enscript-keyword">if</span> (namelen != nsecLen)
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3SameName: ERROR!! namelen %d, nsecLen %d&quot;</span>, namelen, nsecLen);
        <span class="enscript-keyword">return</span> ((namelen &lt; nsecLen) ? -1 : 1);
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; namelen; i++)
    {
        mDNSu8 ac = *name++;
        mDNSu8 bc = *nsecName++;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(ac)) ac += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (mDNSIsUpperCase(bc)) bc += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
        <span class="enscript-keyword">if</span> (ac != bc)
        {
            verbosedebugf(<span class="enscript-string">&quot;NSEC3SameName: returning ac %c, bc %c&quot;</span>, ac, bc);
            <span class="enscript-keyword">return</span> ((ac &lt; bc) ? -1 : 1);
        }
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">// Does the NSEC3 in &quot;ncr&quot; covers the &quot;name&quot; ?
</span><span class="enscript-comment">// hashName is hash of the &quot;name&quot; and b32Name is the base32 encoded equivalent.
</span>mDNSlocal mDNSBool <span class="enscript-function-name">NSEC3CoversName</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *ncr, <span class="enscript-type">const</span> mDNSu8 *hashName, <span class="enscript-type">int</span> hashLen, <span class="enscript-type">const</span> mDNSu8 *b32Name,
	<span class="enscript-type">int</span> b32len)
{
    mDNSu8 *nxtName;
    <span class="enscript-type">int</span> nxtLength;
    <span class="enscript-type">int</span> ret, ret1, ret2;
    <span class="enscript-type">const</span> mDNSu8 b32nxtname[NSEC3_MAX_B32_LEN+1];
    <span class="enscript-type">int</span> b32nxtlen;

    NSEC3Parse(&amp;ncr-&gt;resrec, mDNSNULL, &amp;nxtLength, &amp;nxtName, mDNSNULL, mDNSNULL);

    <span class="enscript-keyword">if</span> (nxtLength != hashLen || ncr-&gt;resrec.name-&gt;c[0] != b32len)
        <span class="enscript-keyword">return</span> mDNSfalse;

    <span class="enscript-comment">// Compare the owner names and the &quot;nxt&quot; names.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Owner name is base32 encoded and hence use the base32 encoded name b32name.
</span>    <span class="enscript-comment">// nxt name is binary and hence use the binary value in hashName. 
</span>    ret1 = NSEC3SameName(&amp;ncr-&gt;resrec.name-&gt;c[1], ncr-&gt;resrec.name-&gt;c[0], b32Name, b32len);
    ret2 = DNSMemCmp(nxtName, hashName, hashLen);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NSEC3_DEBUG</span>
    {
        <span class="enscript-type">char</span> nxtbuf1[50];
        <span class="enscript-type">char</span> nxtbuf2[50];

        PrintHash(nxtName, nxtLength, nxtbuf1, <span class="enscript-keyword">sizeof</span>(nxtbuf1));
        PrintHash((mDNSu8 *)hashName, hashLen, nxtbuf2, <span class="enscript-keyword">sizeof</span>(nxtbuf2));
        LogMsg(<span class="enscript-string">&quot;NSEC3CoversName: Owner name %s, name %s&quot;</span>, &amp;ncr-&gt;resrec.name-&gt;c[1], b32Name);
        LogMsg(<span class="enscript-string">&quot;NSEC3CoversName: Nxt hash name %s, name %s&quot;</span>, nxtbuf1, nxtbuf2);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// &quot;name&quot; is greater than the owner name and smaller than nxtName. This also implies
</span>	<span class="enscript-comment">// that nxtName &gt; owner name implying that it is normal NSEC3.
</span>    <span class="enscript-keyword">if</span> (ret1 &lt; 0 &amp;&amp; ret2 &gt; 0)
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3CoversName: NSEC3 %s covers %s (Normal)&quot;</span>, CRDisplayString(m, ncr), b32Name);
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-comment">// Need to compare the owner name and &quot;nxt&quot; to see if this is the last
</span>    <span class="enscript-comment">// NSEC3 in the zone. Only the owner name is in base32 and hence we need to
</span>    <span class="enscript-comment">// convert the nxtName to base32.
</span>    b32nxtlen = baseEncode((<span class="enscript-type">char</span> *)b32nxtname, <span class="enscript-keyword">sizeof</span>(b32nxtname), nxtName, nxtLength, ENC_BASE32);
    <span class="enscript-keyword">if</span> (!b32nxtlen)
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3CoversName: baseEncode of nxtName of %s failed&quot;</span>, CRDisplayString(m, ncr));
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (b32len != b32nxtlen)
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3CoversName: baseEncode of nxtName for %s resulted in wrong length b32nxtlen %d, b32len %d&quot;</span>,
            CRDisplayString(m, ncr), b32len, b32nxtlen);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    LogDNSSEC(<span class="enscript-string">&quot;NSEC3CoversName: Owner name %s, b32nxtname %s, ret1 %d, ret2 %d&quot;</span>, &amp;ncr-&gt;resrec.name-&gt;c[1], b32nxtname, ret1, ret2);

    <span class="enscript-comment">// If it is the last NSEC3 in the zone nxt &lt; &quot;name&quot; and NSEC3SameName returns -1.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// - ret1 &lt; 0 means &quot;name &gt; owner&quot;
</span>    <span class="enscript-comment">// - ret2 &gt; 0 means &quot;name &lt; nxt&quot;
</span>    <span class="enscript-comment">// 
</span>    <span class="enscript-comment">// Note: We also handle the case of only NSEC3 in the zone where NSEC3SameName returns zero.
</span>    ret = NSEC3SameName(b32nxtname, b32nxtlen, &amp;ncr-&gt;resrec.name-&gt;c[1], ncr-&gt;resrec.name-&gt;c[0]);
    <span class="enscript-keyword">if</span> (ret &lt;= 0 &amp;&amp;
        (ret1 &lt; 0 || ret2 &gt; 0))
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3CoversName: NSEC3 %s covers %s (Last), ret1 %d, ret2 %d&quot;</span>, CRDisplayString(m, ncr), b32Name, ret1, ret2);
        <span class="enscript-keyword">return</span> mDNStrue;
    }

    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal <span class="enscript-type">const</span> mDNSu8 *<span class="enscript-function-name">NSEC3HashName</span>(<span class="enscript-type">const</span> domainname *name, rdataNSEC3 *nsec3, <span class="enscript-type">const</span> mDNSu8 hash[NSEC3_MAX_HASH_LEN], <span class="enscript-type">int</span> *dlen)
{
    AlgContext *ctx;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> iterations;
    domainname lname;
    mDNSu8 *p = (mDNSu8 *)&amp;nsec3-&gt;salt;
    <span class="enscript-type">const</span> mDNSu8 *digest;
    <span class="enscript-type">int</span> digestlen;
    mDNSBool first = mDNStrue;

    <span class="enscript-keyword">if</span> (DNSNameToLowerCase((domainname *)name, &amp;lname) != mStatus_NoError)
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3HashName: ERROR!! DNSNameToLowerCase failed&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }

    digest = lname.c;
    digestlen = DomainNameLength(&amp;lname);

    <span class="enscript-comment">// Note that it is &quot;i &lt;=&quot;. The first iteration is for digesting the name and salt.
</span>    <span class="enscript-comment">// The iteration count does not include that.
</span>    iterations = swap16(nsec3-&gt;iterations);
    <span class="enscript-keyword">for</span> (i = 0; i &lt;= iterations; i++)
    {
        ctx = AlgCreate(DIGEST_ALG, nsec3-&gt;alg);
        <span class="enscript-keyword">if</span> (!ctx)
        {
            LogMsg(<span class="enscript-string">&quot;NSEC3HashName: ERROR!! Cannot allocate context&quot;</span>);
            <span class="enscript-keyword">return</span> mDNSNULL;
        }

        AlgAdd(ctx, digest, digestlen);
        <span class="enscript-keyword">if</span> (nsec3-&gt;saltLength)
            AlgAdd(ctx, p, nsec3-&gt;saltLength);
        <span class="enscript-keyword">if</span> (first)
        {
            first = mDNSfalse;
            digest = hash;
            digestlen = AlgLength(ctx);
        }
        AlgFinal(ctx, (<span class="enscript-type">void</span> *)digest, digestlen);
        AlgDestroy(ctx);
    }
    *dlen = digestlen;
    <span class="enscript-keyword">return</span> digest;
}

<span class="enscript-comment">// This function can be called with NSEC3ClosestEncloser, NSEC3Covers and NSEC3CEProof
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Passing in NSEC3ClosestEncloser means &quot;find an exact match for the origName&quot;.
</span><span class="enscript-comment">// Passing in NSEC3Covers means &quot;find an NSEC3 that covers the origName&quot;.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// i.e., in both cases the nsec3 records are iterated to find the best match and returned.
</span><span class="enscript-comment">// With NSEC3ClosestEncloser, as we are just looking for a name match, extra checks for
</span><span class="enscript-comment">// the types being present or absent will not be checked.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If NSEC3CEProof is passed, the name is tried as such first by iterating through all NSEC3s
</span><span class="enscript-comment">// finding a ClosestEncloser or CloserEncloser and then one label skipped from the left and
</span><span class="enscript-comment">// retried again till both the closest and closer encloser is found.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// ncr is the negative cache record that has the NSEC3 chain
</span><span class="enscript-comment">// origName is the name for which we are trying to find the ClosestEncloser etc.
</span><span class="enscript-comment">// closestEncloser and closerEncloser are the return values of the function
</span><span class="enscript-comment">// ce is the closest encloser that will be returned if we find one
</span>mDNSlocal mDNSBool <span class="enscript-function-name">NSEC3Find</span>(mDNS *<span class="enscript-type">const</span> m, NSEC3FindValues val, CacheRecord *ncr, domainname *origName, CacheRecord **closestEncloser,
	CacheRecord **closerEncloser, <span class="enscript-type">const</span> domainname **ce, mDNSu16 qtype)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> labelCount = CountLabels(origName);
    CacheRecord *cr;
    rdataNSEC3 *nsec3;

    (<span class="enscript-type">void</span>) qtype; <span class="enscript-comment">// unused
</span>    <span class="enscript-comment">// Pick the first NSEC for the iterations, salt etc.
</span>    <span class="enscript-keyword">for</span> (cr = ncr-&gt;nsec; cr; cr = cr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype == kDNSType_NSEC3)
        {
            <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)cr-&gt;resrec.rdata-&gt;u.data;
            nsec3 = (rdataNSEC3 *)rdb-&gt;data;
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">if</span> (!cr)
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3Find: cr NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// Note: The steps defined in this function are for &quot;NSEC3CEProof&quot;. As part of NSEC3CEProof,
</span>    <span class="enscript-comment">// we need to find both the closestEncloser and closerEncloser which can also be found
</span>    <span class="enscript-comment">// by passing NSEC3ClosestEncloser and NSEC3Covers respectively.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Section 8.3 of RFC 5155.
</span>    <span class="enscript-comment">// 1.  Set SNAME=QNAME.  Clear the flag.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// closerEncloser is the &quot;flag&quot;. &quot;name&quot; below is SNAME.
</span>
    <span class="enscript-keyword">if</span> (closestEncloser)
    {
        *ce = mDNSNULL;
        *closestEncloser = mDNSNULL;
    }
    <span class="enscript-keyword">if</span> (closerEncloser)
        *closerEncloser = mDNSNULL;

    <span class="enscript-comment">// If we are looking for a closestEncloser or a covering NSEC3, we don't have
</span>    <span class="enscript-comment">// to truncate the name. For the give name, try to find the closest or closer
</span>    <span class="enscript-comment">// encloser.
</span>    <span class="enscript-keyword">if</span> (val != NSEC3CEProof)
    {
        labelCount = 0;
    }

    <span class="enscript-keyword">for</span> (i = 0; i &lt; labelCount + 1; i++)
    { 
        <span class="enscript-type">int</span> hlen;
        <span class="enscript-type">const</span> mDNSu8 hashName[NSEC3_MAX_HASH_LEN];
        <span class="enscript-type">const</span> domainname *name;
        <span class="enscript-type">const</span> mDNSu8 b32Name[NSEC3_MAX_B32_LEN+1];
        <span class="enscript-type">int</span> b32len;

        name = SkipLeadingLabels(origName, i);
        <span class="enscript-keyword">if</span> (!NSEC3HashName(name, nsec3, hashName, &amp;hlen))
        {
            LogMsg(<span class="enscript-string">&quot;NSEC3Find: NSEC3HashName failed for %##s&quot;</span>, name-&gt;c);
            <span class="enscript-keyword">continue</span>;
        }

        b32len = baseEncode((<span class="enscript-type">char</span> *)b32Name, <span class="enscript-keyword">sizeof</span>(b32Name), (mDNSu8 *)hashName, hlen, ENC_BASE32);
        <span class="enscript-keyword">if</span> (!b32len)
        {
            LogMsg(<span class="enscript-string">&quot;NSEC3Find: baseEncode of name %##s failed&quot;</span>, name-&gt;c);
            <span class="enscript-keyword">continue</span>;
        }


        <span class="enscript-keyword">for</span> (cr = ncr-&gt;nsec; cr; cr = cr-&gt;next)
        {
            <span class="enscript-type">const</span> domainname *nsecZone;
            <span class="enscript-type">int</span> result, subdomain;

            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_NSEC3)
                <span class="enscript-keyword">continue</span>;

            nsecZone = SkipLeadingLabels(cr-&gt;resrec.name, 1);
            <span class="enscript-keyword">if</span> (!nsecZone)
            {
                LogMsg(<span class="enscript-string">&quot;NSEC3Find: SkipLeadingLabel failed for %s, current name %##s&quot;</span>,
                    CRDisplayString(m, cr), name-&gt;c);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// NSEC3 owner names are formed by hashing the owner name and then appending
</span>            <span class="enscript-comment">// the zone name to it. If we skip the first label, the rest should be
</span>            <span class="enscript-comment">// the zone name. See whether it is the subdomain of the name we are looking
</span>            <span class="enscript-comment">// for. 
</span>            result = DNSSECCanonicalOrder(origName, nsecZone, &amp;subdomain);
            
            <span class="enscript-comment">// The check can't be a strict subdomain check. When NSEC3ClosestEncloser is
</span>            <span class="enscript-comment">// passed in, there can be an exact match. If it is a subdomain or an exact
</span>            <span class="enscript-comment">// match, we should continue with the proof.
</span>            <span class="enscript-keyword">if</span> (!(subdomain || !result))
            {
                LogMsg(<span class="enscript-string">&quot;NSEC3Find: NSEC3 %s not a subdomain of %##s, result %d&quot;</span>, CRDisplayString(m, cr),
                    origName-&gt;c, result);
                <span class="enscript-keyword">continue</span>;
            }

            <span class="enscript-comment">// 2.1) If there is no NSEC3 RR in the response that matches SNAME
</span>            <span class="enscript-comment">// (i.e., an NSEC3 RR whose owner name is the same as the hash of
</span>            <span class="enscript-comment">// SNAME, prepended as a single label to the zone name), clear
</span>            <span class="enscript-comment">// the flag.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Note: We don't try to determine the actual zone name. We know that
</span>            <span class="enscript-comment">// the labels following the hash (nsecZone) is the ancestor and we don't
</span>            <span class="enscript-comment">// know where the zone cut is. Hence, we verify just the hash to be
</span>            <span class="enscript-comment">// the same.
</span>
            <span class="enscript-keyword">if</span> (val == NSEC3ClosestEncloser || val == NSEC3CEProof)
            {
                <span class="enscript-keyword">if</span> (!NSEC3SameName(&amp;cr-&gt;resrec.name-&gt;c[1], cr-&gt;resrec.name-&gt;c[0], (<span class="enscript-type">const</span> mDNSu8 *)b32Name, b32len))
                {
                    <span class="enscript-type">int</span> bmaplen;
                    mDNSu8 *bmap;

                    <span class="enscript-comment">// For NSEC3ClosestEncloser, we are finding an exact match and
</span>                    <span class="enscript-comment">// &quot;type&quot; specific checks should be done by the caller.
</span>                    <span class="enscript-keyword">if</span> (val != NSEC3ClosestEncloser)
                    {
                        <span class="enscript-comment">// DNAME bit must not be set and NS bit may be set only if SOA bit is set
</span>                        NSEC3Parse(&amp;cr-&gt;resrec, mDNSNULL, mDNSNULL, mDNSNULL, &amp;bmaplen, &amp;bmap);
                        <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, kDNSType_DNAME))
                        {
                            LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: DNAME bit set in %s, ignoring&quot;</span>, CRDisplayString(m, cr));
                            <span class="enscript-keyword">return</span> mDNSfalse;
                        }
                        <span class="enscript-comment">// This is the closest encloser and should come from the right zone.
</span>                        <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, kDNSType_NS) &amp;&amp;
                            !BitmapTypeCheck(bmap, bmaplen, kDNSType_SOA))
                        {
                            LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: NS bit set without SOA bit in %s, ignoring&quot;</span>, CRDisplayString(m, cr));
                            <span class="enscript-keyword">return</span> mDNSfalse;
                        }
                    }

                    LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: ClosestEncloser %s found for name %##s&quot;</span>, CRDisplayString(m, cr), name-&gt;c);
                    <span class="enscript-keyword">if</span> (closestEncloser)
                    {
                        *ce = name;
                        *closestEncloser = cr;
                    }
                    <span class="enscript-keyword">if</span> (val == NSEC3ClosestEncloser)
                        <span class="enscript-keyword">return</span> mDNStrue;
                    <span class="enscript-keyword">else</span>
                        <span class="enscript-keyword">break</span>;
                }
            }

            <span class="enscript-keyword">if</span> ((val == NSEC3Covers || val == NSEC3CEProof) &amp;&amp; (!closerEncloser || !(*closerEncloser)))
            {
                <span class="enscript-keyword">if</span> (NSEC3CoversName(m, cr, hashName, hlen, b32Name, b32len))
                {
                    <span class="enscript-comment">// 2.2) If there is an NSEC3 RR in the response that covers SNAME, set the flag.
</span>                    <span class="enscript-keyword">if</span> (closerEncloser)
                        *closerEncloser = cr;
                    <span class="enscript-keyword">if</span> (val == NSEC3Covers)
                        <span class="enscript-keyword">return</span> mDNStrue;
                    <span class="enscript-keyword">else</span>
                        <span class="enscript-keyword">break</span>;
                }
            }
        }
        <span class="enscript-comment">// 2.3) If there is a matching NSEC3 RR in the response and the flag
</span>        <span class="enscript-comment">// was set, then the proof is complete, and SNAME is the closest
</span>        <span class="enscript-comment">// encloser.
</span>        <span class="enscript-keyword">if</span> (val == NSEC3CEProof &amp;&amp; closestEncloser &amp;&amp; *closestEncloser)
        {
            <span class="enscript-keyword">if</span> (closerEncloser &amp;&amp; *closerEncloser)
            {
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: Found closest and closer encloser&quot;</span>);
                <span class="enscript-keyword">return</span> mDNStrue;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// 2.4) If there is a matching NSEC3 RR in the response, but the flag
</span>                <span class="enscript-comment">// is not set, then the response is bogus.
</span>                <span class="enscript-comment">//
</span>                <span class="enscript-comment">// Note: We don't have to wait till we finish trying all the names. If the matchName
</span>                <span class="enscript-comment">// happens, we found the closest encloser which means we should have found the closer
</span>                <span class="enscript-comment">// encloser before.
</span>
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: Found closest, but not closer encloser&quot;</span>);
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
        }
        <span class="enscript-comment">// 3.  Truncate SNAME by one label from the left, go to step 2.
</span>    }
    LogDNSSEC(<span class="enscript-string">&quot;NSEC3Find: Cannot find name %##s (%s)&quot;</span>, origName-&gt;c, DNSTypeName(qtype));
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSlocal mDNSBool <span class="enscript-function-name">NSEC3ClosestEncloserProof</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *ncr, domainname *name, CacheRecord **closestEncloser, CacheRecord **closerEncloser,
	<span class="enscript-type">const</span> domainname **ce, mDNSu16 qtype)
{
    <span class="enscript-keyword">if</span> (!NSEC3Find(m, NSEC3CEProof, ncr, name, closestEncloser, closerEncloser, ce, qtype))
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3ClosestEncloserProof: ERROR!! Cannot do closest encloser proof&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// Note: It is possible that closestEncloser and closerEncloser are the same.
</span>    <span class="enscript-keyword">if</span> (!closestEncloser || !closerEncloser || !ce)
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3ClosestEncloserProof: ClosestEncloser %p or CloserEncloser %p ce %p, something is NULL&quot;</span>, closestEncloser, closerEncloser, ce);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }

    <span class="enscript-comment">// If the name exists, we should not have gotten the name error
</span>    <span class="enscript-keyword">if</span> (SameDomainName((*ce), name))
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3ClosestEncloserProof: ClosestEncloser %s same as origName %##s&quot;</span>, CRDisplayString(m, *closestEncloser),
            (*ce)-&gt;c);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSlocal mDNSBool <span class="enscript-function-name">VerifyNSEC3</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord *ncr, CacheRecord *closestEncloser,
    CacheRecord *closerEncloser, CacheRecord *wildcard, DNSSECVerifierCallback callback)
{
    mStatus status;
    RRVerifier *r;

    <span class="enscript-comment">// We have three NSEC3s. If any of two are same, we should just prove one of them.
</span>    <span class="enscript-comment">// This is just not an optimization; DNSSECNegativeValidationCB does not handle
</span>    <span class="enscript-comment">// identical NSEC3s very well.
</span>
    <span class="enscript-keyword">if</span> (closestEncloser == closerEncloser)
        closestEncloser = mDNSNULL;
    <span class="enscript-keyword">if</span> (closerEncloser == wildcard)
        closerEncloser = mDNSNULL;
    <span class="enscript-keyword">if</span> (closestEncloser == wildcard)
        closestEncloser = mDNSNULL;

    dv-&gt;pendingNSEC = mDNSNULL;
    <span class="enscript-keyword">if</span> (closestEncloser)
    {
        r = AllocateRRVerifier(&amp;closestEncloser-&gt;resrec, &amp;status);
        <span class="enscript-keyword">if</span> (!r)
            <span class="enscript-keyword">return</span> mDNSfalse;
        r-&gt;next = dv-&gt;pendingNSEC;
        dv-&gt;pendingNSEC = r;
    }
    <span class="enscript-keyword">if</span> (closerEncloser)
    {
        r = AllocateRRVerifier(&amp;closerEncloser-&gt;resrec, &amp;status);
        <span class="enscript-keyword">if</span> (!r)
            <span class="enscript-keyword">return</span> mDNSfalse;
        r-&gt;next = dv-&gt;pendingNSEC;
        dv-&gt;pendingNSEC = r;
    }
    <span class="enscript-keyword">if</span> (wildcard)
    {
        r = AllocateRRVerifier(&amp;wildcard-&gt;resrec, &amp;status);
        <span class="enscript-keyword">if</span> (!r)
            <span class="enscript-keyword">return</span> mDNSfalse;
        r-&gt;next = dv-&gt;pendingNSEC;
        dv-&gt;pendingNSEC = r;
    }
    <span class="enscript-keyword">if</span> (!dv-&gt;pendingNSEC)
    {
        LogMsg(<span class="enscript-string">&quot;VerifyNSEC3: ERROR!! pending NSEC null&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    r = dv-&gt;pendingNSEC;
    dv-&gt;pendingNSEC = r-&gt;next;
    r-&gt;next = mDNSNULL;

    LogDNSSEC(<span class="enscript-string">&quot;VerifyNSEC3: Verifying %##s (%s)&quot;</span>, r-&gt;name.c, DNSTypeName(r-&gt;rrtype));
    <span class="enscript-keyword">if</span> (!dv-&gt;pendingNSEC)
        VerifyNSEC(m, mDNSNULL, r, dv, ncr, mDNSNULL);
    <span class="enscript-keyword">else</span>
        VerifyNSEC(m, mDNSNULL, r, dv, ncr, callback);
    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">NSEC3NameErrorProof</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord *ncr)
{
    CacheRecord *closerEncloser;
    CacheRecord *closestEncloser;
    CacheRecord *wildcard;
    <span class="enscript-type">const</span> domainname *ce = mDNSNULL;
    domainname wild;

    <span class="enscript-keyword">if</span> (!NSEC3ClosestEncloserProof(m, ncr, &amp;dv-&gt;q.qname, &amp;closestEncloser, &amp;closerEncloser, &amp;ce, dv-&gt;q.qtype))
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    LogDNSSEC(<span class="enscript-string">&quot;NSEC3NameErrorProof: ClosestEncloser %s, ce %##s&quot;</span>, CRDisplayString(m, closestEncloser), ce-&gt;c);
    LogDNSSEC(<span class="enscript-string">&quot;NSEC3NameErrorProof: CloserEncloser %s&quot;</span>, CRDisplayString(m, closerEncloser));

    <span class="enscript-comment">// *.closestEncloser should be covered by some nsec3 which would then prove
</span>    <span class="enscript-comment">// that the wildcard does not exist
</span>    wild.c[0] = 1;
    wild.c[1] = <span class="enscript-string">'*'</span>;
    wild.c[2] = 0;
    <span class="enscript-keyword">if</span> (!AppendDomainName(&amp;wild, ce))
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3NameErrorProof: Can't append domainname to closest encloser name %##s&quot;</span>, ce-&gt;c);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    <span class="enscript-keyword">if</span> (!NSEC3Find(m, NSEC3Covers, ncr, &amp;wild, mDNSNULL, &amp;wildcard, mDNSNULL, dv-&gt;q.qtype))
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3NameErrorProof: Cannot find encloser for wildcard&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    <span class="enscript-keyword">else</span>
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3NameErrorProof: Wildcard %##s covered by %s&quot;</span>, wild.c, CRDisplayString(m, wildcard));
        <span class="enscript-keyword">if</span> (wildcard == closestEncloser)
        {
            LogDNSSEC(<span class="enscript-string">&quot;NSEC3NameErrorProof: ClosestEncloser matching Wildcard %s&quot;</span>, CRDisplayString(m, wildcard));
        }
    }
    <span class="enscript-keyword">if</span> (NSEC3OptOut(closerEncloser))
    {
        dv-&gt;flags |= NSEC3_OPT_OUT;
    }
    <span class="enscript-keyword">if</span> (!VerifyNSEC3(m, dv, ncr, closestEncloser, closerEncloser, wildcard, NameErrorNSECCallback))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>;

<span class="enscript-reference">error</span>:
    dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
}

<span class="enscript-comment">// Section 8.5, 8.6 of RFC 5155 first paragraph
</span>mDNSlocal mDNSBool <span class="enscript-function-name">NSEC3NoDataError</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *ncr, domainname *name, mDNSu16 qtype, CacheRecord **closestEncloser)
{
    <span class="enscript-type">const</span> domainname *ce = mDNSNULL;

    *closestEncloser = mDNSNULL;
    <span class="enscript-comment">// Note: This also covers ENT in which case the bitmap is empty
</span>    <span class="enscript-keyword">if</span> (NSEC3Find(m, NSEC3ClosestEncloser, ncr, name, closestEncloser, mDNSNULL, &amp;ce, qtype))
    {
        <span class="enscript-type">int</span> bmaplen;
        mDNSu8 *bmap;
        mDNSBool ns, soa;

        NSEC3Parse(&amp;(*closestEncloser)-&gt;resrec, mDNSNULL, mDNSNULL, mDNSNULL, &amp;bmaplen, &amp;bmap);
        <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, qtype) || BitmapTypeCheck(bmap, bmaplen, kDNSType_CNAME))
        {
            LogMsg(<span class="enscript-string">&quot;NSEC3NoDataError: qtype %s exists in %s&quot;</span>, DNSTypeName(qtype), CRDisplayString(m, *closestEncloser));
            <span class="enscript-keyword">return</span> mDNSfalse;
        }
        ns = BitmapTypeCheck(bmap, bmaplen, kDNSType_NS);
        soa = BitmapTypeCheck(bmap, bmaplen, kDNSType_SOA);
        <span class="enscript-keyword">if</span> (qtype != kDNSType_DS)
        {
            <span class="enscript-comment">// For non-DS type questions, we don't want to use the parent side records to
</span>            <span class="enscript-comment">// answer it
</span>            <span class="enscript-keyword">if</span> (ns &amp;&amp; !soa)
            {
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataError: Parent side NSEC %s, can't use for child qname %##s (%s)&quot;</span>,
                    CRDisplayString(m, *closestEncloser), name-&gt;c, DNSTypeName(qtype));
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">if</span> (soa)
            {
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataError: Child side NSEC %s, can't use for parent qname %##s (%s)&quot;</span>,
                    CRDisplayString(m, *closestEncloser), name-&gt;c, DNSTypeName(qtype));
                <span class="enscript-keyword">return</span> mDNSfalse;
            }
        }
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataError: Name -%##s- exists, but qtype %s does not exist in %s&quot;</span>, name-&gt;c, DNSTypeName(qtype), CRDisplayString(m, *closestEncloser));
        <span class="enscript-keyword">return</span> mDNStrue;
    }
    <span class="enscript-keyword">return</span> mDNSfalse;
}

mDNSexport <span class="enscript-type">void</span> <span class="enscript-function-name">NSEC3NoDataProof</span>(mDNS *<span class="enscript-type">const</span> m, DNSSECVerifier *dv, CacheRecord *ncr)
{
    CacheRecord *closerEncloser = mDNSNULL;
    CacheRecord *closestEncloser = mDNSNULL;
    CacheRecord *wildcard = mDNSNULL;
    <span class="enscript-type">const</span> domainname *ce = mDNSNULL;
    domainname wild;

    <span class="enscript-comment">// Section 8.5, 8.6 of RFC 5155
</span>    <span class="enscript-keyword">if</span> (NSEC3NoDataError(m, ncr, &amp;dv-&gt;q.qname, dv-&gt;q.qtype, &amp;closestEncloser))
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">verify</span>;
    }
    <span class="enscript-comment">// Section 8.6, 8.7: if we can't find the NSEC3 RR, verify the closest encloser proof
</span>    <span class="enscript-comment">// for QNAME and the &quot;next closer&quot; should have the opt out
</span>    <span class="enscript-keyword">if</span> (!NSEC3ClosestEncloserProof(m, ncr, &amp;dv-&gt;q.qname, &amp;closestEncloser, &amp;closerEncloser, &amp;ce, dv-&gt;q.qtype))
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }

    <span class="enscript-comment">// Section 8.7: find a matching NSEC3 for *.closestEncloser
</span>    wild.c[0] = 1;
    wild.c[1] = <span class="enscript-string">'*'</span>;
    wild.c[2] = 0;
    <span class="enscript-keyword">if</span> (!AppendDomainName(&amp;wild, ce))
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3NameErrorProof: Can't append domainname to closest encloser name %##s&quot;</span>, ce-&gt;c);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    }
    <span class="enscript-keyword">if</span> (!NSEC3Find(m, NSEC3ClosestEncloser, ncr, &amp;wild, &amp;wildcard, mDNSNULL, &amp;ce, dv-&gt;q.qtype))
    {
        <span class="enscript-comment">// Not a wild card case. Section 8.6 second para applies.
</span>        LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataProof: Cannot find encloser for wildcard, perhaps not a wildcard case&quot;</span>);
        <span class="enscript-keyword">if</span> (!NSEC3OptOut(closerEncloser))
        {
            LogDNSSEC(<span class="enscript-string">&quot;NSEC3DataProof: opt out not set for %##s (%s), bogus&quot;</span>, dv-&gt;q.qname.c, DNSTypeName(dv-&gt;q.qtype));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
        }
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3DataProof: opt out set, proof complete for %##s (%s)&quot;</span>, dv-&gt;q.qname.c, DNSTypeName(dv-&gt;q.qtype));
        dv-&gt;flags |= NSEC3_OPT_OUT;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-type">int</span> bmaplen;
        mDNSu8 *bmap;
        NSEC3Parse(&amp;wildcard-&gt;resrec, mDNSNULL, mDNSNULL, mDNSNULL, &amp;bmaplen, &amp;bmap);
        <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, dv-&gt;q.qtype) || BitmapTypeCheck(bmap, bmaplen, kDNSType_CNAME))
        {
            LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataProof: qtype %s exists in %s&quot;</span>, DNSTypeName(dv-&gt;q.qtype), CRDisplayString(m, wildcard));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
        }
        <span class="enscript-keyword">if</span> (dv-&gt;q.qtype == kDNSType_DS &amp;&amp; BitmapTypeCheck(bmap, bmaplen, kDNSType_SOA))
        {
            LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataProof: Child side wildcard NSEC3 %s, can't use for parent qname %##s (%s)&quot;</span>,
                CRDisplayString(m, wildcard), dv-&gt;q.qname.c, DNSTypeName(dv-&gt;q.qtype));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dv-&gt;q.qtype != kDNSType_DS &amp;&amp; !BitmapTypeCheck(bmap, bmaplen, kDNSType_SOA) &amp;&amp;
            BitmapTypeCheck(bmap, bmaplen, kDNSType_NS))
        {
            <span class="enscript-comment">// Don't use the parent side record for this
</span>            LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataProof: Parent side wildcard NSEC3 %s, can't use for child qname %##s (%s)&quot;</span>,
                CRDisplayString(m, wildcard), dv-&gt;q.qname.c, DNSTypeName(dv-&gt;q.qtype));
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
        }
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3NoDataProof: Wildcard %##s matched by %s&quot;</span>, wild.c, CRDisplayString(m, wildcard));
    }
<span class="enscript-reference">verify</span>:

    <span class="enscript-keyword">if</span> (!VerifyNSEC3(m, dv, ncr, closestEncloser, closerEncloser, wildcard, NoDataNSECCallback))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>;
<span class="enscript-reference">error</span>:
    dv-&gt;DVCallback(m, dv, DNSSEC_Bogus);
}

mDNSexport mDNSBool <span class="enscript-function-name">NSEC3WildcardAnswerProof</span>(mDNS *<span class="enscript-type">const</span> m, CacheRecord *ncr, DNSSECVerifier *dv)
{
    <span class="enscript-type">int</span> skip;
    <span class="enscript-type">const</span> domainname *nc;
    CacheRecord *closerEncloser;

    (<span class="enscript-type">void</span>) m;

    <span class="enscript-comment">// Find the next closer name and prove that it is covered by the NSEC3
</span>    skip = CountLabels(&amp;dv-&gt;origName) - CountLabels(dv-&gt;wildcardName) - 1;
    <span class="enscript-keyword">if</span> (skip)
        nc = SkipLeadingLabels(&amp;dv-&gt;origName, skip);
    <span class="enscript-keyword">else</span>
        nc = &amp;dv-&gt;origName;

    LogDNSSEC(<span class="enscript-string">&quot;NSEC3WildcardAnswerProof: wildcard name %##s&quot;</span>, nc-&gt;c);

    <span class="enscript-keyword">if</span> (!NSEC3Find(m, NSEC3Covers, ncr, (domainname *)nc, mDNSNULL, &amp;closerEncloser, mDNSNULL, dv-&gt;q.qtype))
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3WildcardAnswerProof: Cannot find closer encloser&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (!closerEncloser)
    {
        LogMsg(<span class="enscript-string">&quot;NSEC3WildcardAnswerProof: closerEncloser NULL&quot;</span>);
        <span class="enscript-keyword">return</span> mDNSfalse;
    }
    <span class="enscript-keyword">if</span> (NSEC3OptOut(closerEncloser))
    {
        dv-&gt;flags |= NSEC3_OPT_OUT;
    }
    <span class="enscript-comment">// NSEC3 Verification is done by the caller
</span>    <span class="enscript-keyword">return</span> mDNStrue;
}

mDNSexport CacheRecord *<span class="enscript-function-name">NSEC3RecordIsDelegation</span>(mDNS *<span class="enscript-type">const</span> m, domainname *name, mDNSu16 qtype)
{
    CacheGroup *cg;
    CacheRecord *cr;
    CacheRecord *ncr;
    mDNSu32 namehash;

    namehash = DomainNameHashValue(name);

    cg = CacheGroupForName(m, namehash, name);
    <span class="enscript-keyword">if</span> (!cg)
    {
        LogDNSSEC(<span class="enscript-string">&quot;NSEC3RecordForName: cg NULL for %##s&quot;</span>, name);
        <span class="enscript-keyword">return</span> mDNSNULL;
    }
    <span class="enscript-keyword">for</span> (ncr = cg-&gt;members; ncr; ncr = ncr-&gt;next)
    {
        <span class="enscript-keyword">if</span> (ncr-&gt;resrec.RecordType != kDNSRecordTypePacketNegative ||
            ncr-&gt;resrec.rrtype != qtype)
        {
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">for</span> (cr = ncr-&gt;nsec; cr; cr = cr-&gt;next)
        {
            <span class="enscript-type">int</span> hlen, b32len;
            <span class="enscript-type">const</span> mDNSu8 hashName[NSEC3_MAX_HASH_LEN];
            <span class="enscript-type">const</span> mDNSu8 b32Name[NSEC3_MAX_B32_LEN+1];
            <span class="enscript-type">const</span> RDataBody2 *<span class="enscript-type">const</span> rdb = (RDataBody2 *)cr-&gt;resrec.rdata-&gt;u.data;
            rdataNSEC3 *nsec3;

            <span class="enscript-keyword">if</span> (cr-&gt;resrec.rrtype != kDNSType_NSEC3)
                <span class="enscript-keyword">continue</span>;

            nsec3 = (rdataNSEC3 *)rdb-&gt;data;

            <span class="enscript-keyword">if</span> (!NSEC3HashName(name, nsec3, hashName, &amp;hlen))
            {
                LogMsg(<span class="enscript-string">&quot;NSEC3RecordIsDelegation: NSEC3HashName failed for %##s&quot;</span>, name-&gt;c);
                <span class="enscript-keyword">return</span> mDNSNULL;
            }

            b32len = baseEncode((<span class="enscript-type">char</span> *)b32Name, <span class="enscript-keyword">sizeof</span>(b32Name), (mDNSu8 *)hashName, hlen, ENC_BASE32);
            <span class="enscript-keyword">if</span> (!b32len)
            {
                LogMsg(<span class="enscript-string">&quot;NSEC3RecordIsDelegation: baseEncode of name %##s failed&quot;</span>, name-&gt;c);
                <span class="enscript-keyword">return</span> mDNSNULL;
            }
            <span class="enscript-comment">// Section 2.3 of RFC 4035 states that:
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Each owner name in the zone that has authoritative data or a delegation point NS RRset MUST
</span>            <span class="enscript-comment">// have an NSEC resource record. 
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// This applies to NSEC3 record. So, if we have an NSEC3 record matching the question name with the
</span>            <span class="enscript-comment">// NS bit set, then this is a delegation.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-keyword">if</span> (!NSEC3SameName(&amp;cr-&gt;resrec.name-&gt;c[1], cr-&gt;resrec.name-&gt;c[0], (<span class="enscript-type">const</span> mDNSu8 *)b32Name, b32len))
            {
                <span class="enscript-type">int</span> bmaplen;
                mDNSu8 *bmap;
                
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3RecordIsDelegation: CacheRecord %s matches name %##s, b32name %s&quot;</span>, CRDisplayString(m, cr), name-&gt;c, b32Name);
                NSEC3Parse(&amp;cr-&gt;resrec, mDNSNULL, mDNSNULL, mDNSNULL, &amp;bmaplen, &amp;bmap);

                <span class="enscript-comment">// See the Insecure Delegation Proof section in dnssec-bis: DS bit and SOA bit
</span>                <span class="enscript-comment">// should be absent
</span>                <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, kDNSType_SOA) ||
                    BitmapTypeCheck(bmap, bmaplen, kDNSType_DS))
                {
                    LogDNSSEC(<span class="enscript-string">&quot;NSEC3RecordIsDelegation: CacheRecord %s has DS or SOA bit set, ignoring&quot;</span>, CRDisplayString(m, cr));
                    <span class="enscript-keyword">return</span> mDNSNULL;
                }
                <span class="enscript-keyword">if</span> (BitmapTypeCheck(bmap, bmaplen, kDNSType_NS))
                    <span class="enscript-keyword">return</span> cr;
                <span class="enscript-keyword">else</span>
                    <span class="enscript-keyword">return</span> mDNSNULL;
            }
            <span class="enscript-comment">// If opt-out is not set, then it does not cover any delegations
</span>            <span class="enscript-keyword">if</span> (!(nsec3-&gt;flags &amp; NSEC3_FLAGS_OPTOUT))
                <span class="enscript-keyword">continue</span>;
            <span class="enscript-comment">// Opt-out allows insecure delegations to exist without the NSEC3 RR at the
</span>            <span class="enscript-comment">// hashed owner name (see RFC 5155 section 6.0).
</span>            <span class="enscript-keyword">if</span> (NSEC3CoversName(m, cr, hashName, hlen, b32Name, b32len))
            {
                LogDNSSEC(<span class="enscript-string">&quot;NSEC3RecordIsDelegation: CacheRecord %s covers name %##s with optout&quot;</span>, CRDisplayString(m, cr), name-&gt;c);
                <span class="enscript-keyword">return</span> cr;
            }
        }
    }
    <span class="enscript-keyword">return</span> mDNSNULL;
}

#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">DNSSEC_DISABLED</span>
</pre>
<hr />
</body></html>